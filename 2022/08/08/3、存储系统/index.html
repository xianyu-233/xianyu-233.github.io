
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>存储系统 - Hexo</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="xainyu-233,"> 
    <meta name="description" content="一、存储系统概述1、存储器的分类

按在计算机中的作用分类：


主存储器：简称主存，又称内存储器（内存），用于存放计算机运行期间所需的大量程序和数据。CPU可以直接随机地对其进行访问，也可以和高速,"> 
    <meta name="author" content="xianyu"> 
    <link rel="alternative" href="atom.xml" title="Hexo" type="application/atom+xml"> 
    <link rel="icon" href="/img/%E5%96%B7.jfif"> 
    
    
<link rel="stylesheet" href="/css/diaspora.css">

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Hexo</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://xianyu-233.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">存储系统</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">存储系统</h1>
        <div class="stuff">
            <span>八月 08, 2022</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/" rel="tag">基础学科</a></li></ul>


        </div>
        <div class="content markdown">
            <h2 id="一、存储系统概述"><a href="#一、存储系统概述" class="headerlink" title="一、存储系统概述"></a>一、存储系统概述</h2><h3 id="1、存储器的分类"><a href="#1、存储器的分类" class="headerlink" title="1、存储器的分类"></a>1、存储器的分类</h3><blockquote>
<ul>
<li><p><strong>按在计算机中的作用分类：</strong></p>
<blockquote>
<ul>
<li><p><strong>主存储器：</strong>简称<strong>主存</strong>，又称<strong>内存储器（内存）</strong>，用于存放计算机运行期间所需的大量程序和数据。CPU可以直接随机地对其进行访问，也可以和高速缓存及辅存进行数据的交换。</p>
</li>
<li><p><strong>辅助存储器：</strong>简称<strong>辅存</strong>，又称<strong>外存储器（外存）</strong>，是主存储器的后援存储器，用于存储当前暂时用不上的程序和数据，以及一些需要永久性保存的信息，不能与CPU直接交换信息。</p>
</li>
<li><p><strong>高速缓存存储器：</strong>简称<strong>Cache</strong>，位于主存与CPU之间，用于存放正在执行的程序段和数据，存取速度可以和CPU的速度相匹配。</p>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>按存储介质分类：</strong></p>
<blockquote>
<ul>
<li>磁表面存储器：磁盘、磁带</li>
<li>磁芯存储器</li>
<li>半导体存储器</li>
<li>光存储器：光盘</li>
</ul>
</blockquote>
</li>
<li><p><strong>按存取方式分类：</strong></p>
<blockquote>
<ul>
<li><p><strong>随机存储器（RAM）：</strong>存储器的任何一个存储单元的内容都可以随机存取，且存取时间与存储单元的物理位置无关。</p>
</li>
<li><p><strong>只读存储器（ROM）：</strong>存储器内容只能<strong>随机读取</strong>而不能写入，内容一旦写入存储器就固定不变，即使断电，内容也不会丢失。<strong>它与随机存储器可共同作为主存的一部分，统一构成主存的地址域</strong>。</p>
</li>
<li><p><strong>串行访问存储器：</strong>对存储单元进行读写时，<strong>需要按照其物理地址的先后顺序寻址</strong>。</p>
<blockquote>
<ul>
<li><strong>顺序存取存储器：</strong>磁带</li>
<li><strong>直接存取存储器：</strong>磁盘、光盘</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>按信息的可保存性分类：</strong></p>
<blockquote>
<ul>
<li><strong>易失性存储器：</strong>断电后，存储数据就会消失的存储器，如RAM</li>
<li><strong>非易失性存储器：</strong>断电后依旧可以保存数据信息的存储器，如ROM</li>
<li><strong>破坏性读出：</strong>某个存储单元的信息被读出时，原存储信息被破坏。（因此每次读出操作后，必须紧接一个再生操作）</li>
<li><strong>非破坏性读出：</strong>存储单元的数据在被读出后，原信息不会被破坏。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="2、存储器的性能指标"><a href="#2、存储器的性能指标" class="headerlink" title="2、存储器的性能指标"></a>2、存储器的性能指标</h3><blockquote>
<ul>
<li><p><strong>存储容量：</strong></p>
<blockquote>
<p>存储容量&#x3D;存储字数$\times$字长（如$1M \times8位$）</p>
<p>单位换算：1B&#x3D;8b</p>
<p><strong>存储字数表示存储器地址空间大小，字长表示一次存取操作的数据量</strong></p>
</blockquote>
</li>
<li><p><strong>单位成本：</strong></p>
<blockquote>
<p>$每位价格&#x3D;总成本&#x2F;总容量$</p>
</blockquote>
</li>
<li><p><strong>存储速度：</strong></p>
<blockquote>
<p>数据传输率&#x3D;数据的宽度&#x2F;存储周期</p>
<ul>
<li><strong>存取时间：</strong>指从<strong>启动一次存储器操作到完成该操作所经历的时间</strong>，分为<strong>读取时间</strong>与<strong>写入时间</strong></li>
<li><strong>存取周期：</strong>指存储器<strong>进行一次完整的读写操作所需的全部时间</strong>，即两次独立存取操作的时间间隔</li>
<li><strong>主存带宽：</strong>又称<strong>数据传输率</strong>，指每秒从主存进出信息的最大数据量，单位为字&#x2F;秒、字节&#x2F;秒、位&#x2F;秒</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>注意：存取时间不等于存取周期，</strong>因为在读写操作后，总需要有一段<strong>恢复时间</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%8F%96%E5%91%A8%E6%9C%9F.png" alt="存取周期"></p>
</blockquote>
<h2 id="二、半导体存储器"><a href="#二、半导体存储器" class="headerlink" title="二、半导体存储器"></a>二、半导体存储器</h2><h3 id="1、随机存储器"><a href="#1、随机存储器" class="headerlink" title="1、随机存储器"></a>1、随机存储器</h3><blockquote>
<p>随机存储器包括两类：SRAM和DRAM，其中<strong>主存由DRAM实现</strong>，而<strong>Cache由SRAM实现</strong>。</p>
<p><strong>随机存储器的特点：</strong>属于<strong>易失性存储器</strong>，只要<strong>切断电源，存储信息就会消失</strong>。</p>
<p><strong>两种随机存储器的比较：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%8D%8A%E5%AF%BC%E4%BD%93%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="半导体随机存储器的比较"></p>
</blockquote>
</blockquote>
<h4 id="1-1、静态随机存储器SRAM"><a href="#1-1、静态随机存储器SRAM" class="headerlink" title="1.1、静态随机存储器SRAM"></a>1.1、静态随机存储器SRAM</h4><blockquote>
<p>静态随机存储器（SRAM）的存储单元由<strong>双稳态触发器（六晶体管MOS）</strong>组成</p>
<p><strong>特点：</strong></p>
<blockquote>
<ul>
<li><strong>非破坏性读出</strong>，即使信息被读出，数据仍能保持原来的状态</li>
<li><strong>存取速度快</strong>（与DRAM作比较）</li>
<li><strong>集成度低</strong></li>
<li><strong>功耗大</strong></li>
</ul>
</blockquote>
</blockquote>
<h4 id="1-2、动态随机存储器DRAM"><a href="#1-2、动态随机存储器DRAM" class="headerlink" title="1.2、动态随机存储器DRAM"></a>1.2、动态随机存储器DRAM</h4><blockquote>
<p>动态随机存储器（DRAM）的存储单元<strong>利用电容来存储信息</strong>，因此只需一个晶体管，且<strong>需要不断地刷新电容</strong></p>
<p><strong>特点：</strong></p>
<blockquote>
<ul>
<li><p><strong>采用地址复用技术，地址线只需原来的1&#x2F;2</strong>，地址信号分行、列两次传送（<strong>即地址线的消耗减半</strong>）</p>
</li>
<li><p><strong>需要进行电容的刷新</strong>（将一行信息读出后再写回去）</p>
<blockquote>
<ul>
<li><p><strong>集中刷新：</strong>指利用一段固定时间，依次对存储器所有的存储单元进行刷新，这段时间被称作<strong>“死时间”</strong>，也称作<strong>访存“死区”</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%9B%86%E4%B8%AD%E5%88%B7%E6%96%B0.png" alt="集中刷新"></p>
</blockquote>
</li>
<li><p><strong>分散刷新：</strong>把每行的刷新时间分散到各个工作周期中，<strong>类似于读写操作的恢复时间</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%88%86%E6%95%A3%E5%88%B7%E6%96%B0.png" alt="分散刷新"></p>
</blockquote>
</li>
<li><p><strong>异步刷新：</strong>前两者的结合，将刷新周期除以行数，得到两次刷新之间的时间间隔t，每个时间t产生一次刷新请求。</p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%BC%82%E6%AD%A5%E5%88%B7%E6%96%B0.png" alt="异步刷新"></p>
</blockquote>
</li>
</ul>
<p><strong>注意：</strong>刷新对CPU是透明的；DRAM刷新的单位是行；刷新操作类似于读操作</p>
</blockquote>
</li>
<li><p><strong>存取速度慢</strong>（与SRAM作比较）</p>
</li>
<li><p><strong>集成度高</strong></p>
</li>
<li><p><strong>功耗低</strong></p>
</li>
</ul>
</blockquote>
</blockquote>
<h4 id="1-3、存储芯片的内部结构"><a href="#1-3、存储芯片的内部结构" class="headerlink" title="1.3、存储芯片的内部结构"></a>1.3、存储芯片的内部结构</h4><blockquote>
<p><strong>存储器的结构模型：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B.png" alt="存储器结构模型"></p>
<ul>
<li><strong>地址寄存器：</strong>存放存储体中某个单元的地址</li>
<li><strong>时序控制逻辑：</strong>控制器，控制存储器的读写</li>
<li><strong>数据寄存器：</strong>存放从存储体中读取的数据（或存储待写入存储体的数据）</li>
<li><strong>存储体：</strong>存储器的主要构成</li>
</ul>
</blockquote>
<p><strong>一个存储元的结构：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E5%85%83%E7%BB%93%E6%9E%84.png" alt="存储元结构"></p>
<ul>
<li><strong>控制器：</strong>由逻辑控制单元来控制，主要是控制该操作是读还是写</li>
<li><strong>存储的数据信息：</strong>每个存储元存储数据的地方，图中的是以电容来存储信息的。</li>
<li><strong>数据寄存器：</strong>存放从存储体中读取的数据（或存储待写入存储体的数据）</li>
</ul>
</blockquote>
<p><strong>存储芯片的结构</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="存储芯片的结构"></p>
<ul>
<li><strong>控制电路：</strong>本质就是控制器</li>
<li><strong>译码器：</strong>将控制电路的信号转化称相应的读写信号</li>
<li><strong>片选线（$\overline{ CS }$）：</strong>由于存储体是由多片存储芯片组成的，因此设置了一个片选信号来表示当前是否在读取本存储芯片</li>
<li><strong>读&#x2F;写控制线（$\overline{WE}$）：</strong>决定该操作是读操作还是写操作，一般可以用一个线路WE即可表示</li>
<li><strong>地址线：</strong>要读&#x2F;写的存储元的位置</li>
<li><strong>数据线：</strong>连接数据寄存器和存储元的线路</li>
</ul>
<p><strong>注意：存储芯片一次读&#x2F;写操作的单位是一行的存储单元，而不是单个存储单元</strong></p>
</blockquote>
</blockquote>
<h3 id="2、只读存储器-ROM"><a href="#2、只读存储器-ROM" class="headerlink" title="2、只读存储器(ROM)"></a>2、只读存储器(ROM)</h3><blockquote>
<p><strong>存储器类型：</strong></p>
<blockquote>
<ul>
<li><p><strong>掩模式只读存储器（MROM）：</strong></p>
<blockquote>
<p>由厂商按照顾客需求来写入内容，且内容一旦写入就无法再进行修改。</p>
</blockquote>
</li>
<li><p><strong>一次可编程只读存储器（PROM）：</strong></p>
<blockquote>
<p>该存储器可以让用户使用专门的设备写入自己的数据，一旦写入，内容就无法改变。</p>
</blockquote>
</li>
<li><p><strong>可擦除可编程只读存储器（EPROM）：</strong></p>
<blockquote>
<p>可以让用户利用编程器写入信息，需要时也可以进行擦除对其进行多次修改。EPROM根据擦除的方式又可以分为两类：<strong>紫外线擦除（UVEPROM）</strong>和<strong>电擦除（$E^2$PROM）</strong></p>
<p><strong>注意：</strong>EPROM不能代替RAM作主存，因为EPROM的写入时间较长</p>
</blockquote>
</li>
<li><p><strong>闪速存储器（Flash）：</strong></p>
<blockquote>
<p>闪存是在EPROM与$E^2$PROM的基础上发展过来的，主要特点是：<strong>不加电时长时间存储数据</strong>和<strong>在线进行快速擦除和重写</strong></p>
</blockquote>
</li>
<li><p><strong>固态硬盘（SSD）：</strong></p>
<blockquote>
<p>基于闪存利用固态电子存储芯片阵列制成的硬盘，由控制单元和Flash芯片阵列组成</p>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>ROM的特点：</strong></p>
<blockquote>
<ul>
<li><strong>一旦写入信息，就不能轻易改变，具有非易失性</strong></li>
<li><strong>结构简单，位密度高</strong></li>
</ul>
</blockquote>
</blockquote>
<h2 id="三、存储器与CPU的协同工作"><a href="#三、存储器与CPU的协同工作" class="headerlink" title="三、存储器与CPU的协同工作"></a>三、存储器与CPU的协同工作</h2><h3 id="1、存储器的层次结构"><a href="#1、存储器的层次结构" class="headerlink" title="1、存储器的层次结构"></a>1、存储器的层次结构</h3><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E5%8C%96%E7%BB%93%E6%9E%84.png" alt="存储器层次化结构"></p>
<p>其中，能<strong>与CPU直接相连</strong>的有<strong>寄存器、Cache、主存</strong>，磁盘、光盘等只能通过主存才能与CPU交换信息。</p>
<p><strong>主存与Cache之间的数据交换是由硬件自动完成</strong>，对所有程序员都是透明的。</p>
<p><strong>辅存与主存间的数据交换则是由操作系统来完成，</strong>对应用程序员来说也是透明的。</p>
<p><strong>设计这一套存储器层次结构的目的：为了平衡CPU速度过快而存储器读取速度慢的问题</strong></p>
<p><strong>注意：</strong></p>
<blockquote>
<ul>
<li>在存储器的层次结构中，<strong>上层的数据内容只是下层的副本</strong></li>
<li>Cache可以分为多级缓存，其中速度与容量也有所不同</li>
</ul>
</blockquote>
</blockquote>
<h3 id="2、主存与CPU的连接"><a href="#2、主存与CPU的连接" class="headerlink" title="2、主存与CPU的连接"></a>2、主存与CPU的连接</h3><h4 id="2-1、连接原理"><a href="#2-1、连接原理" class="headerlink" title="2.1、连接原理"></a>2.1、连接原理</h4><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E4%B8%BB%E5%AD%98%E4%B8%8ECPU%E7%9A%84%E8%BF%9E%E6%8E%A5.png" alt="主存与CPU的连接"></p>
<ul>
<li>主存通过数据总线、地址总线以及读写控制线与CPU进行连接</li>
<li>数据总线的位数与工作频率的乘积正比于数据传输率：$总线位数 \times 工作频率 &#x3D; k \times数据传输率$</li>
<li><strong>地址总线的位数决定了可寻址的最大内存空间</strong>，如32位地址线最大可表示$2^{32}&#x3D;4GB$的内存空间</li>
<li>读写控制线指出总线周期的类型和本次输入&#x2F;输出操作完成的时刻</li>
</ul>
</blockquote>
<h4 id="2-2、主存容量的扩展"><a href="#2-2、主存容量的扩展" class="headerlink" title="2.2、主存容量的扩展"></a>2.2、主存容量的扩展</h4><blockquote>
<p>由于单个的存储芯片（如8K$\times$2的芯片）容量有限，有时与需求的容量有一点点差距，因此我们需要在<strong>字</strong>和<strong>位</strong>两方面进行扩展才能满足需求。所以可以分为：<strong>位扩展法</strong>、<strong>字扩展法</strong>和<strong>字位同时扩展</strong></p>
<ul>
<li><p><strong>位扩展法：</strong></p>
<blockquote>
<p>位扩展的方式就是将多个存储芯片的<strong>地址端、片选端</strong>和<strong>读写控制端</strong>相应<strong>并联</strong>使得CPU的数据线的位数于其相等，数据端则分别引出</p>
<p><strong>如图所示：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E4%BD%8D%E6%89%A9%E5%B1%95.png" alt="位扩展"></p>
</blockquote>
</li>
<li><p><strong>字扩展法</strong></p>
<blockquote>
<p>字扩展是指<strong>增加存储器中字的数量</strong>，而<strong>位数不变</strong>。字扩展就是将芯片的<strong>地址线、数据线、读写控制线相应并联，由片选信号来区分各芯片的地址范围</strong></p>
<p><strong>如图所示：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%AD%97%E6%89%A9%E5%B1%95.png" alt="字扩展"></p>
<p>​        图中是将4片16K$\times$8位的RAM芯片组成64K$\times$8位的存储器。其中读写控制线$\overline{WE}$是并联在一起的，以$A_{14}和A_{15}$作为<strong>片选信号</strong>。</p>
<p>​        例如，当要选择第3片芯片的时候，令$A_{14},A_{15}&#x3D;10$，通过译码器翻译得到3，那么就将第3片的芯片的$\overline{CS}$置为1，其余的置为0.（这就实现了通过片选信号与$\overline{CS}$来选择相应的芯片了，另外$A_{14},A_{15}$是设计在CPU上的）</p>
<p><strong>具体的地址实现：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%AD%97%E6%89%A9%E5%B1%95%E7%9A%84%E5%9C%B0%E5%9D%80.png" alt="字扩展的地址"></p>
</blockquote>
</blockquote>
</li>
<li><p><strong>字位同时扩展法</strong></p>
<blockquote>
<p>实际上，存储器往往需要同时扩展字长与位长。<strong>字位同时扩展既可以增加存储字的数量，又可以增加存储字长</strong></p>
<p><strong>如图所示：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%AD%97%E4%BD%8D%E5%90%8C%E6%97%B6%E6%89%A9%E5%B1%95.png" alt="字位同时扩展"></p>
<p>如图所示，字位同时扩展本质上就是综合上述两种扩展，先对位数进行扩展，将两个位数较低并联的芯片看作一个位数较高的芯片。然后再将这一组芯片使用字扩展法，结合译码器对其进行扩展。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="2-3、CPU选择存储芯片的方法"><a href="#2-3、CPU选择存储芯片的方法" class="headerlink" title="2.3、CPU选择存储芯片的方法"></a>2.3、CPU选择存储芯片的方法</h4><blockquote>
<p>CPU要实现对存储单元的访问，首先要选择存储芯片，即进行<strong>片选</strong>；然后在选中的芯片中按地址选择相应的存储单元，即进行<strong>字选</strong>。</p>
<p>这里着重讲述片选，而片选的方式可以分为：<strong>线选法</strong>和<strong>译码片选法</strong>。</p>
<ul>
<li><p><strong>线选法</strong></p>
<blockquote>
<p>线选法用除片内寻址外的<strong>高位地址线</strong>直接（过经过反相器）分别接至各个芯片的片选端，当某地址线信号为“0”时，就选中与之对应的存储芯片。（简单来说就是：为每一个芯片额外多接一根片选线，信号为0时表示选中）</p>
<p>因此这些片选地址线每次寻址时只能有一个有效位，例如有4片2K$\times$8位的存储芯片构成一个存储器，那么它的地址线结构为：低位$A_0 — A_{10}$为字选线（$2^{11}&#x3D;2K$），高位$A_{11}—A_{14}$为字选线，且分配如下</p>
<table>
<thead>
<tr>
<th align="center">芯片</th>
<th align="center">$A_{14}—A_{11}$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0#</td>
<td align="center">1110</td>
</tr>
<tr>
<td align="center">1#</td>
<td align="center">1101</td>
</tr>
<tr>
<td align="center">2#</td>
<td align="center">1011</td>
</tr>
<tr>
<td align="center">3#</td>
<td align="center">0111</td>
</tr>
</tbody></table>
<p><strong>优点：</strong>不需要译码器，线路简单</p>
<p><strong>缺点：</strong>地址空间不连续，造成地址资源的浪费，且芯片过多时，线路也会变得过多</p>
</blockquote>
</li>
<li><p><strong>译码片选法</strong></p>
<blockquote>
<p>译码器片选法用除片内寻址外的<strong>高位地址线</strong>通过地址译码器产生片选信号。例如有4片2K$\times$8位的存储芯片构成一个存储器，如果使用译码器片选法，那么只需在高位多加两位作为片选信号即可，即低位$A_0 — A_{10}$为字选线（$2^{11}&#x3D;2K$），高位$A_{11}—A_{12}$为字选线，且分配如下</p>
<table>
<thead>
<tr>
<th align="center">芯片</th>
<th align="center">$A_{12}—A_{11}$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0#</td>
<td align="center">00</td>
</tr>
<tr>
<td align="center">1#</td>
<td align="center">01</td>
</tr>
<tr>
<td align="center">2#</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">3#</td>
<td align="center">11</td>
</tr>
</tbody></table>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="2-4、存储器与CPU的连接方式"><a href="#2-4、存储器与CPU的连接方式" class="headerlink" title="2.4、存储器与CPU的连接方式"></a>2.4、存储器与CPU的连接方式</h4><blockquote>
<ul>
<li><strong>合理选择存储芯片：</strong>主要指存储芯片类型（RAM或ROM和数量的选择）。通常选择ROM存放系统程序，和各类常数；RAM则是为用户编程而设计的。</li>
<li><strong>地址线的连接：</strong>CPU的地址线高于存储器的地址线时，优先使用低位的地址线。</li>
<li><strong>数据线的连接：</strong>CPU与存储器的数据线不等时，需要对存储器芯片进行扩位，使其数据位与CPU的数据位相等后才进行连接</li>
<li><strong>读写命令线的连接</strong></li>
<li><strong>片选线的连接</strong></li>
</ul>
</blockquote>
<h3 id="3、双端口RAM和多模块存储器"><a href="#3、双端口RAM和多模块存储器" class="headerlink" title="3、双端口RAM和多模块存储器"></a>3、双端口RAM和多模块存储器</h3><blockquote>
<p>上一节讲了存储器容量不足时的解决办法，这里将会讲<strong>如何提高CPU访问存储器的速度</strong>，主要讲两种技术：<strong>采用双端口存储器</strong>和<strong>多模块存储器技术</strong>。两者都为<strong>并行技术</strong>，<strong>前者为空间并行</strong>，<strong>后者为时间并行</strong></p>
</blockquote>
<h4 id="3-1、双端口RAM"><a href="#3-1、双端口RAM" class="headerlink" title="3.1、双端口RAM"></a>3.1、双端口RAM</h4><blockquote>
<p>双端口RAM是指同一存储器中有左、右两个独立的端口，分别<strong>有两套相互独立的地址线、数据线和读写控制线</strong>，允许两个独立的控制器同时异步地访问存储单元。</p>
<p><strong>图示：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%8F%8C%E7%AB%AF%E5%8F%A3RAM.png" alt="双端口RAM"></p>
<p><strong>补充：</strong></p>
<blockquote>
<p>当两个端口同时访问两个不同的存储单元时，读写操作都不会发生冲突。</p>
<p>当两个端口对同一存储单元进行读写时，会有以下4种情况：</p>
<ul>
<li>两个端口不同时对同一地址单元读取数据。（不发生错误）</li>
<li>两个端口同时对同一地址单元进行读取。（不发生错误）</li>
<li>两个端口同时对同一地址单元进行写操作。（出现写入错误）</li>
<li>一个端口进行写操作，另一个端口进行读操作。（出现读出错误）</li>
</ul>
<p><strong>解决办法：</strong>设置一个“忙”信号，当一个端口在操作时由判断逻辑决定是否需要暂时关闭另一个端口。</p>
</blockquote>
</blockquote>
<h4 id="3-2、多模块存储器"><a href="#3-2、多模块存储器" class="headerlink" title="3.2、多模块存储器"></a>3.2、多模块存储器</h4><blockquote>
<p>为了提高访存速度，常采用多模块存储器，而常用的有：<strong>单体多字存储器</strong>和<strong>多体并行存储器</strong></p>
<ul>
<li><p><strong>单体多字存储器</strong></p>
<blockquote>
<p>单体多字系统的特点时<strong>存储器中只有一个存储体，每个存储单元存储m个字，总线宽度也为m个字。一次并行读出m个字，地址顺序排列并处于同一存储单元</strong>。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%8D%95%E4%BD%93%E5%A4%9A%E5%AD%97%E5%AD%98%E5%82%A8%E5%99%A8.png" alt="单体多字存储器"></p>
<p>单体多字系统在<strong>一个存储周期内，从同一地址取出m条指令（如图中的一行数据）</strong>，然后讲指令逐条送至CPU，即每隔1&#x2F;m存储周期，CPU就能得到一条指令，这显然增大了存储器的带宽，提高了单体存储器的工作速度。</p>
<p><strong>缺点：</strong>指令和数据在主存的位置必须是连续的，一旦遇到转移指令时，这种方法效果就不明显了。</p>
</blockquote>
</li>
<li><p><strong>多体并行存储器</strong></p>
<blockquote>
<p><strong>前提：</strong></p>
<blockquote>
<p>首先先回忆一下，存储体的访问周期分为<strong>存取时间</strong>与<strong>恢复时间</strong>，即</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%8F%96%E5%91%A8%E6%9C%9F.png" alt="存取周期"></p>
<p>读取时，使用CPU的是<strong>存取时间</strong>，恢复时间并不占用CPU（低位交叉编址会用到）</p>
<p><strong>注意：</strong></p>
<blockquote>
<p>下面会讲到的三个词：</p>
<ul>
<li><p><strong>存储单元：</strong>指一个存储格子</p>
</li>
<li><p><strong>存储体：</strong>指同一列的存储单元</p>
</li>
<li><p><strong>存储器：</strong>指整个图的存储单元的集合</p>
</li>
</ul>
</blockquote>
</blockquote>
<p>多体并行存储器是由多个存储模块组成，每个模块都有相同的容量以及存取速度，且各模块之间都有独立的控制电路、地址线路和数据存储器，它们既可以独立工作又可以交叉工作。</p>
<p>多体并行存储器可以分为两类：<strong>高位交叉编址</strong>和<strong>低位交叉编址</strong></p>
<ul>
<li><p><strong>高位交叉编址：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%AB%98%E4%BD%8D%E4%BA%A4%E5%8F%89%E7%BC%96%E5%9D%80.png" alt="高位交叉编址"></p>
<p>存储体号在前，存储体内地址在后，且编址方式按<strong>顺序编址</strong>，<strong>先编满一个存储体后再到下一个存储体</strong>。</p>
<p><strong>特点：</strong></p>
<blockquote>
<p>进行顺序存取时，如果要读取n个存储单元，那么就要用到n个存取周期，时间上并没有改进，如图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%AB%98%E4%BD%8D%E4%BA%A4%E5%8F%89%E7%BC%96%E5%9D%80%E7%9A%84%E4%BE%8B%E5%AD%90.png" alt="高位交叉编址的例子"></p>
<p>连续访问5个存储单元就会花费5个存储周期，因此不会改进读取存储器的吞吐率。</p>
</blockquote>
</blockquote>
</li>
<li><p><strong>低位交叉编址</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E4%BD%8E%E4%BD%8D%E4%BA%A4%E5%8F%89%E7%BC%96%E5%9D%80.png" alt="低位交叉编址"></p>
<p>存储体内地址在前，而存储体号在后。编址方式<strong>交叉编址</strong>，每<strong>对一个存储体编完一个址，就换下一个存储体继续编址</strong>。</p>
<p><strong>特点：</strong></p>
<blockquote>
<p>由于对存储器进行读取时，真正占用CPU时间的只有一部分，只要读取完成了，CPU就可以换一个存储体进行读取，因此如果是低位交叉编址的存储器，读取一段连续的地址时，时间如图所示</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E4%BD%8E%E4%BD%8D%E4%BA%A4%E5%8F%89%E7%BC%96%E5%88%B6%E7%9A%84%E4%BE%8B%E5%AD%90.png" alt="低位交叉编制的例子"></p>
<p>相邻两个周期重叠的部分就是前一个存储体的恢复时间。由图可以明显看出，存储器的读取效率大幅度提升了，因此缩减了CPU读取存储器的时间。且读取时间满足以下公式<br>$$<br>t&#x3D;T+(m-1)r\quad(其中T为一个存储周期，m为存储体数量，r为传送时间或恢复时间)<br>$$<br><strong>注意：</strong></p>
<p>存储器交叉模块的数量m只有在<strong>大于等于T&#x2F;r</strong>（T为存储周期，r为传送周期）时，<strong>才满足上面的公式</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E5%99%A8%E4%BA%A4%E5%8F%89%E6%A8%A1%E5%9D%97%E6%95%B0%E9%87%8F.png" alt="存储器交叉模块数量"></p>
<p>因为如果m小于T&#x2F;r，那么就会导致读取完最后一个存储体后，第一个存储体仍未完成恢复。（即上图中存储体最后会多等待r的时间）</p>
</blockquote>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="4、高速缓存Cache"><a href="#4、高速缓存Cache" class="headerlink" title="4、高速缓存Cache"></a>4、高速缓存Cache</h3><h4 id="4-1、局部性原理"><a href="#4-1、局部性原理" class="headerlink" title="4.1、局部性原理"></a>4.1、局部性原理</h4><blockquote>
<p>局部性原理就是程序访问的局部性原理，其中可以分为：</p>
<ul>
<li><strong>时间局部性：</strong>指最近未来要用到的信息，很可能时现在正在使用的信息（因为程序中存在循环），但空间上不一定连续</li>
<li><strong>空间局部性：</strong>指未来要用到的信息，很可能与现在正在用的信息在存储空间上是临近的。</li>
</ul>
<p><strong>应用实例：</strong>编程语言中的数组等数据结构</p>
</blockquote>
<h4 id="4-2、基本的工作原理"><a href="#4-2、基本的工作原理" class="headerlink" title="4.2、基本的工作原理"></a>4.2、基本的工作原理</h4><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="高速缓存工作原理"></p>
<p>Cache位于存储器层次结构的顶层，通常由SRAM组成。</p>
<p>为了方便主存与Cache之间交换信息，Cache与主存被化成<strong>大小相同、数量不同</strong>的小块，Cache的容量远小于主存，且Cache只按某种策略存放经常用的<strong>主存块的副本</strong>。</p>
<p>Cache与CPU交换的单位是<strong>字</strong>，Cache与主存交换的单位是<strong>存储块</strong></p>
<p>当CPU需要访问某个数据的时候，它会优先访问Cache，如果Cache中存在该数据，那么此时称为<strong>命中</strong>；如果Cache中不存在改数据，那么<strong>CPU会直接访问主存（然后将改存储块调入Cache中）</strong>或者<strong>等主存的存储调入Cache中后再访问</strong>。</p>
<p>CPU欲访问的信息已在Cache中的比率称为Cache的<strong>命中率</strong>，公式为<br>$$<br>H&#x3D;N_c&#x2F;(N_c+N_m)\quad\quad (N_c为命中次数，N_m为未命中的次数)<br>$$</p>
</blockquote>
<h4 id="4-3、Cache与主存的映射方式"><a href="#4-3、Cache与主存的映射方式" class="headerlink" title="4.3、Cache与主存的映射方式"></a>4.3、Cache与主存的映射方式</h4><blockquote>
<p>由于Cache块数比主存的块数要少得少，因此主存中只有一部分块的信息能够放到Cache中，所以主存块怎么放到Cache中就是一个问题了。常用的映射方式有以下3种：</p>
<ul>
<li><p><strong>直接映射：</strong></p>
<blockquote>
<p><strong>主存种每一块只能装入Cache中的唯一位置</strong>，如果这个位置已经有内容了，则<strong>将原来的块无条件地替换掉</strong>（无需使用替换算法），形式如下图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84.png" alt="直接映射"></p>
<p>这种映射方式实现简单，但不够灵活，即有可能导致Cache中有许多空位不能使用，而又有较高的冲突概率，空间利用率在三种映射中最低。</p>
<p><strong>直接映射的地址结构：</strong></p>
<table>
<thead>
<tr>
<th align="center">主存中的块号</th>
<th align="center">Cache行号</th>
<th align="center">块内地址</th>
</tr>
</thead>
</table>
<p><strong>CPU访问数据的顺序</strong>：先访问Cache行号，找到相应Cache块；然后对主存中的块号进行匹配，如果匹配上就读取块内地址，否则就”不命中“然后读取主存中的信息，并将其数据块一并放入Cache中。</p>
</blockquote>
</li>
<li><p><strong>全相联映射：</strong></p>
<blockquote>
<p>主存中每一块都可以装入Cache中的<strong>任何位置</strong>，每行的标记用于指出该行来至主存的哪一块，形式如下图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%85%A8%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84.png" alt="全相联映射"></p>
<p><strong>优点：</strong>比较灵活，Cache冲突概率低，空间利用率高，命中率也高。</p>
<p><strong>缺点：</strong>标记的配对时间长</p>
<p><strong>地址结构：</strong></p>
<table>
<thead>
<tr>
<th align="center">标记（标识主存中的不同块）</th>
<th align="center">块内地址</th>
</tr>
</thead>
</table>
</blockquote>
</li>
<li><p><strong>组相联映射</strong></p>
<blockquote>
<p>将Cache分成大小相同的组，主存中的块可以放入某一个组中的任意位置，即<strong>组内使用全相联映射，组外使用直接映射</strong>，其形式如下图：</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84.png" alt="组相联映射"></p>
<p>组相联映射的关系可以用以下公式表示：<br>$$<br>j&#x3D;i\ mod\ Q \quad(j为Cahce的组号，i为主存的块号，Q为Cahce的组数)<br>$$<br><strong>地址结构：</strong></p>
<table>
<thead>
<tr>
<th align="center">标记</th>
<th align="center">组号</th>
<th align="center">块内地址</th>
</tr>
</thead>
</table>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="4-4、Cache的替换算法"><a href="#4-4、Cache的替换算法" class="headerlink" title="4.4、Cache的替换算法"></a>4.4、Cache的替换算法</h4><blockquote>
<p>当Cache或Cache组中的空间已已经被占满时，就需要使用替换算法置换Cache行，除了直接映射以外，其余两种都需要使用替换算法进行Cache块的更换。常用的Cache块更换算法有：<strong>随机算法（RAND）、先进先出算法（FIFO）、近期最少使用算法（LRU）</strong>和<strong>最不经常使用算法（LFU）</strong>。</p>
<ul>
<li><strong>随机算法（RAND）：</strong>随机地确定取代的Cache块。实现简单，但命中率会较低。</li>
<li><strong>先进先出算法（FIFO）：</strong>选择最早调入的块进行替代。</li>
<li><strong>近期最少使用算法（LRU）：</strong>根据局部性原理，选择<strong>近期内</strong>最久未访问过的Cache块作为替换的块。</li>
<li><strong>最不经常使用算法（LFU）：</strong>将一段时间内被访问次数最少的块进行替换。</li>
</ul>
<p><strong>注意：</strong>以上内容可以结合操作系统中内存管理那一部分进行理解。</p>
</blockquote>
<h4 id="4-5、Cache的写策略"><a href="#4-5、Cache的写策略" class="headerlink" title="4.5、Cache的写策略"></a>4.5、Cache的写策略</h4><blockquote>
<p>由于Cache中存放的是主存的副本，因此如果Cache中的内容发生变化，那么主存中的内容也要发生相应变化，而这个时候就需要一定的方法来将Cache的内容写入主存中。</p>
<p>而写回的情况分为两类：<strong>写命中</strong>和<strong>写不命中</strong>（即CPU要写的块不在Cache中）</p>
<ul>
<li><p><strong>写命中：</strong></p>
<blockquote>
<p>当CPU写命中时，又可以分为两类：<strong>全写法</strong>和<strong>写回法</strong></p>
<ul>
<li><p><strong>全写法：</strong></p>
<blockquote>
<p> 当CPU写命中的时候，直接将数据同时写入Cache和主存中。当然为了节省时间，也可以在CPU和主存之间加入一个写缓存，CPU同时将数据写到Cache和写缓存中，然后再由写缓存写到主存中。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%86%99%E7%BC%93%E5%AD%98.png" alt="写缓存"></p>
</blockquote>
</li>
<li><p><strong>写回法：</strong></p>
<blockquote>
<p>当CPU对Cache写命中时，只修改Cache的内容，而不立即修改主存中的内容，只有在进行块替换的时候才将修改后的数据块写回主存中。</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>写不命中：</strong></p>
<blockquote>
<p>当Cache写不命中时，也有两类：写<strong>分配法</strong>和<strong>非写分配法</strong></p>
<ul>
<li><p><strong>分配法：</strong></p>
<blockquote>
<p>将主存中的数据块加载到Cache中，然后更新相应的数据。</p>
</blockquote>
</li>
<li><p><strong>非写分配法：</strong></p>
<blockquote>
<p>直接将数据写入主存中。</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="5、虚拟存储器"><a href="#5、虚拟存储器" class="headerlink" title="5、虚拟存储器"></a>5、虚拟存储器</h3><h4 id="5-1、基本概念"><a href="#5-1、基本概念" class="headerlink" title="5.1、基本概念"></a>5.1、基本概念</h4><blockquote>
<p><strong>主存</strong>和<strong>联机工作的辅存</strong>共同构成了虚拟存储器，二者在硬件和系统软件的共同管理下工作。对于<strong>应用程序员而言，虚拟存储器是透明的</strong>。</p>
<p>虚拟存储器将主存或辅存的地址空间<strong>统一编址</strong>，形成一个巨大的地址空间。在这个空间里，用户可以自由使用，无需在乎实际的主存容量，以及实际的物理位置。</p>
<p>用户编程允许涉及的地址称为<strong>虚地址</strong>或<strong>逻辑地址</strong>，虚地址对应的存储空间称为<strong>虚拟空间</strong>或<strong>程序空间</strong>。</p>
<p>实际的主存单元地址称为<strong>实地址</strong>或<strong>物理地址</strong>，实地址对应的存储空间被称为<strong>主存空间</strong>或<strong>实地址空间</strong>。</p>
<p><strong>虚拟存储的作用：</strong>利用辅存对运行的存储空间进行扩展</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png" alt="虚拟存储器的地址空间"></p>
<p><strong>CPU使用虚地址的过程：</strong></p>
<blockquote>
<ul>
<li>由辅助硬件找出虚地址与实地址的对应关系</li>
<li>判断这个虚地址对应的存储单元是否已经装入内存</li>
<li>若已在内存中，通过地址转换，CPU直接访问主存所指示的实际单元</li>
<li>若不在主存中，则将包含这个字的一页或一段调入主存后再由CPU访问（必要时使用算法置换相应的页或着段）</li>
</ul>
</blockquote>
</blockquote>
<h4 id="5-2、页式虚拟存储器"><a href="#5-2、页式虚拟存储器" class="headerlink" title="5.2、页式虚拟存储器"></a>5.2、页式虚拟存储器</h4><blockquote>
<p>以页为基本单位的虚拟存储器称为<strong>页式虚拟存储器</strong>。</p>
<p><strong>虚拟空间</strong>与<strong>主存空间</strong>都被划分成同样大小的页（这里的页是一个计量单位，类似于Cache中的Cache块）</p>
<p>主存中的页称为<strong>实页</strong>，虚存中的页称为<strong>虚页</strong>。<strong>页表</strong>则是一张存放在主存中的虚页号和实页号的对照表，用于<strong>实现虚拟地址到物理地址的转换</strong>，一般长久地保存在内存中。</p>
<p><strong>页表：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt="页表结构"></p>
<ul>
<li>页表的地址包括主存地址和辅存地址</li>
<li><strong>有效位：</strong>也称为<strong>装入位</strong>，<strong>用来表示对应页面是否在主存</strong>。若为1，则表示虚拟页已从外存调入主存，此时页表项存放的是该页的物理地址（主存地址）；若为0，则表示该页没有调入主存，此时页表项存放的是该页的磁盘地址。</li>
<li><strong>脏位：</strong>也称为<strong>修改位</strong>，用来表示页面是否被修改</li>
<li><strong>引用位：</strong>也称为<strong>使用位</strong>，用来配合替换策略进行设置，例如是否实现最先调入（FIFO位）或最近最少用（LRU位）策略</li>
</ul>
<p>CPU执行指令时，需要先将虚拟地址转换为主存物理地址，其过程如下，</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%A1%B5%E8%A1%A8%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png" alt="页表地址转换"></p>
<ul>
<li>假设有一个<strong>虚拟地址</strong>，它可以分为<strong>虚拟页号</strong>和<strong>页内地址</strong></li>
<li><strong>虚拟页号</strong>和<strong>页表基地址（页表起始地址）</strong>拼接起来，得到<strong>页表地址</strong></li>
<li>查询页表的<strong>装入位</strong>，如果装入位是1，那么直接将对应的<strong>物理页号</strong>与虚拟地址中的<strong>页内地址</strong>拼接从而得到<strong>物理地址</strong>；如果装入位是0，那么进行缺页处理（详情可见操作系统）</li>
</ul>
<p><strong>优点：</strong>页面的长度固定，页表简单，调入方便。</p>
<p><strong>缺点：</strong>程序不可能正好是页面的整数倍，可能造成一些空间浪费（解决方法也在操作系统中）。并且页不是逻辑上独立的实体，所以处理、保护和共享都不及段式虚拟存储器方便。</p>
</blockquote>
<p><strong>快表（TLB）：</strong></p>
<blockquote>
<p>由地址转换过程可知，访存是先访问一次主存去查页表，再访问主存才能得到数据，如果缺页那么访问次数就更多了。</p>
<p>根据局部性原理，再一段时间内总是经常访问某些页是，如果将这些页对应的页表项放在高速缓存组成<strong>快表</strong>，明显可以提高效率。与主存和Cache的关系一样，快表的容量也是远小于页表的。</p>
<p>快表通常采用全相联或组相联方式，<strong>每个TLB项</strong>由<strong>页表表项内容加上一个TLB标志字段</strong>组成，<strong>TLB标记</strong>用来<strong>表示该表项曲子页表中哪个虚页号对应的页表项</strong>。</p>
<p>TLB标记的内容在全相联方式下就是该页表项对应的虚页号；组相联方式下则是对应虚页号的高位部分，虚页低位部分用于选择TLB组的组索引。</p>
</blockquote>
<p><strong>具有TLB和Cache的多级存储系统：</strong></p>
<blockquote>
<p>带TLB虚拟存储器的CPU访问过程：</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%B8%A6TLB%E7%9A%84%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84CPU%E8%AE%BF%E5%AD%98%E8%BF%87%E7%A8%8B.png" alt="带TLB的虚拟存储器的CPU访存过程"></p>
<p><strong>三种缺失情况：</strong></p>
<ul>
<li><strong>TLB缺失：</strong>要访问的页面对应的页表项不在TLB中</li>
<li><strong>Cache缺失：</strong>要访问的主存块不在Cache中</li>
<li><strong>页缺失：</strong>要访问的页面不在主存中</li>
</ul>
</blockquote>
</blockquote>
<h4 id="5-3、段式虚拟存储器"><a href="#5-3、段式虚拟存储器" class="headerlink" title="5.3、段式虚拟存储器"></a>5.3、段式虚拟存储器</h4><blockquote>
<p>段式虚拟存储器中的段是按<strong>程序的逻辑结构</strong>划分的，<strong>各个段的长度因程序而异</strong>。</p>
<p>段式存储器的虚拟地址分为两部分：<strong>段号</strong>和<strong>段内地址</strong>。</p>
<p>与页式虚拟存储器一样，虚拟地址与实地址之间的转换式由<strong>段表</strong>来实现的。</p>
<p>段表的每行记录：<strong>段号</strong>、<strong>装入位</strong>、<strong>段起点</strong>和<strong>段长</strong>等信息。</p>
<p><strong>段式虚拟存储器的地址变换过程：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E6%AE%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2.png" alt="段式虚拟存储器的地址变换"></p>
<ul>
<li>根据<strong>段号</strong>和<strong>段表基地址</strong>拼接成对应的<strong>段表行</strong></li>
<li>根据该段表行的装入位判断该段是否已经装入主存</li>
<li>查询段表的<strong>装入位</strong>，如果装入位是1，那么直接将对应的<strong>物理段号</strong>与虚拟地址中的<strong>段内地址</strong>拼接从而得到<strong>物理地址</strong>；如果装入位是0，那么进行缺段处理（详情可见操作系统）</li>
</ul>
</blockquote>
<p><strong>优点：</strong>段的分界与程序的自然分界相对应，因而具有逻辑独立性，使得它易于编译、管理、修改和保护，也便于多道程序的共享</p>
<p><strong>缺点：</strong>因为段的长度可变，分配空间时容易留下段间碎片</p>
</blockquote>
<h4 id="5-4、段页式虚拟存储器"><a href="#5-4、段页式虚拟存储器" class="headerlink" title="5.4、段页式虚拟存储器"></a>5.4、段页式虚拟存储器</h4><blockquote>
<p><strong>把程序按逻辑结构分段，每段在划分为固定大小的页，主存空间也划分为大小相等的页</strong>。</p>
<p>程序对主存的调入、调出仍<strong>以页为基本单位</strong>。</p>
<p>在段页式虚拟存储器中，每个程序对应一个段表，每段对应一个页表，<strong>段的长度必须是页长的整数倍，段的起点也是某一页的起点</strong></p>
<p><strong>虚地址：</strong>段号、段内页号、页内地址。</p>
<p><strong>CPU访问虚地址：</strong></p>
<blockquote>
<ul>
<li>根据段号得到段表地址</li>
<li>从段表中取出该段的页表起始地址</li>
<li>与虚地址段内页号拼接，得到页表地址</li>
<li>从页表中取出实页号，与页内地址拼接形成主存地址</li>
</ul>
</blockquote>
<p><strong>优点：</strong>结合了页式、段式虚拟存储器的优点</p>
<p><strong>缺点：</strong>在地址转换过程中需要两次查表，系统开销较大</p>
</blockquote>
<h4 id="5-5、虚拟存储器与Cache的比较"><a href="#5-5、虚拟存储器与Cache的比较" class="headerlink" title="5.5、虚拟存储器与Cache的比较"></a>5.5、虚拟存储器与Cache的比较</h4><blockquote>
<ul>
<li><p><strong>相同之处：</strong></p>
<blockquote>
<ul>
<li>最终目标都是提高系统性能</li>
<li>都把数据划分为小信息块，并作为基本的传递单位，虚拟系统的信息块更大</li>
<li>都有地址映射、替换算法、更新策略等</li>
<li>都依据程序的局部性原理应用</li>
</ul>
</blockquote>
</li>
<li><p><strong>不同之处：</strong></p>
<blockquote>
<ul>
<li><strong>Cache主要解决系统速度</strong>，<strong>虚拟存储器主要解决主存容量</strong></li>
<li>Cache全由硬件实现，是硬件存储器，<strong>对所有程序员都是透明的</strong>；而虚拟存储器由操作系统和硬件共同实现，是逻辑上的存储器，对<strong>系统程序员不透明，对应用程序员透明</strong></li>
<li>虚拟存储器系统不命中时对系统性能影响更大</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="四、其他补充"><a href="#四、其他补充" class="headerlink" title="四、其他补充"></a>四、其他补充</h2><blockquote>
<ul>
<li><p>本章将的主存、内存都是同一个东西。</p>
</li>
<li><p><strong>多级缓存：</strong></p>
<blockquote>
<p>在现代计算机系统中经常设立多级Cache（与存储器的分级系统一样，越高的速度越快，容量越小），如</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98.png" alt="多级缓存"></p>
<p>这样设置可以使得在CPU写回时避免与主存接触，从而降低效率。</p>
</blockquote>
</li>
</ul>
</blockquote>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">一、存储系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">1、存储器的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">1.2.</span> <span class="toc-text">2、存储器的性能指标</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">二、半导体存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">1、随机存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1%E3%80%81%E9%9D%99%E6%80%81%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8SRAM"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1、静态随机存储器SRAM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2%E3%80%81%E5%8A%A8%E6%80%81%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8DRAM"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2、动态随机存储器DRAM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3%E3%80%81%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.3.</span> <span class="toc-text">1.3、存储芯片的内部结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8-ROM"><span class="toc-number">2.2.</span> <span class="toc-text">2、只读存储器(ROM)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8ECPU%E7%9A%84%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C"><span class="toc-number">3.</span> <span class="toc-text">三、存储器与CPU的协同工作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">1、存储器的层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%B8%BB%E5%AD%98%E4%B8%8ECPU%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.2.</span> <span class="toc-text">2、主存与CPU的连接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1%E3%80%81%E8%BF%9E%E6%8E%A5%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.1、连接原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2%E3%80%81%E4%B8%BB%E5%AD%98%E5%AE%B9%E9%87%8F%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2、主存容量的扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3%E3%80%81CPU%E9%80%89%E6%8B%A9%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.3.</span> <span class="toc-text">2.3、CPU选择存储芯片的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8ECPU%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.4.</span> <span class="toc-text">2.4、存储器与CPU的连接方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%8F%8C%E7%AB%AF%E5%8F%A3RAM%E5%92%8C%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">3、双端口RAM和多模块存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1%E3%80%81%E5%8F%8C%E7%AB%AF%E5%8F%A3RAM"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.1、双端口RAM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2%E3%80%81%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.2、多模块存储器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98Cache"><span class="toc-number">3.4.</span> <span class="toc-text">4、高速缓存Cache</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1%E3%80%81%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.1.</span> <span class="toc-text">4.1、局部性原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2%E3%80%81%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.2.</span> <span class="toc-text">4.2、基本的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3%E3%80%81Cache%E4%B8%8E%E4%B8%BB%E5%AD%98%E7%9A%84%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F"><span class="toc-number">3.4.3.</span> <span class="toc-text">4.3、Cache与主存的映射方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4%E3%80%81Cache%E7%9A%84%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.4.</span> <span class="toc-text">4.4、Cache的替换算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5%E3%80%81Cache%E7%9A%84%E5%86%99%E7%AD%96%E7%95%A5"><span class="toc-number">3.4.5.</span> <span class="toc-text">4.5、Cache的写策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">3.5.</span> <span class="toc-text">5、虚拟存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.5.1.</span> <span class="toc-text">5.1、基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2%E3%80%81%E9%A1%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">3.5.2.</span> <span class="toc-text">5.2、页式虚拟存储器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3%E3%80%81%E6%AE%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">3.5.3.</span> <span class="toc-text">5.3、段式虚拟存储器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4%E3%80%81%E6%AE%B5%E9%A1%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">3.5.4.</span> <span class="toc-text">5.4、段页式虚拟存储器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5%E3%80%81%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8ECache%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">3.5.5.</span> <span class="toc-text">5.5、虚拟存储器与Cache的比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%85%B6%E4%BB%96%E8%A1%A5%E5%85%85"><span class="toc-number">4.</span> <span class="toc-text">四、其他补充</span></a></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
