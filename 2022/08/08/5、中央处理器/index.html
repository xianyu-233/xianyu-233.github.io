
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>中央处理器 - Hexo</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="xainyu-233,"> 
    <meta name="description" content="一、CPU的功能与基本结构1、CPU的功能
中央处理器（CPU）是由运算器和控制器组成。
其中控制器的功能是：负责协调并控制计算机各部件执行程序的指令序列，包括取指令、分析指令和执行指令
其中运算器,"> 
    <meta name="author" content="xianyu"> 
    <link rel="alternative" href="atom.xml" title="Hexo" type="application/atom+xml"> 
    <link rel="icon" href="/img/%E5%96%B7.jfif"> 
    
    
<link rel="stylesheet" href="/css/diaspora.css">

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Hexo</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://xianyu-233.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">中央处理器</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">中央处理器</h1>
        <div class="stuff">
            <span>八月 08, 2022</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/" rel="tag">基础学科</a></li></ul>


        </div>
        <div class="content markdown">
            <h2 id="一、CPU的功能与基本结构"><a href="#一、CPU的功能与基本结构" class="headerlink" title="一、CPU的功能与基本结构"></a>一、CPU的功能与基本结构</h2><h3 id="1、CPU的功能"><a href="#1、CPU的功能" class="headerlink" title="1、CPU的功能"></a>1、CPU的功能</h3><blockquote>
<p><strong>中央处理器（CPU）</strong>是由<strong>运算器</strong>和<strong>控制器</strong>组成。</p>
<p>其中<strong>控制器</strong>的功能是：负责协调并控制计算机各部件执行程序的指令序列，包括取指令、分析指令和执行指令</p>
<p>其中<strong>运算器</strong>的功能是：对数据进行加工</p>
<p><strong>CPU的具体功能包括：</strong></p>
<blockquote>
<ul>
<li><strong>指令控制</strong>：完成取指令、分析指令和执行指令，即程序的顺序控制</li>
<li><strong>操作控制：</strong>管理并产生由内存取出的每条指令的操作信号，把各个信号送往相应的部件，从而控制这些部件按指令的要求进行动作</li>
<li><strong>时间控制：</strong>对各操作加以时间上的控制</li>
<li><strong>数据加工：</strong>对数据进行算术和逻辑运算</li>
<li><strong>中断处理：</strong>对计算机进行过程中出现的异常情况和特殊请求进行处理</li>
</ul>
</blockquote>
</blockquote>
<h3 id="2、CPU的基本结构"><a href="#2、CPU的基本结构" class="headerlink" title="2、CPU的基本结构"></a>2、CPU的基本结构</h3><blockquote>
<p><strong>结构图：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/CPU%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" alt="CPU的基本结构"></p>
<p>在计算机系统中，中央处理器主要由<strong>运算器</strong>和<strong>控制器</strong>组成。</p>
<p><strong>运算器：</strong></p>
<blockquote>
<p>运算器接收从控制器送来的命令并执行相应的动作，对数据进行加工和处理。</p>
<ul>
<li><strong>算术逻辑单元（ALU）：</strong>主要功能是进行算术&#x2F;逻辑运算</li>
<li><strong>暂存寄存器：</strong>可以用于<strong>暂存从主存读来的数据</strong>，该数据不能存放到通用寄存器中，否则会破坏其内容。<strong>（暂存寄存器对程序员来说是透明的）</strong></li>
<li><strong>累加寄存器（ACC）：</strong>它是一个通用寄存器，用于<strong>暂时存放ALU运算的结果</strong>信息，也可以<strong>作为加法运算的一个输入端</strong>。</li>
<li><strong>通用寄存器：</strong>如AX（累加器）、BX（基地址寄存器）、CX（计数寄存器）、DX（数据寄存器）、SP（堆栈指针）等，用于<strong>存放操作数</strong>和<strong>各种地址信息</strong>。</li>
<li><strong>程序状态字寄存器（PSW）：</strong>保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，如<strong>溢出标志（OF）</strong>、<strong>符号标志（SF）</strong>、<strong>零标志（ZF）</strong>、<strong>进位标志（CF）</strong></li>
<li><strong>移位器：</strong>对操作数或结果进行移位操作</li>
<li><strong>计数器：</strong>控制乘除运算的操作步数</li>
</ul>
</blockquote>
<p><strong>控制器：</strong></p>
<blockquote>
<p>控制器的基本功能就是执行指令，每条指令的执行就是控制器发出的一组微操作实现的。</p>
<p>控制器可以分为：<strong>硬布线控制器</strong>和<strong>微程序控制器</strong></p>
<ul>
<li><strong>程序计数器（PC）：</strong>用于指出下一条指令在主存存放地址。（每次读完一条非跳转指令后会自增）</li>
<li><strong>指令寄存器（IR）：</strong>用于保存当前正在执行的那条指令</li>
<li><strong>指令译码器：</strong>对指令的操作码字段进行译码，向控制器提供特定的操作信号</li>
<li><strong>存储地址寄存器（MAR）：</strong>用于存放要访问的主存单元的地址</li>
<li><strong>存储数据寄存器（MDR）：</strong>用于存放要访问的主存单元的数据</li>
<li><strong>时序系统：</strong>用于产生各种时序信号，它由统一时钟（CLOCK）分频得到</li>
<li><strong>微操作信号发生器：</strong>根据IR的内容、PSW的内容及时序信号，产生控制整个计算机系统所需的各种控制信号。</li>
</ul>
<p><strong>控制器的工作原理：</strong>根据<strong>指令操作码</strong>、<strong>指令的执行步骤（微命令序列）</strong>和<strong>条件信号</strong>来形成当前计算机各部件要用到的控制信号。计算机整体各硬件系统在这些控制信号的控制下协同运行，产生预期的结果。</p>
</blockquote>
</blockquote>
<h2 id="二、指令执行过程"><a href="#二、指令执行过程" class="headerlink" title="二、指令执行过程"></a>二、指令执行过程</h2><h3 id="1、指令周期"><a href="#1、指令周期" class="headerlink" title="1、指令周期"></a>1、指令周期</h3><blockquote>
<p><strong>指令周期：</strong>CPU从主存<strong>取出</strong>并<strong>执行</strong>一条指令的时间。</p>
<p><strong>指令周期</strong>通常用若干<strong>机器周期</strong>来表示，一个<strong>机器周期</strong>又包含若干个<strong>时钟周期</strong>（也称<strong>节拍</strong>或<strong>T周期</strong>，是CPU操作的基本单位）</p>
<p><strong>指令周期、机器周期和时钟周期的关系：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E3%80%81%E6%9C%BA%E5%99%A8%E5%91%A8%E6%9C%9F%E3%80%81%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9F.png" alt="指令周期、机器周期、时钟周期"></p>
</blockquote>
<p>完整的指令周期应该包含：<strong>取指、间址（间接寻址）、执行</strong>和<strong>中断</strong>，即</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F.png" alt="指令周期"></p>
<p>不过，并不是所有指令都会有上面的四个周期，如跳转指令只有取指周期和执行周期。</p>
<p><strong>指令周期流程：</strong></p>
<blockquote>
<img src="/picture/学习/计算组成原理上的图/中央处理器/指令周期流程.png" alt="指令周期流程" style="zoom: 67%;" />

<p>其中这四个周期都有CPU访存操作，取指周期为了获得指令，间址周期为了取得有效地址，执行周期进行了取数，中断周期为了保存程序断点。</p>
<p>为了区分不同的工作周期，在CPU内部设置<strong>4个标志触发器FE、IND、EX</strong>和<strong>INT</strong>，它们分别对应<strong>取指、间址、执行</strong>和<strong>中断周期</strong>，并且以“1”状态表示有效，分别由$1 \to FE$、$1 \to IND$、$1 \to EX$、$1 \to INT$这四个信号表示。</p>
</blockquote>
</blockquote>
<h3 id="2、指令周期的数据流"><a href="#2、指令周期的数据流" class="headerlink" title="2、指令周期的数据流"></a>2、指令周期的数据流</h3><h4 id="2-1、取指周期"><a href="#2-1、取指周期" class="headerlink" title="2.1、取指周期"></a>2.1、取指周期</h4><blockquote>
<p><strong>取指周期的任务就是根据PC中的内容，从主存中取出指令并存到IR中。</strong></p>
<p><strong>具体流程图：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E5%8F%96%E6%8C%87%E5%91%A8%E6%9C%9F.png" alt="取指周期"></p>
<ul>
<li>$PC \to MAR \to 地址总线 \to 主存$（根据当前指令地址PC访问主存中相应的存储块）</li>
<li>$CU发出读命令 \to 控制总线 \to 主存$（控制单元告诉主存进行读操作）</li>
<li>$主存 \to 数据总线 \to MDR \to IR$（主存将要读的指令通过数据总线读到IR中）</li>
<li>$CU发出控制信号 \to PC+1$（PC+1）</li>
</ul>
</blockquote>
</blockquote>
<h4 id="2-2、间址周期"><a href="#2-2、间址周期" class="headerlink" title="2.2、间址周期"></a>2.2、间址周期</h4><blockquote>
<p><strong>间址周期的任务就是读取操作数的有效地址</strong>，这里以一次间址为例。</p>
<p><strong>具体流程图：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E9%97%B4%E5%9D%80%E5%91%A8%E6%9C%9F.png" alt="间址周期"></p>
<ul>
<li>$Ad(IR)或Ad(MDR)\to MAR \to 地址总线 \to 主存$（IR根据形式地址读取操作数的有效地址，这也是<strong>与取指周期的最大区别之一</strong>）</li>
<li>$CU发出读命令 \to 控制总线 \to 主存$​（控制单元告诉主存进行读操作）</li>
<li>$主存 \to 数据总线 \to MDR$（主存将要读的操作数的有效地址通过数据总线读到MDR中）</li>
</ul>
</blockquote>
</blockquote>
<h4 id="2-3、执行周期"><a href="#2-3、执行周期" class="headerlink" title="2.3、执行周期"></a>2.3、执行周期</h4><blockquote>
<p>执行周期就是<strong>根据指令的操作码部分进行相应操作</strong>，不同指令有不同的执行周期操作，没有统一的数据流向。</p>
</blockquote>
<h4 id="2-4、中断周期"><a href="#2-4、中断周期" class="headerlink" title="2.4、中断周期"></a>2.4、中断周期</h4><blockquote>
<p>中断周期的<strong>任务是处理中断请求</strong>。假设程序断点是存入堆栈中，并用SP指示栈顶指针，而且<strong>进栈操作是先修改栈顶指针，后存入数据</strong></p>
<p><strong>具体流程图：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E4%B8%AD%E6%96%AD%E5%91%A8%E6%9C%9F.png" alt="中断周期"></p>
<ul>
<li>$CU控制将SP减1，SP\to MAR \to 地址总线 \to 主存$（先修改栈顶指针，然后将栈顶指针存入主存中）</li>
<li>$CU发出写命令\to 控制总线 \to 存储器$（CU向主存发出写命令）</li>
<li>$PC\to MDR \to 数据总线 \to 主存$（保存断点）</li>
<li>$CU(断点的入口地址)\to PC$（将中断服务程序的入口地址放入PC）</li>
</ul>
</blockquote>
</blockquote>
<h3 id="3、指令执行方案"><a href="#3、指令执行方案" class="headerlink" title="3、指令执行方案"></a>3、指令执行方案</h3><blockquote>
<p>一个指令周期包含几个时间段（如取指、间址、执行、中断），每个步骤完成一部分内容，几个依次执行的步骤完成这条指令的全部功能。根据性能和硬件等因素，可以得到以下不同的方案来安排指令的执行步骤。</p>
<p><strong>单指令周期：</strong></p>
<blockquote>
<p>对所有指令都用相同的执行时间来完成。<strong>指令间串行执行</strong>，即下一条指令只能在前一条指令执行结束后才能启动。</p>
<p><strong>指令周期取决于时间最长的指令的执行时间</strong>。</p>
<p>因此对于一些较短的指令，也需要使用这个较长的时间来执行，会降低整个系统的运行效率。</p>
</blockquote>
<p><strong>多指令周期：</strong></p>
<blockquote>
<p><strong>对不同类型的指令选用不同的执行步骤来完成</strong>，指令间<strong>依旧串行执行</strong>，但每一条指令的执行时间可以不一致。</p>
</blockquote>
<p><strong>流水线方案：</strong></p>
<blockquote>
<p><strong>指令之间可以一定程度上地并行执行</strong>，即在硬件上不冲突时，可以安排多条指令执行各自的阶段。</p>
</blockquote>
</blockquote>
<h2 id="三、数据通路的功能与基本结构"><a href="#三、数据通路的功能与基本结构" class="headerlink" title="三、数据通路的功能与基本结构"></a>三、数据通路的功能与基本结构</h2><h3 id="1、数据通路的功能"><a href="#1、数据通路的功能" class="headerlink" title="1、数据通路的功能"></a>1、数据通路的功能</h3><blockquote>
<p><strong>数据通路：</strong>数据在功能部件之间传送的路径</p>
<p>数据通路描述了信息从什么地方开始，中间经过哪个寄存器或开关，最后到达哪个寄存器。</p>
<p>数据通路中专门用于数据运算的部件称为<strong>执行部件</strong>或<strong>功能部件</strong>。数据通路由控制部件控制，控制部件根据每条指令功能的不同生成对数据通路的控制信号（这在下节会重点讲述）</p>
<p><strong>数据通路的功能是将CPU中的运算器与寄存器或寄存器与寄存器之间的数据进行交换（不涉及主存的存取）</strong></p>
</blockquote>
<h3 id="2、数据通路的基本结构"><a href="#2、数据通路的基本结构" class="headerlink" title="2、数据通路的基本结构"></a>2、数据通路的基本结构</h3><blockquote>
<p>数据通路的基本结构主要有以下几种：</p>
<blockquote>
<ul>
<li><strong>CPU内部单总线方式：</strong>将所有寄存器的输入端和输出端都连到同一条数据总线上。</li>
<li><strong>CPU内部三总线方式：</strong>将所有寄存器的输入端和输出端都连到多 条数据总线上</li>
<li><strong>专用数据通路方式：</strong>根据指令执行过程中的数据和地址流动方向安排连接线路。</li>
</ul>
<p><strong>CPU内部单总线型的数据通路：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E5%8D%95%E6%80%BB%E7%BA%BF%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF.png" alt="单总线数据通路"></p>
<p><strong>补充：</strong></p>
<ul>
<li>单词加in表示该部件允许输入信号，单词加out表示该部件允许输出信号。</li>
<li>内部总线负责CPU运算部件与各寄存器之间的数据交流；系统总线（如数据总线）是负责连接计算机内部各部件的。</li>
</ul>
</blockquote>
</blockquote>
<p><strong>寄存器之间的数据传送：</strong></p>
<blockquote>
<p>寄存器之间的数据传送可通过CPU内部总线完成。以PC为例，将PC的数据传送到MAR中。</p>
<ul>
<li>$(PC)\to Bus \quad \quad PC_{out}有效，PC内容送到总线$</li>
<li>$Bus\to MAR \quad \quad MAR_{in}有效，总线内容送至MAR$</li>
</ul>
</blockquote>
<p><strong>主存与CPU之间的数据传送：</strong></p>
<blockquote>
<p>主存与CPU之间的数据传送也需要借助CPU内部总线完成。以CPU读取主存中的指令为例，将指令从主存读取到IR寄存器中</p>
<ul>
<li>$PC\to BUS\to MAR\quad\quad PC_{out}和MAR_{in}有效，现将指令地址\to MAR$</li>
<li>$1\to R$                                     CU发出读命令</li>
<li>$MEM(MAR)\to MDR \quad MDR_{in}有效$</li>
<li>$MDR\to Bus \to IR \quad\quad MDR_{out}和IR_{in}有效，现将指令\to IR$</li>
</ul>
</blockquote>
<p><strong>执行算术或逻辑运算：</strong></p>
<blockquote>
<p>以加法为例，</p>
<ul>
<li>$Ad(IR)\to Bus \to MAR$			将指令中操作数的有效地址放入MAR中</li>
<li>$1\to R$                                               CU发出读信号</li>
<li>$MEM\to 数据总线 \to MDR$      数据暂时放入MDR中</li>
<li>$MDR \to Bus \to Y$				       MDR再通过内部总线放入暂存器Y中（暂存器不能直接读取主存中的数据）</li>
<li>$(ACC)+(Y) \to Z$                        ACC与Y进行计算，结果放入暂存器Z中</li>
<li>$Z \to ACC$                                        最后再将结果放回ACC中</li>
</ul>
</blockquote>
<p><strong>补充：</strong></p>
<blockquote>
<p>数据通路结构直接影响CPU内各种信息的传送路径，数据通路不同，指令执行过程中的微操作序列也不同，它关系着微操作信号形成部件的设计。 	</p>
</blockquote>
</blockquote>
<p>​	</p>
<h2 id="四、控制器的功能与工作原理"><a href="#四、控制器的功能与工作原理" class="headerlink" title="四、控制器的功能与工作原理"></a>四、控制器的功能与工作原理</h2><h3 id="1、控制器的结构和功能"><a href="#1、控制器的结构和功能" class="headerlink" title="1、控制器的结构和功能"></a>1、控制器的结构和功能</h3><blockquote>
<img src="/picture/学习/计算组成原理上的图/中央处理器/控制器结构.png" alt="控制器结构" style="zoom:67%;" />

<p>计算机五大部件之间的连接关系如图所示。其中虚线框内的就是控制器部件。</p>
<p><strong>控制器的功能：</strong></p>
<blockquote>
<ul>
<li>从主存中取出一条指令，并指出下一条指令的位置</li>
<li>对指令进行进行译码或测试，<strong>产生相应的操作控制信号</strong></li>
<li>控制并指挥CPU、主存、输入和输出部件之间的数据流动情况</li>
</ul>
</blockquote>
<p><strong>控制器的信号：</strong></p>
<blockquote>
<ul>
<li><p><strong>信号输入源：</strong></p>
<blockquote>
<ul>
<li><strong>指令寄存器</strong></li>
<li><strong>时钟</strong></li>
<li><strong>标志（程序状态字寄存器）</strong></li>
<li><strong>外来信号</strong></li>
</ul>
</blockquote>
</li>
<li><p><strong>信号输出点：</strong></p>
<blockquote>
<ul>
<li><strong>CPU的内部控制信号</strong></li>
<li><strong>到控制总线的控制信号</strong></li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>控制器的分类：</strong></p>
<blockquote>
<ul>
<li><strong>硬布线控制器</strong></li>
<li><strong>微程序控制器</strong></li>
</ul>
</blockquote>
</blockquote>
<h3 id="2、硬布线控制器"><a href="#2、硬布线控制器" class="headerlink" title="2、硬布线控制器"></a>2、硬布线控制器</h3><blockquote>
<p>硬布线控制器主要由<strong>组合逻辑电路</strong>和<strong>触发器</strong>组成。</p>
<p><strong>控制单元结构图：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8.png" alt="硬布线控制器"></p>
</blockquote>
<p><strong>硬布线控制器的时序系统概念：</strong></p>
<blockquote>
<ul>
<li><strong>时钟周期：</strong>用时钟信号控制节拍发生器，可以产生节拍，每个节拍的宽度正好对应一个时钟周期。</li>
<li><strong>机器周期：</strong>机器周期是指令执行过程中的一个基准时间。</li>
<li><strong>指令周期：</strong>一条指令从取指到指令执行完成的时间。</li>
<li><strong>微操作命令：</strong>控制单元具有发出各种<strong>操作命令（控制信号）</strong>序列的功能。这些命令与指令有关。</li>
</ul>
</blockquote>
<p><strong>硬布线控制器设计步骤：</strong></p>
<blockquote>
<ul>
<li><p><strong>分析每个阶段的微操作序列</strong></p>
<blockquote>
<p><strong>例如：</strong>取指周期</p>
<blockquote>
<p>PC —&gt; MAR				现指令地址—&gt;MAR</p>
<p>1 —&gt;R						  命令存储器进行读操作</p>
<p>M(MAR) —&gt; MDR	   将指令从主存中读到MDR中</p>
<p>OP(IR) —&gt; CU			  指令操作码进行译码</p>
<p>PC+1 —&gt; PC				PC加1</p>
</blockquote>
<p>上面每一步就是一个微操作序列（微程序），此外还有<strong>间址、执行、中断</strong>等微操作序列。</p>
</blockquote>
</li>
<li><p><strong>选择CPU的控制方式</strong></p>
<blockquote>
<p>控制单元控制一条指令执行的过程，实际上是依次执行一个确定的微操作序列的过程。</p>
<p>根据指令的和每个微操作的所需时间不同，可以分为以下三种：</p>
<ul>
<li><strong>同步控制方式：</strong>系统有一个统一的时钟，<strong>所有信号据来自统一的时钟信号</strong>。（时钟周期通常以最长的微操作序列所需的时间为标准）</li>
<li><strong>异步控制方式：</strong>异步控制不存在基准时标信号。<strong>各部件按自身固有的速度工作</strong>。通过应答方式进行联络。</li>
<li><strong>联合控制方式：</strong>大部分使用同步控制，小部分采用异步控制方式。</li>
</ul>
</blockquote>
</li>
<li><p><strong>安排微操作时序</strong></p>
<blockquote>
<p><strong>安排原则：</strong></p>
<blockquote>
<ul>
<li><strong>微操作的先后顺序不能随意改变</strong></li>
<li><strong>操作对象不同的微操作，应尽量安排在一个节拍内完成</strong>（可以节省操作时间）</li>
<li><strong>占用时间短的微操作可以安排在一个节拍内完成，且可以有先后顺序</strong></li>
</ul>
</blockquote>
<p><strong>例如：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E5%AE%89%E6%8E%92%E5%BE%AE%E6%93%8D%E4%BD%9C%E6%97%B6%E5%BA%8F_%E5%8F%96%E6%8C%87%E5%91%A8%E6%9C%9F.png" alt="安排微操作时序_取指周期"></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E5%AE%89%E6%8E%92%E5%BE%AE%E6%93%8D%E4%BD%9C%E6%97%B6%E5%BA%8F_%E5%8F%96%E6%8C%87%E5%91%A8%E6%9C%9F_%E5%90%8E.png" alt="安排微操作时序_取指周期_后"></p>
<p>因此可以根据微操作的安排原则得到上图的安排，一共安排为三个机器周期。</p>
</blockquote>
</blockquote>
</li>
<li><p><strong>组合逻辑电路设计</strong></p>
<blockquote>
<ul>
<li><p><strong>列出操作时间表</strong></p>
<blockquote>
<p><strong>取指周期时间表：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E5%8F%96%E6%8C%87%E5%91%A8%E6%9C%9F%E6%97%B6%E9%97%B4%E8%A1%A8.png" alt="取指周期时间表"></p>
<p><strong>间址周期时间表：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E9%97%B4%E5%9D%80%E5%91%A8%E6%9C%9F%E6%97%B6%E9%97%B4%E8%A1%A8.png" alt="间址周期时间表"></p>
<p><strong>执行周期时间表：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E6%89%A7%E8%A1%8C%E5%91%A8%E6%9C%9F%E6%97%B6%E9%97%B4%E8%A1%A8.png" alt="执行周期时间表"></p>
</blockquote>
</li>
<li><p><strong>写微操作命令的最简表达式</strong></p>
<blockquote>
<p><strong>以$M(MAR) \to MDR$为例：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E5%BE%AE%E6%93%8D%E4%BD%9C%E4%BF%A1%E5%8F%B7%E7%BB%BC%E5%90%88.png" alt="微操作信号综合"></p>
<p>由上图可以得到产生$M(MAR) \to MDR$信号的电路表达式为：</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F.png" alt="逻辑表达式"></p>
</blockquote>
</li>
<li><p><strong>画出电路逻辑图</strong></p>
<blockquote>
<p>根据表达式可以得到产生$M(MAR) \to MDR$信号的电路逻辑图为：</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1.png" alt="电路设计"></p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<h3 id="3、微程序控制器"><a href="#3、微程序控制器" class="headerlink" title="3、微程序控制器"></a>3、微程序控制器</h3><blockquote>
<p><strong>微程序工作原理：</strong></p>
<blockquote>
<p>事先把<strong>微操作控制信号</strong>存储在一个专门的存储器中（<strong>控制存储器</strong>），将每一条机器指令编写成一个微程序，这些微程序可以存到<strong>控制存储器</strong>中，用寻址用户程序机器指令的办法来寻址每个微程序中的微指令。</p>
</blockquote>
<p><strong>微程序控制的基本概念：</strong></p>
<blockquote>
<ul>
<li><p><strong>微操作：</strong>一条机器指令可以分解成一个微操作序列，微操作序列是计算机中最基本、不可再分的操作。如$PC \to MAR$就属于一个微操作。</p>
</li>
<li><p><strong>微命令：</strong>在进行微操作的时候所产生的各种控制信号，如$1 \to R$产生的读信号。微命令就是微操作的控制信号。<strong>微命令根据相容性可以分为</strong>：<strong>相容性微命令</strong>和<strong>互斥性微命令</strong></p>
</li>
<li><p><strong>微指令：</strong>是若干微命令的集合。微指令通常分为两部分：<strong>操作控制字段</strong>（存放产生某一步所需的各种操作的控制信号）、<strong>顺序控制字段</strong>（存放下一条要执行的微指令的控制存储器地址）</p>
</li>
<li><p><strong>控制存储器（CM）：</strong>用于存放<strong>微程序</strong>，在CPU内部，<strong>用ROM实现</strong>。（与主存储器作区别）</p>
</li>
<li><p><strong>微程序：</strong>是微指令的有序集合，一条指令的功能由一段微程序来实现。</p>
</li>
<li><p><strong>寄存器：</strong></p>
<blockquote>
<ul>
<li><strong>微地址寄存器（CMAR）：</strong>用于存放<strong>控制存储器（CM）</strong>的读&#x2F;写微指令的地址</li>
<li><strong>微指令寄存器（CMDR或$\mu IR$）</strong>：用于存放从<strong>控制存储器（CM）</strong>读出的指令</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>注意：</strong></p>
<blockquote>
<p>对于程序员来说，计算机系统中<strong>微程序</strong>的结构和功能是<strong>透明的</strong>，无须知道。</p>
<p>而程序的结构和功能是由软件设计人员实现编制好并存放在主存或辅存中的。</p>
</blockquote>
</blockquote>
<p><strong>微程序控制器组成和工作过程：</strong></p>
<blockquote>
<p><strong>结构：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" alt="微程序控制器的基本结构"></p>
<ul>
<li><strong>控制存储器（CM）：</strong>是微程序控制器的核心部件，用于存放各指令对应的微程序，<strong>控制存储器用只读存储器ROM构成</strong></li>
<li><strong>微指令寄存器（CMDR）：</strong>用于存放从CM中取出的微指令，位数与微指令字长相等</li>
<li><strong>微地址形成部件：</strong>用于<strong>产生初始微地址</strong>和<strong>后续微地址</strong>，以保证微指令的连续执行</li>
<li><strong>微地址寄存器（CMAR）：</strong>接收微地址形成部件送来的微地址，为在CM中读取微地址作准备</li>
<li><strong>地址译码：</strong>将地址转化为存储单元控制信号</li>
</ul>
<p><strong>控制存储器（CM）的结构：</strong></p>
<blockquote>
<img src="/picture/学习/计算组成原理上的图/中央处理器/控制存储器（CM）的结构.png" alt="控制存储器（CM）的结构" style="zoom:50%;" />

<p>控制存储器中存放了每条指令中各个阶段所需的<strong>微指令</strong>或<strong>微程序</strong>，其结构图如上</p>
<ul>
<li><strong>取指周期：</strong>这是所有指令都需要的实现周期，因此在控制存储器的公共部分可以写入取指周期的微程序。</li>
<li><strong>间址周期&amp;&amp;中断周期：</strong>有些地方会将这两个机器周期也写入控制存储器的公共部分。</li>
<li><strong>执行周期：</strong>微指令的控制执行字段放的都是下一条微指令的地址，最后一条微指令则存放取指周期微程序的起始地址。</li>
</ul>
</blockquote>
</blockquote>
<p><strong>微指令格式：</strong></p>
<blockquote>
<p>微指令格式与微指令的编码方式有关，根据不同的编码方式，可以分为两类：<strong>水平型微指令</strong>和<strong>垂直型微指令</strong></p>
<ul>
<li><p><strong>水平型微指令</strong></p>
<blockquote>
<p><strong>基本格式图：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E6%B0%B4%E5%B9%B3%E5%9E%8B%E5%BE%AE%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F.png" alt="水平型微指令格式"></p>
<p>一次可以定义并执行多个并行操作（其中A就是操作类型）</p>
<p><strong>优点：</strong>程序短，执行速度快</p>
<p><strong>缺点：</strong>微指令长，编写微程序复杂</p>
</blockquote>
</li>
<li><p><strong>垂直型微指令</strong></p>
<blockquote>
<p><strong>基本格式图：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E5%9E%82%E7%9B%B4%E5%9E%8B%E5%BE%AE%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F.png" alt="垂直型微指令格式"></p>
<p>采用类似机器指令操作码的方式，在微指令中设置微操作码字段</p>
<p><strong>优点：</strong>指令短，简单，便于微程序的编写</p>
<p><strong>缺点：</strong>微程序长，执行速度慢，工作效率低</p>
</blockquote>
</li>
<li><p><strong>混合型微指令</strong></p>
<blockquote>
<p>在垂直型微指令的基础上加入一些不太复杂的并行操作，从而使微指令同时具备水平型微指令和垂直型微指令的特点。</p>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>微指令的编码方式</strong></p>
<blockquote>
<p>微指令的编码方式又称微指令的控制方式，是指如何<strong>对微指令的控制字段进行编码</strong>，从而形成控制信号。</p>
<ul>
<li><p><strong>直接编码（直接控制）：</strong></p>
<blockquote>
<p>对控制字段直接编码，无需译码，即<strong>在控制字段中，每一位都代表一个微操作命令</strong>，如图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E7%9B%B4%E6%8E%A5%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F.png" alt="直接编码方式"></p>
<p>在设置微指令的时候，可以直接将对应位的微命令信号设置为0&#x2F;1即可</p>
<p><strong>优点：</strong>简单、直观，执行速度快，操作并行性好</p>
<p><strong>缺点：</strong>微指令字长过长。</p>
</blockquote>
</li>
<li><p><strong>字段直接编码：</strong></p>
<blockquote>
<p>将微指令的微命令字段分成若干小字段，<strong>每段经过编码后再发出控制信号</strong>，如图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E5%AD%97%E6%AE%B5%E7%9B%B4%E6%8E%A5%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F.png" alt="字段直接编码方式"></p>
<p><strong>注意：</strong>每一段中的微命令都是互斥的。（如$(PC)\to MAR和PC+1 \to PC$这一类信号不可能同时发出）</p>
<p><strong>微命令字段分段原则：</strong></p>
<blockquote>
<ul>
<li><strong>互斥性微命令分在同一段内，相容性微命令分在不同段内</strong></li>
<li><strong>每个小段中包含的信息位不能太多</strong>（会加重译码的复杂度和译码时间）</li>
<li><strong>一般每个小段还要留出一个状态，表示本字段不发出任何微命令信号</strong></li>
</ul>
</blockquote>
<p><strong>优点：</strong>缩短了微指令的长度</p>
<p><strong>缺点：</strong>由于需要编码，因此使用此编码后，微命令信号发出的速度会下降</p>
</blockquote>
</li>
<li><p><strong>字段间接编码：</strong></p>
<blockquote>
<p>在分字段编码的基础之上，<strong>由多个译码结果最后再决定发出的信号</strong>，如图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E5%AD%97%E6%AE%B5%E9%97%B4%E6%8E%A5%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F.png" alt="字段间接编码方式"></p>
<p>一个字段的某些微命令需要另一些字段的微命令来解释，因此也称为<strong>隐式编码</strong>。</p>
<p><strong>优点：</strong>进一步削减了微指令的长度</p>
<p><strong>缺点：</strong>降低微指令的并行控制能力，因此只作于字段直接编码的辅助手段</p>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>微指令的地址形成方式：</strong></p>
<blockquote>
<ul>
<li><p><strong>直接由微指令的下地址字段指出：</strong>微指令格式中设置一个下地址字段，由微指令的下地址字段直接指出后续微指令的地址，这种方式也称为<strong>断定方式</strong></p>
</li>
<li><p><strong>根据机器指令的操作码形成：</strong>指令取到指令寄存器后，微指令的地址由操作码经过微地址形成部件形成。</p>
</li>
<li><p><strong>其余方式：</strong></p>
<blockquote>
<ul>
<li>增量计数器法：即$(CMAR)+1 \to CMAR$</li>
<li>根据各种标志决定微指令分支转移的地址</li>
<li>通过测试网络形成（即通过硬件形成）</li>
<li>由硬件直接产生微程序入口地址</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<p><strong>微程序控制单元的设计</strong></p>
<blockquote>
<ul>
<li><p><strong>分析每个阶段的微操作序列</strong></p>
<blockquote>
<p><strong>例如：</strong>取指周期</p>
<blockquote>
<p>PC —&gt; MAR				现指令地址—&gt;MAR</p>
<p>1 —&gt;R						  命令存储器进行读操作</p>
<p>M(MAR) —&gt; MDR	   将指令从主存中读到MDR中</p>
<p>OP(IR) —&gt; CU			  指令操作码进行译码</p>
<p>PC+1 —&gt; PC				PC加1</p>
</blockquote>
<p>上面每一步就是一个微操作序列（微程序），此外还有<strong>间址、执行、中断</strong>等微操作序列。</p>
</blockquote>
</li>
<li><p><strong>写出对应机器指令的微操作命令及节拍安排</strong></p>
<blockquote>
<ul>
<li>写出每个周期所需要的微操作</li>
<li>补充微程序控制器特有的微操作</li>
</ul>
<p><strong>例如：</strong>取指周期</p>
<blockquote>
<ul>
<li><strong>写出每个周期所需要的微操作</strong></li>
</ul>
<blockquote>
<p>PC —&gt; MAR				现指令地址—&gt;MAR<br>1 —&gt;R						  命令存储器进行读操作</p>
<p>M(MAR) —&gt; MDR	   将指令从主存中读到MDR中<br>(PC)+1 —&gt; PC				PC加1</p>
<p>MDR —&gt; IR<br>OP (IR) —&gt; 微地址形成部件</p>
</blockquote>
<ul>
<li><strong>补充微程序控制器特有的微操作</strong></li>
</ul>
<blockquote>
<p>由上述形成三条微指令，但是还需要考虑如何读出这三条微指令以及如何转入下一周期，即</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E7%9A%84%E5%BE%AE%E6%8C%87%E4%BB%A4%E8%AE%BE%E8%AE%A1.png" alt="微程序控制单元的微指令设计"></p>
<p>因此在对取指令设计其微指令时，我们可以设计6条微指令来实现取指令这一操作</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><p><strong>确定微指令格式</strong></p>
<blockquote>
<p>采用微指令的格式，然后确定微指令的编码方式。</p>
</blockquote>
</li>
<li><p><strong>编写微指令码点</strong></p>
<blockquote>
<p>根据操作控制字段每一位代表的微操作命令，编写每一条微指令的码点</p>
</blockquote>
</li>
</ul>
<p><strong>补充：</strong></p>
<blockquote>
<ul>
<li><p><strong>静态微程序设计和动态微程序设计</strong></p>
<blockquote>
<p><strong>静态：</strong>微程序无需改变，使用ROM作控制存储器（CM）</p>
<p><strong>动态：</strong>通过改变微指令和微程序改变机器指令，因此采用EPROM作控制存储器（CM）</p>
</blockquote>
</li>
<li><p><strong>毫微程序设计：</strong>在微指令的基础上再设计一层来解释微指令。（关系类似于指令和微指令的关系）</p>
</li>
</ul>
</blockquote>
</blockquote>
<p><strong>硬布线和微程序的比较</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E7%A1%AC%E5%B8%83%E7%BA%BF%E5%92%8C%E5%BE%AE%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="硬布线和微程序的比较"></p>
</blockquote>
</blockquote>
<h2 id="五、指令流水线"><a href="#五、指令流水线" class="headerlink" title="五、指令流水线"></a>五、指令流水线</h2><h3 id="1、指令流水线的基本概念"><a href="#1、指令流水线的基本概念" class="headerlink" title="1、指令流水线的基本概念"></a>1、指令流水线的基本概念</h3><blockquote>
<p>一条指令执行的过程可以分解为若干个阶段（取指周期、间址周期、执行周期、中断周期等），而每个阶段所用到的硬件设备各不相同，因此可以将各阶段视作流水线，那么指令就形成了一条指令流水线。</p>
<p><strong>定义：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="指令执行过程"></p>
<ul>
<li><strong>取指：</strong>根据PC内容访问主存储器，取出一条指令送到IR中</li>
<li><strong>分析：</strong>对指令操作码进行译码，按照给定的寻址方式和地址字段中的内容形成操作数的有效地址，并从有效地址中取出操作数</li>
<li><strong>执行：</strong>根据操作数字段，完成指令规定的功能</li>
</ul>
</blockquote>
<p><strong>指令执行方式：</strong></p>
<blockquote>
<ul>
<li><p><strong>顺序执行方式：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C.png" alt="顺序执行"></p>
<p>这是早期的冯·诺依曼机采取的执行方式，又称作<strong>串行执行方式</strong>。所需要的执行时间为：<br>$$<br>T&#x3D;3nt\quad \quad \quad (其中n为指令数量，t为一个阶段所花费的时间，3是指令分成的3个阶段)<br>$$<br><strong>优点：</strong>控制简单，硬件代价小</p>
<p><strong>缺点：</strong>执行指令的速度较慢，任何时刻在机器中只有一条指令在执行，部件利用效率低</p>
</blockquote>
</li>
<li><p><strong>流水线执行方式：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F.png" alt="流水线执行方式"></p>
<p>在将指令分成各个阶段后，由于每个阶段使用的硬件设备不同，因此在上一条指令完成当前阶段的任务后，可以立即去完成下一条指令这一阶段的任务。从而提升运行速度以及部件的利用率。所需要的执行时间为：<br>$$<br>T&#x3D;3t+(n-1)t&#x3D;(2+n)t\quad \quad (其中n为指令数量，t为一个阶段所花费的时间，3是指令分成的3个阶段)<br>$$<br><strong>解释：</strong>可以理解为，除去第一条指令外，所有指令都是在上一条指令完成后一个阶段就完成的，因此可以看作除第一条指令与最后一条指令外，机器同时执行三条指令。</p>
<p><strong>注意：</strong>为了进一步提升运算速度，还可以将指令拆分为5个阶段（常见的也是4、5个阶段）</p>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>流水线的表示方式：</strong></p>
<blockquote>
<ul>
<li><p><strong>指令执行过程图</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%9B%BE.png" alt="指令执行过程图"></p>
<p>可以用于分析指令执行过程和影响流水线的因素</p>
</blockquote>
</li>
<li><p><strong>指令流水线时空图</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%97%B6%E7%A9%BA%E5%9B%BE.png" alt="指令流水线时空图"></p>
<p>用于衡量指令流水线的性能</p>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<h3 id="2、流水线的分类"><a href="#2、流水线的分类" class="headerlink" title="2、流水线的分类"></a>2、流水线的分类</h3><blockquote>
<ul>
<li><strong>部件功能级、处理机级</strong>和<strong>处理机间级流水线</strong></li>
<li><strong>单功能流水线</strong>和<strong>多功能流水线</strong></li>
<li><strong>动态流水线</strong>和<strong>静态流水线</strong></li>
<li><strong>线性流水线</strong>和<strong>非线性流水线</strong></li>
</ul>
</blockquote>
<h3 id="3、影响流水线的因素"><a href="#3、影响流水线的因素" class="headerlink" title="3、影响流水线的因素"></a>3、影响流水线的因素</h3><blockquote>
<p>在指令流水线中，可能会出现一些状况（如所需要的操作数未产生、指令分阶后长度不一样之类的）导致流水线无法正确执行后续指令而引起流水线阻塞或停顿，这种现象被称为<strong>流水线冲突（冒险）</strong>。导致流水线冲突的原因有三种：<strong>资源冲突（结构冒险）</strong>、<strong>数据冲突（数据冒险）</strong>和<strong>控制冲突（控制冒险）</strong></p>
<ul>
<li><p><strong>资源冲突：</strong></p>
<blockquote>
<p><strong>指多条指令同一时刻争用同一资源（一般为硬件资源）而产生的冲突</strong></p>
<img src="/picture/学习/计算组成原理上的图/中央处理器/结构冲突.png" alt="结构冲突" style="zoom:50%;" />

<p>如图，Load指令和Instr3指令同时需要操作主存，因此产生了资源冲突。</p>
<p><strong>解决办法：</strong></p>
<blockquote>
<ul>
<li><strong>后一个指令暂停一个周期，即Instr3延后一个周期来执行</strong></li>
<li><strong>单独设置数据存储器和指令存储器，使得取指和取数操作各自分开</strong></li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>数据冲突：</strong></p>
<blockquote>
<p><strong>指在一个程序中，下一条指令会用到当前指令计算出的结果</strong></p>
<img src="/picture/学习/计算组成原理上的图/中央处理器/数据冲突.png" alt="数据冲突" style="zoom: 67%;" />

<p>如图，后面的sub、and、or指令中都需要用到r1，但是r1在使用时并未放回主存，因此产生了数据冲突</p>
<p><strong>数据冲突的三种类型：</strong></p>
<blockquote>
<ul>
<li><strong>写后读（RAW）：</strong>当前指令将数据写入寄存器后，下一条指令才能从该寄存器读取数据。否则会使得下一条指令读出旧数据。</li>
<li><strong>读后写（WAR）：</strong>当前指令读出数据后，下一条指令才能写该寄存器。否则会读到错误数据（新数据）。</li>
<li><strong>写后写（WAW）：</strong>当前指令写入寄存器后，下一条指令才能写该寄存器。否则，下一条指令在当前指令之前写，会使得寄存器的值不是最新值。（下一条指令的才是最新值）</li>
</ul>
</blockquote>
<p><strong>解决办法：</strong></p>
<blockquote>
<ul>
<li><p><strong>把遇到数据相关的指令及其后续指令都暂停一个或多个时钟周期</strong>，直到数据相关问题消失后才继续执行</p>
<blockquote>
<ul>
<li><p><strong>硬件阻塞（stall）：</strong>在硬件的层面上塞入空白周期，如</p>
<img src="/picture/学习/计算组成原理上的图/中央处理器/硬件阻塞.png" alt="硬件阻塞" style="zoom:50%;" />
</li>
<li><p><strong>软件插入：</strong>在设计指令集时，使用软件塞入”NOP“指令，如</p>
<img src="/picture/学习/计算组成原理上的图/中央处理器/软件插入.png" alt="软件插入" style="zoom:50%;" />

<p><strong>两者区别：</strong>硬件是自动插入的空指令，指令周期不完整；软件插入是手动插入空指令，而且每条空指令都有完整周期（但不做任何操作）。</p>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>数据旁路技术：</strong> 在数据产生的第一时间不是放回主存中，而是<strong>发送给下面需要用到这个数的指令</strong></p>
</li>
<li><p><strong>编译优化：</strong>通过调整指令顺序来解决冲突，即先将不用该操作数的指令先提前执行（这个只能适度调整，应保持整体功能不变的情况下调整）</p>
</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>控制冲突：</strong></p>
<blockquote>
<p><strong>当流水线遇到转移或其它改变PC值的指令时，造成断流</strong>，如</p>
<img src="/picture/学习/计算组成原理上的图/中央处理器/控制冲突.png" alt="控制冲突" style="zoom:60%;" />

<p>Beq指令可能会进行跳转，如果进行跳转，那么执行阶段在第四阶段，而到了第四阶段后，已经开始了三条指令的执行（而这三条指令在原本意愿中不需要执行），因此会造成混乱。</p>
<p><strong>解决办法：</strong></p>
<blockquote>
<ul>
<li><strong>对转移指令进行分支预测，尽早生成转移目标的地址</strong>，又分为静态预测（默认条件不满足）和动态预测（根据历史进行预测）</li>
<li><strong>对转移成功和转移失败上的指令都预先获取</strong></li>
<li><strong>加快和提前形成条件码</strong></li>
<li><strong>根据概率统计，对转移方向进行猜测</strong></li>
</ul>
</blockquote>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="4、流水线的性能指标"><a href="#4、流水线的性能指标" class="headerlink" title="4、流水线的性能指标"></a>4、流水线的性能指标</h3><blockquote>
<p>衡量流水线性能指标主要有<strong>吞吐率</strong>、<strong>加速比</strong>和<strong>效率</strong>，这些都是指令流水线常见的性能指标</p>
<ul>
<li><p><strong>流水线的吞吐率：</strong></p>
<blockquote>
<p>在指令流水线中，吞吐率是指<strong>在单位时间内流水线所完成的任务数量，或输出结果的数量</strong>。其公式为：<br>$$<br>TP &#x3D; \frac{n}{T_k}<br>$$<br>其中，n是任务数，$T_k$是处理完n个任务所用的时间。</p>
<p>在<strong>理想</strong>（不出差错，所有阶段的时间都一样）的情况下，流水线的时空图如下，</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E5%90%9E%E5%90%90%E7%8E%87.png" alt="吞吐率"></p>
<p>设一个分<strong>k段</strong>的指令流水线能够在$(k+n-1)$个时钟周期内完成<strong>n个</strong>任务，$\Delta t$为时钟周期，可以得到流水线的实际吞吐率为<br>$$<br>TP&#x3D;\frac{n}{(k+n-1)\Delta t}<br>$$<br>当连续输入的任务数$n \to \infty$时，得到最大吞吐率为$TP_{max}&#x3D;\frac{1}{\Delta t}$</p>
<p><strong>补充：</strong>在指令流水线中，从第一条指令取指到第一条指令结束这一段时间被称为<strong>装入时间</strong>；从最后一条指令取指到最后一条指令结束这一段时间被称为<strong>排空时间</strong>。</p>
</blockquote>
</li>
<li><p><strong>流水线的加速比：</strong></p>
<blockquote>
<p><strong>定义：</strong>完成同一批任务，不使用流水线所用时间与使用流水线所用的时间之比，公式为：<br>$$<br>S&#x3D;\frac{T_0}{T_k}<br>$$<br>其中$T_0$为不使用流水线的时间，$T_k$为使用流水线的时间。</p>
<p>假设有n条分为k段的指令，每一段使用$\Delta t$的时间，那么流水线的加速比可以写成<br>$$<br>S&#x3D;\frac{kn\Delta t}{(k+n-1)\Delta t}&#x3D;\frac{kn}{k+n-1}<br>$$<br>当连续输入的任务数$n \to \infty$时，得到最大加速比为$S_{max}&#x3D;k$</p>
</blockquote>
</li>
<li><p><strong>流水线的效率：</strong></p>
<blockquote>
<p><strong>定义</strong>：流水线设备利用率</p>
<p>在时空图上，流水线的效率定义为完成n个任务占用的时空区有效面积，即n个任务所用时间和k个流水段所围成的时空区总面积之比，如图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E6%95%88%E7%8E%87.png" alt="流水线的效率"></p>
<p>蓝色的为完成n个任务所用的总时间，红色部分为k个流水段所围成的面积，表达式为：<br>$$<br>E&#x3D;\frac{T_0}{kT_k}<br>$$<br>其中，$T_0$为完成n个任务所花费的时间；$T_k$为流水线完成n个任务所使用的总时间（对应图中的横轴），k为一条指令分成的阶段数（对应图中的纵轴）</p>
<p>当连续输入的任务数$n \to \infty$时，最高效率为$E_{max}&#x3D;1$</p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="5、超标量流水线的基本概念"><a href="#5、超标量流水线的基本概念" class="headerlink" title="5、超标量流水线的基本概念"></a>5、超标量流水线的基本概念</h3><blockquote>
<ul>
<li><p><strong>超标量流水线技术</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E8%B6%85%E6%A0%87%E9%87%8F%E6%8A%80%E6%9C%AF.png" alt="超标量技术"></p>
<p>每个时钟周期内可<strong>并发多条独立指令</strong>，并以<strong>并行操作方式</strong>将多条指令编译并执行，因此需要配备多个功能部件。</p>
<p><strong>注意：</strong>不能调整指令的执行顺序，只能通过编译优化技术，将可以并行的指令搭配起来从而提高运行效率。</p>
</blockquote>
</li>
<li><p><strong>超流水线技术</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E8%B6%85%E6%B5%81%E6%B0%B4%E6%8A%80%E6%9C%AF.png" alt="超流水技术"></p>
<p>在<strong>一个时钟周期内再分段</strong>，即<strong>一个时钟周期内一个功能部件使用多次</strong></p>
<p><strong>注意：</strong>也是不能调整指令的执行顺序，只能通过编译器来解决优化问题</p>
</blockquote>
</li>
<li><p><strong>超长指令字</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E8%B6%85%E9%95%BF%E6%8C%87%E4%BB%A4%E5%AD%97.png" alt="超长指令字"></p>
<p>由编译程序挖掘指令间潜在的并行性，将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字（如多条指令同时取指等），因此需要配备多个功能部件。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="六、其他补充"><a href="#六、其他补充" class="headerlink" title="六、其他补充"></a>六、其他补充</h2><blockquote>
<ul>
<li><p><strong>流水线并不是越多越好：</strong>流水线越多，所需要的控制部件就越复杂，且出现冲突的概率就会越高。</p>
</li>
<li><p><strong>微指令与指令：</strong>在采用微程序控制的CPU中，一条指令对应一个微程序，一个微程序由多个微指令组成。（一条微指令又可以发出多个微命令信号）</p>
</li>
<li><p><strong>指令周期、机器周期和时钟周期：</strong></p>
<blockquote>
<ul>
<li><strong>指令周期：</strong>指令从取出到执行完成所需要的所有时间</li>
<li><strong>机器周期：</strong>在同步控制的机器中，执行指令周期中一步相对完整的操作（如取指阶段）所需的时间（一般安排机器周期长度为：主存周期）</li>
<li><strong>时钟周期：</strong>是计算机主时钟的周期时间，是计算机运行时最基本的时间单位，对应完成一个微操作的时间。通常$时钟周期&#x3D;\frac{1}{计算机主频}$</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81CPU%E7%9A%84%E5%8A%9F%E8%83%BD%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">一、CPU的功能与基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81CPU%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.</span> <span class="toc-text">1、CPU的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81CPU%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">2、CPU的基本结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">二、指令执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F"><span class="toc-number">2.1.</span> <span class="toc-text">1、指令周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">2.2.</span> <span class="toc-text">2、指令周期的数据流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1%E3%80%81%E5%8F%96%E6%8C%87%E5%91%A8%E6%9C%9F"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1、取指周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2%E3%80%81%E9%97%B4%E5%9D%80%E5%91%A8%E6%9C%9F"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2、间址周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3%E3%80%81%E6%89%A7%E8%A1%8C%E5%91%A8%E6%9C%9F"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.3、执行周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4%E3%80%81%E4%B8%AD%E6%96%AD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.4、中断周期</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%96%B9%E6%A1%88"><span class="toc-number">2.3.</span> <span class="toc-text">3、指令执行方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E7%9A%84%E5%8A%9F%E8%83%BD%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">三、数据通路的功能与基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">3.1.</span> <span class="toc-text">1、数据通路的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.</span> <span class="toc-text">2、数据通路的基本结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">四、控制器的功能与工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD"><span class="toc-number">4.1.</span> <span class="toc-text">1、控制器的结构和功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">4.2.</span> <span class="toc-text">2、硬布线控制器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text">3、微程序控制器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">5.</span> <span class="toc-text">五、指令流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.</span> <span class="toc-text">1、指令流水线的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">5.2.</span> <span class="toc-text">2、流水线的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%BD%B1%E5%93%8D%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="toc-number">5.3.</span> <span class="toc-text">3、影响流水线的因素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">5.4.</span> <span class="toc-text">4、流水线的性能指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E8%B6%85%E6%A0%87%E9%87%8F%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.5.</span> <span class="toc-text">5、超标量流水线的基本概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%85%B6%E4%BB%96%E8%A1%A5%E5%85%85"><span class="toc-number">6.</span> <span class="toc-text">六、其他补充</span></a></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
