
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>输入输出系统 - Hexo</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="xainyu-233,"> 
    <meta name="description" content="一、I&amp;#x2F;O系统的基本概念1、基本概念

I&amp;#x2F;O硬件：包括外部设备、设备控制器和接口、I&amp;#x2F;O总线等。通过设备控制器来控制I&amp;#x2F;O设备的具体动作。


外部设备：包,"> 
    <meta name="author" content="xianyu"> 
    <link rel="alternative" href="atom.xml" title="Hexo" type="application/atom+xml"> 
    <link rel="icon" href="/img/%E5%96%B7.jfif"> 
    
    
<link rel="stylesheet" href="/css/diaspora.css">

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Hexo</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://xianyu-233.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">输入输出系统</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">输入输出系统</h1>
        <div class="stuff">
            <span>八月 08, 2022</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/" rel="tag">基础学科</a></li></ul>


        </div>
        <div class="content markdown">
            <h2 id="一、I-O系统的基本概念"><a href="#一、I-O系统的基本概念" class="headerlink" title="一、I&#x2F;O系统的基本概念"></a>一、I&#x2F;O系统的基本概念</h2><h3 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h3><blockquote>
<ul>
<li><p><strong>I&#x2F;O硬件：</strong>包括外部设备、设备控制器和接口、I&#x2F;O总线等。通过设备控制器来控制I&#x2F;O设备的具体动作。</p>
<blockquote>
<ul>
<li><strong>外部设备：</strong>包括输入&#x2F;输出设备及通过输入&#x2F;输出接口才能访问的外存储器设备</li>
<li><strong>I&#x2F;O接口：</strong>又称<strong>I&#x2F;O控制器、设备控制器</strong>，负责协调主机和外部设备之间的数据传输。（I&#x2F;O控制器本质就是一块芯片，一般集成在主板上）</li>
</ul>
</blockquote>
</li>
<li><p><strong>I&#x2F;O软件：</strong>包括驱动程序、用户程序、管理程序、升级补丁等。通常采用I&#x2F;O指令和通道指令（这两与CPU指令有所区别）实现CPU和I&#x2F;O设备的信息交换。</p>
</li>
</ul>
</blockquote>
<h3 id="2、I-O控制方式"><a href="#2、I-O控制方式" class="headerlink" title="2、I&#x2F;O控制方式"></a>2、I&#x2F;O控制方式</h3><blockquote>
<ul>
<li><p><strong>程序查询方式：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/IO%E8%AE%BE%E5%A4%87/%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F.png" alt="程序查询方式"></p>
<p>由CPU通过程序<strong>不断</strong>查询I&#x2F;O设备是否已经做好准备，从而控制I&#x2F;O设备与主机交换信息</p>
</blockquote>
</li>
<li><p><strong>程序中断方式：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/IO%E8%AE%BE%E5%A4%87/%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F.png" alt="程序中断方式"></p>
<p>只在I&#x2F;O设备准备就绪并向CPU发出中断请求时才给予响应</p>
</blockquote>
</li>
<li><p><strong>DMA方式：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/IO%E8%AE%BE%E5%A4%87/DMA%E6%96%B9%E5%BC%8F.png" alt="DMA方式"></p>
<p>主存与I&#x2F;O设备之间有一条直接数据通路，当主存和I&#x2F;O设备交换信息时，无需调用中断服务程序</p>
</blockquote>
</li>
<li><p><strong>通道方式：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/IO%E8%AE%BE%E5%A4%87/%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F.png" alt="通道控制方式"></p>
<p>在系统中设有通道控制部件，每个通道都挂接若干外设，主机在执行I&#x2F;O命令时，只需启动有关通道，通道只需通道程序，从而完成I&#x2F;O操作</p>
</blockquote>
</li>
</ul>
<p>其中，<strong>程序查询方式</strong>和<strong>程序中断方式</strong>主要用于数据传输率较低的外部设备，<strong>DMA方式</strong>和<strong>通道方式</strong>主要用于传输速率较高的设备。</p>
</blockquote>
<h2 id="二、外部设备"><a href="#二、外部设备" class="headerlink" title="二、外部设备"></a>二、外部设备</h2><h3 id="1、输入设备"><a href="#1、输入设备" class="headerlink" title="1、输入设备"></a>1、输入设备</h3><blockquote>
<ul>
<li><p><strong>键盘：</strong></p>
<blockquote>
<p> 键盘通常以矩阵的形式排列按键，每个键用符号表明其含义和作用。每个键相当于一个开关，按下按键时，电信号接通；松开键时，弹簧弹起键，电信号断开。</p>
<p><strong>输入信息的步骤：</strong>①、查出按下的是哪个键；②、将该键翻译成能被主机接收的编码；③、将编码传送给主机</p>
</blockquote>
</li>
<li><p><strong>鼠标：</strong></p>
<blockquote>
<p><strong>工作原理：</strong>鼠标在平面上移动时，其底部传感器把运动的方向和距离检测出来，从而控制光标做相应的运动</p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="2、输出设备"><a href="#2、输出设备" class="headerlink" title="2、输出设备"></a>2、输出设备</h3><blockquote>
<ul>
<li><p><strong>显示器：</strong></p>
<blockquote>
<p>显示设备种类很多，按显示设备所用的显示器分类，有阴极射线管显示器，液晶显示器，发光二极管显示器等。显示器属于点阵方式运行的设备，有以下主要参数：</p>
<ul>
<li><p><strong>屏幕大小：</strong>以屏幕对角线长度表示</p>
</li>
<li><p><strong>分辨率：</strong>所能表示的像素个数，以宽和高的像素数的乘积表示，如$1024 \times 768$</p>
</li>
<li><p><strong>灰度级</strong>：指黑白显示器中所显示的像素点的亮暗差别，在彩电中则是表示为颜色的不同，灰度级越多，图像层次就越清楚、逼真。</p>
</li>
<li><p><strong>刷新：</strong>光点消失前再重新扫描显示一遍的过程</p>
</li>
<li><p><strong>刷新频率：</strong>指单位时间内扫描整个屏幕的次数，当刷新频率大于30Hz时，人眼才不会看出卡顿</p>
</li>
<li><p><strong>显示存储器：</strong>也称刷新存储器，用于存储每帧图像的信息，其存储容量由分辨率和灰度级决定，<br>$$<br>VRAM容量&#x3D;分辨率 \times 灰度级位数 \<br>VRAM带宽&#x3D;分辨率 \times 灰度级位数 \times 帧频<br>$$</p>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="3、外存储器"><a href="#3、外存储器" class="headerlink" title="3、外存储器"></a>3、外存储器</h3><blockquote>
<ul>
<li><strong>磁表面存储器：</strong>指某些磁性材料薄薄地涂在金属铝或塑料表面上作为载磁体来存储信息。磁盘存储器、磁带存储器和磁鼓存储器均属于磁表面存储器</li>
<li><strong>固态硬盘：</strong>采用高性能Flash存储器作为组成元件</li>
<li><strong>光盘存储器：</strong>利用光学原理读&#x2F;写信息的存储装置，采用计较激光束对盘式介质以非接触方式记录信息。</li>
</ul>
</blockquote>
<h2 id="三、I-O接口"><a href="#三、I-O接口" class="headerlink" title="三、I&#x2F;O接口"></a>三、I&#x2F;O接口</h2><h3 id="1、I-O接口的功能"><a href="#1、I-O接口的功能" class="headerlink" title="1、I&#x2F;O接口的功能"></a>1、I&#x2F;O接口的功能</h3><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/IO%E8%AE%BE%E5%A4%87/IO%E6%8E%A5%E5%8F%A3%E7%BB%93%E6%9E%84.png" alt="IO接口结构"></p>
<ul>
<li><strong>数据缓冲：</strong>通过数据缓冲寄存器（DBR）达到主机和外设工作速度的匹配</li>
<li><strong>错误信息或工作状态监测：</strong>通过状态寄存器反馈设备的各种错误、状态信息，供CPU查用</li>
<li><strong>控制和定时：</strong>接收从控制总线发来的控制信号、时钟信号</li>
<li><strong>数据格式转换：</strong>串-并、并-串等格式转换</li>
<li><strong>与主机和设备通信：</strong>实现 主机-I&#x2F;O接口-I&#x2F;O设备 之间的通信</li>
</ul>
</blockquote>
<h3 id="2、I-O接口的基本结构"><a href="#2、I-O接口的基本结构" class="headerlink" title="2、I&#x2F;O接口的基本结构"></a>2、I&#x2F;O接口的基本结构</h3><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/IO%E8%AE%BE%E5%A4%87/IO%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" alt="IO接口的基本结构"></p>
<ul>
<li><strong>主机侧：</strong>指通过总线连接计算机系统的一侧</li>
<li><strong>设备侧：</strong>指与外部设备进行连接的一侧，设备侧可以有多个外部设备的控制逻辑</li>
<li><strong>数据缓冲寄存器：</strong>连接CPU和外设数据交互的一个中间媒介</li>
<li><strong>状态&#x2F;控制寄存器：</strong>状态寄存器：存取设备的状态字；控制寄存器：存放从CPU发送过来的控制命令</li>
<li><strong>I&#x2F;O控制逻辑：</strong>根据主机侧发送过来的命令字，向设备发送相对应的命令（需要驱动程序的协助）</li>
<li><strong>数据线：</strong>读写数据、状态字、控制字、中断类型</li>
<li><strong>地址线：</strong>传送CPU要读取的寄存器的地址（I&#x2F;O端口）</li>
<li><strong>控制线：</strong>读写IO端口的信号、中断请求的信号</li>
</ul>
<p><strong>I&#x2F;O端口：</strong>IO控制器中的各种寄存器的统称</p>
</blockquote>
<h3 id="3、I-O接口类型"><a href="#3、I-O接口类型" class="headerlink" title="3、I&#x2F;O接口类型"></a>3、I&#x2F;O接口类型</h3><blockquote>
<p>根据不同的角度来看，I&#x2F;O接口可以分为不同的类型。</p>
<ul>
<li>按数据传输方式：<strong>并行接口</strong>和<strong>串行接口</strong></li>
<li>按主机访问I&#x2F;O设备的控制方式：<strong>程序查询接口</strong>、<strong>中断接口</strong>和<strong>DMA接口</strong></li>
<li>按功能选择的灵活性：<strong>可编程接口</strong>和<strong>不可编程接口</strong></li>
</ul>
</blockquote>
<h3 id="4、I-O端口机器编址"><a href="#4、I-O端口机器编址" class="headerlink" title="4、I&#x2F;O端口机器编址"></a>4、I&#x2F;O端口机器编址</h3><blockquote>
<p>I&#x2F;O端口是指接口电路中可被CPU直接访问的寄存器，主要有数据端口（读&#x2F;写）、状态端口（读）、控制端口（写）。</p>
<p>I&#x2F;O端口需要能够被访问，就需要对各个端口进行编号，每个端口对应一个地址，而对I&#x2F;O端口的编址方式可以分为<strong>存储器统一编址</strong>和<strong>独立编址</strong></p>
<ul>
<li><strong>存储器统一编址：</strong>又称<strong>存储器映射方式</strong>，指把I&#x2F;O端口当作存储器的单元进行地址分配（即将I&#x2F;O端口的地址放入内存中）。这种方式CPU无需额外设置专门的I&#x2F;O指令，用统一的访存指令就可以访问I&#x2F;O端口。</li>
<li><strong>独立编址：</strong>又称<strong>I&#x2F;O映射方式</strong>，I&#x2F;O端口的地址空间与内存空间是两个独立的地址空间（I&#x2F;O端口的地址与内存分开）。采用这种方式的话CPU需要专门设计相应的I&#x2F;O指令来访问I&#x2F;O端口。</li>
</ul>
</blockquote>
<h2 id="四、I-O控制方式"><a href="#四、I-O控制方式" class="headerlink" title="四、I&#x2F;O控制方式"></a>四、I&#x2F;O控制方式</h2><h3 id="1、程序查询方式"><a href="#1、程序查询方式" class="headerlink" title="1、程序查询方式"></a>1、程序查询方式</h3><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/IO%E8%AE%BE%E5%A4%87/%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F.png" alt="程序查询方式"></p>
<p>信息交换的控制完全由CPU执行程序实现，程序查询方式接口中设置了一组数据缓冲寄存器（数据端口）和一个设备状态寄存器（状态端口）。</p>
<p>主机进行I&#x2F;O操作时，先发出询问信号，读取设备的状态，并根据设备的状态决定下一步操作时进行数据传送还是等待。</p>
<p><strong>程序查询方式的工作流程图：</strong></p>
<blockquote>
<img src="/picture/学习/计算组成原理上的图/IO设备/程序查询方式流程图.png" alt="程序查询方式流程图" style="zoom:50%;" />

<ul>
<li>CPU执行初始化程序，并预置传送参数</li>
<li>向I&#x2F;O接口发出命令字，并启动I&#x2F;O设备</li>
<li>从外设接口读取器状态信息</li>
<li><strong>CPU不断查询I&#x2F;O设备的状态，直至外设准备就绪</strong></li>
<li>传送一次数据</li>
<li>修改地址和计数器参数</li>
<li>判断是否传送完成，如果未完成则返回第三步，直到计数器为0</li>
</ul>
</blockquote>
<p>在这种控制方式下，CPU一旦启动I&#x2F;O，就必须停止现行程序的运行。程序查询的特点时<strong>CPU有“踏步”等待现象</strong>。</p>
<p><strong>优点：</strong>接口设计简单、设备量少</p>
<p><strong>缺点：</strong>CPU需要花大量时间进行查询和等待，且一段时间内只能与一台外设进行交换信息，效率太低</p>
</blockquote>
<h3 id="2、程序中断方式"><a href="#2、程序中断方式" class="headerlink" title="2、程序中断方式"></a>2、程序中断方式</h3><blockquote>
<p><strong>程序中断：</strong>指在计算机执行程序的过程中，出现某些急需处理的异常情况或特殊请求，CPU暂时终止现行程序，转而去对这些异常情况或特殊请求进行处理，在处理完成后CPU又自动返回到原来程序的断点处，继续执行原来的程序。</p>
<p><strong>概念：</strong></p>
<blockquote>
<ul>
<li><strong>中断源：</strong>请求CPU中断的设备或事件。</li>
<li><strong>开中断：</strong>允许CPU处理中断请求</li>
<li><strong>关中断：</strong>不允许CPU处理中断请求</li>
<li><strong>非屏蔽中断：</strong>关中断时也会被影响（如，断点）</li>
<li><strong>可屏蔽中断：</strong>关中断时不会被响应</li>
<li><strong>中断请求标记：</strong>用于区分不同的中断源的一个标记，一般存放在中断请求标记寄存器中</li>
<li><strong>中断向量：</strong>中断服务程序的入口地址</li>
<li><strong>中断向量表：</strong>全部中断向量集中存放的区域</li>
</ul>
</blockquote>
<p><strong>工作流程：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/IO%E8%AE%BE%E5%A4%87/%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B.png" alt="程序中断流程"></p>
<ul>
<li><p><strong>中断请求：</strong></p>
<blockquote>
<p> 即中断源向CPU提出中断信号</p>
<p><strong>CPU响应中断的条件：</strong></p>
<blockquote>
<ul>
<li>中断源有中断请求</li>
<li>CPU允许中断及开中断（异常和不可屏蔽中断不受此限制）</li>
<li>一条指令执行完毕（异常不受此限制），且没有迫切的任务</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>中断响应判优：</strong></p>
<blockquote>
<p>由于中断类型千差万别，因此对于不同的中断信号可以划分不同的优先级（中断判优通常是通过硬件排队器实现的）</p>
<p>一般来说，不可屏蔽中断 &gt; 内部异常 &gt; 可屏蔽中断</p>
<p>内部异常中，硬件故障 &gt; 软件中断</p>
<p>DMA中断请求要优于I&#x2F;O设备传送的中断请求；高速设备优于低速设备；输入设备高于输出设备；实时设备高于普通设备。</p>
<p><strong>注意：</strong>中断请求的优先级可以使用关中断和开中断进行动态调整</p>
</blockquote>
</li>
<li><p><strong>保存现场：</strong></p>
<blockquote>
<p>CPU响应中断后，需要进行一些操作方便呆会回到源程序，这些操作是<strong>由硬件直接实现</strong>的，被称为<strong>中断隐指令</strong>。中断隐指令不是CPU具体的某一条指令，而是一系列操作的统称，其操作如下：</p>
<ul>
<li><strong>关中断：</strong>CPU响应中断后，首先要做的是保护程序的断点以及现场信息。而在保存现场信息的过程是不能中断的，因此需要使用关中断和开中断进行原子操作。</li>
<li><strong>保存断点与保存现场：</strong>将源程序的断点以及所有寄存器的内容存到特定的栈中。</li>
<li><strong>开中断</strong></li>
</ul>
</blockquote>
</li>
<li><p><strong>引出中断服务程序：</strong></p>
<blockquote>
<p>识别中断源，将对应的服务程序入口地址送入程序计数器中。常用的识别方法有：<strong>硬件向量法</strong>和<strong>软件查询法</strong></p>
<p>在保存完断点以后，需要的就是找到中断向量，从而进入中断服务程序。</p>
<p>在排队器输出向量地址后，根据向量地址去查找中断向量表来得到中断向量。</p>
<p><strong>硬件向量法：</strong>中断向量则是由排队器输出的<strong>向量地址</strong>（中断向量的地址，也称为<strong>中断类型号</strong>）所形成。</p>
</blockquote>
</li>
<li><p><strong>执行中断服务程序</strong></p>
</li>
<li><p><strong>恢复现场</strong></p>
<blockquote>
<p>恢复现场也是一个原子操作，因此需要用到开中断和关中断。恢复现场就是将保存现场中存入栈的数据恢复到原来的位置，而且程序计数器也要指回断点处。</p>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>总结：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/IO%E8%AE%BE%E5%A4%87/%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.png" alt="中断处理过程"></p>
<p>程序中断处理时由硬件和软件共同完成的，如图，至中断服务程序寻址之前的步骤都是由硬件实现的，后面一系列操作则是由中断程序完成的。</p>
</blockquote>
<p><strong>多重中断和中断屏蔽技术：</strong></p>
<blockquote>
<ul>
<li><p><strong>多重中断：</strong></p>
<blockquote>
<p>如果CPU在执行中断服务程序的过程中，又出现了更高优先级的中断请求，CPU暂停现行的中断服务程序，转而处理新的中断请求，这就称作<strong>多重中断</strong>（类似函数嵌套）</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/IO%E8%AE%BE%E5%A4%87/%E5%A4%9A%E9%87%8D%E4%B8%AD%E6%96%AD.png" alt="多重中断"></p>
</blockquote>
</li>
<li><p><strong>中断屏蔽技术：</strong></p>
<blockquote>
<p>中断屏蔽技术主要用于多重中断。</p>
<p>每个中断源都会设置一个<strong>屏蔽触发器</strong>，1表示屏蔽该中断源的请求，0表示可以正常发出中断请求，所有屏蔽触发器组合在一起，就会构成一个屏蔽字寄存器，这个寄存器被称为<strong>屏蔽字</strong>，如</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/IO%E8%AE%BE%E5%A4%87/%E5%B1%8F%E8%94%BD%E5%AD%97.png" alt="屏蔽字"></p>
<p><strong>屏蔽字规律：</strong></p>
<blockquote>
<ul>
<li>一般用“1”表示屏蔽，”0“则表示正常申请</li>
<li>每个中断源对应一个屏蔽字，即在处理该中断源时，屏蔽寄存器中的内容为该中断源对应的内容</li>
<li>屏蔽字中“1”越多，优先级越高。每个中断源必须屏蔽它本身</li>
</ul>
<p>例如，当A在进行中断服务时，如果此时D也发送中断请求，由表可知，A不能屏蔽D，那么此时进入多重中断，先执行D的中断服务</p>
</blockquote>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<h3 id="3、DMA方式"><a href="#3、DMA方式" class="headerlink" title="3、DMA方式"></a>3、DMA方式</h3><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/IO%E8%AE%BE%E5%A4%87/DMA%E6%96%B9%E5%BC%8F.png" alt="DMA方式"></p>
<p>DMA方式是一种完全由硬件进行信息传递的控制方式。DMA方式在外设与内存之间开辟一条“直接数据通道”，信息传送不再经过CPU，降低了CPU在传输数据时的开销。</p>
<p>这种方式适用于磁盘、显卡、声卡、网卡等高速设备大批量数据的传送。</p>
<p>在DMA方式中，中断的作用仅限于故障和正常传送结束时的处理</p>
<p><strong>DMA方式的特点：</strong></p>
<blockquote>
<p>主存和DMA接口之间有一条直接数据通路。由于DMA方式传送数据不需要经过CPU，因此不必中断现行程序，I&#x2F;O与主机并行工作，程序和传送并行工作</p>
<ul>
<li>它使主存与CPU的固定联系脱钩，主存既可被CPU访问，也可以被外设访问</li>
<li>在数据传输，主存地址的确定，传输数据的计数等都由硬件电路直接实现</li>
<li>主存中有一块专用缓冲区，及时供给和接收外设的数据</li>
<li>DMA可以使得CPU和外设同时工作</li>
<li>DMA在传输开始前需要通过程序进行预处理，结束后需要通过中断方式进行后处理</li>
</ul>
</blockquote>
<p><strong>DMA控制器的结构：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/IO%E8%AE%BE%E5%A4%87/DMA%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="DMA控制器的结构"></p>
<p>在DMA方式中，对数据传输过程进行控制的硬件称为DMA控制器（DMA接口）。当I&#x2F;O设备需要进行数据传输时，通过DMA控制器向CPU发送传送请求，CPU响应后让出总线。由DMA控制器接管总线从而进行数据传输。</p>
<ul>
<li><strong>控制&#x2F;状态逻辑：</strong>用于指定传送方向，修改传送参数，并对DMA请求信号和CPU响应信号进行协调和同步</li>
<li><strong>主存地址计数器：</strong>存放要交换数据的主存地址</li>
<li><strong>传递长度计数器：</strong>记录传送数据的长度。计数器溢出时，就代表传送完毕，自动发出中断请求信号</li>
<li><strong>数据缓冲寄存器：</strong>暂存每次传送的数据</li>
<li><strong>DMA请求触发器：</strong>当数据缓冲寄存器存好数据后，发出信号，通过控制&#x2F;状态逻辑告知CPU数据已经准备好了</li>
<li><strong>中断机构：</strong>当一个数据块传送完毕后除法中断机构，从而向CPU提出中断请求</li>
</ul>
</blockquote>
<p><strong>DMA的传送方式</strong></p>
<blockquote>
<p>在主存和I&#x2F;O设备之间交换信息时，如果CPU和I&#x2F;O设备同时访问主存，可能会发生冲突，因此DMA可以有以下3种方式使用主存：</p>
<ul>
<li><p><strong>停止CPU访存：</strong>在外设通过DMA访问主存时，直接禁止CPU访问主存，直到外设访问结束后，才将总线控制权交还给CPU</p>
</li>
<li><p><strong>周期挪用（周期窃取）：</strong></p>
<blockquote>
<ul>
<li>当CPU没有访问主存时，外设正常访问主存</li>
<li>当CPU正在访问主存时，等CPU访问完成后，外设才访问CPU</li>
<li>CPU和外设同时都要访问主存时，让外设优先访问，等到外设访问完一个数据后，立即将数据交还给CPU</li>
</ul>
</blockquote>
</li>
<li><p><strong>DMA与CPU交替访存：</strong>将一个周期分成两部分，一半给外设使用，另一半给CPU使用。这种方法不需要总线使用权的申请、建立和归还过程。常使用与CPU工作周期比主存存取周期长的情况</p>
</li>
</ul>
</blockquote>
<p><strong>DMA的传送过程</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/IO%E8%AE%BE%E5%A4%87/DMA%E4%BC%A0%E9%80%81%E6%B5%81%E7%A8%8B.png" alt="DMA传送流程"></p>
<ul>
<li><p><strong>预处理：</strong></p>
<blockquote>
<p>由CPU完成一些必要工作，如执行几条I&#x2F;O指令，测试I&#x2F;O设备的状态，向与DMA控制器有关的寄存器置初值、设置传送方向、启动设备等。然后，CPU就可以继续去做自己的事了，直到I&#x2F;O设备准备好要发送的数据时，I&#x2F;O设备向DMA控制器发送DMA请求，再由DMA控制器向CPU发送总线请求。</p>
</blockquote>
</li>
<li><p><strong>数据传输：</strong></p>
<blockquote>
<p>传输的循环过程如上图所示。</p>
<p><strong>注意：</strong>这一循环过程时由DMA控制器实现的，即<strong>数据传输阶段都是由DMA控制器完成的</strong></p>
</blockquote>
</li>
<li><p><strong>后处理：</strong></p>
<blockquote>
<p>DMA控制器向CPU发送中断请求，CPU执行中断服务程序。</p>
<p><strong>包括：</strong>校验送入主存的数据是否正确，测试传送过程种是否出错，决定是否继续使用DMA传送其他数据</p>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>DMA方式与中断方式的区别：</strong></p>
<blockquote>
<ul>
<li>中断方式是CPU程序的切换；而DMA方式除了预处理和后处理，其他时间不占用CPU任何资源</li>
<li>对中断请求的响应只能发生在每条指令执行完毕之后；而对DMA请求的响应可以发生在每个机器周期结束时</li>
<li>中断传输过程需要CPU的干预；DMA传输过程不需要CPU的干预</li>
<li><strong>DMA请求的优先级高于中断请求</strong></li>
<li>中断方式可以对异常事件进行处理；而DMA方式只能用于数据传输</li>
<li>中断方式靠程序传递；而DMA方式靠硬件传递</li>
</ul>
</blockquote>
</blockquote>
<h2 id="五、其他补充"><a href="#五、其他补充" class="headerlink" title="五、其他补充"></a>五、其他补充</h2><blockquote>
<ul>
<li><p><strong>通道：</strong>可以理解为一个弱化版的CPU，可以识别并执行一系列<strong>通道指令</strong>（提前编制好，存放在内存中），通道指令种类、功能都比较单一。</p>
</li>
<li><p><strong>I&#x2F;O指令与通道指令：</strong></p>
<blockquote>
<p>I&#x2F;O指令是CPU指令的一部分，而通道指令是通道能识别的指令。</p>
<p>I&#x2F;O指令的格式：<strong>操作码|命令码|设备码</strong>。操作码：识别I&#x2F;O指令；命令码：做什么操作；设备码：对哪个设备进行操作</p>
</blockquote>
</li>
</ul>
</blockquote>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81I-O%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">一、I&#x2F;O系统的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">1、基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81I-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">2、I&#x2F;O控制方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%A4%96%E9%83%A8%E8%AE%BE%E5%A4%87"><span class="toc-number">2.</span> <span class="toc-text">二、外部设备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%BE%93%E5%85%A5%E8%AE%BE%E5%A4%87"><span class="toc-number">2.1.</span> <span class="toc-text">1、输入设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87"><span class="toc-number">2.2.</span> <span class="toc-text">2、输出设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%A4%96%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">2.3.</span> <span class="toc-text">3、外存储器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81I-O%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.</span> <span class="toc-text">三、I&#x2F;O接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81I-O%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">3.1.</span> <span class="toc-text">1、I&#x2F;O接口的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81I-O%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.</span> <span class="toc-text">2、I&#x2F;O接口的基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81I-O%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.</span> <span class="toc-text">3、I&#x2F;O接口类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81I-O%E7%AB%AF%E5%8F%A3%E6%9C%BA%E5%99%A8%E7%BC%96%E5%9D%80"><span class="toc-number">3.4.</span> <span class="toc-text">4、I&#x2F;O端口机器编址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81I-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">四、I&#x2F;O控制方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">1、程序查询方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">2、程序中断方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81DMA%E6%96%B9%E5%BC%8F"><span class="toc-number">4.3.</span> <span class="toc-text">3、DMA方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%85%B6%E4%BB%96%E8%A1%A5%E5%85%85"><span class="toc-number">5.</span> <span class="toc-text">五、其他补充</span></a></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
