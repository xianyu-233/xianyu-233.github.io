
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>指令系统 - Hexo</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="xainyu-233,"> 
    <meta name="description" content="一、指令格式
指令（机器指令）是指计算机执行某种操作的命令。一台计算机的所有指令集合构成该机器的指令系统，也称为指令集。指令系统位于计算机的硬件和软件的交界面上，是计算机的主要属性

1、指令的基本,"> 
    <meta name="author" content="xianyu"> 
    <link rel="alternative" href="atom.xml" title="Hexo" type="application/atom+xml"> 
    <link rel="icon" href="/img/%E5%96%B7.jfif"> 
    
    
<link rel="stylesheet" href="/css/diaspora.css">

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Hexo</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://xianyu-233.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">指令系统</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">指令系统</h1>
        <div class="stuff">
            <span>八月 08, 2022</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/" rel="tag">基础学科</a></li></ul>


        </div>
        <div class="content markdown">
            <h2 id="一、指令格式"><a href="#一、指令格式" class="headerlink" title="一、指令格式"></a>一、指令格式</h2><blockquote>
<p><strong>指令（机器指令）</strong>是指计算机执行某种操作的命令。一台计算机的所有指令集合构成该机器的<strong>指令系统</strong>，也称为<strong>指令集</strong>。指令系统位于计算机的硬件和软件的交界面上，是计算机的主要属性</p>
</blockquote>
<h3 id="1、指令的基本格式"><a href="#1、指令的基本格式" class="headerlink" title="1、指令的基本格式"></a>1、指令的基本格式</h3><blockquote>
<p>一条指令就是机器语言的一个语句。一条指令通常由两部分组成：<strong>操作码字段</strong>和<strong>地址码字段</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F.png" alt="指令格式"></p>
<ul>
<li><strong>操作码字段：</strong>指明该指令应该执行什么性质的操作以及具有什么功能</li>
<li><strong>地址码字段：</strong>指明被操作的信息（指令或数据）的地址</li>
</ul>
<p><strong>补充：</strong></p>
<blockquote>
<p>指令长度是指一条指令中所包含的二进制代码的<strong>位数</strong>。</p>
<p>指令字长与机器字长没有固定关系，指令指出可以小于机器字长，也可以大于机器字长。</p>
</blockquote>
<p>根据指令中操作数地址的个数，可以将指令分成以下几种格式：</p>
<ul>
<li><p><strong>零地址指令：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4.png" alt="零地址指令"></p>
<p>只有操作码OP，没有显示地址，这种指令有两种可能</p>
<ul>
<li><strong>不需要操作数的指令：</strong>如空操作指令、停机指令、关中断指令等</li>
<li><strong>运行在堆栈计算机中：</strong>指令的操作数地址默认存储在栈顶中，执行指令时自动在栈顶中获取</li>
</ul>
</blockquote>
</li>
<li><p><strong>一地址指令：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E4%B8%80%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4.png" alt="一地址指令"></p>
<p>这种指令也有两种常见形态：</p>
<ul>
<li><p><strong>只有目的操作数的单操作数指令：</strong>按$A_1$地址读取操作数，进行OP操作后，将结果存回原地址。</p>
<p><strong>指令含义：</strong>$OP(A_1) \to A_1$</p>
<p><strong>常见操作：</strong>加1、减1、求反、求补等</p>
</li>
<li><p><strong>隐含约定目的地址的双操作数指令：</strong>按按$A_1$地址读取源操作数，指令可隐含约定另一个操作数由<strong>累加器（ACC）</strong>提供，运算结果也存到累加器中。</p>
<p><strong>指令含义：</strong>$(ACC)OP(A_1) \to ACC$</p>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>二地址指令：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E4%BA%8C%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4.png" alt="二地址指令"></p>
<ul>
<li><strong>指令含义：</strong>$(A_1)OP(A_2) \to A_1$</li>
<li><strong>常见操作：</strong>算术运算、逻辑运算，其中目的操作数地址还用于保存本次运算结果。</li>
</ul>
</blockquote>
</li>
<li><p><strong>三地址指令：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E4%B8%89%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4.png" alt="三地址指令"></p>
<ul>
<li><strong>指令含义：</strong>$(A_1)OP(A_2) \to A_3$</li>
</ul>
<p>如果三个地址都是主存地址，则完成一条三地址指令需要进行4次访存（读取指令1次，读取两个操作数2次，存放结果1次）</p>
</blockquote>
</li>
<li><p><strong>四地址指令：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E5%9B%9B%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4.png" alt="四地址指令"></p>
<ul>
<li><strong>指令含义：</strong>$(A_1)OP(A_2) \to A_3,A_4&#x3D;下一条指令的地址$</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="2、定长操作码指令格式"><a href="#2、定长操作码指令格式" class="headerlink" title="2、定长操作码指令格式"></a>2、定长操作码指令格式</h3><blockquote>
<p>定长操作码指令在指令字的最高位部分<strong>分配若干位（定长）表示操作码</strong>，即一共n位操作码字段的治理系统最大能表示$2^n$条指令。</p>
<p>定长操作码有利于计算机硬件设计与提高译码速度，但缺点是操作码长度固定不变，有时会造成不必要的浪费。</p>
</blockquote>
<h3 id="3、扩展操作码指令格式"><a href="#3、扩展操作码指令格式" class="headerlink" title="3、扩展操作码指令格式"></a>3、扩展操作码指令格式</h3><blockquote>
<p>为了在指令字长有限的前提下仍能保持丰富的指令种类，可采用可变长度操作码，即<strong>指令操作码字段位数不固定</strong>。例如，</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C%E7%A0%81%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F.png" alt="扩展操作码指令格式"></p>
<p>在上例中，<strong>16位</strong>长度的指令可以表示：15条三地址指令、15条二地址指令、15条一地址指令和16条零地址指令。</p>
<p>且，<strong>三地址指令</strong>的操作码取值：$0000—1110$；<strong>二地址指令</strong>的操作码取值：$1111\ 0000—1111\ 1110$；<strong>一地址指令</strong>的操作码取值：$1111\ 1111\ 0000—1111\ 1111\ 1110$；<strong>零地址指令</strong>的操作码取值：$1111\ 1111\ 1111\ 0000—1111\ 1111\ 1111\ 1110$；</p>
<p>通常情况下，对使用频率较高的指令分配较短的操作码，对使用频率较低的指令分配较长的操作码。（哈夫曼编码）</p>
<p><strong>注意：</strong></p>
<blockquote>
<ul>
<li><strong>短码的前缀不能是长码的前缀</strong>，即短码短码操作码不能与长码操作码前面重合</li>
<li><strong>各指令的操作码不能重复</strong></li>
</ul>
</blockquote>
</blockquote>
<h3 id="4、指令的操作类型"><a href="#4、指令的操作类型" class="headerlink" title="4、指令的操作类型"></a>4、指令的操作类型</h3><blockquote>
<ul>
<li><p><strong>数据传送</strong></p>
<blockquote>
<ul>
<li><strong>寄存器之间的传送（MOV）</strong></li>
<li><strong>从内存单元读取数据到CPU寄存器（LOAD）</strong></li>
<li><strong>从CPU寄存器写数据到内存单元（STORE）</strong></li>
</ul>
</blockquote>
</li>
<li><p><strong>算术与逻辑运算</strong></p>
<blockquote>
<ul>
<li><strong>加（ADD）</strong></li>
<li><strong>减（SUB）</strong></li>
<li><strong>比较（CMP）</strong></li>
<li><strong>乘（MUL）</strong></li>
<li><strong>除（DIV）</strong></li>
<li><strong>加1（INC）</strong></li>
<li><strong>减1（DEC）</strong></li>
<li><strong>与（AND）</strong></li>
<li><strong>或（OR）</strong></li>
<li><strong>取反（NOT）</strong></li>
<li><strong>异或（XOR）</strong></li>
</ul>
</blockquote>
</li>
<li><p><strong>移位操作</strong></p>
<blockquote>
<ul>
<li><strong>算术移位</strong></li>
<li><strong>逻辑移位</strong></li>
<li><strong>循环移位</strong></li>
</ul>
</blockquote>
</li>
<li><p><strong>转移操作</strong></p>
<blockquote>
<ul>
<li><strong>无条件转移（JMP）</strong></li>
<li><strong>条件转移（BRANCH）</strong></li>
<li><strong>调用（CALL）</strong></li>
<li><strong>返回（RET）</strong></li>
<li><strong>陷阱（TRAP）</strong></li>
</ul>
</blockquote>
</li>
<li><p><strong>输入输出操作</strong></p>
<blockquote>
<p>用于完成CPU与外部设备交换数据或传送控制命令及状态信息</p>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="二、指令的寻址方式"><a href="#二、指令的寻址方式" class="headerlink" title="二、指令的寻址方式"></a>二、指令的寻址方式</h2><h3 id="1、指令寻址和数据寻址"><a href="#1、指令寻址和数据寻址" class="headerlink" title="1、指令寻址和数据寻址"></a>1、指令寻址和数据寻址</h3><blockquote>
<p>寻址方式是寻找指令或操作数有效地址的方式，即确定本条指令的数据地址及下一条待执行指令的地址的方式。寻址方式分为<strong>指令寻址</strong>和<strong>数据寻址</strong>两大类。</p>
<ul>
<li><p><strong>指令寻址：</strong></p>
<blockquote>
<p>指令寻址方式有两种：一种是<strong>顺序寻址方式</strong>，另一种是<strong>跳跃寻址方式</strong></p>
<ul>
<li><strong>顺序寻址：</strong>通过程序计数器（PC）加1（1个指令字长），自动形成下一条指令的地址。</li>
<li><strong>跳跃寻址：</strong>通过转移类指令实现，即下一条指令的地址码不由程序计数器给出，而由本条指令给出下条指令地址的计算方式。给出的地址也有<strong>绝对地址</strong>和<strong>相对地址</strong>，不过跳跃结果都是通过程序计数器（PC）给出。</li>
</ul>
</blockquote>
</li>
<li><p><strong>数据寻址：</strong></p>
<blockquote>
<p>数据寻址是指如何在指令中表示一个操作数的地址，如何用这种表示得到操作数或算出操作数的地址。</p>
<p>数据寻址方式较多，为了区分各种方式，通常在指令中设一个字段，用于表示寻址方式，格式如下</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E6%8C%87%E4%BB%A4%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%AF%BB%E5%9D%80%EF%BC%89.png" alt="指令模式（寻址）"></p>
<ul>
<li><strong>操作码：</strong>本条指令要执行的操作</li>
<li><strong>寻址特征：</strong>寻址的方式</li>
<li><strong>形式地址A：</strong>指令的操作数地址，有可能是有效地址、间接地址、寄存器号等</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="2、常见的数据寻址方式"><a href="#2、常见的数据寻址方式" class="headerlink" title="2、常见的数据寻址方式"></a>2、常见的数据寻址方式</h3><blockquote>
<p><strong>补充：</strong>以下指令都假设只有一个操作数。</p>
<ul>
<li><p><strong>立即（数）寻址</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%80.png" alt="立即寻址"></p>
<p>这种类型的指令的<strong>地址字段</strong>给出的不是操作数地址，而是操作数本身，又称<strong>立即数</strong>。</p>
<p>数据采取<strong>补码</strong>形式存放。</p>
<p><strong>访问内存次数：</strong>取指令1次，共1次。</p>
<p><strong>优点：</strong>指令在<strong>执行阶段</strong>不访问主存，指令执行时间最短</p>
<p><strong>缺点：</strong>A的位数限制了立即数的范围</p>
</blockquote>
</li>
<li><p><strong>直接寻址</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.png" alt="直接寻址"></p>
<p>指令字中的形式地址A是操作数的真实地址EA，即<strong>EA&#x3D;A</strong></p>
<p><strong>访问内存次数：</strong>取指令1次，取操作数1次，一共2次。</p>
<p><strong>优点：</strong>指令在<strong>执行阶段</strong>仅访问一次内存，不需要专门计算操作数的地址</p>
<p><strong>缺点：</strong>A的位数决定了该指令操作数的寻址范围，操作数的地址不易修改。</p>
</blockquote>
</li>
<li><p><strong>间接寻址：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.png" alt="间接寻址"></p>
<p>间接寻址是相对直接寻址而言的，指令的地址字段给出的形式地址不是操作数的真实地址，而是操作数有效地址所在的存储单元的地址，即<strong>EA&#x3D;(A)</strong></p>
<p><strong>访问内存次数：</strong>取指令1次，取有效地址1次，取操作数1次，一共3次。</p>
<p><strong>优点：</strong>扩大寻址范围，便于编址程序（用间接地址方便子程序返回）</p>
<p><strong>缺点：</strong>指令在执行阶段要多次访存</p>
<p><strong>补充：</strong></p>
<blockquote>
<ul>
<li>在间接寻址中，主存第一位为1时，表示取出的仍不是操作数的地址，此时为多次间址；主存第一位为0时，才表示取得的是操作数的地址。</li>
<li>由于间接寻址的速度较慢（因为要多次访存），因此<strong>问道扩大寻址范围时，通常指的是寄存器间接寻址</strong></li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>隐含寻址：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E9%9A%90%E5%90%AB%E5%AF%BB%E5%9D%80.png" alt="隐含寻址"></p>
<p>这种类型的指令不明显地给出操作数的地址，而是在指令中隐含操作数的地址。如，一条加法指令中，可以规定累加器（ACC）作为第二操作数的地址，指令仅给出第一个操作数的地址。</p>
<p><strong>访问内存次数：</strong>取指令1次，一共1次。</p>
<p><strong>优点：</strong>有利于缩短指令字长</p>
<p><strong>缺点：</strong>需要增加<strong>存储操作数或隐含地址的硬件</strong></p>
</blockquote>
</li>
<li><p><strong>寄存器寻址</strong>：</p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80.png" alt="寄存器寻址"></p>
<p>寄存器寻址是指指令地址字段中直接给出操作数所在的<strong>寄存器编号</strong>，即<strong>EA&#x3D;R</strong>，器操作数在由R所指示的寄存器内。</p>
<p><strong>访问内存次数：</strong>取指令1次，一共1次。</p>
<p><strong>优点</strong>：指令执行过程不访问内存，只访问寄存器</p>
<p><strong>缺点：</strong>寄存器价格昂贵，且数量有限</p>
</blockquote>
</li>
<li><p><strong>寄存器间接寻址</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.png" alt="寄存器间接寻址"></p>
<p>在该指令类型中，寄存器R中给出的不是一个操作数，而是操作数所在内存单元的地址，即<strong>EA&#x3D;（R）</strong></p>
<p><strong>特点：</strong>与间接寻址已知，但由于少访问了1次内存，因此速度快于间接寻址</p>
</blockquote>
</li>
<li><p><strong>偏移寻址</strong></p>
<blockquote>
<ul>
<li><p><strong>相对寻址（指令寻址）：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80.png" alt="相对寻址"></p>
<p>相对寻址是把<strong>程序计数器（PC）</strong>的内容加上指令格式中的形式地址A而形成操作数的有效地址，即<strong>EA&#x3D;(PC)+A</strong>，其中A是相对与当前指令地址的为一类，可正可负，用<strong>补码</strong>表示</p>
<p><strong>访问内存次数：</strong>取指令1次，取操作数1次，一共2次。</p>
<p><strong>优点：</strong>操作数的地址不是固定的，它虽PC值的变化而变化，且与指令地址总是相差一个固定值，便于程序浮动。</p>
<p><strong>补充：</strong>相对寻址被广泛用于<strong>转移指令</strong></p>
</blockquote>
</li>
<li><p><strong>基址寻址</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80.png" alt="基址寻址"></p>
<p>基址寻址是指将CPU中<strong>基址寄存器（BR）</strong>的内容加上指令格式中的形式地址A而形成操作数的有效地址，即<strong>EA&#x3D;(BR)+A</strong>。其中基址寄存器既可以采用专用寄存器，又可以采用通用寄存器。</p>
<p><strong>优点：</strong>扩大寻址范围；用户不必考虑自己的程序存在于内存上的哪个空间，利于多道程序设计，并可用于编址浮动程序</p>
<p><strong>特点：</strong> </p>
<blockquote>
<p> <strong>基址寄存器是面向操作系统</strong>的，其内容由操作系统或管理程序确定。</p>
<p>采用<strong>通用寄存器</strong>作为基址地址时，<strong>可由用户决定</strong>哪个寄存器作为基址寄存器，<strong>但其内容仍由操作系统确定</strong>。</p>
</blockquote>
</blockquote>
</li>
<li><p><strong>变址寻址：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80.png" alt="变址寻址"></p>
<p>变址寻址是指有效地址EA等于指令中的形式地址A于<strong>变址寄存器IX</strong>的内容之和，即<strong>EA&#x3D;(IX)+A</strong>，其中变址寄存器既可以采用专用寄存器，又可以采用通用寄存器。</p>
<p><strong>优点：</strong>可扩大寻址范围；在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器IX的内容，从而适合编址循环程序。</p>
<p><strong>特点：</strong></p>
<blockquote>
<p><strong>变址寄存器是面向用户的</strong>，在程序执行过程中，变址寄存器的内容可由用户改变（作为偏移量），形式地址A不变（作为基地址）。</p>
<p><strong>基址寻址与变址寻址的区别：</strong>基址寄存器中的内容由系统决定，变址寄存器的内容可以由用户在执行程序中改变</p>
</blockquote>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>堆栈寻址：</strong></p>
<blockquote>
<p>堆栈式存储器（或专用寄存器组）中一块特定、按<strong>后进先出（LIFO）</strong>原则管理的存储区，<strong>该存储区中读&#x2F;写单元的地址使用一个特定的寄存器给出</strong>，该寄存器称为<strong>堆栈指针（SP）</strong>。堆栈可分为<strong>硬堆栈</strong>与<strong>软堆栈</strong>两类。</p>
<ul>
<li><strong>硬堆栈：</strong>寄存器堆栈</li>
<li><strong>软堆栈：</strong>从内存中划出一段区域</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>寻址总结：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E5%AF%BB%E5%9D%80%E6%80%BB%E7%BB%93.png" alt="寻址总结"></p>
</blockquote>
<h3 id="3、x86汇编指令入门"><a href="#3、x86汇编指令入门" class="headerlink" title="3、x86汇编指令入门"></a>3、x86汇编指令入门</h3><blockquote>
<ul>
<li><p><strong>相关寄存器</strong></p>
<blockquote>
<p>x86处理器有8个32位的<strong>通用寄存器</strong>，分别为：</p>
<ul>
<li><strong>累加寄存器（EAX）</strong></li>
<li><strong>基地址寄存器（EBX）</strong></li>
<li><strong>计数寄存器（ECX）</strong></li>
<li><strong>数据寄存器（EDX）</strong></li>
<li><strong>变址寄存器（两个）（ESI和EDI）</strong></li>
<li><strong>堆栈基寄存器（EBP）</strong></li>
<li><strong>堆栈顶寄存器（ESP）</strong></li>
</ul>
</blockquote>
</li>
<li><p><strong>寻址模式与内存分配</strong></p>
<blockquote>
<ul>
<li><p><strong>寻址模式</strong></p>
<blockquote>
<p>x86提供了一种灵活的内存寻址方式，这里以mov指令为例，mov用于在内存和寄存器之间移动数据，它的两个参数：第一个为目的地址，第二个为源地址，以下为常见例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [ebx]					;将ebx值所指示的内存地址中的<span class="number">4</span>字节传送到eax中</span><br><span class="line">   	mov [var], ebx					;将ebx值传送到var的值所指示的内存地址中</span><br><span class="line">   	mov eax, [esi<span class="number">-4</span>]				;将esi<span class="number">-4</span>值所指示的内存地址中的<span class="number">4</span>字节传送到eax中</span><br><span class="line">mov [esi+eax], cl				;将cl值传送到esi+eax值所指示的内存地址中</span><br><span class="line">   	mov edx, [esi+<span class="number">4</span>*ebx]			;将esi+<span class="number">4</span>*ebx值所指示的内存中的<span class="number">4</span>字节传送到edx</span><br><span class="line">       </span><br><span class="line">   	<span class="comment">//错误例子</span></span><br><span class="line">   	mov eax, [ebx-ecx]				;错误，寄存器只能参与加法计算</span><br><span class="line">   	mov [eax+esi+edi], ebx			;错误，最多只能有两个寄存器参与运算</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>数据类型长度规定</strong></p>
<blockquote>
<p>在汇编语言中声明内存大小时，一般显式地使用DB（Data Byte）、DW（Data Word，2Byte）和DD（Double Word，4Byte）等标记来指导编译器分配内存空间。</p>
<p>对于物特殊表示的指令，x86提供了三个指示规则标记，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov byte ptr [ebx], <span class="number">2</span>			;将<span class="number">2</span>以单字节形式传送到ebx值所指示的内存地址中</span><br><span class="line">   	mov word ptr [ebx], <span class="number">2</span>			;将<span class="number">2</span>以双字节形式传送到ebx值所指示的内存地址中</span><br><span class="line">   	mov dword ptr [ebx], <span class="number">2</span>			;将<span class="number">2</span>以四字节形式传送到ebx值所指示的内存地址中</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>常用指令</strong></p>
<blockquote>
<p>汇编指令通常可以分为<strong>数据传输指令</strong>、<strong>逻辑计算指令</strong>和<strong>控制流指令</strong>。其中以下操作数的标记分别表示寄存器、内存和常数</p>
<ul>
<li>**<reg>**：表示任意寄存器，若其后带数字，则代表指定其位数，如<reg32>表示32位寄存器</li>
<li><strong><mem>：</strong>表示内存地址</li>
<li><con>：表示常数，若其后带数字，则代表指定其位数，如<con32>表示32位常数</li>
</ul>
<p><strong>数据传输指令：</strong></p>
<blockquote>
<ul>
<li><p><strong>mov指令：</strong></p>
<blockquote>
<p>mov指令将第二个操作数（寄存器、内存中的内容）复制到第一个操作数（寄存器或内存）中。<strong>但不能直接从内存复制到内存</strong>，其语法如下：</p>
<pre><code class="c">    mov &lt;reg&gt;,&lt;reg&gt;
    mov &lt;reg&gt;,&lt;mem&gt;
    mov &lt;mem&gt;,&lt;reg&gt;
    mov &lt;reg&gt;,&lt;con&gt;
    mov &lt;mem&gt;,&lt;con&gt;
</code></pre>
</blockquote>
</li>
<li><p><strong>push指令</strong></p>
<blockquote>
<p>push指令将操作数压入内存的栈，常用于函数调用。ESP是栈顶，压栈前<strong>先将ESP值减4</strong>（字节，<strong>栈的增长方向与内存的增长方向相反</strong>），<strong>然后将操作数压入</strong>ESP指示的地址，其语法如下：</p>
<pre><code class="c">    push &lt;reg32&gt;
        push &lt;mem&gt;
        push &lt;con32&gt;
</code></pre>
</blockquote>
</li>
<li><p><strong>pop指令</strong></p>
<blockquote>
<p>与push指令相反，pop指令执行的工作是出栈，出栈前先将ESP所指示的地址中的内容<strong>出</strong>栈，然后将ESP值加4，其语法如下：</p>
<pre><code class="c">    pop &lt;reg32&gt;
        pop &lt;mem&gt;
        pop &lt;con32&gt;
</code></pre>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>算术和逻辑运算指令：</strong></p>
<blockquote>
<ul>
<li><p><strong>add&#x2F;sub指令</strong></p>
<blockquote>
<p>add指令将两个操作数相加，相加的<strong>结果保存到第一个操作数中</strong>。sub与add指令类似，唯一区别是两操作数相减，语法如下：</p>
<pre><code class="c">    add &lt;reg&gt;,&lt;reg&gt;	/ sub &lt;reg&gt;,&lt;reg&gt;
    add &lt;reg&gt;,&lt;mem&gt;	/ sub &lt;reg&gt;,&lt;mem&gt;
    add &lt;mem&gt;,&lt;reg&gt;	/ sub &lt;mem&gt;,&lt;reg&gt;
    add &lt;reg&gt;,&lt;con&gt;	/ sub &lt;reg&gt;,&lt;con&gt;
    add &lt;mem&gt;,&lt;con&gt;	/ sub &lt;mem&gt;,&lt;con&gt;
</code></pre>
</blockquote>
</li>
<li><p><strong>inc&#x2F;dec指令</strong></p>
<blockquote>
<p>inc、dec指令分别表示将操作数自加1、自减1，其语法如下：</p>
<pre><code class="c">    inc &lt;reg&gt; / dec &lt;reg&gt;
        inc &lt;mem&gt; / dec &lt;mem&gt;
</code></pre>
</blockquote>
</li>
<li><p><strong>imul指令</strong></p>
<blockquote>
<p><strong>带符号整数乘法</strong>指令，有两种格式：</p>
<p>①两个操作数，将两个操作数相乘，并将<strong>结果存放到第一个操作数中，第一个操作数必须为寄存器</strong>；</p>
<p>②三个操作数，将第二个和第三个操作数相乘，将<strong>结果存放到第一个操作数中，第一个操作数必须为寄存器</strong>。其语法如下：</p>
<pre><code class="c">    imul &lt;reg32&gt;,&lt;reg32&gt;
        imul &lt;reg32&gt;,&lt;mem&gt;
        imul &lt;reg32&gt;,&lt;reg32&gt;,&lt;con&gt;
        imul &lt;reg32&gt;,&lt;mem&gt;,&lt;con&gt;
</code></pre>
<p>乘法操作容易造成溢出，因此编译器置溢出位OF&#x3D;1，使得CPU可以调出溢出异常处理程序</p>
</blockquote>
</li>
<li><p><strong>idiv指令</strong></p>
<blockquote>
<p>idiv是带符号整数除法指令，<strong>它只有一个操作数</strong>，即除数，而<strong>被除数则为edx&#x2F;eax中的内容</strong>，操作结果有两部分：商和余数，<strong>商送到eax，余数则送到edx</strong>。其语法如下：</p>
<pre><code class="c">    idiv &lt;reg32&gt;
        idiv &lt;mem&gt;
</code></pre>
</blockquote>
</li>
<li><p><strong>and&#x2F;or&#x2F;xor指令</strong></p>
<blockquote>
<p>and、or、xor指令分别是逻辑与、逻辑或、逻辑异或操作指令，用于操作数的<strong>位操作</strong>，<strong>操作结果放在第一个操作数中</strong>。其语法如下：</p>
<pre><code class="c">    add &lt;reg&gt;,&lt;reg&gt; / or &lt;reg&gt;,&lt;reg&gt; / xor &lt;reg&gt;,&lt;reg&gt;
        add &lt;reg&gt;,&lt;mem&gt; / or &lt;reg&gt;,&lt;mem&gt; / xor &lt;reg&gt;,&lt;mem&gt;
        add &lt;mem&gt;,&lt;reg&gt; / or &lt;mem&gt;,&lt;reg&gt; / xor &lt;mem&gt;,&lt;reg&gt;
        add &lt;reg&gt;,&lt;con&gt; / or &lt;reg&gt;,&lt;con&gt; / xor &lt;reg&gt;,&lt;con&gt;
        add &lt;mem&gt;,&lt;con&gt; / or &lt;mem&gt;,&lt;con&gt; / xor &lt;mem&gt;,&lt;con&gt;
</code></pre>
</blockquote>
</li>
<li><p><strong>not指令</strong></p>
<blockquote>
<p>not指令是位翻转指令，将操作数中的每一位翻转，即$1 \to 0$，$0 \to 1$。其语法如下：</p>
<pre><code class="c">    not &lt;reg&gt;
        not &lt;mem&gt;
</code></pre>
</blockquote>
</li>
<li><p><strong>neg指令</strong></p>
<blockquote>
<p>neg指令是取负指令（$n \to -n$）。其语法如下：</p>
<pre><code class="c">    neg &lt;reg&gt;
        neg &lt;mem&gt;
</code></pre>
</blockquote>
</li>
<li><p><strong>shl&#x2F;shr指令</strong></p>
<blockquote>
<p>shl、shr是<strong>逻辑移位指令</strong>，<strong>shl是逻辑左移指令</strong>，<strong>shr是逻辑右移指令</strong>，第一个操作数表示被操作数，第二个操作数表示移位的位数。其语法如下：</p>
<pre><code class="c"> shl &lt;reg&gt;,&lt;con8&gt; / shr &lt;reg&gt;,&lt;con8&gt;
    shl &lt;mem&gt;,&lt;con8&gt; / shr &lt;mem&gt;,&lt;con8&gt;
    shl &lt;reg&gt;,&lt;cl&gt; / shr &lt;reg&gt;,&lt;cl&gt;			;cl表示循环逻辑位移
    shl &lt;mem&gt;,&lt;cl&gt; / shr &lt;mem&gt;,&lt;cl&gt;
</code></pre>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>控制流指令：</strong></p>
<blockquote>
<p>x86处理器维持着一个当前执行指令的指令指针（IP），当一条指令执行后，此指针自动指向下一条指令。<strong>IP寄存器不能直接操作，</strong>但可以通过控制流指令更新。通常用标签（label）指示程序中的指令地址，在x86汇编代码中，可以在任何指令前加入标签。如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	mov esi, [ebp+<span class="number">8</span>]</span><br><span class="line">begin: 	xor ecx, ecx</span><br><span class="line">    		mov eax, [esi]</span><br></pre></td></tr></table></figure>

<p>这样利用转跳指令时，可以直接转跳到begin所指的位置</p>
<ul>
<li><p><strong>jump指令</strong></p>
<blockquote>
<p>jump指令控制IP转移到label所指示的地址。其语法如下，</p>
<pre><code class="c">    jmp &lt;label&gt;
</code></pre>
</blockquote>
</li>
<li><p><strong>jcondition指令</strong></p>
<blockquote>
<p>条件转移指令，它根据处理机状态字中的条件进行转移。处理机状态包括算术运算结果是否为0，运算结果是否为负数等。其语法如下：</p>
<pre><code class="c"> je &lt;label&gt;				;jump when qeual
    jne &lt;label&gt;				;jump when not qeual
    jz &lt;label&gt;				;jump when last result was zero
    jg &lt;label&gt;				;jump when greater than
    jge &lt;label&gt;				;jump when greater than or equal to
    jl &lt;label&gt;				;jump when less than
    jle &lt;label&gt;				;jump when less than or equal to
</code></pre>
</blockquote>
</li>
<li><p><strong>cmp指令</strong></p>
<blockquote>
<p>cmp指令用于比较两个操作数的值，并根据比较结果设置处理机状态字中的条件码。其语法如下：</p>
<pre><code class="c">    cmp &lt;reg&gt;,&lt;reg&gt;
     cmp &lt;reg&gt;,&lt;mem&gt;
        cmp &lt;mem&gt;,&lt;reg&gt;
        cmp &lt;reg&gt;,&lt;con&gt;
</code></pre>
<p>其中cmp常与jcondition指令一起使用，如</p>
<pre><code class="c">    cmp dword ptr [var], 10
        jne loop				;如果var所指示的内存地址的4字节内容等于10，则继续执行下一跳指令；否则转跳							 到loop所指示的指令中
</code></pre>
</blockquote>
</li>
<li><p><strong>call&#x2F;ret指令</strong></p>
<blockquote>
<p>call和ret指令分别实现子程序（过程、函数等）的调用及返回。</p>
<p>call指令将当前执行指令地址入栈，然后无条件转移到标签所指的指令。</p>
<p>ret指令则可以弹出栈中保存的指令地址，然后无条件转移到保存的指令地址执行。其语法如下：</p>
<pre><code class="c">    call &lt;label&gt;
        ret
</code></pre>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="三、CISC和RISC的基本概念"><a href="#三、CISC和RISC的基本概念" class="headerlink" title="三、CISC和RISC的基本概念"></a>三、CISC和RISC的基本概念</h2><blockquote>
<p>指令系统分为两种不同的发展方向：</p>
<blockquote>
<ul>
<li>增强原有指令功能，设置更为复杂的辛芷蕾来实现软件功能的硬件化，这类机器称为<strong>复杂指令系统计算机（CISC）</strong>，如采用x86架构的计算机</li>
<li>减少指令种类和简化指令功能，提高指令的执行速度，这类机器称为<strong>精简指令系统计算机（RISC）</strong>，典型的有ARM、MIPS架构的计算机</li>
</ul>
</blockquote>
</blockquote>
<h3 id="1、复杂指令系统计算机（CISC）"><a href="#1、复杂指令系统计算机（CISC）" class="headerlink" title="1、复杂指令系统计算机（CISC）"></a>1、复杂指令系统计算机（CISC）</h3><blockquote>
<p>随着技术的不断发展，硬件成本不断下降，而软件成本不断上升，促使人们在指令系统中增加更多、更复杂的指令，这样就构成了<strong>复杂指令系统计算机（CISC）</strong></p>
<p><strong>特点：</strong></p>
<blockquote>
<ul>
<li>指令系统复杂庞大，指令数目较多</li>
<li>指令的长度不固定，指令格式多，寻址方式多</li>
<li>访存的指令不受限制</li>
<li>各指令使用频率相差较大</li>
<li>各种指令执行时间相差较大</li>
<li>控制器大多数采用微程序控制</li>
<li>难以用优化编译生成高效的代码程序</li>
</ul>
</blockquote>
</blockquote>
<h3 id="2、精简指令系统计算机（RISC）"><a href="#2、精简指令系统计算机（RISC）" class="headerlink" title="2、精简指令系统计算机（RISC）"></a>2、精简指令系统计算机（RISC）</h3><blockquote>
<p><strong>精简指令系统计算机（RISC）</strong>的中心思想是要求指令系统简化，尽量使用寄存器-寄存器操作指令，指令格式力求一致。</p>
<p><strong>特点：</strong></p>
<blockquote>
<ul>
<li>选取使用频率最高的一些简单指令，复杂指令的功能由简单指令的组合来实现</li>
<li>指令长度固定，指令格式种类少，寻址方式种类少</li>
<li>只有Load&#x2F;Store（取数&#x2F;存数）指令访存，其余指令都在寄存器之间操作</li>
<li>CPU中通用寄存器的数量相当多</li>
<li>RISC一定采用指令流水线技术，大部分指令在一个时钟周期内完成</li>
<li>以硬布线控制为主，少数使用微程序控制（PS：第五章会讲两者区别）</li>
<li>重视编译优化工作，减少程序执行时间</li>
</ul>
</blockquote>
</blockquote>
<h3 id="3、CISC和RISC的比较"><a href="#3、CISC和RISC的比较" class="headerlink" title="3、CISC和RISC的比较"></a>3、CISC和RISC的比较</h3><blockquote>
<ul>
<li>CISC大多数实现软件兼容，新机器包含了旧机器的全部指令，且可以扩充；RISC简化了指令系统，指令条数少，因此大多数RISC机不能与老机器兼容。</li>
<li>RISC更充分利用芯片的面积。CISC的控制器多采用微程序控制，其控制存储器栈CPU芯片的50%以上，而RISC采用组合逻辑控制，其硬布线只占CPU面积的10%</li>
<li>RISC能提高运算速度。（指令少，格式统一，能访存的指令少）</li>
<li>RISC便于设计，可降低成本、</li>
</ul>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/CISC%E4%B8%8ERISC%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="CISC与RISC的区别"></p>
</blockquote>
<h2 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h2>
            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">一、指令格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%8C%87%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">1、指令的基本格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%AE%9A%E9%95%BF%E6%93%8D%E4%BD%9C%E7%A0%81%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">2、定长操作码指令格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C%E7%A0%81%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">3、扩展操作码指令格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%8C%87%E4%BB%A4%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">4、指令的操作类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%8C%87%E4%BB%A4%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">二、指令的寻址方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80"><span class="toc-number">2.1.</span> <span class="toc-text">1、指令寻址和数据寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">2、常见的数据寻址方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81x86%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E5%85%A5%E9%97%A8"><span class="toc-number">2.3.</span> <span class="toc-text">3、x86汇编指令入门</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81CISC%E5%92%8CRISC%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.</span> <span class="toc-text">三、CISC和RISC的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%A4%8D%E6%9D%82%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%88CISC%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">1、复杂指令系统计算机（CISC）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%B2%BE%E7%AE%80%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%88RISC%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">2、精简指令系统计算机（RISC）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81CISC%E5%92%8CRISC%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">3.3.</span> <span class="toc-text">3、CISC和RISC的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%A1%A5%E5%85%85"><span class="toc-number">4.</span> <span class="toc-text">其他补充</span></a></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
