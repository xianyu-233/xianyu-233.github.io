
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>计算机操作系统概述 - Hexo</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="xainyu-233,"> 
    <meta name="description" content="一、操作系统的基本概念1、操作系统的概念
操作系统：指控制和管理整个计算机系统的硬件与软件资源，合理地组织、调度计算机的工作和资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合。

2、操,"> 
    <meta name="author" content="xianyu"> 
    <link rel="alternative" href="atom.xml" title="Hexo" type="application/atom+xml"> 
    <link rel="icon" href="/img/%E5%96%B7.jfif"> 
    
    
<link rel="stylesheet" href="/css/diaspora.css">

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Hexo</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://xianyu-233.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">计算机操作系统概述</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">计算机操作系统概述</h1>
        <div class="stuff">
            <span>八月 08, 2022</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/" rel="tag">基础学科</a></li></ul>


        </div>
        <div class="content markdown">
            <h2 id="一、操作系统的基本概念"><a href="#一、操作系统的基本概念" class="headerlink" title="一、操作系统的基本概念"></a>一、操作系统的基本概念</h2><h3 id="1、操作系统的概念"><a href="#1、操作系统的概念" class="headerlink" title="1、操作系统的概念"></a>1、操作系统的概念</h3><blockquote>
<p><strong>操作系统：</strong>指<strong>控制</strong>和<strong>管理</strong>整个计算机系统的<strong>硬件</strong>与<strong>软件资源</strong>，合理地组织、调度计算机的工作和资源的分配，进而为用户和其他软件提供方便接口与环境的<strong>程序集合</strong>。</p>
</blockquote>
<h3 id="2、操作系统的功能"><a href="#2、操作系统的功能" class="headerlink" title="2、操作系统的功能"></a>2、操作系统的功能</h3><blockquote>
<p>​        操作系统管理着计算机的硬件&#x2F;软件资源，为多道程序提供了良好的运行环境，也是<strong>硬件和软件的连接桥梁</strong>，因此计算机系统有以下功能：</p>
<ul>
<li><strong>处理机管理：</strong>即在多道程序的环境下，处理机要向每道程序分配合适的资源，以及对进程何时创建、何时销毁、如何管理等问题进行解决，还有对于程序发生冲突（如对资源的抢夺）后如何处理，这都是操作系统处理机管理所需要负责的部分。</li>
<li><strong>存储器管理：</strong>为多道程序运行提供良好环境，包括程序内存的分配和回收、地址映射、内存保护等功能。</li>
<li><strong>文件管理：</strong>包括文件存储空间的管理、目录管理、文件读写管理和文件权限管理等内容</li>
<li><strong>设备管理：</strong>完成外部设备的I&#x2F;O请求，方便用户使用各种外设。</li>
</ul>
<p>同时还需要<strong>向用户提供接口</strong></p>
<ul>
<li><p><strong>命令接口</strong></p>
<blockquote>
<p>用户使用命令接口进行作业控制，其主要有两种方式：<strong>联机控制方式</strong>和<strong>脱机控制方式</strong></p>
<ul>
<li><strong>联机控制方式：</strong>又称<strong>交互式命令接口</strong>，即用户通过控制台或终端输入操作命令，而系统根据输入的命令进行反馈。用户输入一条命令，系统就反馈一条命令的结果。（类似于shell、python的交互编程）</li>
<li><strong>脱机控制方式：</strong>又称<strong>批处理命令接口</strong>，即需要用户实现写好一段作业控制命令，交给操作系统，操作系统收到以后，按照控制命令执行，期间用户无法对其进行修改，只能等操作系统完成所有命令后才能拿到结果。</li>
</ul>
</blockquote>
</li>
<li><p><strong>程序接口</strong></p>
<blockquote>
<p>程序接口由一组<strong>系统调用（也称广义指令）</strong>组成。用户通过在程序种使用这些系统调用来请求操作系统为其程序提供服务，如使用各种外部设备、申请分配和回收内存等。</p>
</blockquote>
</li>
</ul>
<p>操作系统还用作<strong>扩充机器</strong></p>
<blockquote>
<p>没有任何软件支持的计算机称为裸机，它仅有计算机系统的物质基础。而操作系统提供的各类管理服务使得用户可以更方便地使用计算机；因此我们把覆盖了软件的机器称为<strong>扩充机器</strong>或<strong>虚拟机</strong></p>
</blockquote>
</blockquote>
<h3 id="3、操作系统的特性"><a href="#3、操作系统的特性" class="headerlink" title="3、操作系统的特性"></a>3、操作系统的特性</h3><blockquote>
<ul>
<li><p><strong>并发性</strong></p>
<blockquote>
<p>指两个或多个事件在同一时间间隔内发生。操作系统的并发性是通过<strong>分时</strong>来实现的</p>
<p><strong>注意：</strong>并发在宏观上是同时发生的，但是在微观上（很小的时间间隔里）是交替发生的。</p>
<p><strong>并行：</strong>两个或多个事件在同一时间内同时发生，需要相应数量的硬件支持。</p>
<p><strong>并发与并行的区别：</strong>并发本质是在极短的时间内交替运行，并行则是在同一时刻都可以同时进行。</p>
</blockquote>
</li>
<li><p><strong>共享性</strong></p>
<blockquote>
<p>​        指系统中的资源可供内存中多个并发执行的进程共同使用，可以分为<strong>互斥共享</strong>与<strong>同时访问共享</strong></p>
<ul>
<li><strong>互斥共享：</strong>指在一个时间段内只允许一个进程访问该资源。（如一台打印机在一个时间段内只能打印一个进程发送的文件，下一个文件必须要等上一个文件打印完才能打印）</li>
<li><strong>同时访问共享：</strong>允许一段时间内由多个进程“同时“访问（这的同时也是宏观上的），在微观上这些进程也是对这些资源进行”分时共享“。</li>
</ul>
<p><strong>并发和共享是操作系统两个最基本的特征，两者间互为存在条件</strong></p>
</blockquote>
</li>
<li><p><strong>虚拟性</strong></p>
<blockquote>
<p>​        指把一个物理上的实体变为若干逻辑上的对应物。（如虚拟内存，利用空分复用技术来扩充内存的大小）</p>
<p>​        实际上虚拟性就是使用了并发性和共享性，将资源的使用时间分为很小的一段时间，让不同进程可以交替使用，从而在宏观上让我们看到一份资源可以供多个进程使用，感觉资源好像变多了。</p>
<p><strong>常见的虚拟技术：</strong>时分复用技术（处理器的共享）、空分复用技术（存储器的共享）</p>
</blockquote>
</li>
<li><p><strong>异步性</strong></p>
<blockquote>
<p>指多道程序允许多个进程并发执行，但资源有限，进程的执行不是一贯到底的，有时候需要停下来等待需要的资源，因此会走走停停，以不可知的速度向前推进。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="二、操作系统的发展与分类"><a href="#二、操作系统的发展与分类" class="headerlink" title="二、操作系统的发展与分类"></a>二、操作系统的发展与分类</h2><blockquote>
<ul>
<li><p><strong>手工操作阶段</strong></p>
<blockquote>
<p>​        此时并没有操作系统，机器的一切操作（程序装入、运行、结果输出）都基本需要人工干预。如，将程序通过打孔机打在一条纸带上，然后将指代放入机器，又机器执行完后又输出一条带孔的纸带作为结果。</p>
<p>此时有两个突出的缺点：</p>
<ul>
<li>用户独占全机，没有共享性，且每次只能输入一个程序</li>
<li>机器等待人工操作的时间过长，各资源利用率过低</li>
</ul>
</blockquote>
</li>
<li><p><strong>批处理阶段</strong>（操作系统开始出现）</p>
<blockquote>
<ul>
<li><p><strong>单道批处理系统</strong></p>
<blockquote>
<p>​        机器引入了一个<strong>脱机输入&#x2F;输出技术</strong>，即用户依次将作业输入到磁带上，机器会根据<strong>监督程序</strong>自动从磁带上读取作业，一个个地执行，当执行完成后，将结果输出到磁带上。</p>
<p><strong>特征：</strong></p>
<ul>
<li><strong>自动性：</strong>在顺利的情况下，磁带上的作业可以自动地逐一运行，无需人工干扰</li>
<li><strong>顺序性：</strong>磁带上的作业按照顺序依次进入内存，完成后的结果也依次输出到磁带中，因此属于先进先出类型的机器</li>
<li><strong>单道性：</strong>机器内存中一次只能有一个作业在运行，只有上一个作业退出后，下一个作业才能进入内存</li>
</ul>
</blockquote>
</li>
<li><p><strong>多道批处理系统</strong></p>
<blockquote>
<p>​        多道批处理设计技术允许多个程序同时进入内存并允许它们<strong>交替地运行</strong>，这些程序<strong>共享</strong>系统中各种资源。（因此这才是操作系统出现的标志）</p>
<p>​        虽然多道批处理解决了程序运行效率问题以及提高了机器的利用率，但是机器还是<strong>没有提供人机交互能力</strong>，用户不能了解自己程序的运行情况，也不能控制机器；也不能让多人使用机器。</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>分时操作系统</strong></p>
<blockquote>
<p>​        为了提供人机交互功能，后面又提出了分时操作系统。分时操作系统就是<strong>把处理器的运行时间分为很短的时间片</strong>，把这些时间片分给各个用户使用。使得各个用户可以交替获得计算机的服务。同时用户也可以使用键盘、鼠标等设备对操作系统进行操作，从而提供了人机交互功能。</p>
<p>​        由于计算机速度快，作业轮转得也快，因此每个用户都感觉自己独占了一台计算机。</p>
<p>​        虽然分时系统解决了人机交互问题，但无法解决紧急任务与普通任务得区分。</p>
</blockquote>
</li>
<li><p><strong>实时操作系统</strong></p>
<blockquote>
<p>​        实时操作系统就是<strong>为了能在某个时间限制内完成某些紧急任务而无需排队</strong>而诞生的。根据可靠度的不同，实时操作系统可以分为两类：</p>
<ul>
<li><strong>硬实时操作系统：</strong>某个动作<strong>必须</strong>在规定时间内完成，否则会出现重大问题的实时操作系统</li>
<li><strong>软实时操作系统：</strong>能接受<strong>偶尔</strong>违反时间限制且不会引起重大损害的实时操作系统</li>
</ul>
</blockquote>
</li>
<li><p>网络操作系统</p>
<blockquote>
<p>​        利用计算机网络将不同地点的计算机有机结合起来，提供一个统一、有效地使用各台计算机的方法，实现各台计算机之间的数据互传。</p>
<p>​        网络操作系统的主要特点是：网络中各资源的共享以及各计算机之间的通信</p>
</blockquote>
</li>
<li><p>分布式操作系统</p>
<blockquote>
<p>​        系统中任意两台计算机通过通信方式交换信息；系统中每台激素那几都具有等同地位；每台计算机上的资源为所有用户共享；系统中任意台计算机都能构成一个子系统，并且还能重构；任何工作都可以分布在几台计算机上，由它们并行工作。</p>
<p>​        特点是：分布性、并行性</p>
<p>​        与网络操作系统的区别是：分布式操作系统中的若干计算机相互协调完成同一任务。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="三、操作系统的运行环境"><a href="#三、操作系统的运行环境" class="headerlink" title="三、操作系统的运行环境"></a>三、操作系统的运行环境</h2><h3 id="1、操作系统的运行机制"><a href="#1、操作系统的运行机制" class="headerlink" title="1、操作系统的运行机制"></a>1、操作系统的运行机制</h3><blockquote>
<p><strong>程序的运行原理：</strong>系统在运行高级语言编写的程序时，会先将程序编译成一条条的机器指令；而运行时就是CPU执行一条条指令的过程。</p>
<p>​        根据程序的性质，可以将其分为两类程序：<strong>内核程序</strong>和<strong>应用程序</strong>。对于操作系统来说，这两种程序的作用不同，内核程序时应用程序的管理者。</p>
<p>​        而根据程序的不同，又可以分出两类指令：<strong>特权指令</strong>和<strong>非特权指令</strong>。其中内核程序使用的是特权指令，如I&#x2F;O指令、置中断指令等。而应用程序是无法使用特权指令的，当应用程序想要使用特权指令时，系统会自动产生中断，此时操作系统强行夺回电脑控制权，并禁止用户使用特权指令。</p>
<p>​        而根据CPU的状态，可以分出：<strong>用户态（目态）</strong>和<strong>核心态（管态、内核态）</strong>。其中用户态是运行应用程序的状态，当运行内核程序时，系统会转至核心态。CPU内部会有一个<strong>程序状态字寄存器（PSW）</strong>，其中存放的就是用户态或核心态的标志位，如果运行内核程序，该寄存器的标记为会变为核心态的标志位。</p>
<p>​        大多数操作系统的内核包括以下4方面：</p>
<ul>
<li><p><strong>时钟管理</strong></p>
<blockquote>
<p>​        时钟管理指的是对时钟部件的管理，操作系统除了向用户提供系统时间外，在程序并发执行的过程中也需要时钟信号（这会在内中断里会提到）。</p>
</blockquote>
</li>
<li><p><strong>中断机制</strong></p>
<blockquote>
<p>​        中断机制的初衷就是提高CPU的利用率（通过中断来切换不同进程对CPU的占有，使得CPU可以尽可能地工作）。</p>
<p>​        在中断机制中，只有少部分功能属于内核，它们负责保护现场和恢复中断现场，将控制权转移到其它程序上。</p>
</blockquote>
</li>
<li><p><strong>原语</strong></p>
<blockquote>
<p>原语是一些可被调用的公用小程序，它们各自完成一个规定的操作，并且有以下特点：</p>
<ul>
<li><strong>处于操作系统的最底层，最接近硬件</strong></li>
<li><strong>这些程序具有原子性</strong>（即执行时不能中断，只能一气呵成）</li>
<li><strong>这些程序执行时间短，且频繁被调用</strong></li>
</ul>
</blockquote>
</li>
<li><p><strong>系统控制的数据结构及处理</strong></p>
<blockquote>
<p>​        系统中用于登记状态信息的数据结构（作业控制块、进程控制块、消息队列、内存分配表等），为了实现有效的管理，系统需要一些基本的操作，常见的有以下操作：</p>
<ul>
<li><strong>进程管理</strong>：进程状态管理、进程调度和分配、进程创建和撤销等</li>
<li><strong>存储器管理</strong>：存储器空间的分配和回收、内存信息保护、代码对换程序等</li>
<li><strong>设备管理</strong>：缓冲区管理、设备分配和回收等</li>
</ul>
</blockquote>
</li>
</ul>
<p>核心态指令实际上就是<strong>系统调用类指令</strong>和一些针对<strong>时钟</strong>、<strong>中断</strong>、<strong>原语</strong>的操作指令。</p>
</blockquote>
<h3 id="2、中断与异常"><a href="#2、中断与异常" class="headerlink" title="2、中断与异常"></a>2、中断与异常</h3><blockquote>
<p><strong>中断的作用：</strong></p>
<blockquote>
<ul>
<li>CPU由用户态转为核心态的唯一方法</li>
<li>帮助操作系统重新取得CPU的使用权的方法</li>
</ul>
</blockquote>
<p><strong>中断的分类：</strong></p>
<blockquote>
<ul>
<li><p><strong>外中断</strong></p>
<blockquote>
<p>​        指来自于CPU以外的中断请求，如I&#x2F;O设备的中断信号，时钟部件的中断信号等。</p>
<p>​        当CPU收到外中断信号后，会进入核心态，查看中断类型，然后处理中断请求。</p>
<p><strong>注意：</strong>外中断与当前的指令无关，因为中断信号都来源于CPU外部。</p>
</blockquote>
</li>
<li><p><strong>内中断</strong></p>
<blockquote>
<p>​        内中断则是指来自于CPU内部的中断信号，也称为<strong>异常</strong>。如用户程序非法使用特权指令、操作数的违法输入、算术溢出等。根据类型不同又可以细分为以下三种：</p>
<ul>
<li><strong>陷阱&#x2F;陷入（trap）：</strong>由陷入指令引发，是应用程序需要请求内核服务时故意引发的。</li>
<li><strong>故障（fault）：</strong>由错误条件引发，<strong>可能被内核程序修复</strong>，修复后内核会把CPU还给应用程序。如缺页故障。</li>
<li><strong>终止（abort）：</strong>由致命错误引起，<strong>内核程序无法修复</strong>，引发此中断后，操作系统不会把CPU还给应用程序。如被除数为0，非法使用特权指令等。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>基本实现原理：</strong></p>
<blockquote>
<ul>
<li><p><strong>检测中断信号：</strong></p>
<blockquote>
<p><strong>外中断</strong>：CPU在执行指令的时候，在每一条指令的末尾都会有一个中断周期，用于检查是否存在中断信号</p>
<p><strong>内中断：</strong>CPU在执行指令的过程中会检查是否有异常发生</p>
</blockquote>
</li>
<li><p><strong>找到相应的中断处理程序：</strong>通过“中断向量表”来查找，操作系统会在内存中查找“中断向量表”来辨别中断的类型。</p>
</li>
</ul>
<p>详细的执行过程见计算机组成原理的第七章</p>
</blockquote>
</blockquote>
<h3 id="3、系统调用"><a href="#3、系统调用" class="headerlink" title="3、系统调用"></a>3、系统调用</h3><blockquote>
<p><strong>概念：</strong></p>
<blockquote>
<p><strong>系统调用</strong>：指用户在程序中调用操作系统所提供的一些子功能</p>
<p>​         可以将系统调用理解为操作系统提供的特殊公共子程序。系统中各类资源都是由操作系统统一控制的，因此凡是与资源相关的操作（内存分配、文件管理等），都需要通过系统调用方式向操作系统提出服务请求。</p>
<p>​        根据功能的不同，系统调用大致可以分为：设备管理、文件管理、进程控制、进程通信、内存管理</p>
<p><strong>系统调用与库函数的区别：</strong>系统调用一般封装在库函数中；而库函数不止系统调用，还有许多其他普通函数</p>
</blockquote>
<p><strong>系统调用的过程：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.png" alt="系统调用"></p>
<ul>
<li>用户程序向CPU传递参数（如所需系统调用的类型）</li>
<li>执行陷入指令&#x2F;Trap指令&#x2F;访管指令</li>
<li>此时转为内核态，由操作系统内核程序处理系统调用</li>
<li>返回应用程序，并由内核态转回用户态</li>
</ul>
</blockquote>
</blockquote>
<h2 id="四、操作系统体系结构"><a href="#四、操作系统体系结构" class="headerlink" title="四、操作系统体系结构"></a>四、操作系统体系结构</h2><blockquote>
<p>​        根据操作系统提供的服务和如何提供服务的问题上，可以将操作系统的体系结构分为以下几种：</p>
<ul>
<li><p><strong>大内核（单内核&#x2F;宏内核）</strong></p>
<blockquote>
<p>大内核是将操作系统的主要功能模块都作为系统内核（大内核之间功能之间的调用也是直接调用，无需消息传递）</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E5%A4%A7%E5%86%85%E6%A0%B8.png" alt="大内核"></p>
<p><strong>优点</strong>：高性能</p>
<p><strong>缺点：</strong>内核代码庞大，结构复杂</p>
</blockquote>
</li>
<li><p><strong>微内核</strong></p>
<blockquote>
<p>微内核只把基本的功能保留在内核中（微内核中各功能之间的调用需要消息传递）</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E5%BE%AE%E5%86%85%E6%A0%B8.png" alt="微内核"></p>
<p><strong>优点：</strong>内核功能少，结构简单</p>
<p><strong>缺点：</strong>使用时需要频繁地在核心态和用户态之间切换，性能低</p>
</blockquote>
</li>
<li><p><strong>分层结构</strong></p>
<blockquote>
<p>分层结构的操作系统的内核有多层结构，每一层可以<strong>单向</strong>调用<strong>更低一层</strong>提供的接口（类似计网中的网络系统结构）</p>
<img src="/picture/学习/操作系统上的图/计算机系统概述/分层结构.png" alt="分层结构" style="zoom:67%;" />

<p><strong>优点：</strong></p>
<blockquote>
<ul>
<li><strong>便于调试和验证</strong>，自底向上逐层调试验证</li>
<li>易于拓展，各接口之间调用接口清晰固定</li>
</ul>
</blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<ul>
<li>仅能调用相邻低层，难以确定各层的边界</li>
<li><strong>效率低</strong>，不可跨层调用，系统调用时间长</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>模块化</strong></p>
<blockquote>
<p>将内核划分为多个模块，各模块间相互协作</p>
<p>内核&#x3D;主模块+可加载内核模块</p>
<p><strong>主模块</strong>：只负责核心功能，如进程调度、内存管理等；<strong>可加载内核模块</strong>：可以动态加载新模块到内核，而无需重新编译整个内核，如驱动程序等</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E6%A8%A1%E5%9D%97%E5%8C%96.png" alt="模块化"></p>
<p><strong>优点：</strong></p>
<blockquote>
<ul>
<li>逻辑清晰，易于维护，确定模块间接口后即可多模块同时开发</li>
<li><strong>支持动态加载新的内核模块</strong>（如安装设备驱动程序到内核等），增强系统适应性</li>
<li><strong>任何模块都可以直接调用其它模块，无需采用消息传递进行通信</strong>，效率高</li>
</ul>
</blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<ul>
<li>模块间的接口定义</li>
<li>模块间相互依赖，难以调试</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>外核</strong></p>
<blockquote>
<p>这类操作系统有内核与外核组成。其中，<strong>内核负责进程调度、进程通信等功能</strong>；<strong>外核负责为用户进程分配未经抽象的硬件资源，且保证资源的使用安全</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E5%A4%96%E6%A0%B8.png" alt="外核"></p>
<p><strong>优点：</strong></p>
<blockquote>
<ul>
<li><strong>外核可以直接给用户进程分配“不虚拟、不抽象”（如未经虚拟化的内存空间）的硬件资源，用户可以更灵活的使用硬件资源</strong></li>
<li><strong>减少了虚拟硬件资源的“映射层”，提高了效率</strong>（如不需要再查页表）</li>
</ul>
</blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<ul>
<li>降低系统的一致性</li>
<li>使系统变得更复杂</li>
</ul>
</blockquote>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="五、操作系统引导"><a href="#五、操作系统引导" class="headerlink" title="五、操作系统引导"></a>五、操作系统引导</h2><blockquote>
<p><strong>操作系统引导（开机）：</strong>指计算机利用CPU运行特定程序，通过程序识别硬盘，识别硬盘分区，识别硬盘分区上的操作系统，最后通过程序启动操作系统。</p>
<p><strong>过程如下：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC.png" alt="操作系统系统引导"></p>
<ul>
<li><strong>激活CPU</strong>。激活的CPU会读取ROM中的boot程序，将指令寄存器设置为BIOS（基本输入&#x2F;输出系统）的第一条指令，即开始执行BIOS指令</li>
<li><strong>硬件自检：</strong>启动BIOS程序后，先进行硬件自检，检查硬件是否发生故障。</li>
<li><strong>加载带有操作系统的硬盘</strong>。硬件自检完后，BIOS开始读取BOOT Sequence，把控制权交给启动顺序排在第一位的存储设备（系统盘），然后CPU将该存储设备引导扇区的内容加载到内存中</li>
<li><strong>加载主引导记录（MBR）</strong>。硬盘通过特定的标识符区分引导硬盘和非引导硬盘，发现一个存储设备不是引导盘后，就检查下一个存储设备，直到找到引导记录。<strong>主引导记录MBR会告诉CPU去哪个分区找操作系统</strong></li>
<li><strong>扫描硬盘分区表</strong>，识别并找到操作系统所在的分区（也叫作活动分区）</li>
<li><strong>加载分区引导记录PBR</strong>。读取活动分区的第一个扇区，这个扇区被称为分区引导记录（PBR），其作用时寻找并激活分区根目录下用于引导操作系统的程序</li>
<li><strong>加载启动管理器</strong>。PBR搜索活动分区中的启动管理器，并加载它</li>
<li><strong>加载操作系统</strong></li>
</ul>
</blockquote>
</blockquote>
<h2 id="六、虚拟机"><a href="#六、虚拟机" class="headerlink" title="六、虚拟机"></a>六、虚拟机</h2><blockquote>
<p><strong>传统的计算机：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E4%BC%A0%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%9C%BA.png" alt="传统计算机"></p>
<p>​        一个机器只有一个操作系统，且只有操作系统可以使用特权指令，用户之间的程序可能会相互影响。</p>
</blockquote>
<p><strong>虚拟机</strong></p>
<blockquote>
<p>​        为了能在一台计算机上运行多个操作系统供多个用户使用，人们又发明了虚拟机的概念。</p>
<p>​        虚拟机是一台逻辑计算机，利用特殊的虚拟化技术，将计算机的物理特征抽象化，为用户提供一个抽象的、统一的、模拟的计算环境。虚拟化技术可以分为两类：</p>
<ul>
<li><p><strong>第一类虚拟化技术：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E7%AC%AC%E4%B8%80%E7%B1%BB%E8%99%9A%E6%8B%9F%E6%9C%BA.png" alt="第一类虚拟机"></p>
<p>​        第一类的<strong>虚拟机管理程序（VMM）</strong>类似于一个操作系统。它是唯一一个运行在最高特权级的程序（直接与硬件接触，代替了原来操作系统的位置）。在VMM的基础之上向上层提供若干台虚拟机。这些虚拟机是裸机硬件的复制品（拥有相应功能，但实际上不存在），因此可以在此基础之上运行不同的操作系统。</p>
<p>​        在第一类的虚拟机管理程序的作用下，所有的操作系统都是用户态的一个程序，不允许使用特权指令的。然而虚拟机上的操作系统认为自己运行在内核态中（伪），<strong>当这些操作系统需要用到特权指令时，VMM会将这些指令截获下来，判断是否合法，如果合法，那么将真正调用这些指令，然后将结果返回给相应的操作系统</strong>。</p>
<p>​        注意，第一类虚拟管理系统是直接作用在硬件上的，因此<strong>它为虚拟机赋予的如内存空间，存储空间都是未经抽象的物理资源</strong>。</p>
</blockquote>
</li>
<li><p><strong>第二类虚拟化技术：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E7%AC%AC%E4%BA%8C%E7%B1%BB%E8%99%9A%E6%8B%9F%E6%9C%BA.png" alt="第二类虚拟机"></p>
<p>​        第二类<strong>虚拟机管理程序（VMM）</strong>则与第一类完全不同，它是在原来操作系统的基础上增加了一个VMM，然后再在VMM上添加需要的操作系统。</p>
<p>​        因此，VMM就运行在了用户态上，而且所需要的资源是要经过宿主操作系统来分配的，因此<strong>此类虚拟机的内存空间，存储空间都是经过抽象的资源（逻辑上连续，物理上不一定连续）</strong>。而且此VMM实际上就一个应用程序，是和宿主操作系统上的进程有着相同地位的。</p>
<p>​        注意：在第二类虚拟机管理程序中，VMM的驱动程序是运行在核心态上的。</p>
</blockquote>
</li>
</ul>
<p><strong>两者的区别：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E4%B8%A4%E7%B1%BB%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AE%A1%E7%90%86%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AF%B9%E6%AF%94.png" alt="两类虚拟机管理程序的对比"></p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="七、其他补充"><a href="#七、其他补充" class="headerlink" title="七、其他补充"></a>七、其他补充</h2><blockquote>
</blockquote>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">一、操作系统的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">1、操作系统的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.2.</span> <span class="toc-text">2、操作系统的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">1.3.</span> <span class="toc-text">3、操作系统的特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">二、操作系统的发展与分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="toc-number">3.</span> <span class="toc-text">三、操作系统的运行环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">3.1.</span> <span class="toc-text">1、操作系统的运行机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8"><span class="toc-number">3.2.</span> <span class="toc-text">2、中断与异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">3.3.</span> <span class="toc-text">3、系统调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">四、操作系统体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC"><span class="toc-number">5.</span> <span class="toc-text">五、操作系统引导</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">6.</span> <span class="toc-text">六、虚拟机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%85%B6%E4%BB%96%E8%A1%A5%E5%85%85"><span class="toc-number">7.</span> <span class="toc-text">七、其他补充</span></a></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
