
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>文件管理 - Hexo</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="xainyu-233,"> 
    <meta name="description" content="一、文件系统基础1、文件系统的基本概念
文件：文件是以计算机硬盘为载体的存储在计算机上的信息集合，文件可以是文本文档、图片、程序等。在用户进行的输入、输出中，是以文件作为基本单位的。
文件系统：操作,"> 
    <meta name="author" content="xianyu"> 
    <link rel="alternative" href="atom.xml" title="Hexo" type="application/atom+xml"> 
    <link rel="icon" href="/img/%E5%96%B7.jfif"> 
    
    
<link rel="stylesheet" href="/css/diaspora.css">

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Hexo</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://xianyu-233.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">文件管理</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">文件管理</h1>
        <div class="stuff">
            <span>八月 11, 2022</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/" rel="tag">基础学科</a></li></ul>


        </div>
        <div class="content markdown">
            <h2 id="一、文件系统基础"><a href="#一、文件系统基础" class="headerlink" title="一、文件系统基础"></a>一、文件系统基础</h2><h3 id="1、文件系统的基本概念"><a href="#1、文件系统的基本概念" class="headerlink" title="1、文件系统的基本概念"></a>1、文件系统的基本概念</h3><blockquote>
<p><strong>文件：</strong>文件是以计算机硬盘为载体的存储在计算机上的信息集合，文件可以是文本文档、图片、程序等。在用户进行的输入、输出中，是以文件作为基本单位的。</p>
<p><strong>文件系统：</strong>操作系统中提供的一个文件管理系统。</p>
<p><strong>文件的属性：</strong></p>
<blockquote>
<ul>
<li><strong>名称：</strong>文件名称是唯一的，以易读取的形式保存</li>
<li><strong>标识符：</strong>标识符是系统内文件的唯一标签，通常为数字，对用户透明的一种内部名称</li>
<li><strong>类型：</strong>指文件的种类，常见的有.txt、.jpg、.mp4等文件类型</li>
<li><strong>位置：</strong>指向设备和设备上文件的指针</li>
<li><strong>大小：</strong>指文件所占的空间大小</li>
<li><strong>保护：</strong>指对文件进行保护的访问控制信息</li>
<li><strong>时间、日期和用户标识：</strong>文件创建、上次修改和上次访问的相关信息，用于保护和追踪文件的使用</li>
</ul>
</blockquote>
<p><strong>文件的基本操作：</strong></p>
<blockquote>
<p>​        文件是一种抽象的数据类型，对于文件的操作。操作系统提供了系统调用，它可以对文件进行<strong>创建、读取、写、重定位、删除</strong>和<strong>截断</strong>。</p>
<ul>
<li><strong>创建文件：</strong>创建文件可以分为两步：①、在文件系统中为文件找到空间；②、在目录中为新文件创建条目。</li>
<li><strong>写文件：</strong>通过执行write系统调用，指明文件名称和要写入文件的内容。系统需要为该文件维护一个写位置的指针，每当发生写操作时，便更新写指针。</li>
<li><strong>读文件：</strong>通过执行read系统调用，指明文件名称和要读入文件块的内存位置。读文件时也需要使用一个指针，而对一个文件在同一时刻只能是读或写，因此读写可以共用一个指针</li>
<li><strong>文件重定位：</strong>按照某条件搜索目录，不会读、写文件</li>
<li><strong>删除文件：</strong>先从目录中找到要删除文件的目录项，使之成为空项，然后回收该文件所占用的存储空间</li>
<li><strong>截断文件：</strong>允许文件所有属性不变，只删除文件内容，使文件长度变为0</li>
</ul>
<p><strong>注意：</strong>以上的读文件和写文件都需要用到<strong>文件的打开（open）和关闭（close）</strong>两个操作.</p>
</blockquote>
</blockquote>
<h3 id="2、文件的逻辑结构"><a href="#2、文件的逻辑结构" class="headerlink" title="2、文件的逻辑结构"></a>2、文件的逻辑结构</h3><blockquote>
<p>​        文件的逻辑结构是指文件的组织形式，文件的<strong>物理结构</strong>是从现实观点出发看到的文件在外存上的存储组织形式，与存储介质特性密切相关。文件的<strong>逻辑结构</strong>指的是数据在逻辑上是如何组织起来的，与存储介质特性无关。根据逻辑结构的不同，可以将文件划分为：<strong>无结构文件</strong>和<strong>有结构文件</strong>两种</p>
<ul>
<li><p><strong>无结构文件</strong></p>
<blockquote>
<p>​        无结构文件又称为<strong>流式文件</strong>，无结构文件将数据<strong>以字节为单位，将数据按顺序组织成记录并累积、保存</strong>（实际上就是按字节流的顺序存储数据）</p>
</blockquote>
</li>
<li><p><strong>有结构文件</strong></p>
<blockquote>
<p>​        有结构文件又称<strong>记录式文件</strong>，有结构文件将数据分为一个个的<strong>数据项</strong>每一个数据项有统一的格式，根据数据项中的记录是否可变长，又可以分为：<strong>可变长记录</strong>和<strong>定长记录</strong></p>
<ul>
<li><p><strong>顺序文件：</strong></p>
<blockquote>
<p>​        文件中的记录一个接一个地顺序排列，记录可以是定长或可变长的，可以<strong>顺序存储</strong>或以<strong>链式形式存储</strong>。顺序文件有以下两种结构：<strong>串结构</strong>（记录之间的顺序与关键字无关，通常顺序由时间决定）和<strong>顺序结构</strong>（文件中的所有记录按关键字排序）</p>
<p><strong>特点：</strong>在读写一大批记录时，顺序结构的文件具有极好的效率；但顺序文件对于修改、增加和删除等操作就相对繁琐。</p>
<p><strong>分类：</strong></p>
<blockquote>
<p><strong>链式存储：</strong>无论定长&#x2F;可变长记录，都无法实现随机存取，每次只能从第一个记录开始依次往后查找。</p>
<p><strong>顺序存储：</strong></p>
<blockquote>
<ul>
<li><p><strong>可变长记录：</strong>无法实现随机存储，因为每一条记录的长度可不同</p>
</li>
<li><p><strong>定长记录：</strong>可实现随机存取</p>
<blockquote>
<ul>
<li>采用<strong>串结构</strong>，无法快速找到某关键字对应的记录</li>
<li>采用<strong>顺序结构</strong>，可快速找到某关键字对应的记录</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><p><strong>索引文件：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6.png" alt="索引文件"></p>
<p>​        建立一张索引表，每条记录对应一个索引项，而每个索引项都有一个指针指向相应的物理块（这些物理块可以离散地存放，<strong>类似于内存管理中的页表</strong>）</p>
<p><strong>特点：</strong>索引表本身就是定长记录的顺序文件，因此可以快速查找到某一记录的索引项，而在物理地址上的记录块可以离散存储，因此记录块不会被限制。因此索引文件常用于对信息处理的及时性要求比较高的场合；但存储索引表也需要一定的空间，因此使用索引文件结构时，可能需要额外的地址空间（空间换时间策略）</p>
</blockquote>
</li>
<li><p><strong>索引顺序文件</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6.png" alt="索引顺序文件"></p>
<p>​        索引顺序文件是索引文件和顺序文件思想的结合。在索引顺序文件中：<strong>一组记录对应一个索引表项</strong>（即一个索引表项对应一组的记录）。因此在查询某条记录时，需要<strong>先查询索引表</strong>找到相应组，然后<strong>在相应组中找到需要的记录</strong>。</p>
<p><strong>注意：</strong>索引顺序文件可以根据需要分为多级的文件结构，即</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95%E8%A1%A8.png" alt="多级索引表"></p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="3、文件目录结构"><a href="#3、文件目录结构" class="headerlink" title="3、文件目录结构"></a>3、文件目录结构</h3><blockquote>
<p><strong>文件控制块和索引结点</strong></p>
<blockquote>
<ul>
<li><p><strong>文件控制块</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%9D%97.png" alt="文件控制块"></p>
<p>​        如图中红框所表示的就是一个<strong>文件控制块（FCB）</strong>，而多个文件控制块组成的集合被称为<strong>文件目录</strong>（注意，文件目录也是一种文件）。</p>
<p>​        当在目录中创建一个新文件，系统会为其分配一个FCB并存放在文件目录中，成为<strong>目录项</strong>（就是FCB）。</p>
<p><strong>FCB主要包括以下信息：</strong></p>
<blockquote>
<ul>
<li><strong>基本信息</strong>，如<strong>文件名、文件的物理地址</strong>（最重要，文件检索时所使用的两个信息）、文件的逻辑结构、文件的物理结构等</li>
<li><strong>存取控制信息</strong>，如文件的存取权限等</li>
<li><strong>使用信息</strong>，如文件建立时间、修改时间等</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>索引结点</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E7%B4%A2%E5%BC%95%E7%BB%93%E7%82%B9.png" alt="索引结点"></p>
<p>​        在检索目录文件时，一般只用到了文件名，而仅当找到一个目录项时，才需要从该目录项中读出该文件的物理地址。因此在文件控制块的基础上，我们可以在找到相应文件夹时，才将相关信息放入内存中。</p>
<p>​        使用索引结点时，目录表只每一项只有<strong>文件名</strong>和<strong>索引指针</strong>。文件名在查找时用，而索引结点指针则指向一个索引结点，在索引结点内存放着对应文件名的详细信息（如物理地址、逻辑结构、权限信息等），且只有用户访问时，才会将这些信息读入内存中。这样一来可以<strong>减少目录项的长度</strong>，降低其冗余值。同时也可以降低目录存放所需的磁盘块，从而<strong>加快读取速度</strong>。（本质就是文件控制块的优化版）</p>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>目录结构</strong></p>
<blockquote>
<p>​        在一个文件系统中，对目录项的操作有以下几种：搜索、创建、删除、显示、修改。而操作时，常见以下几种目录结构：</p>
<ul>
<li><p><strong>单级目录结构：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E5%8D%95%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="单级目录结构"></p>
<p>在整个文件系统中之间了一张目录表，每个文件占一个目录项。</p>
<p>在创建新的文件目录时，必须先检索所有目录项是否有“重名”现象，只有确认没有重名目录项后，才能在目录表中创建并加入一个新的目录项。</p>
<p><strong>特点：</strong></p>
<blockquote>
<ul>
<li>单级目录结构实现了“按名存取”，但查询速度慢、文件不能重名等</li>
<li>在单级目录结构中系统难以实现共享（多人容易造成文件重名），即<strong>不适用于多用户的操作系统</strong></li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>两级目录结构：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E4%B8%A4%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="两级目录结构"></p>
<p>为了提高文件系统的共享性，在单级文件系统的基础上，又提出了两级文件系统。将文件目录分为<strong>主文件目录</strong>（用于记录不同用户的文件目录）和<strong>用户文件目录</strong>（每个用户专属的文件目录）。</p>
<p>这样一来，在两个不同用户文件目录中，就可以放置同名的文件了。</p>
<p><strong>特点：</strong>两级目录依旧缺乏灵活性，且不能对文件进行分类。</p>
</blockquote>
</li>
<li><p><strong>多级目录结构（树形目录结构）：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E5%A4%9A%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="多级目录结构"></p>
<p>在两级目录结构的基础上，进一步拓展了文件目录的层次关系，将其变成了多级的目录结构。</p>
<p>在多级的目录结构中，只要在不同目录下，文件是可以重名的。而且其结构如图.</p>
<p>系统在找相应的文件时，假如寻找图中的自拍.jpg</p>
<blockquote>
<ul>
<li>将根目录读取到内存中，找到照片这一项</li>
<li>跟据照片，找到其目录，读取到内存中，找到2015-08这一项</li>
<li>找到2015-08这个目录中自拍.jpg，然后再去磁盘中将相应的文件读取到内存中</li>
</ul>
<p>因此<strong>如果文件所在位置越深，那么需要读取磁盘的次数就越多</strong></p>
</blockquote>
<p><strong>特点：</strong>增加了磁盘读取的次数；不便于文件间的共享</p>
<p><strong>补充：</strong></p>
<blockquote>
<ul>
<li><strong>绝对路径：</strong>从根目录出发的路径</li>
<li><strong>相对路径：</strong>从当前目录出发的路径</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>无环图目录结构：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%97%A0%E7%8E%AF%E5%9B%BE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="无环图目录结构"></p>
<p>在树型目录结构的基础上，又增加了一些指向同一结点的有向边，使得整个目录变成一个<strong>有向无环图</strong>。可以增加系统的可共享性。</p>
<p><strong>注意：</strong></p>
<blockquote>
<p>对于无环图目录结构的文件删除，其操作与上面的目录结构有所不同：</p>
<ul>
<li><strong>每个共享结点中都设置了一个共享计数器</strong></li>
<li><strong>每当有一个用户接上这个共享结点时，计数器就加1</strong></li>
<li><strong>当用户删除这个结点时，仅删除这个用户目录的这一条边，且计数器减1</strong></li>
<li><strong>当这个共享结点的计数器为0时，才真正删除这个结点</strong></li>
</ul>
</blockquote>
</blockquote>
</li>
</ul>
<p><strong>注意：</strong></p>
<blockquote>
<p>这里提到的每一个目录中的一项都代表这一个文件，即一个目录项代表一个文件。整个目录表才能代表熟知的目录。</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="4-、文件系统层次结构"><a href="#4-、文件系统层次结构" class="headerlink" title="$4^*$、文件系统层次结构"></a>$4^*$、文件系统层次结构</h3><blockquote>
<img src="/picture/学习/操作系统上的图/文件管理/文件系统层次结构.png" alt="文件系统层次结构" style="zoom:67%;" />

<ul>
<li><strong>用户接口</strong>：为用户提供文件及目录的相关调用，如新键、打开、读写、关闭、删除文件，建立、删除目录等</li>
<li><strong>文件目录系统</strong>：主要管理文件目录，如过来活跃文件目录表、用户进程的打开目录表、存储设备上的文件目录结构等</li>
<li><strong>存取控制模块</strong>：对用户的访问请求与FCB中指示的访问控制权限进行比较，确定访问是否合法</li>
<li><strong>逻辑文件系统与文件信息缓冲区</strong>：将用户要读写的逻辑记录转化成文件逻辑结构内的相应块号</li>
<li><strong>物理文件系统</strong>：把逻辑结构对应的块号转化成实际的物理地址</li>
<li><strong>辅助分配模块</strong>：负责分配磁盘的空闲空间和回收磁盘空间</li>
<li><strong>设备管理模块：</strong>分配设备读写用的缓冲区、磁盘调度、启动设备、设备中断处理、释放读写缓冲区、释放设备等</li>
</ul>
</blockquote>
<h3 id="5、文件系统的全局结构"><a href="#5、文件系统的全局结构" class="headerlink" title="5、文件系统的全局结构"></a>5、文件系统的全局结构</h3><blockquote>
<p><strong>磁盘的格式化</strong></p>
<blockquote>
<ul>
<li><p><strong>原始磁盘：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E5%8E%9F%E5%A7%8B%E7%A3%81%E7%9B%98.png" alt="原始磁盘"></p>
<p>指一块刚被生产出来的磁盘，上面还没有划分扇区</p>
</blockquote>
</li>
<li><p><strong>物理格式化：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E7%89%A9%E7%90%86%E6%A0%BC%E5%BC%8F%E5%8C%96.png" alt="物理格式化"></p>
<p>即低级格式化，为磁盘划分扇区并检测坏扇区，并且使用备用扇区来替换坏扇区。（这个替换是磁盘驱动自动完成的，对操作系统来说是透明的）</p>
</blockquote>
</li>
<li><p><strong>逻辑格式化：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E9%80%BB%E8%BE%91%E6%A0%BC%E5%BC%8F%E5%8C%96.png" alt="逻辑格式化"></p>
<ul>
<li><strong>逻辑格式化：</strong>磁盘分区（分卷），完成各分区的文件系统初始化（即灰色部分的数据就是此时写入的）</li>
<li>引导块的内容在第一章中操作系统的引道中有详细说明</li>
<li>i结点区就是文件系统连续存放索引结点的地方</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>文件系统在内存中的结构</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="文件系统在内存中的结构"></p>
<ul>
<li><p>在内存中，存在着三部分：</p>
<blockquote>
<ul>
<li><strong>目录缓存：</strong>存放着曾经打开过的文件的FCB（用户第二次打开时可以直接查询缓存，不用再查询外存，提高效率）</li>
<li><strong>系统打开文件表：</strong>记录当前系统中各文件的打开情况（打开计数指的是该文件当前被多少各用户打开）</li>
<li><strong>进程(用户)打开文件表：</strong>该进程的打开文件表</li>
</ul>
</blockquote>
</li>
<li><p>文件打开顺序：</p>
<blockquote>
<ul>
<li>根据路径将相应文件的FCB读取到缓存中（或检查缓存中是否有相应文件的FCB）</li>
<li>将相应文件的FCB复制到系统打开文件表</li>
<li>在进程（用户）打开文件表中新键一个条目，并返回<strong>文件描述符（文件句柄）</strong></li>
<li>进程（户用）就可以用文件描述符（文件句柄）对相应文件进行操作</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<h3 id="6、虚拟文件系统"><a href="#6、虚拟文件系统" class="headerlink" title="6、虚拟文件系统"></a>6、虚拟文件系统</h3><blockquote>
<p><strong>虚拟文件系统</strong></p>
<blockquote>
<p>​        在日常使用中，可能会遇到一个系统中出现多个文件系统（磁盘、移动硬盘、U盘），而这些文件系统之间的调用函数各不相同，在使用的时候非常不方便，因此引入一个虚拟文件系统对此进行统一管理。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png" alt="虚拟文件系统"></p>
<ul>
<li><p>向上层用户进程提供统一标准的系统调用接口，并且屏蔽了底层具体文件系统的实现差异</p>
</li>
<li><p>虚拟文件系统要求下层的文件系统必须实现规定标准的函数功能，如open&#x2F;read&#x2F;write</p>
</li>
<li><p>为不同的文件系统的目录项<strong>提供一个统一的表示方式</strong></p>
<blockquote>
<img src="/picture/学习/操作系统上的图/文件管理/v结点.png" alt="v结点" style="zoom:60%;" />

<p>​        即无论是哪种文件系统的目录项，在打开一个文件后，虚拟文件系统会给它创建一个v结点，并且将相应的信息复制到v结点中。</p>
<p><strong>注意：</strong> <strong>v结点只会存在于内存中，i结点既可被调入内存中，也会存在磁盘中</strong></p>
<ul>
<li><p><strong>函数功能指针：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD%E6%8C%87%E9%92%88.png" alt="函数功能指针"></p>
<p>每个v结点的函数功能指针都会指向它所属的文件系统所提供的具体函数。（即v结点可以通过函数功能指针来找到相应的函数）</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>文件系统的挂载</strong></p>
<blockquote>
<p>文件系统的挂载需要做以下的事：</p>
<ul>
<li>在虚拟文件系统中注册新挂载的文件系统。即在<strong>内存中的挂在表（mount table）</strong>中写入该文件系统的相关信息</li>
<li>新挂载的文件系统要向虚拟文件系统提供一个<strong>函数地址列表</strong>（相应文件系统的函数地址）</li>
<li>将新文件系统加到<strong>挂载点</strong>，即将新文件系统挂载到某个父目录之下</li>
</ul>
</blockquote>
</blockquote>
<h2 id="二、文件系统实现"><a href="#二、文件系统实现" class="headerlink" title="二、文件系统实现"></a>二、文件系统实现</h2><h3 id="1、文件分配方式（文件的物理结构）"><a href="#1、文件分配方式（文件的物理结构）" class="headerlink" title="1、文件分配方式（文件的物理结构）"></a>1、文件分配方式（文件的物理结构）</h3><blockquote>
<p>文件分配方式就是指当要存储新文件到磁盘上时，操作系统系统要按照什么样的方式给它分配空间。</p>
<p><strong>前提知识：</strong></p>
<blockquote>
<ul>
<li>类似于内存管理，磁盘中的空间也是分成许多个等大的小分块，且操作系统以这些分块为基本单位来给文件分配空间</li>
<li>磁盘中的分块一般与内存中的分页有着相同的大小</li>
<li>因为磁盘也是分成一小块一小块地，所以每个文件在存入磁盘时也会有一个表来记录文件的位置。（这与内存的分页很类似）</li>
<li>相同地，文件本身的记录表上的都是逻辑地址，在查询时需要经过地址转换（这与内存的分页也很类似）</li>
</ul>
</blockquote>
<ul>
<li><p><strong>连续分配</strong></p>
<blockquote>
<p><strong>思想：</strong>连续分配方法就是将一组连续的块分配给磁盘。</p>
<img src="/picture/学习/操作系统上的图/文件管理/连续分配.png" alt="连续分配" style="zoom:67%;" />

<img src="/picture/学习/操作系统上的图/文件管理/连续分配的记录表.png" alt="连续分配的记录表" style="zoom:67%;" />

<p>由于文件的物理地址和逻辑地址都是连续的，因此在进行<strong>地址转换</strong>时，可以直接：<strong>物理地址&#x3D;逻辑块号+初始块号</strong>（注意要判断是否越界）</p>
<p><strong>优点：</strong></p>
<blockquote>
<ul>
<li>可以支持<strong>顺序访问</strong>和<strong>直接访问（随机访问）</strong></li>
<li>访问磁盘时需要的寻道数和巡道时间最短</li>
</ul>
</blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<ul>
<li>文件长度不宜动态增加（因为增加时如果后面没有空闲位置，需要对整个文件进行搬迁，直到找到能放得下的位置）</li>
<li>反复增删文件会产生外部碎片（类似于内存管理中的连续分配）</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>链接分配</strong></p>
<blockquote>
<p>链式分配采取<strong>离散分配</strong>的方式，消除了外部碎片，因此可以提高磁盘的空间利用率。链式分配可以分为：<strong>隐式链接</strong>和<strong>显式链接</strong></p>
<ul>
<li><p><strong>隐式链接：</strong></p>
<blockquote>
<img src="/picture/学习/操作系统上的图/文件管理/隐式链接.png" alt="隐式链接" style="zoom:67%;" />

<ul>
<li><p>每个文件对应一个磁盘块的链表。</p>
</li>
<li><p>磁盘块可以分布在磁盘的任何地方。</p>
</li>
<li><p>除去最后一个磁盘块外，每个磁盘块都有指向下一个盘块的指针，而<strong>这些指针对用户是透明的</strong></p>
</li>
<li><p>当用户访问文件的某一个盘块时，只能先找到起始块号，然后使用<strong>顺序查找</strong>来查询所需要的盘块</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<blockquote>
<ul>
<li>无法直接访问某一盘块，只能顺序访问文件，且盘块指针会消耗一定的存储空间	</li>
<li>当链表中某一块的指针丢失时，会造成整个文件损坏</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>显式链接：</strong></p>
<blockquote>
<img src="/picture/学习/操作系统上的图/文件管理/显示链接.png" alt="显示链接" style="zoom:67%;" />

<ul>
<li>显示链接就是把用于链接物理块得指针，从每个物理块末尾中提取出来，<strong>显示地存放在内存得一张链接表中</strong></li>
<li>该表在整个磁盘中仅设置一张（即一个磁盘一张表），被称为<strong>文件分配表（FAT）</strong></li>
<li>读取文件某一块时，系统会先查链接表，然后根据查到得结果再去读取磁盘（只读一次，而隐式链接需要顺序地读取多次磁盘）</li>
</ul>
<p><strong>优点：</strong></p>
<blockquote>
<ul>
<li>方便拓展，不会产生外部碎片，</li>
<li>支持随机存取</li>
<li>相较于隐式链接，地址转换时不需要读取磁盘</li>
</ul>
</blockquote>
<p><strong>缺点：</strong>文件分配表需要占用一定内存空间</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>索引分配</strong></p>
<blockquote>
<p>​        索引分配允许文件离散地分配在各个磁盘块中，系统会为<strong>每个文件建立一张索引表</strong>，索引表中记录了文件各个逻辑块对应的物理块（类似于内存管理中的页表）。</p>
<p>​        存放索引表的磁盘块称为<strong>索引块</strong>，存放文件数据的磁盘块称为<strong>数据块</strong>。</p>
<img src="/picture/学习/操作系统上的图/文件管理/索引分配.png" alt="索引分配" style="zoom:67%;" />

<ul>
<li>每一个文件都有一个索引表</li>
<li>读取文件的某一块的内容时，需要先在该文件的FCB中，找到<strong>索引块</strong>；然后根据索引块上的索引表，找到需要的逻辑块号并找到对应的物理块号。</li>
</ul>
<p><strong>优点：</strong></p>
<blockquote>
<ul>
<li>索引分配方式支持随机访问</li>
<li>文件拓展耶很容易实现</li>
</ul>
</blockquote>
<p><strong>缺点：</strong>索引表需要占用一定的存储空间</p>
<p>假如一个磁盘块为1KB，一个索引表项4B，则一个磁盘块只能存放256个索引表（即一个索引块最多只能表示256KB大小的文件），对于超过大小的文件，通常有以下的解决方法：</p>
<blockquote>
<ul>
<li><p><strong>链接方案</strong></p>
<blockquote>
<p>当索引表太大时，可以将多个索引块链接起来存放，即</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E9%93%BE%E6%8E%A5%E6%96%B9%E6%A1%88.png" alt="链接方案"></p>
<p>当一个索引块存满后依旧不能完整表示整个文件，则<strong>空出一部分空间来表示下一个索引块的地址</strong>。</p>
<p><strong>缺点：</strong>如果需要查找最后一个索引块时，就需要顺序查找，因此执行效率低</p>
</blockquote>
</li>
<li><p><strong>多层索引</strong></p>
<blockquote>
<p>建立多层索引（类似于多级页表）。使用第一层索引块来指向第二层的索引块（当然还可以以此类推建立第三层、第四层的索引块），如图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95.png" alt="多级索引"></p>
<p>采用多层索引时，则<strong>各层索引表不能超过一个磁盘块</strong></p>
<p>如上图的结构，假设要查找1026好逻辑块，则</p>
<p>$1026&#x2F;256&#x3D;4$，$1026% 256&#x3D;2$,查找一级索引表中的4号索引表，再查找二级索引表中的2号逻辑块。</p>
<p>访问一个二级索引结构，则需要访问3次读磁盘的操作。</p>
</blockquote>
</li>
<li><p><strong>混合索引</strong></p>
<blockquote>
<p>多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含<strong>直接地址索引</strong>（直接指向数据块），又包含<strong>一级间接索引</strong>（单层索引表），还包含<strong>两级间接索引</strong>（两层索引表），如图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%B7%B7%E5%90%88%E7%B4%A2%E5%BC%95.png" alt="混合索引"></p>
<p>在混合索引表中，一般直接地址较多，且需要访问磁盘的次数最少，依次是一级间接索引，二级间接索引。</p>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
</li>
</ul>
<p><strong>三种分配方式的区别：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E4%B8%89%E7%A7%8D%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="三种分配方式的区别"></p>
</blockquote>
</blockquote>
<h3 id="2、文件存储空间管理"><a href="#2、文件存储空间管理" class="headerlink" title="2、文件存储空间管理"></a>2、文件存储空间管理</h3><blockquote>
<p>文件存储空间管理是指管理磁盘中未被分配的空闲块。</p>
<p><strong>文件存储器空间的划分和初始化：</strong></p>
<blockquote>
<img src="/picture/学习/操作系统上的图/文件管理/逻辑卷和物理盘的关系.png" alt="逻辑卷和物理盘的关系" style="zoom:67%;" />

<ul>
<li>逻辑卷是操作系统对物理盘的一个划分</li>
<li>一个逻辑卷可以分为<strong>目录区</strong>和<strong>文件区</strong>。</li>
<li>一个物理盘可以划分为多个逻辑卷，一个逻辑卷也可以由多个物理盘组成</li>
</ul>
</blockquote>
<p><strong>文件存储器空间管理：</strong></p>
<blockquote>
<p>​        文件存储设备分成许多大小相同的物理块，文件存储设备的管理实质上是对空间块的组织和管理（它包括空闲块的组织、分配和回收）。</p>
<ul>
<li><p><strong>空闲表法</strong></p>
<blockquote>
<p>​        空闲表法属于<strong>连续分配方式</strong>，与内存动态方式类似。系统为磁盘上所有空闲区建立了一张空闲盘块表，每个空闲区对应一个空闲表项。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E7%A9%BA%E9%97%B2%E8%A1%A8%E6%B3%95.png" alt="空闲表法"></p>
<ul>
<li>每一项表示一段空闲盘块。第一个空闲盘块：这段空闲盘块中的第一个；空闲盘块数：指这段空闲盘块中的个数</li>
</ul>
<p><strong>分配：</strong>与内存的动态分配类似，同样可以采用首次适应算法、循环首次适应算法等</p>
<p><strong>回收：</strong>在回收时，要注意回收区是否与空闲表的前区和后区相邻接，对相邻的要进行合并（即回收区块时，如果前后都是空闲区块，则需要将这两项空闲盘块表项进行合并）</p>
</blockquote>
</li>
<li><p><strong>空闲链表法</strong></p>
<blockquote>
<p>将所有空闲盘区拉成一条空闲链，根据空闲链的基本元素不同，可以把链表分成两类：</p>
<ul>
<li><p><strong>空闲盘块链</strong></p>
<blockquote>
<p>把磁盘上的所有空闲空间以盘块为单位拉成一条链</p>
<img src="/picture/学习/操作系统上的图/文件管理/空闲盘块链.png" alt="空闲盘块链" style="zoom:67%;" />
</blockquote>
</li>
<li><p><strong>空闲盘区链</strong></p>
<blockquote>
<p>把磁盘上的所有空闲盘区（每个盘区包含若干个盘块）为单位组成一条链</p>
<img src="/picture/学习/操作系统上的图/文件管理/空闲盘区链.png" alt="空闲盘区链" style="zoom:67%;" /></blockquote>
</li>
</ul>
<p><strong>分配：</strong>无论是哪种链接方式，分配时也可以使用与内存动态分区类似的算法，<strong>常用的是首次适应算法</strong></p>
<p><strong>回收：</strong>回收盘块时，同样要注意回收区相邻接的空闲盘区的合并问题</p>
<p><strong>注意：</strong>两种链接方式中，都需要分配一定的空间来指向下一个空闲块的地址；系统只需要保存头指针和尾指针。</p>
</blockquote>
</li>
<li><p><strong>位示图法</strong></p>
<blockquote>
<p>利用二进制的一位来表示磁盘中某一个磁盘块的使用情况，即磁盘上的每一个磁盘块都有一位二进制位与之对应。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E4%BD%8D%E7%A4%BA%E5%9B%BE%E6%B3%95.png" alt="位示图法"></p>
<ul>
<li>横向的称为<strong>字号</strong>；纵向的称为<strong>位号</strong>（实际上就是一个二维数组的行号和列号）</li>
<li>一对字号和位号（字号, 位号）可以转化成一个逻辑地址，反之也成立。</li>
<li>通常以“1”表示该盘块已分配，“0”表示该盘块未分配</li>
</ul>
<p><strong>分配：</strong>①、顺序扫描位示图，找到k个相邻或不相邻的“0”；②、根据字号、位号算出对应的盘块号，将相应盘块分配给文件；③、将分配的位设置为“1”</p>
<p><strong>回收：</strong>①、根据回收的盘块号计算出对应的字号、位号；②、将相应的二进制位设为“0”</p>
</blockquote>
</li>
<li><p><strong>成组链接法</strong></p>
<blockquote>
<p>​        为了适应大文件系统，UNIX系统中采用了<strong>成组链接法</strong>对磁盘空间块进行管理。</p>
<p>​        <strong>文件卷的目录区中</strong>专门用一个磁盘块作为“<strong>超级块</strong>”，当系统启动时就将超级块读入内存。并且保证内存与外存中的“超级块”数据一致</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%88%90%E7%BB%84%E9%93%BE%E6%8E%A5%E6%B3%95.png" alt="成组链接法"></p>
<ul>
<li>超级块中第一行记录的是该分组空闲盘块的数量</li>
<li>第二行的空闲块记录的是下一个分组的地址</li>
<li>第三行直到后面指的是可用的盘块地址（可以不连续）</li>
<li>第二行空闲块记录的是300，是一个新的分组，它的第一行也是表示该分组空闲盘块的数量，第二行记录的是下一个分组的地址，而后续的则记录的是可用的盘块地址</li>
<li>依次类推，直到最后一个分组，第二行用特殊数字-1表示本组就是最后一组</li>
</ul>
<p><strong>分配：</strong>检查本组空闲块是否足够，够则直接分配（分配时注意每个分组的第一块记录的是下一个分组的地址信息）；不够可以跨组分配</p>
<p><strong>回收：</strong>回收时注意本分组的空闲块是否已满，如果满了就需要新开一个分组，然后更改第二行空闲块的内容</p>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<h3 id="3、文件的基本操作"><a href="#3、文件的基本操作" class="headerlink" title="3、文件的基本操作"></a>3、文件的基本操作</h3><blockquote>
<ul>
<li><p><strong>创建文件</strong></p>
<blockquote>
<p>在用户创建文件的时候，系统在背后自动调用<strong>“create”系统调用</strong>，在进行系统调用时，需要提供以下几个参数：</p>
<ul>
<li>所需的外存空间大小</li>
<li>文件存放路径</li>
<li>文件名</li>
</ul>
<p>而上述参数都是可以由系统自动补全的。而操作系统在处理系统调用时，主要做了两件事：</p>
<ul>
<li><strong>在外存找到文件所需要的空间</strong></li>
<li>根据文件存放路径的信息找到该目录对应的目录文件，在目录中<strong>创建该文件对应的目录项</strong>（目录项中包含了文件名、文件在外存中的存放位置等信息）</li>
</ul>
</blockquote>
</li>
<li><p><strong>删除文件</strong></p>
<blockquote>
<p>在用户删除文件时，系统会自动调用<strong>“delete”系统调用</strong>，在进行系统调用时，需要提供以下几个参数：</p>
<ul>
<li>文件存放路径</li>
<li>文件名</li>
</ul>
<p>而上述参数都是可以由系统自动补全的。而操作系统在处理系统调用时，主要做了三件事：</p>
<ul>
<li>根据文件存放路径找到相应的目录文件，从目录中<strong>找到文件名所对应的目录项</strong></li>
<li>根据该目录项记录的文件在外存的存放位置、文件大小等信息，<strong>回收文件占用的磁盘块</strong></li>
<li>从目录表中<strong>删除文件对应的目录项</strong></li>
</ul>
</blockquote>
</li>
<li><p><strong>写文件</strong></p>
<blockquote>
<p>在进行写文件时，操作系统会自动调用<strong>write系统调用</strong>，然后系统调用会自动完成打开文件这一操作。</p>
<p>进程调用write系统调用时，需要指明是哪个文件（提供打开文件表中的索引号即可），还需要指明要写入多少数据、指明写入的数据要放在内存中的什么位置。</p>
</blockquote>
</li>
<li><p><strong>读文件</strong></p>
<blockquote>
<p>在进行读文件时，操作系统会自动调用<strong>read系统调用</strong>，将文件数据读入内存中。而系统调用会自动完成打开文件这一操作。</p>
<p>进程调用read系统调用时，需要指明是哪个文件（提供打开文件表中的索引号即可），还需要指明要读入多少数据、指明读入的数据要放在内存中的什么位置。</p>
</blockquote>
</li>
<li><p><strong>打开文件</strong></p>
<blockquote>
<p>在操作系统中，在对文件进行操作之前，需要先使用<strong>“open”系统调用</strong>，“打开文件”需要提供以下的参数：</p>
<ul>
<li>文件保存路径</li>
<li>文件名</li>
<li>要对文件的操作类型（如，只读操作，读写操作等）</li>
</ul>
<p>操作系统处理open系统调用时，主要做了几件事：</p>
<ul>
<li>根据文件存放路径找到对应的目录文件，从目录中<strong>找到文件名对应的目录项</strong>，并<strong>检查用户是否拥有该操作的权限</strong></li>
<li><strong>将目录项复制到内存中的“打开文件表”中</strong>，并将对应目录表的目的编号返回给用户。之后<strong>用户使用该编号来指明要操作的文件</strong>（此时文件被放到内存中了）</li>
</ul>
<p><strong>打开文件表：</strong></p>
<blockquote>
<p> <img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E8%A1%A8.png" alt="打开文件表"></p>
<ul>
<li>系统具有一个总的打开文件表</li>
<li>每个用户进程也有一个局部的打开文件表（只用于记录本进程打开的文件）</li>
<li><strong>打开计数器：</strong>对文件正在被打开的次数</li>
<li><strong>读写指针：</strong>指文件中读写的位置</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>关闭文件</strong></p>
<blockquote>
<p>进程使用完文件后，要“关闭文件”，操作系统在处理close系统调用时，主要做了几件事：</p>
<ul>
<li>将进程的打开文件表相应表项删除</li>
<li>回收分配给该文件的内存空间等资源</li>
<li>系统打开文件表的打开计数器减1，若count&#x3D;0，则删除对应表项</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="4、文件共享"><a href="#4、文件共享" class="headerlink" title="4、文件共享"></a>4、文件共享</h3><blockquote>
<p>文件共享可以使多个用户（进程）共享同一个文件，<strong>系统中只保留该文件的一个副本</strong>。现在常用的共享方式有以下两种：</p>
<ul>
<li><p><strong>基于索引结点的共享方式（硬链接）</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6_%E7%A1%AC%E9%93%BE%E6%8E%A5.png" alt="共享文件_硬链接"></p>
<p>​        硬链接是根据目录结构中提到的一种目录结构——索引结点，用户通过<strong>索引结点指针</strong>来共同指向一个索引结点（这个索引结点指向一个文件），从而达到共享文件的效果。</p>
<p><strong>注意：</strong></p>
<ul>
<li>索引结点上有一个参数Count，这个参数记录了<strong>链接到本结点的用户数</strong></li>
<li>用户删除相应文件时，只会删除相应的索引节点指针，然后相应索引结点中的Count会自动减1。直到Count&#x3D;0时，该文件才会从系统中删除</li>
<li>当有新用户需要连接这个文件时，该用户的目录表中会创建一个索引节点指针指向该索引结点，然后相应索引结点中的Count会自动加1</li>
</ul>
</blockquote>
</li>
<li><p><strong>利用符号链实现文件共享（软链接）</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB_%E8%BD%AF%E9%93%BE%E6%8E%A5.png" alt="文件共享_软链接"></p>
<p>​        软链接是可以让用户3使用到共享用户的文件，它由系统创建一个<strong>LINK类型的文件</strong>，该文件记录了通过User1访问文件1的存放路径（类似于Windows上的快捷方式）</p>
<p><strong>注意：</strong></p>
<ul>
<li>软链接是在其它用户的硬链接的基础上实现的，因此如果该用户的硬链接断开，那么软连接也会随之失效（即无法访问目标文件）</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="5、文件保护"><a href="#5、文件保护" class="headerlink" title="5、文件保护"></a>5、文件保护</h3><blockquote>
<p>​        文件保护是为了防止文件共享时可能会导致文件被破坏或未经批准的用户修改文件，其主要手段为：<strong>口令保护</strong>、<strong>加密保护</strong>、<strong>访问控制</strong>。</p>
<ul>
<li><p><strong>口令保护</strong></p>
<blockquote>
<p>​        口令保护是指用户在创建一个文件时提供一个<strong>口令</strong>，而系统会在创建文件PCB时放入相应的口令。同时所有用户在访问该文件时都需要提供该口令。</p>
<p><strong>优点：</strong>开销不大，匹配迅速</p>
<p><strong>缺点：</strong>口令直接存放在系统内部，不够安全</p>
</blockquote>
</li>
<li><p><strong>加密保护</strong></p>
<blockquote>
<p>​        加密保护是指用户对文件进行加密，文件被访问时，需要用密钥来进行解密后才会显示原始数据。如</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E5%8A%A0%E5%AF%86%E4%BF%9D%E6%8A%A4.png" alt="加密保护"></p>
<ul>
<li>即如果使用的不是正确的密码，那么解密出来的结果依旧会是乱码数据</li>
</ul>
<p><strong>优点：</strong>安全性高</p>
<p><strong>缺点：</strong>解密过程需要消耗一定时间</p>
</blockquote>
</li>
<li><p><strong>访问控制</strong></p>
<blockquote>
<p>​        访问控制是指<strong>根据用户身份进行控制</strong>，即在每个文件和目录中增加一个<strong>访问控制表</strong>，上面记录了每个用户名及其允许访问的类型。如</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6.png" alt="访问控制"></p>
<ul>
<li>通过0和1来表示是否拥有相应权限</li>
</ul>
<p>而随着用户越来越多，后来又多了一种优化方式，即为每个文件和目录创建一个<strong>精简的访问列表</strong>，上面记录的是一个分组的名字及其允许访问的类型，而一个组里可以又多个不同的用户。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E7%B2%BE%E7%AE%80%E7%9A%84%E8%AE%BF%E9%97%AE%E5%88%97%E8%A1%A8.png" alt="精简的访问列表"></p>
<ul>
<li>这个列表也是存放在文件的PCB中</li>
<li>在同一个组内的所有用户对该文件的权限都是一样的</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="三、磁盘组织与管理"><a href="#三、磁盘组织与管理" class="headerlink" title="三、磁盘组织与管理"></a>三、磁盘组织与管理</h2><h3 id="1、磁盘的结构"><a href="#1、磁盘的结构" class="headerlink" title="1、磁盘的结构"></a>1、磁盘的结构</h3><blockquote>
<img src="/picture/学习/操作系统上的图/文件管理/磁盘结构.png" alt="磁盘结构" style="zoom:67%;" />

<ul>
<li><strong>磁盘：</strong>由表面涂有磁性唔知的金属或塑料构成的圆形盘片，通过一个称为<strong>磁头</strong>的导体线圈从磁盘存取数据</li>
<li><strong>盘面：</strong>磁盘盘片的一面</li>
<li><strong>磁道：</strong>指磁盘盘面上存储数据的一个同心圆（即盘面上的一圈就是一个磁道）</li>
<li><strong>扇区：</strong>将一个盘面划分为若干内角相同的扇形，这样盘面上的<strong>每个磁道</strong>就被分为若干段圆弧，每段圆弧叫做一个扇区（一个磁道上分割的才叫扇区）</li>
<li><strong>柱面：</strong>所有盘面上的统一磁道所构成的一个圆柱（空心圆柱）</li>
</ul>
<p>对于一个磁盘块，可以用（<strong>柱面号</strong>，<strong>盘面号</strong>（有时也叫磁头号），<strong>扇区号</strong>）来表示</p>
<p><strong>磁盘读取磁盘块的方法：</strong></p>
<blockquote>
<ul>
<li>根据柱面号移动磁臂，让磁头指向指定柱面</li>
<li>激活指定盘面对应的磁头</li>
<li>磁盘旋转过程中，指定的扇区会从磁头下划过，这样就可对指定扇区进行读写操作</li>
</ul>
</blockquote>
<p><strong>注意：</strong></p>
<blockquote>
<ul>
<li>磁盘中的信息存储密度不同，内侧的信息密度大于外侧的信息密度，且<strong>磁盘的存储空间大小取决于内侧的信息密度</strong></li>
<li>相邻磁道和扇区之间都会有一定的间隔进行分割</li>
<li>所有次有都连在统一各磁臂上，即所有磁头移动时方向一致</li>
<li>每个扇区大小固定，且<strong>一个扇区称为一个盘块</strong></li>
</ul>
</blockquote>
<p><strong>磁盘的分类：</strong></p>
<blockquote>
<p><strong>根据磁头：</strong></p>
<blockquote>
<ul>
<li><strong>固定头磁盘</strong>：每个磁道一个磁头，磁头不能移动的磁盘</li>
<li><strong>活动头磁盘</strong>：每一个磁面一个磁头，磁头可以移到不同磁道上的磁盘</li>
</ul>
</blockquote>
<p><strong>根据磁盘片：</strong></p>
<blockquote>
<ul>
<li><strong>固定盘磁盘：</strong>磁盘永久固定在磁盘驱动器内的磁盘</li>
<li><strong>可换盘磁盘：</strong>磁盘可移动和替换的磁盘</li>
</ul>
</blockquote>
</blockquote>
</blockquote>
<h3 id="2、磁盘调度算法"><a href="#2、磁盘调度算法" class="headerlink" title="2、磁盘调度算法"></a>2、磁盘调度算法</h3><blockquote>
<p><strong>磁盘操作时间计算</strong></p>
<blockquote>
<p>一次磁盘的读写操作的时间由<strong>寻找（寻道）时间、旋转延迟时间</strong>和<strong>传输时间</strong>决定</p>
<ul>
<li><p><strong>寻道时间</strong>$T_s$：将磁头移动到指定磁道所花费的时间</p>
<blockquote>
<ul>
<li><strong>启动磁头臂</strong>所需要的时间，假设为s</li>
<li><strong>移动磁头</strong>所需要的时间，假设磁头匀速移动，每跨越一个磁道耗时为m，总共需要跨越n条磁道，则</li>
</ul>
<p>$$<br>寻道时间T_s&#x3D;s+m\times n<br>$$</p>
</blockquote>
</li>
<li><p><strong>旋转延迟时间</strong>$T_r$：通过旋转磁盘，使磁头定位道目标扇区所需要的时间。</p>
<blockquote>
<p>假设磁盘转速为r，且找到目标扇区平均需要转$\frac{1}{2}$圈，因此<br>$$<br>T_r&#x3D;\frac{1}{2r}<br>$$</p>
</blockquote>
</li>
<li><p><strong>传输时间</strong>$T_t$：从硬盘读出或写入数据所经历的时间。</p>
<blockquote>
<p>这个时间取决于每次读写的字节数b和磁盘的转速r，假设N为一个磁道上的字节数即<br>$$<br>T_t&#x3D;\frac{b}{rN}\quad(其中\frac{b}{N}为需要转的圈数)<br>$$</p>
</blockquote>
</li>
</ul>
<p>因此，总的操作时间为：<br>$$<br>T_a&#x3D;T_s+\frac{1}{2r}+\frac{b}{rN}<br>$$</p>
</blockquote>
<p><strong>磁盘的调度算法：</strong></p>
<blockquote>
<ul>
<li><p><strong>先来先服务算法</strong>（FCFS）</p>
<blockquote>
<p>​        先来先服务算法<strong>根据进程请求访问磁盘的先后顺序进行调度</strong>，是一种最简单的调度算法。</p>
<p>​        假如磁盘的请求队列中的请求顺序分别为55，58，39，18，90，160，150，38，184，磁头的初始位置在100，那么它的调度顺序如下图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6.png" alt="先来先服务调度"></p>
<p>磁头一共移动了$45+3+19+21+72+70+10+112+146&#x3D;498$个磁道，平均寻找长度为$498&#x2F;9&#x3D;55.3$</p>
<p><strong>优点：</strong>实现简单，公平</p>
<p><strong>缺点：</strong>性能不佳，近乎于随机调度算法</p>
</blockquote>
</li>
<li><p><strong>最短寻找时间优先算法</strong>（SSTF）</p>
<blockquote>
<p>​        最短寻找时间优先算法会选择调度处理的磁道是<strong>当前磁头所在磁道距离最近的磁道</strong>，以便使每次寻找的时间最短（局部最优解）</p>
<p>​        假如磁盘的请求队列中的请求顺序分别为55，58，39，18，90，160，150，38，184，磁头的初始位置在100，那么它的调度顺序如下图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%9C%80%E7%9F%AD%E5%AF%BB%E6%89%BE%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95.png" alt="最短寻找时间优先算法"></p>
<p>磁头一共移动了$10+32+3+16+1+20+132+10+24&#x3D;248$个磁道，平均寻找长度为$248&#x2F;9&#x3D;27.5$</p>
<p><strong>注意</strong>：虽然SSTF算法每一步都寻找最优解，但是不一定是全局的最优解。</p>
<p><strong>优点：</strong>寻道时间短，效率高</p>
<p><strong>缺点：</strong>如果在某一区段内源源不断地出现新请求，那么可能会对其它区段内的请求造成“饥饿”现象</p>
</blockquote>
</li>
<li><p><strong>扫描算法</strong>（SCAN）</p>
<blockquote>
<p>​        在扫描算法中，<strong>磁头只有移动道最外侧磁道是才能往内移动，移动道最内侧磁道才能往外移动</strong>。</p>
<p>​        假如磁盘的请求队列中的请求顺序分别为55，58，39，18，90，160，150，38，184，磁头的初始位置在100，那么它的调度顺序如下图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%89%AB%E6%8F%8F%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.png" alt="扫描调度算法"></p>
<p>磁头一共移动了$50+10+24+16+110+32+3+16+1+20&#x3D;282$个磁道，平均寻道长度为$282&#x2F;9&#x3D;31.33$</p>
<p><strong>优点：</strong>不会产生饥饿现象，性能较好，平均寻道时间短</p>
<p><strong>缺点：</strong></p>
<blockquote>
<ul>
<li>只有到达最边上的磁道时才能改变磁道方向（很多时候都不用到最边上）</li>
<li>对于各个位置磁道的响应频率不平均</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>循环扫描算法</strong>（C-SCAN）</p>
<blockquote>
<p>​        在扫描算法的基础之上，<strong>规定磁头朝某个特定方向移动时才处理磁道访问请求，而返回时快速移动至始端而不处理任何请求</strong></p>
<p>​        假如磁盘的请求队列中的请求顺序分别为55，58，39，18，90，160，150，38，184，磁头的初始位置在100，那么它的调度顺序如下图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E5%BE%AA%E7%8E%AF%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95.png" alt="循环扫描算法"></p>
<p><strong>优点：</strong>比起扫描算法，对于各个位置磁道的响应频率都很平均</p>
<p><strong>缺点：</strong>依旧存在“只有到达最边上的磁道时才能改变磁道方向”的问题</p>
</blockquote>
</li>
<li><p><strong>LOCK算法</strong></p>
<blockquote>
<p>​        在扫描算法的基础之上，<strong>规定在磁头移动方向上已经没有别的请求时，就可以改变磁头的移动方向了</strong></p>
<p>​        假如磁盘的请求队列中的请求顺序分别为55，58，39，18，90，160，150，38，184，磁头的初始位置在100，那么它的调度顺序如下图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/LOCK%E7%AE%97%E6%B3%95.png" alt="LOCK算法"></p>
<p><strong>优点：</strong>比起扫描算法，不需要每次移动到最外侧或最内侧才改变磁头方向，使得寻道时间进一步缩短。</p>
<p>如果将LOCK于循环扫描相结合可以得到<strong>C-LOCK算法</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/C_LOCK%E7%AE%97%E6%B3%95.png" alt="C_LOCK算法"></p>
</blockquote>
</li>
</ul>
<p><strong>算法之间的总结：</strong></p>
<blockquote>
<ul>
<li><strong>先来先服务算法</strong>（SCFS）太简单，性能差，仅在请求队列长度接近于1时才较为理想</li>
<li><strong>最短寻找时间优先算法</strong>（SSTF）较为通用和自然</li>
<li><strong>扫描算法</strong>（SCAN）和<strong>循环扫描算法</strong>（C-SCAN）在磁盘负载较大时（磁盘请求多时）比较占优势</li>
</ul>
</blockquote>
</blockquote>
</blockquote>
<h3 id="3、减少磁盘旋转延迟的方法"><a href="#3、减少磁盘旋转延迟的方法" class="headerlink" title="3、减少磁盘旋转延迟的方法"></a>3、减少磁盘旋转延迟的方法</h3><blockquote>
<p>除了减少寻道时间外，减少延迟时间也是提高磁盘传输效率的重要	因素。</p>
<ul>
<li><p><strong>交替编号</strong></p>
<blockquote>
<p><strong>原理：</strong>磁头读完一个扇区后需要一段处理时间才可以继续读下一个扇区</p>
<p><strong>具体做法：</strong>让编号相邻的扇区在物理上不相邻</p>
<img src="/picture/学习/操作系统上的图/文件管理/交替编号.png" alt="交替编号" style="zoom:60%;" />

<p>这样一来，磁头每读完一个扇区后，就可以利用经过一些不需要读取的扇区的时间作为处理时间。等到处理结束后，就又可以读取下一个需要的扇区了</p>
</blockquote>
</li>
<li><p><strong>错位命名</strong></p>
<blockquote>
<p><strong>原理：</strong>连续地址有时会需要跨盘面读取，而所有盘面都是共同旋转的</p>
<p><strong>具体做法：</strong>让相邻盘面的扇区编号“错位”</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E9%94%99%E4%BD%8D%E5%91%BD%E5%90%8D.png" alt="错位命名"></p>
<p>这样一来，磁头如果需要跨盘面读取时，上盘面读取完，就可以恰好让下盘面的磁头在需要读取的扇区前。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="4、磁盘的管理"><a href="#4、磁盘的管理" class="headerlink" title="4、磁盘的管理"></a>4、磁盘的管理</h3><blockquote>
<ul>
<li><p><strong>磁盘初始化</strong></p>
<blockquote>
<ul>
<li><p><strong>低级格式化（物理格式化）：</strong></p>
<blockquote>
<p>磁盘在出厂时，根据需要<strong>将各个磁道划分为扇区</strong>，这一操作被称为物理格式化</p>
<img src="/picture/学习/操作系统上的图/文件管理/低级格式化.png" alt="低级格式化" style="zoom:60%;" />

<p>而一个扇区可以分为三部分：<strong>头部</strong>、<strong>数据区域</strong>（如512B大小）、<strong>尾部</strong>。</p>
<p>管理扇区所需要的各种数据结构一般存放在头、尾两个部分，如扇区校验码，扇区的指针等</p>
</blockquote>
</li>
<li><p><strong>逻辑格式化：</strong></p>
<blockquote>
<p>将磁盘分区，每个分区由若干柱面组成</p>
<img src="/picture/学习/操作系统上的图/文件管理/逻辑格式化2.png" alt="逻辑格式化2" style="zoom:60%;" />

<p>创建文件系统，包括创建文件系统的根目录、初始化存储空间管理所用的数据结构（如位示图、空闲分区表等）</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>引导块</strong></p>
<blockquote>
<p><strong>自举程序（初始化程序）：</strong>指计算机开机时需要进行一系列初始化的工作，完成这些工作的程序就称为<strong>自举程序</strong>。</p>
<ul>
<li>在过去，自举程序一般存放在ROM中，随着计算机生产时就写入，然后就无法更改了</li>
<li>现在，ROM中不在存放自举程序，而是存放<strong>自举装入程序</strong>，自举装入程序可以引导系统在磁盘上找到自举程序，并读入内存。而完整的自举程序放在磁盘的<strong>启动块</strong>中，启动块位于磁盘的固定位置。</li>
</ul>
<p><strong>补充：</strong>拥有启动分区的磁盘称为<strong>启动磁盘</strong>或<strong>系统磁盘</strong></p>
</blockquote>
</li>
<li><p><strong>坏块管理</strong></p>
<blockquote>
<ul>
<li><p>对于简单的磁盘，可以在逻辑格式化时，对整个磁盘进行坏块检查，标明哪些扇区时坏块。（注意：在这种方式中，<strong>坏块对操作系统不透明</strong>）</p>
</li>
<li><p>对于复杂的磁盘，<strong>磁盘控制器</strong>（磁盘设备内部的一个硬件部件）会维护一个坏块链表。在磁盘进行低级格式化时就会将坏块链进行初始化。同时保留一些备用扇区，用于替换坏块，这种方案称为<strong>扇区备用</strong>（注意：在这种方式中，<strong>坏块对操作系统透明</strong>）</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E5%9D%8F%E5%9D%97%E7%9A%84%E7%AE%A1%E7%90%86.png" alt="坏块的管理"></p>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="5、固态硬盘-SSD"><a href="#5、固态硬盘-SSD" class="headerlink" title="5、固态硬盘(SSD)"></a>5、固态硬盘(SSD)</h3><blockquote>
<p><strong>组成</strong></p>
<blockquote>
<img src="/picture/学习/操作系统上的图/文件管理/固态硬盘的结构.png" alt="固态硬盘的结构" style="zoom:50%;" />

<p>固态硬盘的存储技术：<strong>闪存技术</strong>，属于电可擦除ROM。</p>
<img src="/picture/学习/操作系统上的图/文件管理/固态硬盘结构.png" alt="固态硬盘结构"  />

<ul>
<li>固态硬盘上有许多的<strong>闪存芯片</strong></li>
<li>每个闪存芯片内又有许多的<strong>块</strong></li>
<li>每一个块又可以分成许多<strong>页</strong>（这一页相对应于磁盘中的一个扇区）</li>
</ul>
</blockquote>
<p><strong>读写性能特性</strong></p>
<blockquote>
<ul>
<li>固态硬盘<strong>以页为单位</strong>进行读写</li>
<li>但<strong>以块为单位</strong>进行擦除，其中每页可以写一次，读无数次。因此进行某一页的擦除时，<strong>需要将块内其它页全部都复制到一个新的块中</strong></li>
<li>支持随机访问，系统给定一个逻辑地址，闪存翻译层可以通过电路迅速定位到对应的物理地址</li>
<li>读取快，写入慢。因为要写的页有数据时，需要将其擦除后再写，而擦除操作又是以块为单位的，需要将其它无关页写到其它块中。</li>
</ul>
</blockquote>
<p><strong>与机械硬盘相比较</strong></p>
<blockquote>
<ul>
<li>SSD读写速度快，随机访问性能高，即通过电路控制访问位置；机械硬盘通过移动磁臂旋转磁盘控制访问位置，因此需要寻道时间和旋转延迟</li>
<li>SSD安静无噪声、耐摔抗震、能耗低，但造价高</li>
<li>SSD的一个块如果<strong>擦除次数过多</strong>，可能会坏掉；而机械硬盘的扇区不会因为写的次数太多而坏掉</li>
</ul>
</blockquote>
<p><strong>磨损均衡技术</strong></p>
<blockquote>
<p>因为SSD擦除时有损坏的风险，因此可以将擦除平均分布在各个块上，从而提升使用寿命</p>
<ul>
<li><strong>动态磨损均衡：</strong>写入数据时，优先选择累计擦除次数少的新闪存块</li>
<li><strong>静态磨损均衡：</strong>SSD监测并自动进行数据分配、迁移，让老旧的闪存块承担以读为主的存储任务，让较新的闪存块承担更多的写任务</li>
</ul>
</blockquote>
</blockquote>
<h2 id="四、其它补充"><a href="#四、其它补充" class="headerlink" title="四、其它补充"></a>四、其它补充</h2><blockquote>
<ul>
<li><p><strong>为什么磁盘的地址编码方式为（柱面号, 盘面号, 扇区号）：</strong></p>
<blockquote>
<p>假设某磁盘有8个柱面，4个盘面，8个扇区。现需要连续读取物理地址（00, 000, 000）~（00, 001, 111）的扇区</p>
<ul>
<li>若物理地址结构为（<strong>盘面号, 柱面号</strong>, 扇区号），读取（00, 000, 000）<del>（00, 000, 111）转两圈即可读完。但是读取（00, 001, 000）</del>（00, 001, 111）时，则<strong>需要启动磁头臂，将磁头转移到下一个磁道（柱面）上</strong></li>
<li>若物理地址结构为（<strong>柱面号, 盘面号</strong>, 扇区号），读取（00, 000, 000）<del>（00, 000, 111）转两圈即可读完。读取（00, 001, 000）</del>（00, 001, 111）时，只需要<strong>切换激活下一个盘面的磁头即可</strong></li>
</ul>
<p>因此两者相比较，明显读取连续地址时，直接切换盘面的磁头要比移动磁头要更省时间。</p>
</blockquote>
</li>
</ul>
</blockquote>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">一、文件系统基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">1、文件系统的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">2、文件的逻辑结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">3、文件目录结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.</span> <span class="toc-text">$4^*$、文件系统层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%85%A8%E5%B1%80%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.</span> <span class="toc-text">5、文件系统的全局结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.6.</span> <span class="toc-text">6、虚拟文件系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">二、文件系统实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%EF%BC%88%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">1、文件分配方式（文件的物理结构）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">2、文件存储空间管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.</span> <span class="toc-text">3、文件的基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="toc-number">2.4.</span> <span class="toc-text">4、文件共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4"><span class="toc-number">2.5.</span> <span class="toc-text">5、文件保护</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%A3%81%E7%9B%98%E7%BB%84%E7%BB%87%E4%B8%8E%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">三、磁盘组织与管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%A3%81%E7%9B%98%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">1、磁盘的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">2、磁盘调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%87%8F%E5%B0%91%E7%A3%81%E7%9B%98%E6%97%8B%E8%BD%AC%E5%BB%B6%E8%BF%9F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text">3、减少磁盘旋转延迟的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E7%A3%81%E7%9B%98%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">3.4.</span> <span class="toc-text">4、磁盘的管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98-SSD"><span class="toc-number">3.5.</span> <span class="toc-text">5、固态硬盘(SSD)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%85%B6%E5%AE%83%E8%A1%A5%E5%85%85"><span class="toc-number">4.</span> <span class="toc-text">四、其它补充</span></a></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
