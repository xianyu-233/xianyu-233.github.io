
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>数据链路层层 - Hexo</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="xainyu-233,"> 
    <meta name="description" content="数据链路层的功能：
数据链路层在物理层提供服务的基础上向网络层提供服务，主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路。
所以我们可以近似认为,"> 
    <meta name="author" content="xianyu"> 
    <link rel="alternative" href="atom.xml" title="Hexo" type="application/atom+xml"> 
    <link rel="icon" href="/img/%E5%96%B7.jfif"> 
    
    
<link rel="stylesheet" href="/css/diaspora.css">

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Hexo</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://xianyu-233.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">数据链路层层</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">数据链路层层</h1>
        <div class="stuff">
            <span>一月 26, 2022</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/" rel="tag">基础学科</a></li></ul>


        </div>
        <div class="content markdown">
            <h1 id="数据链路层的功能："><a href="#数据链路层的功能：" class="headerlink" title="数据链路层的功能："></a>数据链路层的功能：</h1><blockquote>
<p>数据链路层在<strong>物理层</strong>提供服务的基础上向<strong>网络层</strong>提供服务，主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造为<strong>逻辑上无差错的数据链路</strong>。</p>
<p>所以我们可以近似认为：<strong>数据链路层接收的帧均无差错</strong>。</p>
<p>数据链路层的传输单元为<strong>数据帧</strong>。</p>
</blockquote>
<h2 id="为网络层提供服务"><a href="#为网络层提供服务" class="headerlink" title="为网络层提供服务"></a>为网络层提供服务</h2><blockquote>
<p>对于网络层来说，数据链路层的基本任务是将原机器中的网络层数据传输到目标机器的网络层之中。因此数据链路层为网络层提供以下服务：</p>
<ul>
<li><strong>无确定的无连接服务：</strong>源机器发送数据帧时<strong>不需要建立链路连接</strong>，目的机器在收到数据后也<strong>不用发送确认信息</strong>。常用于实时通信或质量较好的信道通信。</li>
<li><strong>有确认的无连接服务：</strong>源机器发送数据帧时<strong>不需要建立链路连接</strong>，但目的机器在收到数据后<strong>需要发送确认信息</strong>。源机器在规定时间内没收到确认消息就重传数据。</li>
<li><strong>有确认的有链接服务：</strong>帧传输过程分为三个阶段：<strong>建立数据链路、传输帧、释放数据链路</strong>。且目的机器对收到的每一个帧都要给出确认，源机器收到后才发送下一个帧。</li>
</ul>
</blockquote>
<h2 id="链路管理"><a href="#链路管理" class="headerlink" title="链路管理"></a>链路管理</h2><blockquote>
<p><strong>定义：</strong>数据链路层连接的<strong>建立、维持和释放</strong>过程。</p>
<p><strong>主要内容：</strong>它主要用于面向连接的服务。链路两端的结点要进行有链接的通信，必须首先确认对方已经处于就绪状态，并交换一些必要的信息以对帧序号的初始化，然后才开始建立连接。在传输过程中则要能维持连接，在传输完毕后要释放连接。</p>
</blockquote>
<h2 id="数据链路层的基本问题"><a href="#数据链路层的基本问题" class="headerlink" title="数据链路层的基本问题"></a>数据链路层的基本问题</h2><h3 id="封（组）装成帧"><a href="#封（组）装成帧" class="headerlink" title="封（组）装成帧"></a>封（组）装成帧</h3><blockquote>
<p><strong>帧的结构：</strong>将一段数据的前后分别添加首部和尾部，就构成了帧。其中帧的首部和尾部包含许多控制信息，其中一个重要的作用就是确定<strong>帧的界限</strong>，也称为<strong>帧定界</strong>。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%B8%A7%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="帧的结构"></p>
<p><strong>帧同步：</strong>指接收方能从接收到的二进制比特流中区分出帧的起始与终止。</p>
<p><strong>最大传送单元（MTU）：</strong>每种数据链路层协议所规定<strong>帧的数据部分长度上限</strong>。</p>
<p><strong>帧的四种组成方法：</strong>1、字符计数法；2、字符（节）填充法；3、零比特填充法；4、违规编码法</p>
<ul>
<li><p><strong>字符计数法：</strong>在帧首部使用一个计数字段（第一个字节，八位）来标明帧内字符数。</p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%AD%97%E7%AC%A6%E8%AE%A1%E6%95%B0%E6%B3%95.png" alt="字符计数法"></p>
<p><strong>缺点：</strong>如果某一个计数字段出现差错，那么后面所有帧都会出现错误。</p>
</blockquote>
</li>
<li><p><strong>字符（节）填充法：</strong>使用两个定界字符作为首部与尾部。</p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%AD%97%E7%AC%A6%E5%A1%AB%E5%85%85%E6%B3%95.png" alt="字符填充法"></p>
<p>当传输数据的编码为ASCII码时，无论数据部分输入的是什么，都可以进行透明传输。</p>
<p>同样<strong>字符（节）填充法</strong>也会出现控制信息在数据部分出现的问题，所以可以对出现在数据部分的控制信息位加上转义字符。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%AD%97%E7%AC%A6%E5%A1%AB%E5%85%85%E6%B3%95%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.png" alt="字符填充法解决方法"></p>
<p>这样一来，只需要在接收方刻意去除数据部分中的转移字符即可。</p>
</blockquote>
</li>
<li><p><strong>零比特填充法：</strong></p>
<blockquote>
<p>用<strong>01111110</strong>作为头部与尾部的标识符。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E9%9B%B6%E6%AF%94%E7%89%B9%E5%A1%AB%E5%85%85%E6%B3%95.png" alt="零比特填充法"></p>
<p><strong>操作：</strong></p>
<p>在发送端，扫描整个信息字段，子要出现连续5个1，就立即填入1个0。</p>
<p>在接收端收到一个帧时，先找到字段确定边界，再对数据部分的比特流进行扫描，发现5个1时，将后面的0删除。</p>
</blockquote>
</li>
<li><p><strong>违规编码法：</strong></p>
<blockquote>
<p>在编码的时候利用不可能出现的编码作为帧边界。如曼彻斯特编码，</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E8%BF%9D%E8%A7%84%E7%BC%96%E7%A0%81%E6%B3%95.png" alt="违规编码法"></p>
</blockquote>
</li>
</ul>
<p><strong>补充：</strong>比较普遍使用的帧同步法是<strong>零比特填充</strong>和<strong>违规编码法</strong>。</p>
</blockquote>
<h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><blockquote>
<p><strong>定义：</strong>指不管所传输的数据是什么样的比特组合，都应当能在链路上传送。</p>
<p><strong>要求：</strong>当所传数据中的比特组合与某一段控制信息完全一样是，应当采取适当的措施，使得接收方不会将该数据误认为是某种控制信息。</p>
</blockquote>
<h3 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h3><blockquote>
<p>概括来说，传输的差错是由于噪声引起的，</p>
<p><strong>全局性的噪声：</strong>由于线路本身电气特性所产生的<strong>随机噪声</strong>，这是信道固有的，且随机存在的。<strong>解决方法：</strong>提高信噪比或避免干扰。</p>
<p><strong>局部性的噪声：</strong>外界特定的短暂原因造成的<strong>冲击噪声</strong>，是产生差错的主要原因。</p>
<p><strong>差错的类型：</strong></p>
<ul>
<li><strong>位错：</strong>比特位出错，1变成0，0变成1（差错检测主要解决的问题）。</li>
<li><strong>帧错：</strong>又分为<strong>帧丢失、帧重复</strong>和<strong>帧失序</strong>。</li>
</ul>
</blockquote>
<h4 id="检错编码"><a href="#检错编码" class="headerlink" title="检错编码"></a>检错编码</h4><blockquote>
<p>只能检查出帧是否出错，无法定位和纠正错误。</p>
<p>检错编码又分为：<strong>奇偶检验码</strong>和<strong>循环冗余码</strong>。</p>
<ul>
<li><p><strong>奇偶检验码</strong></p>
<blockquote>
<p>可以分为<strong>奇校验码</strong>和<strong>偶校验码</strong>。在n-1位的信息元之前加入0或1，来保证整体1的个数为<strong>奇数</strong>或<strong>偶数</strong>。因此发送时有n-1位的信息元以及1位的校验元。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%A5%87%E5%81%B6%E6%A3%80%E9%AA%8C%E7%A0%81.png" alt="奇偶检验码"><br>在接收端，根据接收到的数据，一位位地统计其中1的个数。在奇校验码中，如果1的个数为奇数，那么判定为无差错；如果为偶数，则丢弃。</p>
<p><strong>注意：</strong>奇偶检验码的检错成功率只有50%，如奇校验码，如果出错的位恰好导致1的个数依旧是奇数，那么奇校验码就无法检出差错。</p>
</blockquote>
</li>
<li><p><strong>循环冗余码</strong></p>
<blockquote>
<p><strong>步骤：</strong></p>
<ul>
<li><strong>加0：</strong>设生成多项式G(x)的阶为r，则在待发送数据后面加r个0.</li>
<li><strong>模2除法：</strong>数据加0后除以多项式（直接除，不需要考虑进位），余数为**冗余码(FCS)**。</li>
</ul>
<p><strong>补充：</strong>多项式的一种表示方法：</p>
<blockquote>
<p>10011表示为多项式为：<br>$$<br>X^4+X^1+X^0<br>$$</p>
</blockquote>
<p><strong>例子：</strong>要发送的数据是1101 0110 11，采用CRC校验，生成多项式是10011，那么最终发送数据为？</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E7%A0%81.png" alt="循环冗余码"></p>
<p>最终结果将一开始加上的0全部换为除得的余数。（除得的商没有任何作用！）</p>
<p><strong>检错：</strong></p>
<blockquote>
<p>把收到的每一个帧都除以同样的除数，然后检查得到的余数R。</p>
<ul>
<li>余数为0，判定这个帧没有差错，接收。</li>
<li>余数不为0，判定这个帧有差错，丢弃。</li>
</ul>
</blockquote>
<p><strong>补充：</strong>FCS的生成以及CRC检测都是由硬件实现的。</p>
<p>链路层使用CRC检验能实现无比特差错，但这并不属于可靠传输。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="纠错编码"><a href="#纠错编码" class="headerlink" title="纠错编码"></a>纠错编码</h4><blockquote>
<p><strong>海明码：</strong></p>
<p><strong>特点：</strong>发现双比特错，纠正单比特错。</p>
<p><strong>过程：</strong></p>
<ul>
<li><p><strong>确定校验码位数r</strong></p>
<blockquote>
<p>满足海明不等式：<br>$$<br>2^r \ge k+r+1<br>$$<br>其中r为冗余码的位数，k为信息数据的位数。</p>
</blockquote>
</li>
<li><p><strong>确定校验码和数据的位置</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%A1%AE%E5%AE%9A%E6%A0%A1%E9%AA%8C%E7%A0%81%E4%BD%8D%E7%BD%AE.png" alt="确定校验码位置"></p>
</blockquote>
</li>
<li><p><strong>求校验码的值</strong></p>
<blockquote>
<p><strong>令所有要校验的位与校验码异或&#x3D;0</strong>，从而求出该位的校验码。</p>
<p>如上图的第一位校验码的求法：</p>
<blockquote>
<ul>
<li><p>首先确定$P_1$要校验的位数是1、3、5、7、9（这些的共同点是位数化为二进制后第一位的值相同都是1）</p>
</li>
<li><p>根据定义求：$P_1$ xor $D_1$ xor $D_3$ xor $D_5$ xor $D_7$ xor $D_9$ &#x3D;$P_1$ xor 1 xor 0  xor 1  xor 0 &#x3D; 0，求得P1等于0</p>
</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>检错并纠错</strong></p>
<blockquote>
<p><strong>令所有要校验的位与校验码异或</strong>，检查最后结果，如果结果全为0，那么帧无差错。如果结果出现1，那帧出错。</p>
<p>将所有<strong>校验的位与校验码异或</strong>的结果合起来就可以得到出错位的位号。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="流量控制与可靠传输机制"><a href="#流量控制与可靠传输机制" class="headerlink" title="流量控制与可靠传输机制"></a>流量控制与可靠传输机制</h2><blockquote>
<p><strong>前请补充：</strong></p>
<blockquote>
<ul>
<li>数据链路层中的<strong>流量控制</strong>与后面传输层中的<strong>流量控制</strong>会有一定的交叉。 </li>
<li><strong>现在数据链路层已经不再负责数据的流量控制与可靠传输</strong>了，但在计算机网络早期线路并不可靠的时候，数据链路层就需要承担起这两样职责。</li>
<li>现在数据链路层主要负责<strong>差错检验</strong>（即发现出错的帧就丢掉）。</li>
</ul>
</blockquote>
<p><strong>可靠传输：</strong>发送端发送什么，接收端就接收什么（帧的内容，帧的数量，帧组的序列等）。</p>
<p><strong>流量控制：</strong>控制发送方的发送速率，使得接收方有足够的能力接收发送的每一个帧。</p>
</blockquote>
<h3 id="可靠传输机制"><a href="#可靠传输机制" class="headerlink" title="可靠传输机制"></a>可靠传输机制</h3><blockquote>
<p>数据链路层使用<strong>确认</strong>和<strong>超时重传</strong>这两种机制来完成可靠传输。</p>
<p>确认是一种<strong>无数据的控制帧</strong>，它可以让发送方知道哪些帧被正确接收；有时确认还会捎带在一个回复帧里面，成为<strong>捎带确认</strong>。</p>
<p><strong>超时重传</strong>指在发送方中每发送完一个帧都会启用一个计时器，在计时器计时结束后仍未收到接收方的确认帧，那么就自动将数据再次重传。</p>
<p>在数据链路层中，可靠传输与流量控制有一定程度的相交。</p>
</blockquote>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><blockquote>
<p>当发送方的发送速率大于接收方的接受速率时就会出现传输出错，因此就需要流量控制进行调整。</p>
<p>流量控制的基本手段是：<strong>由接收方控制发送方的发送速率</strong>。</p>
<p><strong>数据链路层流量控制与传输层流量控制的区别</strong>：</p>
<blockquote>
<ul>
<li><strong>数据链路层的流量控制</strong>是<strong>点到点</strong>的（即本传输结点到下一个传输结点），而<strong>传输层的流量控制</strong>是<strong>端到端</strong>的（即本主机到目的主机之间，当然中间包含了许多的路由器等设备）</li>
<li><strong>数据链路层流量控制手段</strong>：接收方收不下就不回复确认；<strong>传输层流量控制手段</strong>：接收端给发送端一个窗口公告（缓冲区剩余量）。</li>
<li><strong>数据链路层</strong>中的<strong>发送窗口与接收窗口</strong>都是<strong>固定的</strong>，<strong>传输层</strong>中的<strong>发送窗口与接收窗口</strong>都是<strong>变化的</strong></li>
</ul>
</blockquote>
<p><strong>流量控制的方法：</strong></p>
<blockquote>
<ul>
<li><p><strong>停止-等待协议</strong>：每发送完一个帧就停止发送，等待对方的确认，在收到确认帧后再发送下一个帧。</p>
</li>
<li><p><strong>滑动窗口协议</strong>：反退N帧协议(GBN)、选择重传协议(SR)</p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png" alt="滑动窗口"></p>
</blockquote>
</li>
</ul>
<p><strong>窗口数量：</strong></p>
<blockquote>
<ul>
<li><strong>停止-等待协议：</strong>发送窗口大小&#x3D;1，接收窗口大小&#x3D;1；</li>
<li><strong>反退N帧协议(GBN)：</strong>发送窗口大小&gt;1，接收窗口大小&#x3D;1；</li>
<li><strong>选择重传协议(SR)：</strong>发送窗口大小&gt;1，接收窗口大小&gt;1；</li>
</ul>
</blockquote>
</blockquote>
</blockquote>
<h4 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h4><blockquote>
<p><strong>工作原理：</strong>发送端每发送完一个分组就停止发送，等待接收方确认，只有在收到确认后才发送下一个分组。</p>
<p><strong>无差错的情况：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%81%9C%E6%AD%A2-%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE%E6%97%A0%E5%B7%AE%E9%94%99.png" alt="停止-等待协议无差错"></p>
<p><strong>补充：</strong>由于每次只发送一个数据帧，因此用1bit来编号即可。</p>
</blockquote>
<p><strong>有差错的情况：</strong></p>
<blockquote>
<ul>
<li><p><strong>数据帧丢失或检测出错：</strong></p>
<blockquote>
<img src="/picture/学习/计算机网络上的图/数据链路层/停止-等待协议超时.png" alt="停止-等待协议超时" style="zoom: 67%;" />

<p><strong>过程：</strong>发送方有一个<strong>超时计时器</strong>，每发送一个帧就启动一个计时器，当计时器归零的时候还未收到确认，那就将刚刚的数据帧重新发送。</p>
<p><strong>注意：</strong>超时计时器设置的重传时间需要比帧的传输的平均RTT更长一些；发送完一个帧后，必须保留它的副本；数据帧和确认帧必须编号。</p>
</blockquote>
</li>
<li><p><strong>ACK丢失</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%81%9C%E6%AD%A2-%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AEACK%E4%B8%A2%E5%A4%B1.png" alt="停止-等待协议ACK丢失"></p>
<p><strong>过程：</strong>如果出现确认帧丢失，在超时后发送方仍未收到确认帧，那么就会重新发送数据帧；此时接收方收到重复的帧后，<strong>丢弃然后发送确认帧</strong>。</p>
</blockquote>
</li>
<li><p><strong>ACK迟到</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%81%9C%E6%AD%A2-%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AEACK%E8%BF%9F%E5%88%B0.png" alt="停止-等待协议ACK迟到"></p>
<p><strong>过程：</strong>ACK由于某种原因在超过重传计时器的范围后仍未到达，发送端进行超时重传，第二次ACK到达了，然后发送下一个数据帧，此时如果收到已经收到的确认帧，那么就直接丢弃不做处理。</p>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>停止-等待协议性能：</strong>优点是简单，缺点是信道利用率低。</p>
<p><strong>信道利用率：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87.png" alt="信道利用率"><br>$$<br>信道利用率U&#x3D;\frac{T_D}{T_D+RTT+T_A}<br>$$<br>即一个发送周期中，发送数据所需时间的占比。<br>$$<br>信道利用率&#x3D;(L&#x2F;C)&#x2F;T \quad(L为发送的比特长度，C发送方数据传输率，T发送周期)<br>$$</p>
<p>$$<br>信道吞吐率&#x3D;信道利用率*发送方的发送速率<br>$$</p>
<p> <strong>例题：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E4%BE%8B%E9%A2%98.png" alt="例题"></p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="反退N帧协议-GBN"><a href="#反退N帧协议-GBN" class="headerlink" title="反退N帧协议(GBN)"></a>反退N帧协议(GBN)</h4><blockquote>
<p>与停止-等待协议不同，反退N帧协议的发送方有n个发送窗口，因此相较于停止-等待协议，反退N帧协议的信道利用率更高。</p>
<p><strong>协议运行过程：</strong></p>
<blockquote>
<ul>
<li>发送方发送一连串有序的数据帧</li>
<li>接收方逐个接收数据帧，并发回<strong>一个确认帧</strong></li>
<li>发送方根据接受到的确认帧，继续发送确认帧后一位的数据帧</li>
<li>重复上诉步骤</li>
</ul>
</blockquote>
<p><strong>细节：</strong></p>
<blockquote>
<ul>
<li><p><strong>发送方：</strong></p>
<blockquote>
<ul>
<li><strong>上层的调用：</strong>上层要发送数据时，发送方会检测发送窗口是否已满，如果<strong>未满</strong>，则产生一个帧将其发送；如果<strong>窗口已满</strong>，发送方将数据返回给上层，提示上层窗口已满。（实际上发送方可以用缓冲区先缓存这些数据）</li>
<li><strong>收到一个ACK：</strong>在GBN协议中，对n号帧采用<strong>累积确认</strong>的方式，即n号帧的确认帧就可以表明了接收方接收到了n号帧和它之前的所有帧。</li>
<li><strong>超时事件：</strong>对于丢失或者出错的帧，发送方会重传所有已发送但未被确认的帧。</li>
</ul>
</blockquote>
</li>
<li><p><strong>接收方：</strong></p>
<blockquote>
<ul>
<li>如果正确收到n个帧，并且都按序，那么接收方发送一个n号的确认帧，并将数据交付给上层。</li>
<li>接收方中有一个变量expectedseqnum，专门用于存储下一个按序接收的帧的序号；当接收方收到一串失序的帧，那么它会将失序部分丢弃。如，接收方接收到0，1，2，3，5，6，7的帧，那么expectedseqnum就会等于4，并且接收方会丢弃5，6，7号的帧，直到收到4号帧为止。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>GBN协议运作流程例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/GBN%E5%8D%8F%E8%AE%AE%E8%BF%90%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="GBN协议运作流程">、</p>
</blockquote>
<p><strong>GBN协议重点总结：</strong></p>
<blockquote>
<ul>
<li><strong>累计确认</strong></li>
<li><strong>接收方只按顺序接收帧，无序部分将会丢弃</strong></li>
<li><strong>接收方确认序列号最大、且按序到达的帧</strong></li>
<li><strong>发送窗口最大为</strong>$2^n-1$，<strong>接收窗口大小为1</strong>（n为发送端为发送数据进行编码的位数，只要n一确定，那么后面将不会跟着改变）</li>
</ul>
</blockquote>
<p><strong>GBN协议的性能：</strong></p>
<blockquote>
<ul>
<li>提高了信道利用率</li>
<li>在重传时将一部分已经正确传送的帧重传，使得传送效率降低，也浪费了一部分的网络资源。</li>
</ul>
</blockquote>
</blockquote>
<h4 id="选择重传协议-SR"><a href="#选择重传协议-SR" class="headerlink" title="选择重传协议(SR)"></a>选择重传协议(SR)</h4><blockquote>
<p>GBN协议虽然解决了信道利用率较低的问题，但是它会出现过多的重传帧，因此会造成网络传输资源的浪费，为了解决这个问题，后来又提出了选择重传协议。</p>
<p><strong>协议运行过程：</strong></p>
<blockquote>
<ul>
<li>发送方连续发送窗口内的数据帧。</li>
<li>接收方<strong>仅接收属于滑动窗口内的数据帧</strong>。</li>
<li>发送方只有在滑动窗口的下界帧收到了确定后才移动滑动窗口。</li>
<li>接收方只有收到滑动窗口的下届的帧后才移动滑动窗口。</li>
<li>重复以上步骤。</li>
</ul>
</blockquote>
<p><strong>细节部分：</strong></p>
<blockquote>
<ul>
<li><p><strong>发送方：</strong></p>
<blockquote>
<ul>
<li><strong>上层的调用：</strong>从上层接收到待发送的数据后，SR检查滑动窗口是否已满，如果未满，则封装成帧然后发送；否则将数据缓存或者返回给上层。</li>
<li><strong>收到一个ACK</strong>：如果ACK对应帧的序号在窗口内，则将该帧标记为以确认帧，如果该帧时窗口的下界（最左边第一个窗口对应的序号），则窗口向前移动到具有最小序号的未确认帧处（移到窗口的下界是未确认帧处）。</li>
<li><strong>超时事件：</strong> <strong>每一个帧都有属于自己的定时器</strong>，当一个出现一个超时事件后就重传该帧。</li>
</ul>
</blockquote>
</li>
<li><p><strong>接收方：</strong></p>
<blockquote>
<ul>
<li><strong>对于窗口内的帧都来者不拒：</strong>接收方对于一个<strong>正确的帧（不过是否失序）</strong>都进行缓存（所以接收方也有一个缓存），并且接收哪个帧就发回哪个帧的确认帧，直到窗口内所有帧都被接收为止。只有<strong>窗口下界的帧被接收到</strong>了，<strong>窗口才会向后移动</strong>。</li>
<li>如果收到窗口序号外（小于窗口下界）的帧，就丢弃该帧并返回一个ACK。</li>
<li>其他情况就丢弃该帧。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>SR协议运作流程例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/SR%E5%8D%8F%E8%AE%AE%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="SR协议运行流程"></p>
<p>在本例中最终结果是发送端等待2号帧的确认，当收到确认以后，发送方的窗口会往前滑动。</p>
</blockquote>
<h6 id="滑动窗口长度："><a href="#滑动窗口长度：" class="headerlink" title="滑动窗口长度："></a><strong>滑动窗口长度：</strong></h6><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/SR%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%95%BF%E5%BA%A6.png" alt="SR滑动窗口长度"></p>
<p>当滑动窗口大于$2^{n-1}$（n为帧序号的编码位）时，就会出现上面的问题。</p>
<p>所以<strong>滑动窗口最大值不能大于</strong>$2^{n-1}$。</p>
</blockquote>
<p><strong>SR协议的重点总结：</strong></p>
<blockquote>
<ul>
<li><strong>对数据帧逐一确认，接收一个就确认一个</strong>（仅限于滑动窗口内）。</li>
<li><strong>只重传出错的帧</strong>。</li>
<li><strong>滑动窗口最大值不能大于</strong>$2^{n-1}$。</li>
</ul>
</blockquote>
</blockquote>
<h2 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h2><blockquote>
<p><strong>介质访问控制的任务：</strong>为使用介质的每一个结点隔离来自同一信道上其他结点的信号，已协调活动结点的传输，同时又增强数据的传输效率。</p>
<p><strong>分类：</strong></p>
<blockquote>
<ul>
<li><strong>静态划分信道：</strong>信道划分介质访问控制</li>
<li><strong>动态划分信道：</strong>随机访问介质访问控制、轮询访问介质访问控制</li>
</ul>
</blockquote>
<p><strong>各特点：</strong></p>
<blockquote>
<ul>
<li><p><strong>信道划分介质访问控制：</strong>基于<strong>多路复用</strong>技术，不会产生冲突。</p>
<blockquote>
<ul>
<li><strong>网络负载重：</strong>共享信道效率高，且公平</li>
<li><strong>网络负载轻：</strong>共享信道效率低</li>
</ul>
</blockquote>
</li>
<li><p><strong>随机划分介质访问控制：</strong>用户根据意愿<strong>随机</strong>发送信息，发送信息时可以独占信道带宽。</p>
<blockquote>
<ul>
<li><strong>网络负载重：</strong>产生冲突开销，信道效率下降</li>
<li><strong>网络负载轻：</strong>共享信道效率高，单个结点可以利用信道全部的带宽</li>
</ul>
</blockquote>
</li>
<li><p><strong>轮询访问介质访问控制</strong> </p>
<blockquote>
<p>既<strong>不产生冲突</strong>，又可以发送时<strong>占用全部带宽</strong>。</p>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<h3 id="信道划分介质访问控制"><a href="#信道划分介质访问控制" class="headerlink" title="信道划分介质访问控制"></a>信道划分介质访问控制</h3><blockquote>
<p><strong>定义：</strong>将使用介质的每个设备与在同一介质上的其他设备隔离开，把<strong>时域</strong>和<strong>频域</strong>合理地分配给网络上的设备。</p>
<p><strong>分类：</strong> **时分复用(TDM)、频分复用(FDM)、波分复用(WDM)、码分复用(CDM)**。</p>
<p><strong>多路复用：</strong>把多个信号组合在一条物理信道上进行传输，使得多个设备能够<strong>共享信道资源</strong>，提高信道利用率。</p>
</blockquote>
<h4 id="频分多路复用"><a href="#频分多路复用" class="headerlink" title="频分多路复用"></a>频分多路复用</h4><blockquote>
<p><strong>描述：</strong>在物理信道的可用带宽（可用频率）的范围里将物理信道的总带宽划分为若干个子信道的频带。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E9%A2%91%E5%88%86%E5%A4%8D%E7%94%A8.png" alt="频分复用"></p>
<p><strong>注意：</strong>在实际应用中还会在每个子信道之中加入“<strong>保护频带</strong>”，防止各信道之间产生干扰。</p>
<p><strong>优点：</strong>充分利用了传输介质的带宽；系统传输效率较高；技术比较成熟，容易实现。</p>
</blockquote>
<h4 id="时分多路复用"><a href="#时分多路复用" class="headerlink" title="时分多路复用"></a>时分多路复用</h4><blockquote>
<ul>
<li><p><strong>时分多路复用：</strong></p>
<blockquote>
<p> <strong>描述：</strong>将一条物理信道<strong>按时间分成若干时间片</strong>，轮流分配给多个信号使用。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8.png" alt="时分复用"></p>
<p>如果一个介质的传输速率有8Mb&#x2F;s，那么利用时分复用可以使得A、B、C、D每一个用户分到2Mb&#x2F;s的速度。</p>
<p><strong>注意：</strong>这里的帧<strong>并非数据链路层里的帧</strong>，而是物理层里的<strong>比特串</strong>。</p>
</blockquote>
</li>
<li><p><strong>统计时分多路复用：</strong></p>
<blockquote>
<p>不难看出如果B、C、D的传输数据量很低的话，采用固定的时分复用会导致介质传输的效率低下。为此又提出了<strong>统计时分多路复用。</strong></p>
<p><strong>区别：</strong>统计时分多路复用的帧改成按需的<strong>动态分配</strong>。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BB%9F%E8%AE%A1%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8.png" alt="统计时分复用"></p>
<p><strong>每个STDM帧中的时隙数小于连接在集中器上的用户数</strong>。各用户要发送数据时就将数据发往集中器中的<strong>输入缓存</strong>，集中器按顺序依次将数据扫描输入缓存，然后再把缓存的数据放入STDM帧中，当一个STDM帧满了就发出。</p>
<p>因此在统计时分多路复用中，如果介质的传输速率为8Mb&#x2F;s，每一个用户的传输速率<strong>范围变为0Mb&#x2F;s - 8Mb&#x2F;s</strong>。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="波分多路复用"><a href="#波分多路复用" class="headerlink" title="波分多路复用"></a>波分多路复用</h4><blockquote>
<p><strong>定义：</strong>波分多路复用就是光的频分多路复用，指的是在<strong>光纤中传输多种不同波长的光信号</strong>，从而使得各路光信号互不干扰。</p>
</blockquote>
<h4 id="码分多路复用"><a href="#码分多路复用" class="headerlink" title="码分多路复用"></a>码分多路复用</h4><blockquote>
<p> <strong>定义：</strong>码分多路复用是<strong>采用不同编码</strong>来区分各路原始信号的一种复用方式。它<strong>既共享时间，又共享频率</strong>。</p>
<p> <strong>原理：</strong>每个比特时间再划分成m个短的时间槽，称为<strong>码片</strong>，通常m的值为64或128。（下面的例子只是方便起见）</p>
<p> <strong>例子：</strong></p>
<blockquote>
<p>有A、B两个设备共享一条介质信道，A‘、B’分别是这两个设备的接收设备。</p>
<p>现在设A的码片序列为：(-1,-1,-1,+1,+1,-1,+1,+1)为1，(+1,+1,+1,-1,-1,+1,-1,-1)为0；</p>
<p>B的码片序列为：(-1,-1,+1,-1,+1,+1,+1,-1)为1，(+1,+1,-1,+1,-1,-1,-1,+1)为0。</p>
<p>当A发送1，B发送0时，两个向量就到公共信道上叠加，叠加方式是<strong>线性相加</strong>，即<br>$$<br>(-1,-1,-1,+1,+1,-1,+1,+1)+(+1,+1,-1,+1,-1,-1,-1,+1)&#x3D;(0,0,-2,2,0,-2,0,2)<br>$$<br>到达目的地址后，需要进行数据分离，此时只需要将得到的数据与对应接收方的码片进行内积再取平均即可，如A’收到后：<br>$$<br>[(0,0,-2,2,0,-2,0,2)*(-1,-1,-1,+1,+1,-1,+1,+1)]&#x2F;8&#x3D;1<br>$$<br>那么A‘就判定A发送的是1。</p>
</blockquote>
<p> <strong>注意点：</strong></p>
<blockquote>
<ul>
<li>码分复用的本质是利用互不相交的两个码片来代替不同信道上的0，1信号。</li>
<li>虽然码片序列中存在-1和+1，实际上传输的依旧是0，1信号。</li>
<li>码片序列0和1互为<strong>反码</strong>。</li>
<li>码片互不相交的体现：<strong>规格化内积为0</strong>（又称相互正交）。即如同$[(-1,-1,-1,+1,+1,-1,+1,+1)*(-1,-1,+1,-1,+1,+1,+1,-1)]&#x2F;8&#x3D;0$</li>
<li>在接收方分离信号的时候，得出的结果实际意义是：<strong>该信号是否与解码用的码片相同</strong>。如在上例中，A’如果用的是(+1,+1,+1,-1,-1,+1,-1,-1)来解码，那么得到的结果就为-1，就表示收到的信号不是0。</li>
<li>如果分离出的结果不是+1，也不是-1，那么代表叠加信号中没有要本设备接收的信号。</li>
</ul>
</blockquote>
</blockquote>
<h3 id="随机访问介质访问控制"><a href="#随机访问介质访问控制" class="headerlink" title="随机访问介质访问控制"></a>随机访问介质访问控制</h3><blockquote>
<p><strong>定义：</strong>不采用集中控制方式解决发送信息的次序问题，所有用户根据自身情况随机发送信息，占用介质的全部速率。</p>
<p><strong>实现特点：</strong>当两个或多个用户发生碰撞时，每个用户按照一定<strong>规则（协议）</strong>来重复重传帧，直到帧无碰撞通过。</p>
<p><strong>常用协议：</strong>ALOHA协议、CSMA协议、CSMA&#x2F;CD协议、CSMA&#x2F;CA协议</p>
</blockquote>
<h4 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h4><blockquote>
<p><strong>基本思想：</strong>不监听信道，各用户随时发送信息。</p>
<p>ALOHA协议又分<strong>纯ALOHA协议</strong>与<strong>时隙ALOHA协议</strong>。</p>
<ul>
<li><p><strong>纯ALOHA协议</strong>：</p>
<blockquote>
<p><strong>协议步骤：</strong></p>
<ul>
<li><p>每个用户需要发送数据时直接发送，然后等待接收方的确认帧。</p>
</li>
<li><p>当发生碰撞的时候不做处理，接收方收到发生碰撞的帧<strong>自动丢弃</strong>。</p>
</li>
<li><p>发送方计时器超时后<strong>随机找一个时间重发数据</strong>。</p>
</li>
</ul>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/ALOHA%E5%8D%8F%E8%AE%AE.png" alt="ALOHA协议"></p>
</blockquote>
</li>
<li><p><strong>时隙ALOHA协议：</strong></p>
<blockquote>
<p>由于纯ALOHA协议的随意性，会导致信道多处发生碰撞，使得信息传输效率下降。</p>
<p><strong>特点：</strong>时隙ALOHA协议的特点是<strong>将时间划分为一段段等长的时隙，规定只有在每一个时隙开始时才能发送一个帧。</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%97%B6%E9%9A%99ALOHA%E5%8D%8F%E8%AE%AE.png" alt="时隙ALOHA协议"></p>
<p>时隙ALOHA协议相较于纯ALOHA协议来说随机性更低了，因此使得信息传输效率更高了。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="CSMA协议"><a href="#CSMA协议" class="headerlink" title="CSMA协议"></a>CSMA协议</h4><blockquote>
<p>CSMA协议全称为<strong>载波监听多路访问协议</strong>。</p>
<p><strong>基本思想：</strong>每个站点在发送数据前都先监听一下共用信道，发现信道为空之后再发送数据。</p>
<p>根据监听方式和监听到信道繁忙后的处理方式不同可以将CSMA协议分成三类：<strong>1-坚持CSMA、非坚持CSMA</strong>和<strong>p-坚持CSMA</strong>。</p>
<p><strong>监听方式：</strong>检测信道上的电信号是否超过阈值。</p>
<ul>
<li><p><strong>1-坚持CSMA</strong></p>
<blockquote>
<p><strong>思想：</strong></p>
<blockquote>
<ul>
<li>一个结点要发送数据时，首先监听信道；</li>
<li>如果信道空闲，则立即发送数据；</li>
<li>如果信道繁忙，则<strong>继续</strong>监听信道，直到信道空闲；</li>
<li>如果发生冲突，那么<strong>随机等待一段时间后再重新开始监听信道</strong>，重复上诉步骤。</li>
</ul>
</blockquote>
<p><strong>1-坚持的意义：</strong>在信道繁忙的时候坚持监听信道。</p>
<p><strong>缺点：</strong>如果有两个结点都想发送数据的时候，它们一定会发生碰撞。</p>
</blockquote>
</li>
<li><p><strong>非坚持CSMA</strong></p>
<blockquote>
<p><strong>思想：</strong></p>
<blockquote>
<ul>
<li>一个结点要发送数据时，首先监听信道；</li>
<li>如果信道空闲，则立即发送数据；</li>
<li>如果信道繁忙，则<strong>放弃监听</strong>，等待一个随机的时间再重复上诉步骤。</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>p-坚持CSMA</strong></p>
<blockquote>
<p><strong>思想：</strong></p>
<blockquote>
<ul>
<li>一个结点要发送数据时，首先监听信道；</li>
<li>如果信道空闲，则以p的概率发送数据，以1-p的概率推迟到下一个时隙；</li>
<li>如果信道繁忙，则<strong>继续</strong>监听信道，直到信道空闲；</li>
</ul>
</blockquote>
</blockquote>
</li>
</ul>
<p><strong>三种CSMA协议的对比：</strong></p>
<blockquote>
<table>
<thead>
<tr>
<th>信道状态</th>
<th>1-坚持</th>
<th>非坚持</th>
<th>p-坚持</th>
</tr>
</thead>
<tbody><tr>
<td>空闲</td>
<td>立即发送数据</td>
<td>立即发送数据</td>
<td>以p概率发送数据，以1-p的概率推迟到下一时隙</td>
</tr>
<tr>
<td>繁忙</td>
<td>继续坚持监听</td>
<td>放弃监听，等待一个随机时间再监听</td>
<td>继续监听</td>
</tr>
</tbody></table>
</blockquote>
</blockquote>
<h4 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA&#x2F;CD协议"></a>CSMA&#x2F;CD协议</h4><blockquote>
<p><strong>全称：载波监听多点接入&#x2F;碰撞检测协议</strong>，其中各部分为：</p>
<blockquote>
<ul>
<li><strong>CS：</strong>载波监听，即每一个站<strong>在发数据之前</strong>以及<strong>发数据时</strong>都检测一下总线上是否有其他计算机在发送数据。</li>
<li><strong>MA：</strong>多点接入，表示许多计算机以多点接入的方式连接在一根总线上。（总线型网络）</li>
<li><strong>CD：</strong>碰撞检测（冲突检测），“<strong>边发送边监听</strong>”，适配器边发送数据变检测信道上信号电压的变化情况。（半双工网络）</li>
</ul>
</blockquote>
<p><strong>基本思想：</strong>在发送前先监听，如果信道有信号则停止不发送，等到信道空闲以后再发送。在发送的时候继续监听，一检测到碰撞就停止发送。总结就是：<strong>先听后发，边听边发，冲突停止，随机重发</strong>。</p>
<p><strong>只先监听后发送也会发生碰撞的原因（CSMA的缺点）：</strong></p>
<blockquote>
<p>由于传输信道会有传播时延，所以有可能出现A发出信息还没到B端，B端监听发现没有信号，所以B端也发送信息，这时就会出现碰撞。</p>
</blockquote>
<p> <strong>传播时延对载波监听的影响：</strong></p>
<blockquote>
<img src="/picture/学习/计算机网络上的图/数据链路层/碰撞分析.png" alt="碰撞分析"  />

<p>通过图可知，这个传播信道中最长需要<strong>两倍端到端传播时延</strong>（$2\tau$）的时间才知道是否发生碰撞。（也称冲突窗口&#x2F;碰撞窗口&#x2F;争用期）</p>
<p>因此可得，<strong>当两倍端到端传播时延后没检测到碰撞，那么就知道没有发生碰撞</strong>。</p>
</blockquote>
<p><strong>确定重传时机：</strong></p>
<blockquote>
<p>利用<strong>截断二进制指数规避算法</strong>来确定：</p>
<blockquote>
<ul>
<li>确定基本退避（推迟）时间争用期$2\tau$</li>
<li>确定参数k（<strong>重传次数</strong>），但k不超过10，当重传次数不超过10时，k等于重传次数；当k超过10时就一直等于10。</li>
<li>从离散的整数集合$[0,1,…,2^k-1]$中随机取出一个数r，重传所需的退避时间就是<strong>r倍的基本退避时间，</strong>即$2r\tau$</li>
<li>当重传达到<strong>16次</strong>仍不成功，那说明网络太拥挤，抛弃此帧并向高层报告出错。</li>
</ul>
</blockquote>
</blockquote>
<p><strong>最小帧长问题：</strong></p>
<blockquote>
<p>A发送一个帧，如果在发生碰撞时，这个帧太小，就直接发送出去了。为了解决这个问题就需要定义最小帧长。</p>
<p>为此帧的<strong>传输时延</strong>至少要大于两倍的传播时延（$2\tau$），即$\frac{帧长（bit）}{数据传输速率} \ge 2\tau$，所以有，</p>
<p><strong>最小帧长</strong>&#x3D;<strong>总线传输时延</strong> * <strong>数据传输速率</strong> * 2</p>
</blockquote>
</blockquote>
<h4 id="CSMA-CA协议"><a href="#CSMA-CA协议" class="headerlink" title="CSMA&#x2F;CA协议"></a>CSMA&#x2F;CA协议</h4><blockquote>
<p>CSMA&#x2F;CD协议多用于<strong>总线型的有线</strong>局域网，而对于无线的局域网，CSMA&#x2F;CD协议并不容易实现。</p>
<p>因此对于无线的局域网，CSMA将碰撞检测改成了碰撞避免，所以就出现了CSMA&#x2F;CA。</p>
<p><strong>基本思路：</strong></p>
<blockquote>
<ul>
<li>发送数据前，先检测信道是否空闲。</li>
<li>空闲则发出<strong>RTS</strong>，RTS包括发送端的地址、接收端的地址、下一份数据将持续发送的时间等信息。</li>
<li>信道繁忙则等待。</li>
<li>接收端收到RTS后，将响应<strong>CTS</strong>。</li>
<li>发送端接收到CTS后，开始发送数据（同时<strong>预约信道</strong>，即发送方告知其他站点自己要占用多长时间）</li>
<li>接收端接收到数据后进行<strong>CRC检错</strong>，如无误则回复ACK。</li>
<li>发送端收到ACK就继续发送下一个数据帧，若没有则<strong>采用二进制指数退避算法（详看CSMA&#x2F;CD）来界定推迟重传的时间（也是有重传次数上限的）。</strong></li>
</ul>
</blockquote>
<p><strong>注意：</strong>接收方收到RTS后将不再接收除发送RTS的结点外的其他数据；其他结点没收到CTS也不会发送数据。</p>
<p><strong>与CSMA&#x2F;CD的区别：</strong></p>
<blockquote>
<ul>
<li><strong>传输介质不同：</strong>CSMA&#x2F;CD用于总线型以太网（有线），而CSMA&#x2F;CA用于无线局域网（无线）。</li>
<li><strong>载波检测方式不同：</strong>CSMA&#x2F;CD基于电压的起伏来检测，CSMA&#x2F;CA基于能量来检测。</li>
<li><strong>CSMA&#x2F;CD侧重于检测冲突，CSMA&#x2F;CA侧重于避免冲突</strong></li>
</ul>
</blockquote>
</blockquote>
<h3 id="轮询访问介质访问控制"><a href="#轮询访问介质访问控制" class="headerlink" title="轮询访问介质访问控制"></a>轮询访问介质访问控制</h3><blockquote>
<p><strong>轮询协议：</strong></p>
<blockquote>
<p><strong>思路：</strong>在网络中有一台主机作为控制主机，该主机<strong>按一定顺序询问网络中其他主机是否发送数据</strong>。只有<strong>收到询问帧</strong>的主机才能发送数据。</p>
</blockquote>
<p><strong>令牌传递协议：</strong></p>
<blockquote>
<p><strong>思路：</strong>一个令牌在各节点之间以某个<strong>固定次序</strong>进行交换（令牌是一组特殊的比特而组成的帧）。当环上的一个站想要传输帧的时候，必须等待令牌。只有收到令牌以后才可以启动发送帧。</p>
<p><strong>使用过程：</strong>当某一结点需要发送数据帧的时候，会先将令牌设置为占用的状态，然后再发送数据，这个时候其他结点在接收到数据帧后如果不是给自己的都转发出去，直到找到目的结点。目的结点收到数据帧后会复制一份，然后让原数据帧传回原节点。原节点收到循环一圈的数据帧后查看数据帧是否出错，如果出错就进行重传。</p>
<p><strong>注意：</strong>令牌传递协议中每个节点持有令牌的时间都是有限的，如果时间用完则需要将令牌交给下一个节点。 </p>
</blockquote>
<p><strong>特点：</strong>轮询访问介质访问控制<strong>适合用于负载较高的信道</strong>。</p>
</blockquote>
<h2 id="广域网："><a href="#广域网：" class="headerlink" title="广域网："></a>广域网：</h2><h3 id="广域网的定义"><a href="#广域网的定义" class="headerlink" title="广域网的定义"></a>广域网的定义</h3><blockquote>
<p><strong>定义：</strong>通常跨界很大的物理范围，覆盖范围从几十公里到几千公里。可以连接多个城市或国家，甚至横跨几个洲并能提供远距离通信，形成国际性的远程网络。</p>
<p><strong>特点：</strong>广域网的通信子网主要使用<strong>分组交换</strong>技术，该通信子网利用各类公用交换网将分布在<strong>不同地区的局域网或计算机系统</strong>互连起来，实现<strong>资源共享</strong>的目的。（因特网是世界范围内最大的广域网）</p>
<p><strong>广域网结构图：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%B9%BF%E5%9F%9F%E7%BD%91%E7%BB%93%E6%9E%84.png" alt="广域网结构"></p>
</blockquote>
<h3 id="PPP协议特点"><a href="#PPP协议特点" class="headerlink" title="PPP协议特点"></a>PPP协议特点</h3><blockquote>
<p><strong>特点：</strong>PPP协议又称<strong>点对点协议</strong>（Point-to-Point），是目前使用最广泛的链路层协议。在用户计算机和ISP进行通信时所使用的数据链路层协议。（<strong>PPP协议只支持全双工链路</strong>）</p>
<p><strong>PPP协议需满足的要求：</strong></p>
<blockquote>
<ul>
<li><strong>简单：</strong>对于链路层的帧，无需纠错（<strong>但需要检错</strong>），无须序号，无需流量控制。</li>
<li><strong>封装成帧：</strong>规定帧定界符。</li>
<li><strong>透明传输：</strong>数据部分出现与帧定界符一致的比特组合应如何处理：<strong>异步线路用字节填充，同步线路用比特填充</strong>。</li>
<li><strong>多类型网络层协议：</strong>在同一条物理链路上需要同时支持多种网络层协议。</li>
<li><strong>多类型链路：</strong>支持多种类型的链路。如，串行&#x2F;并行链路，同步&#x2F;异步的链路，电信号&#x2F;光信号的链路等等。</li>
<li><strong>差错检测：</strong>检测到错误的帧立即丢弃。</li>
<li><strong>检测连接状态：</strong>及时自动检测链路是否正常工作。</li>
<li><strong>最大传送单元：</strong>规定数据部分最大长度MTU。</li>
<li><strong>网络层地址协商：</strong>通过某种机制知道通信双方网络层的地址（如IP地址）。</li>
<li><strong>数据压缩协商：</strong>提供一种方法来协商使用一种数据压缩的算法。</li>
</ul>
</blockquote>
<p><strong>PPP协议无需满足的要求：</strong></p>
<blockquote>
<ul>
<li><strong>纠错</strong></li>
<li><strong>流量控制</strong></li>
<li><strong>序号：</strong>无需对帧进行编号</li>
<li><strong>无需支持多点线路：</strong>直须满足点对点的线路即可。</li>
</ul>
</blockquote>
</blockquote>
<h3 id="PPP协议的组成"><a href="#PPP协议的组成" class="headerlink" title="PPP协议的组成"></a>PPP协议的组成</h3><blockquote>
<ul>
<li><strong>将IP数据报封装到串行链路（同步串行&#x2F;异步串行）的方法</strong></li>
<li><strong>链路控制协议：</strong>建立并维护数据链路连接（实际上就是进行身份验证）</li>
<li><strong>网络控制协议NCP：</strong>PPP支持多种网络层的协议，每一种协议都需要相应的NCP来配置，为网络层协议建立与配置<strong>逻辑连接</strong>。</li>
</ul>
<p><strong>PPP协议的状态图：</strong></p>
<blockquote>
<img src="/picture/学习/计算机网络上的图/数据链路层/PPP协议的状态图.png" alt="PPP协议的状态图" style="zoom:60%;" />
</blockquote>
<p><strong>PPP协议的帧格式：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/PPP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" alt="PPP协议的帧格式"></p>
<p><strong>注释：</strong></p>
<ul>
<li><p>F部分为标志字段也是<strong>帧定界符</strong>。</p>
</li>
<li><p>A为地址字段，C为控制字段，但这两个到目前为止并无实际意义。</p>
</li>
<li><p>协议用来表示信息部分是什么（也可以理解为解释这一个帧是做什么的）。</p>
</li>
<li><p>FCS是CRC的帧检验序列。</p>
</li>
</ul>
<p><strong>补充：</strong>由PPP协议的帧格式可以看出，PPP协议面向的是<strong>字节传输</strong>的数据链路层协议。</p>
</blockquote>
</blockquote>
<h3 id="HDLC协议"><a href="#HDLC协议" class="headerlink" title="HDLC协议"></a>HDLC协议</h3><blockquote>
<p><strong>介绍：</strong>HDLC协议全称<strong>高级数据链路控制</strong>，该协议是ISO的面向<strong>比特</strong>的数据链路层协议（<strong>PPP协议是面向字节的</strong>）</p>
<p><strong>特点：</strong></p>
<blockquote>
<ul>
<li>数据报文使用<strong>0比特填充</strong>实现<strong>透明传输</strong></li>
<li><strong>全双工通信</strong></li>
<li>所有帧<strong>采用CRC检验</strong></li>
<li>传输控制功能与处理功能分离</li>
</ul>
</blockquote>
<p>HDLC适用于链路的两种基本配置：<strong>非平衡配置</strong>和<strong>平衡配置</strong></p>
<blockquote>
<ul>
<li><strong>非平衡配置</strong>：特点是<strong>由一个主站控制整个链路的工作</strong></li>
<li><strong>平衡配置</strong>：特点是两个站都是复合站，每个复合站都可以<strong>平等地发起数据传输</strong>，而不需要得到对方复合站的允许</li>
</ul>
</blockquote>
<p><strong>HDLC站的种类</strong>：</p>
<blockquote>
<ul>
<li><strong>主站：</strong>负责控制链路的操作，主站发出的帧称为<strong>命令帧</strong>。</li>
<li><strong>从站：</strong>受控于主站，按主站的命令进行操作，从站发出的帧称为<strong>响应帧</strong>。</li>
<li><strong>复合站：</strong>既具有主站的功能，又具有从站的功能，复合站可以发出命令帧和响应帧。</li>
</ul>
</blockquote>
<p><strong>数据操作方式：</strong></p>
<blockquote>
<ul>
<li><strong>正常响应方式：</strong>是一种非平衡结构操作方式，主站向从站传输数据，从站只有在得到主站的许可后才进行响应。</li>
<li><strong>异步平衡方式：</strong>是一种平衡结构操作方式，每个复合站都可以进行对另一个站的数据传输。</li>
<li><strong>异步响应方式：</strong>是一种非平衡结构操作方式，从站即使未受到主站的允许，也可以进行传输。</li>
</ul>
</blockquote>
<p><strong>HDLC帧：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/HDLC%E5%B8%A7%E5%8D%8F%E8%AE%AE.png" alt="HDLC帧协议"></p>
<ul>
<li><p><strong>标志F：</strong>为01111110，用于确认HDLC帧的开头与结束，利用0比特填充来进行透明传输。</p>
</li>
<li><p><strong>地址A：</strong>使用<strong>非平衡方式</strong>传输数据的时候，地址A写入的是<strong>从站</strong>的地址；在<strong>平衡方式</strong>传输数据时，地址A填入<strong>应答站</strong>的地址</p>
</li>
<li><p><strong>控制C：</strong>根据第1位，或第1，2位的取值，可以将HDLC帧分成三类：</p>
<blockquote>
<ul>
<li><strong>信息帧：</strong>第1位为0，用于<strong>传输数据信息</strong>，或使用捎带技术<strong>对数据进行确认</strong>。</li>
<li><strong>监督帧：</strong>第1、2位分别为1、0，用于<strong>流量控制</strong>和<strong>差错控制</strong>，执行<strong>对信息帧的确认，请求重发</strong>和<strong>请求暂停发送</strong>等功能。</li>
<li><strong>无编号帧：</strong>第1、2位都为1，用于对<strong>链路的建立、拆除</strong>等功能。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>与PPP协议帧的区别：</strong></p>
<blockquote>
<ul>
<li>PPP协议是面向字节的，HDLC协议是面向比特的。</li>
<li>PPP帧比HDLC帧多一个2字节的协议字段。</li>
<li>PPP协议不使用序号和确认机制，<strong>只确保无差错接收（CRC检验）</strong>，HDLC协议的信息帧使用编号和确认机制，能够提供可靠传输。</li>
</ul>
</blockquote>
</blockquote>
<h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><blockquote>
<p><strong>定义：</strong>局域网，简称LAN(Local Area Network)，指在<strong>某一区域内</strong>由多台计算机互联成的计算机组，使用<strong>广播信道</strong>。</p>
<p><strong>分类：</strong> <strong>以太网</strong>、令牌环网、FDDI网、ATM网和<strong>无线局域网</strong>。</p>
<p><strong>特点：</strong></p>
<blockquote>
<ul>
<li><strong>覆盖的地理范围较小。</strong></li>
<li>使用<strong>专门铺设的传输介质进行联网，数据传输速率高</strong>（10Mb&#x2F;s~10Gb&#x2F;s）。</li>
<li><strong>通信延迟时间短，误码率低，可靠性强。</strong></li>
<li>各站平等，<strong>共享传输信道</strong>。</li>
<li>多采用分布式控制和广播式通信，能进行<strong>广播</strong>和<strong>组播</strong>。</li>
</ul>
</blockquote>
<p><strong>决定局域网的主要要素：</strong> <strong>网络拓扑</strong>、<strong>传输介质</strong>和<strong>介质访问控制方法</strong>。</p>
</blockquote>
<h3 id="局域网的拓扑结构"><a href="#局域网的拓扑结构" class="headerlink" title="局域网的拓扑结构"></a>局域网的拓扑结构</h3><blockquote>
<ul>
<li><p><strong>星型拓扑：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%98%9F%E5%9E%8B%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84.png" alt="星型拓扑结构"></p>
<p><strong>特点：</strong>中心结点是控制中心，任意两个结点间的通信最多只需<strong>两步</strong>，传输速度快，且网络结构简单、建网容易、便于控制与管理。但可靠性低，网络共享能力差。</p>
</blockquote>
</li>
<li><p><strong>总线型拓扑：</strong></p>
<blockquote>
<p><img src="/../%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%80%BB%E7%BA%BF%E5%9E%8B%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84.png" alt="总线型拓扑结构"></p>
<p><strong>特点：</strong>网络可靠性高、网络结点间响应速度快、网络共享能力强、设备投入量少，接入简单。当某个节点出现问题，对整个网络系统影响小。</p>
</blockquote>
</li>
<li><p><strong>环型拓扑：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%8E%AF%E5%9E%8B%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84.png" alt="环型拓扑结构"></p>
<p><strong>特点：</strong>系统中通信设备和线路比较节省，有<strong>单点故障问题</strong>，即不便于扩充，系统响应时间长，中间某节点出现问题，对网络系统影响大。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="局域网介质访问控制方法"><a href="#局域网介质访问控制方法" class="headerlink" title="局域网介质访问控制方法"></a>局域网介质访问控制方法</h3><blockquote>
<ul>
<li><strong>CSMA&#x2F;CD：</strong>常用于<strong>总线型局域网</strong>，也用于树型网络。</li>
<li><strong>令牌总线：</strong>常用于<strong>总线型局域网</strong>。它把总线型网络中的各个工作站按一定顺序形成一个逻辑环。只有令牌持有者才能控制总线，才能发送信息。</li>
<li><strong>令牌环：</strong>用于环型局域网。</li>
</ul>
</blockquote>
<h3 id="局域网中数据链路的两个子层"><a href="#局域网中数据链路的两个子层" class="headerlink" title="局域网中数据链路的两个子层"></a>局域网中数据链路的两个子层</h3><blockquote>
<p>IEEE802委员会把局域网数据链路层拆分为两个子层：<strong>逻辑链路控制LLC</strong>子层和<strong>媒体接入控制MAC</strong>子层。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%AD%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%AD%90%E5%B1%82.png" alt="局域网中的两个子层"></p>
<ul>
<li><p><strong>逻辑链路控制LLC：</strong></p>
<blockquote>
<p>负责识别网络层协议，然后对它们进行封装。LLC报头告诉数据链路层一旦帧被接收到，应该对数据包做什么处理。</p>
</blockquote>
</li>
<li><p><strong>媒体接入控制MAC：</strong></p>
<blockquote>
<p>主要功能包括数据帧的封装&#x2F;拆卸，帧的寻址和识别，帧的接收和发送，链路的管理，帧的差错控制等。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><blockquote>
<p>以太网是当今现有局域网采用最通用的通信协议标准，是一种<strong>基带总线局域网规范</strong>。以太网使用<strong>CSMA&#x2F;CD技术</strong>。</p>
<p><strong>以太网两个标准：</strong></p>
<blockquote>
<ul>
<li><strong>DIX Ethernet V2：</strong>第一个局域网产品（以太网）规约。</li>
<li><strong>IEEE 802.3：</strong>第一个IEEE的以太网标准。</li>
</ul>
</blockquote>
<p><strong>以太网提供无连接、不可靠的服务：</strong></p>
<blockquote>
<ul>
<li><strong>无连接：</strong>发送方与接收方之间无“握手过程”。</li>
<li><strong>不可靠：</strong>不对发送方的数据帧编号，接收方不向发送方进行确认，差错帧直接丢弃不进行纠错。</li>
</ul>
</blockquote>
<p><strong>以太网的拓扑结构：</strong>逻辑上总线型，物理上星型。</p>
<p><strong>10BASE-T 以太网：</strong></p>
<blockquote>
<p><strong>定义：</strong>是传输<strong>基带信号</strong>的双绞线以太网，T表示采用双绞线，现10BASE-T采用<strong>无屏蔽双绞线</strong>，<strong>传输速率是10Mb&#x2F;s</strong>。</p>
<p><strong>特点：</strong></p>
<blockquote>
<ul>
<li><strong>物理上采用星型拓扑，逻辑上为总线型</strong>，每段双绞线最长为<strong>100m</strong>。</li>
<li>采用<strong>曼彻斯特编码</strong>。</li>
<li>采用<strong>CSMA&#x2F;CD</strong>介质访问控制。</li>
</ul>
</blockquote>
</blockquote>
<p><strong>适配器与MAC地址</strong></p>
<blockquote>
<p><strong>适配器：</strong>计算机与外界局域网的连接需要<strong>通信适配器</strong>。</p>
<img src="/picture/学习/计算机网络上的图/数据链路层/网卡.png" alt="网卡" style="zoom:60%;" />

<p><strong>特点：</strong>适配器上有独立的处理器和存储器（包括RAM和ROM）。在ROM上有计算机硬件地址<strong>MAC地址</strong>。</p>
<p>在局域网中，硬件地址又称<strong>物理地址</strong>，或<strong>MAC地址</strong>。</p>
<p><strong>MAC地址：</strong>每个适配器有一个<strong>全球唯一</strong>的48位二进制地址，其中前24位代表厂家（由IEEE规定），后24位厂家自己指定。常用6个十六进制数表示，如：02-60-8c-e4-b1-21</p>
</blockquote>
<p><strong>以太网MAC帧</strong></p>
<blockquote>
<p>最常用的MAC帧是以太网V2的格式（使用以太网第一个标准）。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/MAC%E5%B8%A7.png" alt="MAC帧"></p>
<ul>
<li><p><strong>目的地址：</strong>包括<strong>单播地址（单播帧）</strong>即在本局域网中进行一对一通信站点的MAC地址、<strong>广播地址（广播帧）</strong>即发送给本局域网上所有站点且地址为全1、<strong>多播地址（多播帧）</strong>即发送给本局域网中多个站点的地址。</p>
</li>
<li><p><strong>源地址：</strong>发送端的MAC地址。</p>
</li>
<li><p><strong>类型：</strong>表示网络层所使用的协议。</p>
</li>
<li><p><strong>数据：</strong>数据部分，以太网最小帧的长度是64字节，因此这里的数据最小值为46字节。</p>
</li>
<li><p><strong>FCS：</strong>CRC验证的冗余码。</p>
</li>
</ul>
<p><strong>补充：</strong>MAC帧没有帧结束定界符是因为曼彻斯特编码特点是一个时钟周期中有两种电信号，如果帧发送结束后，一个时钟周期内只有一种电信号，因此没有必要加上帧的结束定界符。</p>
<p><strong>与IEEE 802.3标准下的MAC帧的区别：</strong></p>
<blockquote>
<ul>
<li>IEEE 802.3标准下的MAC帧中第三个字段是<strong>长度&#x2F;类型</strong>。</li>
<li>当长度&#x2F;类型字段值小于0x 0600时，数据字段必须装入LLC子层。</li>
</ul>
</blockquote>
</blockquote>
<p><strong>高速以太网</strong></p>
<blockquote>
<p><strong>定义：</strong>速率大于100Mb&#x2F;s的以太网称为高速以太网。</p>
<p><strong>种类：</strong></p>
<ul>
<li><strong>100BASE-T以太网：</strong>在<strong>双绞线</strong>上传输<strong>100Mb&#x2F;s基带信号</strong>的<strong>星型</strong>拓扑以太网，使用<strong>CSMA&#x2F;CD协议</strong>，支持<strong>全双工</strong>和<strong>半双工</strong>。</li>
<li><strong>吉比特以太网：</strong>在<strong>光纤</strong>或<strong>双绞线</strong>上传输<strong>1Gb&#x2F;s信号</strong>。支持<strong>全双工</strong>和<strong>半双工</strong>。</li>
<li><strong>10吉比特以太网：</strong>在<strong>光纤</strong>上传输<strong>10Gb&#x2F;s信号</strong>。只支持<strong>全双工</strong>。</li>
</ul>
</blockquote>
</blockquote>
<h3 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h3><blockquote>
<p><strong>IEEE 802.11标准：</strong>是<strong>无线局域网</strong>通用的标准，它有多个衍生标准都是对无线局域网的规定。</p>
<p><strong>MAC帧头格式：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/MAC%E5%B8%A7%E5%A4%B4%E6%A0%BC%E5%BC%8F.png" alt="MAC帧头格式"></p>
<ul>
<li><strong>DA：</strong>实际通信设备<strong>接收端</strong>的MAC地址。</li>
<li><strong>SA：</strong>实际通信设备<strong>发送端</strong>的MAC地址。</li>
<li><strong>RA：</strong>通信过程中<strong>离接收端最近的基站</strong>的MAC地址。</li>
<li><strong>TA：</strong>通信过程中<strong>离发送端最近的基站</strong>的MAC地址。**</li>
</ul>
</blockquote>
<p><strong>其他的帧头格式：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%85%B6%E4%BB%96MAC%E5%B8%A7%E5%A4%B4%E6%A0%BC%E5%BC%8F.png" alt="其他MAC帧头格式"></p>
<p><strong>注意：</strong>图中AP代表基站。BSSID表示基站的MAC地址。</p>
</blockquote>
<p><strong>无线局域网的类型：</strong></p>
<ul>
<li><p><strong>有固定基础设施无线局域网</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%9C%89%E5%9B%BA%E5%AE%9A%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91.png" alt="有固定基础设施无线局域网"></p>
<p><strong>漫游：</strong>指一个设备可以联系到另一个基站内的设备（长途电话）。</p>
</blockquote>
</li>
<li><p><strong>无固定基础设施无线局域网的自组织网络</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%97%A0%E5%9B%BA%E5%AE%9A%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9A%84%E8%87%AA%E7%BB%84%E7%BB%87%E7%BD%91%E7%BB%9C.png" alt="无固定基础设施无线局域网的自组织网络"></p>
<p>该网络中只有主机，没有转发设备，也没有集线器，每一台主机都是平等的。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="拓展的以太网"><a href="#拓展的以太网" class="headerlink" title="拓展的以太网"></a>拓展的以太网</h2><h3 id="物理层拓展以太网"><a href="#物理层拓展以太网" class="headerlink" title="物理层拓展以太网"></a>物理层拓展以太网</h3><blockquote>
<p>已知传统的以太网的覆盖距离都非常短，否则主机之间的通信信号会衰弱到CSMA&#x2F;CD协议都无法识别。以此提出了对以太网进行拓展的想法。</p>
<ul>
<li><p>第一种想法就是利用光纤对以太网进行拓展。</p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%8B%93%E5%B1%95%E4%BB%A5%E5%A4%AA%E7%BD%911.png" alt="拓展以太网1"></p>
<p>其中光纤调制器就是将光信号和电信号进行相互转换。</p>
</blockquote>
</li>
<li><p>第二种就是使用多个集线器对以太网进行连接。</p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%8B%93%E5%B1%95%E4%BB%A5%E5%A4%AA%E7%BD%912.png" alt="拓展以太网2"><br>不过也会导致通信效率降低，如在主干集线器中发生冲突的概率也会增大，当一台主机在发送数据时，其他主机如果也发送就会导致冲突的发生。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="链路层拓展以太网"><a href="#链路层拓展以太网" class="headerlink" title="链路层拓展以太网"></a>链路层拓展以太网</h3><blockquote>
<p><strong>网桥：</strong>对收到的帧根据其MAC的目的地址进行<strong>转发</strong>和<strong>过滤</strong>。当网桥收到一个帧时，并不会向所有接口转发，而是根据转发表确定该帧转发到哪一个接口，或者把它丢弃（即过滤）。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BD%91%E6%A1%A5.png" alt="网桥"><br><strong>网桥的优点：</strong></p>
<blockquote>
<ul>
<li>过滤通信量，增发吞吐量</li>
<li>扩大了物理传输范围。</li>
<li>提高了整体网络的可靠性。</li>
<li>可互连不同物理层、不同MAC子层和不同速率的以太网。</li>
</ul>
</blockquote>
<p><strong>网桥分类：</strong></p>
<blockquote>
<ul>
<li><strong>透明网桥：</strong>指以太网上的站点并不知道所发送的帧要经过哪几个网桥，是一种即插即用的设备。（网桥中的转发表一开始是空的，需要通过自学习的方式逐步丰富转发表）</li>
<li><strong>源路由网桥：</strong>在发送帧时，把详细的最佳路由信息（路由最少&#x2F;时间最短）放到帧的首部。</li>
</ul>
</blockquote>
<p><strong>交换机（多接口网桥）：</strong></p>
<blockquote>
<p>网桥的升级版，网桥一般只有少数的转发接口。交换机通常有十几个甚至更多的接口。</p>
<p>交换机相较于网桥来说能使多对主机同时通信，相互通信的主机都是<strong>独占传输媒体，无碰撞地传输数据</strong>。</p>
</blockquote>
<p><strong>交换机原理：</strong>检测从以太端口来的数据帧的源和目的地址的MAC地址，然后与系统内部的动态查找表进行比较，若数据帧的源MAC地址不在查找表中，则将该地址加入查找表，并将数据帧发送给相应的目的端口。</p>
<p><strong>交换机的种类：</strong></p>
<blockquote>
<ul>
<li><strong>直通式交换机：</strong>查看完目的地址就立刻转发。特点是延迟小，可靠性低。</li>
<li><strong>存储转发式交换机：</strong>将帧放入高速缓存，检测是否正确。特点式可靠高，但延迟也高。</li>
</ul>
</blockquote>
</blockquote>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">数据链路层的功能：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.1.</span> <span class="toc-text">为网络层提供服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">链路管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.</span> <span class="toc-text">数据链路层的基本问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%EF%BC%88%E7%BB%84%EF%BC%89%E8%A3%85%E6%88%90%E5%B8%A7"><span class="toc-number">1.3.1.</span> <span class="toc-text">封（组）装成帧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93"><span class="toc-number">1.3.2.</span> <span class="toc-text">透明传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B"><span class="toc-number">1.3.3.</span> <span class="toc-text">差错检测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E9%94%99%E7%BC%96%E7%A0%81"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">检错编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A0%E9%94%99%E7%BC%96%E7%A0%81"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">纠错编码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.</span> <span class="toc-text">流量控制与可靠传输机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.1.</span> <span class="toc-text">可靠传输机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">1.4.2.</span> <span class="toc-text">流量控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2-%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">停止-等待协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E9%80%80N%E5%B8%A7%E5%8D%8F%E8%AE%AE-GBN"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">反退N帧协议(GBN)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E9%87%8D%E4%BC%A0%E5%8D%8F%E8%AE%AE-SR"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">选择重传协议(SR)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%95%BF%E5%BA%A6%EF%BC%9A"><span class="toc-number">1.4.2.3.0.1.</span> <span class="toc-text">滑动窗口长度：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">1.5.</span> <span class="toc-text">介质访问控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E9%81%93%E5%88%92%E5%88%86%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">1.5.1.</span> <span class="toc-text">信道划分介质访问控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%91%E5%88%86%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">频分多路复用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E5%88%86%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">时分多路复用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A2%E5%88%86%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">波分多路复用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%81%E5%88%86%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">码分多路复用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">1.5.2.</span> <span class="toc-text">随机访问介质访问控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ALOHA%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">ALOHA协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSMA%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">CSMA协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSMA-CD%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">CSMA&#x2F;CD协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSMA-CA%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">CSMA&#x2F;CA协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2%E8%AE%BF%E9%97%AE%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">1.5.3.</span> <span class="toc-text">轮询访问介质访问控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E5%9F%9F%E7%BD%91%EF%BC%9A"><span class="toc-number">1.6.</span> <span class="toc-text">广域网：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%9F%9F%E7%BD%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.6.1.</span> <span class="toc-text">广域网的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PPP%E5%8D%8F%E8%AE%AE%E7%89%B9%E7%82%B9"><span class="toc-number">1.6.2.</span> <span class="toc-text">PPP协议特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PPP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.6.3.</span> <span class="toc-text">PPP协议的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HDLC%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.6.4.</span> <span class="toc-text">HDLC协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E5%9F%9F%E7%BD%91"><span class="toc-number">1.7.</span> <span class="toc-text">局域网</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9A%84%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.1.</span> <span class="toc-text">局域网的拓扑结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.2.</span> <span class="toc-text">局域网介质访问控制方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%AD%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%AD%90%E5%B1%82"><span class="toc-number">1.7.3.</span> <span class="toc-text">局域网中数据链路的两个子层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91"><span class="toc-number">1.7.4.</span> <span class="toc-text">以太网</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91"><span class="toc-number">1.7.5.</span> <span class="toc-text">无线局域网</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E7%9A%84%E4%BB%A5%E5%A4%AA%E7%BD%91"><span class="toc-number">1.8.</span> <span class="toc-text">拓展的以太网</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%B1%82%E6%8B%93%E5%B1%95%E4%BB%A5%E5%A4%AA%E7%BD%91"><span class="toc-number">1.8.1.</span> <span class="toc-text">物理层拓展以太网</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82%E6%8B%93%E5%B1%95%E4%BB%A5%E5%A4%AA%E7%BD%91"><span class="toc-number">1.8.2.</span> <span class="toc-text">链路层拓展以太网</span></a></li></ol></li></ol></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
