<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/12/20/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>存储系统</title>
    <url>/2022/08/08/3%E3%80%81%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="一、存储系统概述"><a href="#一、存储系统概述" class="headerlink" title="一、存储系统概述"></a>一、存储系统概述</h2><h3 id="1、存储器的分类"><a href="#1、存储器的分类" class="headerlink" title="1、存储器的分类"></a>1、存储器的分类</h3><blockquote>
<ul>
<li><p><strong>按在计算机中的作用分类：</strong></p>
<blockquote>
<ul>
<li><p><strong>主存储器：</strong>简称<strong>主存</strong>，又称<strong>内存储器（内存）</strong>，用于存放计算机运行期间所需的大量程序和数据。CPU可以直接随机地对其进行访问，也可以和高速缓存及辅存进行数据的交换。</p>
</li>
<li><p><strong>辅助存储器：</strong>简称<strong>辅存</strong>，又称<strong>外存储器（外存）</strong>，是主存储器的后援存储器，用于存储当前暂时用不上的程序和数据，以及一些需要永久性保存的信息，不能与CPU直接交换信息。</p>
</li>
<li><p><strong>高速缓存存储器：</strong>简称<strong>Cache</strong>，位于主存与CPU之间，用于存放正在执行的程序段和数据，存取速度可以和CPU的速度相匹配。</p>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>按存储介质分类：</strong></p>
<blockquote>
<ul>
<li>磁表面存储器：磁盘、磁带</li>
<li>磁芯存储器</li>
<li>半导体存储器</li>
<li>光存储器：光盘</li>
</ul>
</blockquote>
</li>
<li><p><strong>按存取方式分类：</strong></p>
<blockquote>
<ul>
<li><p><strong>随机存储器（RAM）：</strong>存储器的任何一个存储单元的内容都可以随机存取，且存取时间与存储单元的物理位置无关。</p>
</li>
<li><p><strong>只读存储器（ROM）：</strong>存储器内容只能<strong>随机读取</strong>而不能写入，内容一旦写入存储器就固定不变，即使断电，内容也不会丢失。<strong>它与随机存储器可共同作为主存的一部分，统一构成主存的地址域</strong>。</p>
</li>
<li><p><strong>串行访问存储器：</strong>对存储单元进行读写时，<strong>需要按照其物理地址的先后顺序寻址</strong>。</p>
<blockquote>
<ul>
<li><strong>顺序存取存储器：</strong>磁带</li>
<li><strong>直接存取存储器：</strong>磁盘、光盘</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>按信息的可保存性分类：</strong></p>
<blockquote>
<ul>
<li><strong>易失性存储器：</strong>断电后，存储数据就会消失的存储器，如RAM</li>
<li><strong>非易失性存储器：</strong>断电后依旧可以保存数据信息的存储器，如ROM</li>
<li><strong>破坏性读出：</strong>某个存储单元的信息被读出时，原存储信息被破坏。（因此每次读出操作后，必须紧接一个再生操作）</li>
<li><strong>非破坏性读出：</strong>存储单元的数据在被读出后，原信息不会被破坏。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="2、存储器的性能指标"><a href="#2、存储器的性能指标" class="headerlink" title="2、存储器的性能指标"></a>2、存储器的性能指标</h3><blockquote>
<ul>
<li><p><strong>存储容量：</strong></p>
<blockquote>
<p>存储容量&#x3D;存储字数$\times$字长（如$1M \times8位$）</p>
<p>单位换算：1B&#x3D;8b</p>
<p><strong>存储字数表示存储器地址空间大小，字长表示一次存取操作的数据量</strong></p>
</blockquote>
</li>
<li><p><strong>单位成本：</strong></p>
<blockquote>
<p>$每位价格&#x3D;总成本&#x2F;总容量$</p>
</blockquote>
</li>
<li><p><strong>存储速度：</strong></p>
<blockquote>
<p>数据传输率&#x3D;数据的宽度&#x2F;存储周期</p>
<ul>
<li><strong>存取时间：</strong>指从<strong>启动一次存储器操作到完成该操作所经历的时间</strong>，分为<strong>读取时间</strong>与<strong>写入时间</strong></li>
<li><strong>存取周期：</strong>指存储器<strong>进行一次完整的读写操作所需的全部时间</strong>，即两次独立存取操作的时间间隔</li>
<li><strong>主存带宽：</strong>又称<strong>数据传输率</strong>，指每秒从主存进出信息的最大数据量，单位为字&#x2F;秒、字节&#x2F;秒、位&#x2F;秒</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>注意：存取时间不等于存取周期，</strong>因为在读写操作后，总需要有一段<strong>恢复时间</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%8F%96%E5%91%A8%E6%9C%9F.png" alt="存取周期"></p>
</blockquote>
<h2 id="二、半导体存储器"><a href="#二、半导体存储器" class="headerlink" title="二、半导体存储器"></a>二、半导体存储器</h2><h3 id="1、随机存储器"><a href="#1、随机存储器" class="headerlink" title="1、随机存储器"></a>1、随机存储器</h3><blockquote>
<p>随机存储器包括两类：SRAM和DRAM，其中<strong>主存由DRAM实现</strong>，而<strong>Cache由SRAM实现</strong>。</p>
<p><strong>随机存储器的特点：</strong>属于<strong>易失性存储器</strong>，只要<strong>切断电源，存储信息就会消失</strong>。</p>
<p><strong>两种随机存储器的比较：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%8D%8A%E5%AF%BC%E4%BD%93%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="半导体随机存储器的比较"></p>
</blockquote>
</blockquote>
<h4 id="1-1、静态随机存储器SRAM"><a href="#1-1、静态随机存储器SRAM" class="headerlink" title="1.1、静态随机存储器SRAM"></a>1.1、静态随机存储器SRAM</h4><blockquote>
<p>静态随机存储器（SRAM）的存储单元由<strong>双稳态触发器（六晶体管MOS）</strong>组成</p>
<p><strong>特点：</strong></p>
<blockquote>
<ul>
<li><strong>非破坏性读出</strong>，即使信息被读出，数据仍能保持原来的状态</li>
<li><strong>存取速度快</strong>（与DRAM作比较）</li>
<li><strong>集成度低</strong></li>
<li><strong>功耗大</strong></li>
</ul>
</blockquote>
</blockquote>
<h4 id="1-2、动态随机存储器DRAM"><a href="#1-2、动态随机存储器DRAM" class="headerlink" title="1.2、动态随机存储器DRAM"></a>1.2、动态随机存储器DRAM</h4><blockquote>
<p>动态随机存储器（DRAM）的存储单元<strong>利用电容来存储信息</strong>，因此只需一个晶体管，且<strong>需要不断地刷新电容</strong></p>
<p><strong>特点：</strong></p>
<blockquote>
<ul>
<li><p><strong>采用地址复用技术，地址线只需原来的1&#x2F;2</strong>，地址信号分行、列两次传送（<strong>即地址线的消耗减半</strong>）</p>
</li>
<li><p><strong>需要进行电容的刷新</strong>（将一行信息读出后再写回去）</p>
<blockquote>
<ul>
<li><p><strong>集中刷新：</strong>指利用一段固定时间，依次对存储器所有的存储单元进行刷新，这段时间被称作<strong>“死时间”</strong>，也称作<strong>访存“死区”</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%9B%86%E4%B8%AD%E5%88%B7%E6%96%B0.png" alt="集中刷新"></p>
</blockquote>
</li>
<li><p><strong>分散刷新：</strong>把每行的刷新时间分散到各个工作周期中，<strong>类似于读写操作的恢复时间</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%88%86%E6%95%A3%E5%88%B7%E6%96%B0.png" alt="分散刷新"></p>
</blockquote>
</li>
<li><p><strong>异步刷新：</strong>前两者的结合，将刷新周期除以行数，得到两次刷新之间的时间间隔t，每个时间t产生一次刷新请求。</p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%BC%82%E6%AD%A5%E5%88%B7%E6%96%B0.png" alt="异步刷新"></p>
</blockquote>
</li>
</ul>
<p><strong>注意：</strong>刷新对CPU是透明的；DRAM刷新的单位是行；刷新操作类似于读操作</p>
</blockquote>
</li>
<li><p><strong>存取速度慢</strong>（与SRAM作比较）</p>
</li>
<li><p><strong>集成度高</strong></p>
</li>
<li><p><strong>功耗低</strong></p>
</li>
</ul>
</blockquote>
</blockquote>
<h4 id="1-3、存储芯片的内部结构"><a href="#1-3、存储芯片的内部结构" class="headerlink" title="1.3、存储芯片的内部结构"></a>1.3、存储芯片的内部结构</h4><blockquote>
<p><strong>存储器的结构模型：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B.png" alt="存储器结构模型"></p>
<ul>
<li><strong>地址寄存器：</strong>存放存储体中某个单元的地址</li>
<li><strong>时序控制逻辑：</strong>控制器，控制存储器的读写</li>
<li><strong>数据寄存器：</strong>存放从存储体中读取的数据（或存储待写入存储体的数据）</li>
<li><strong>存储体：</strong>存储器的主要构成</li>
</ul>
</blockquote>
<p><strong>一个存储元的结构：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E5%85%83%E7%BB%93%E6%9E%84.png" alt="存储元结构"></p>
<ul>
<li><strong>控制器：</strong>由逻辑控制单元来控制，主要是控制该操作是读还是写</li>
<li><strong>存储的数据信息：</strong>每个存储元存储数据的地方，图中的是以电容来存储信息的。</li>
<li><strong>数据寄存器：</strong>存放从存储体中读取的数据（或存储待写入存储体的数据）</li>
</ul>
</blockquote>
<p><strong>存储芯片的结构</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="存储芯片的结构"></p>
<ul>
<li><strong>控制电路：</strong>本质就是控制器</li>
<li><strong>译码器：</strong>将控制电路的信号转化称相应的读写信号</li>
<li><strong>片选线（$\overline{ CS }$）：</strong>由于存储体是由多片存储芯片组成的，因此设置了一个片选信号来表示当前是否在读取本存储芯片</li>
<li><strong>读&#x2F;写控制线（$\overline{WE}$）：</strong>决定该操作是读操作还是写操作，一般可以用一个线路WE即可表示</li>
<li><strong>地址线：</strong>要读&#x2F;写的存储元的位置</li>
<li><strong>数据线：</strong>连接数据寄存器和存储元的线路</li>
</ul>
<p><strong>注意：存储芯片一次读&#x2F;写操作的单位是一行的存储单元，而不是单个存储单元</strong></p>
</blockquote>
</blockquote>
<h3 id="2、只读存储器-ROM"><a href="#2、只读存储器-ROM" class="headerlink" title="2、只读存储器(ROM)"></a>2、只读存储器(ROM)</h3><blockquote>
<p><strong>存储器类型：</strong></p>
<blockquote>
<ul>
<li><p><strong>掩模式只读存储器（MROM）：</strong></p>
<blockquote>
<p>由厂商按照顾客需求来写入内容，且内容一旦写入就无法再进行修改。</p>
</blockquote>
</li>
<li><p><strong>一次可编程只读存储器（PROM）：</strong></p>
<blockquote>
<p>该存储器可以让用户使用专门的设备写入自己的数据，一旦写入，内容就无法改变。</p>
</blockquote>
</li>
<li><p><strong>可擦除可编程只读存储器（EPROM）：</strong></p>
<blockquote>
<p>可以让用户利用编程器写入信息，需要时也可以进行擦除对其进行多次修改。EPROM根据擦除的方式又可以分为两类：<strong>紫外线擦除（UVEPROM）</strong>和<strong>电擦除（$E^2$PROM）</strong></p>
<p><strong>注意：</strong>EPROM不能代替RAM作主存，因为EPROM的写入时间较长</p>
</blockquote>
</li>
<li><p><strong>闪速存储器（Flash）：</strong></p>
<blockquote>
<p>闪存是在EPROM与$E^2$PROM的基础上发展过来的，主要特点是：<strong>不加电时长时间存储数据</strong>和<strong>在线进行快速擦除和重写</strong></p>
</blockquote>
</li>
<li><p><strong>固态硬盘（SSD）：</strong></p>
<blockquote>
<p>基于闪存利用固态电子存储芯片阵列制成的硬盘，由控制单元和Flash芯片阵列组成</p>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>ROM的特点：</strong></p>
<blockquote>
<ul>
<li><strong>一旦写入信息，就不能轻易改变，具有非易失性</strong></li>
<li><strong>结构简单，位密度高</strong></li>
</ul>
</blockquote>
</blockquote>
<h2 id="三、存储器与CPU的协同工作"><a href="#三、存储器与CPU的协同工作" class="headerlink" title="三、存储器与CPU的协同工作"></a>三、存储器与CPU的协同工作</h2><h3 id="1、存储器的层次结构"><a href="#1、存储器的层次结构" class="headerlink" title="1、存储器的层次结构"></a>1、存储器的层次结构</h3><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E5%8C%96%E7%BB%93%E6%9E%84.png" alt="存储器层次化结构"></p>
<p>其中，能<strong>与CPU直接相连</strong>的有<strong>寄存器、Cache、主存</strong>，磁盘、光盘等只能通过主存才能与CPU交换信息。</p>
<p><strong>主存与Cache之间的数据交换是由硬件自动完成</strong>，对所有程序员都是透明的。</p>
<p><strong>辅存与主存间的数据交换则是由操作系统来完成，</strong>对应用程序员来说也是透明的。</p>
<p><strong>设计这一套存储器层次结构的目的：为了平衡CPU速度过快而存储器读取速度慢的问题</strong></p>
<p><strong>注意：</strong></p>
<blockquote>
<ul>
<li>在存储器的层次结构中，<strong>上层的数据内容只是下层的副本</strong></li>
<li>Cache可以分为多级缓存，其中速度与容量也有所不同</li>
</ul>
</blockquote>
</blockquote>
<h3 id="2、主存与CPU的连接"><a href="#2、主存与CPU的连接" class="headerlink" title="2、主存与CPU的连接"></a>2、主存与CPU的连接</h3><h4 id="2-1、连接原理"><a href="#2-1、连接原理" class="headerlink" title="2.1、连接原理"></a>2.1、连接原理</h4><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E4%B8%BB%E5%AD%98%E4%B8%8ECPU%E7%9A%84%E8%BF%9E%E6%8E%A5.png" alt="主存与CPU的连接"></p>
<ul>
<li>主存通过数据总线、地址总线以及读写控制线与CPU进行连接</li>
<li>数据总线的位数与工作频率的乘积正比于数据传输率：$总线位数 \times 工作频率 &#x3D; k \times数据传输率$</li>
<li><strong>地址总线的位数决定了可寻址的最大内存空间</strong>，如32位地址线最大可表示$2^{32}&#x3D;4GB$的内存空间</li>
<li>读写控制线指出总线周期的类型和本次输入&#x2F;输出操作完成的时刻</li>
</ul>
</blockquote>
<h4 id="2-2、主存容量的扩展"><a href="#2-2、主存容量的扩展" class="headerlink" title="2.2、主存容量的扩展"></a>2.2、主存容量的扩展</h4><blockquote>
<p>由于单个的存储芯片（如8K$\times$2的芯片）容量有限，有时与需求的容量有一点点差距，因此我们需要在<strong>字</strong>和<strong>位</strong>两方面进行扩展才能满足需求。所以可以分为：<strong>位扩展法</strong>、<strong>字扩展法</strong>和<strong>字位同时扩展</strong></p>
<ul>
<li><p><strong>位扩展法：</strong></p>
<blockquote>
<p>位扩展的方式就是将多个存储芯片的<strong>地址端、片选端</strong>和<strong>读写控制端</strong>相应<strong>并联</strong>使得CPU的数据线的位数于其相等，数据端则分别引出</p>
<p><strong>如图所示：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E4%BD%8D%E6%89%A9%E5%B1%95.png" alt="位扩展"></p>
</blockquote>
</li>
<li><p><strong>字扩展法</strong></p>
<blockquote>
<p>字扩展是指<strong>增加存储器中字的数量</strong>，而<strong>位数不变</strong>。字扩展就是将芯片的<strong>地址线、数据线、读写控制线相应并联，由片选信号来区分各芯片的地址范围</strong></p>
<p><strong>如图所示：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%AD%97%E6%89%A9%E5%B1%95.png" alt="字扩展"></p>
<p>​        图中是将4片16K$\times$8位的RAM芯片组成64K$\times$8位的存储器。其中读写控制线$\overline{WE}$是并联在一起的，以$A_{14}和A_{15}$作为<strong>片选信号</strong>。</p>
<p>​        例如，当要选择第3片芯片的时候，令$A_{14},A_{15}&#x3D;10$，通过译码器翻译得到3，那么就将第3片的芯片的$\overline{CS}$置为1，其余的置为0.（这就实现了通过片选信号与$\overline{CS}$来选择相应的芯片了，另外$A_{14},A_{15}$是设计在CPU上的）</p>
<p><strong>具体的地址实现：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%AD%97%E6%89%A9%E5%B1%95%E7%9A%84%E5%9C%B0%E5%9D%80.png" alt="字扩展的地址"></p>
</blockquote>
</blockquote>
</li>
<li><p><strong>字位同时扩展法</strong></p>
<blockquote>
<p>实际上，存储器往往需要同时扩展字长与位长。<strong>字位同时扩展既可以增加存储字的数量，又可以增加存储字长</strong></p>
<p><strong>如图所示：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%AD%97%E4%BD%8D%E5%90%8C%E6%97%B6%E6%89%A9%E5%B1%95.png" alt="字位同时扩展"></p>
<p>如图所示，字位同时扩展本质上就是综合上述两种扩展，先对位数进行扩展，将两个位数较低并联的芯片看作一个位数较高的芯片。然后再将这一组芯片使用字扩展法，结合译码器对其进行扩展。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="2-3、CPU选择存储芯片的方法"><a href="#2-3、CPU选择存储芯片的方法" class="headerlink" title="2.3、CPU选择存储芯片的方法"></a>2.3、CPU选择存储芯片的方法</h4><blockquote>
<p>CPU要实现对存储单元的访问，首先要选择存储芯片，即进行<strong>片选</strong>；然后在选中的芯片中按地址选择相应的存储单元，即进行<strong>字选</strong>。</p>
<p>这里着重讲述片选，而片选的方式可以分为：<strong>线选法</strong>和<strong>译码片选法</strong>。</p>
<ul>
<li><p><strong>线选法</strong></p>
<blockquote>
<p>线选法用除片内寻址外的<strong>高位地址线</strong>直接（过经过反相器）分别接至各个芯片的片选端，当某地址线信号为“0”时，就选中与之对应的存储芯片。（简单来说就是：为每一个芯片额外多接一根片选线，信号为0时表示选中）</p>
<p>因此这些片选地址线每次寻址时只能有一个有效位，例如有4片2K$\times$8位的存储芯片构成一个存储器，那么它的地址线结构为：低位$A_0 — A_{10}$为字选线（$2^{11}&#x3D;2K$），高位$A_{11}—A_{14}$为字选线，且分配如下</p>
<table>
<thead>
<tr>
<th align="center">芯片</th>
<th align="center">$A_{14}—A_{11}$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0#</td>
<td align="center">1110</td>
</tr>
<tr>
<td align="center">1#</td>
<td align="center">1101</td>
</tr>
<tr>
<td align="center">2#</td>
<td align="center">1011</td>
</tr>
<tr>
<td align="center">3#</td>
<td align="center">0111</td>
</tr>
</tbody></table>
<p><strong>优点：</strong>不需要译码器，线路简单</p>
<p><strong>缺点：</strong>地址空间不连续，造成地址资源的浪费，且芯片过多时，线路也会变得过多</p>
</blockquote>
</li>
<li><p><strong>译码片选法</strong></p>
<blockquote>
<p>译码器片选法用除片内寻址外的<strong>高位地址线</strong>通过地址译码器产生片选信号。例如有4片2K$\times$8位的存储芯片构成一个存储器，如果使用译码器片选法，那么只需在高位多加两位作为片选信号即可，即低位$A_0 — A_{10}$为字选线（$2^{11}&#x3D;2K$），高位$A_{11}—A_{12}$为字选线，且分配如下</p>
<table>
<thead>
<tr>
<th align="center">芯片</th>
<th align="center">$A_{12}—A_{11}$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0#</td>
<td align="center">00</td>
</tr>
<tr>
<td align="center">1#</td>
<td align="center">01</td>
</tr>
<tr>
<td align="center">2#</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">3#</td>
<td align="center">11</td>
</tr>
</tbody></table>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="2-4、存储器与CPU的连接方式"><a href="#2-4、存储器与CPU的连接方式" class="headerlink" title="2.4、存储器与CPU的连接方式"></a>2.4、存储器与CPU的连接方式</h4><blockquote>
<ul>
<li><strong>合理选择存储芯片：</strong>主要指存储芯片类型（RAM或ROM和数量的选择）。通常选择ROM存放系统程序，和各类常数；RAM则是为用户编程而设计的。</li>
<li><strong>地址线的连接：</strong>CPU的地址线高于存储器的地址线时，优先使用低位的地址线。</li>
<li><strong>数据线的连接：</strong>CPU与存储器的数据线不等时，需要对存储器芯片进行扩位，使其数据位与CPU的数据位相等后才进行连接</li>
<li><strong>读写命令线的连接</strong></li>
<li><strong>片选线的连接</strong></li>
</ul>
</blockquote>
<h3 id="3、双端口RAM和多模块存储器"><a href="#3、双端口RAM和多模块存储器" class="headerlink" title="3、双端口RAM和多模块存储器"></a>3、双端口RAM和多模块存储器</h3><blockquote>
<p>上一节讲了存储器容量不足时的解决办法，这里将会讲<strong>如何提高CPU访问存储器的速度</strong>，主要讲两种技术：<strong>采用双端口存储器</strong>和<strong>多模块存储器技术</strong>。两者都为<strong>并行技术</strong>，<strong>前者为空间并行</strong>，<strong>后者为时间并行</strong></p>
</blockquote>
<h4 id="3-1、双端口RAM"><a href="#3-1、双端口RAM" class="headerlink" title="3.1、双端口RAM"></a>3.1、双端口RAM</h4><blockquote>
<p>双端口RAM是指同一存储器中有左、右两个独立的端口，分别<strong>有两套相互独立的地址线、数据线和读写控制线</strong>，允许两个独立的控制器同时异步地访问存储单元。</p>
<p><strong>图示：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%8F%8C%E7%AB%AF%E5%8F%A3RAM.png" alt="双端口RAM"></p>
<p><strong>补充：</strong></p>
<blockquote>
<p>当两个端口同时访问两个不同的存储单元时，读写操作都不会发生冲突。</p>
<p>当两个端口对同一存储单元进行读写时，会有以下4种情况：</p>
<ul>
<li>两个端口不同时对同一地址单元读取数据。（不发生错误）</li>
<li>两个端口同时对同一地址单元进行读取。（不发生错误）</li>
<li>两个端口同时对同一地址单元进行写操作。（出现写入错误）</li>
<li>一个端口进行写操作，另一个端口进行读操作。（出现读出错误）</li>
</ul>
<p><strong>解决办法：</strong>设置一个“忙”信号，当一个端口在操作时由判断逻辑决定是否需要暂时关闭另一个端口。</p>
</blockquote>
</blockquote>
<h4 id="3-2、多模块存储器"><a href="#3-2、多模块存储器" class="headerlink" title="3.2、多模块存储器"></a>3.2、多模块存储器</h4><blockquote>
<p>为了提高访存速度，常采用多模块存储器，而常用的有：<strong>单体多字存储器</strong>和<strong>多体并行存储器</strong></p>
<ul>
<li><p><strong>单体多字存储器</strong></p>
<blockquote>
<p>单体多字系统的特点时<strong>存储器中只有一个存储体，每个存储单元存储m个字，总线宽度也为m个字。一次并行读出m个字，地址顺序排列并处于同一存储单元</strong>。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%8D%95%E4%BD%93%E5%A4%9A%E5%AD%97%E5%AD%98%E5%82%A8%E5%99%A8.png" alt="单体多字存储器"></p>
<p>单体多字系统在<strong>一个存储周期内，从同一地址取出m条指令（如图中的一行数据）</strong>，然后讲指令逐条送至CPU，即每隔1&#x2F;m存储周期，CPU就能得到一条指令，这显然增大了存储器的带宽，提高了单体存储器的工作速度。</p>
<p><strong>缺点：</strong>指令和数据在主存的位置必须是连续的，一旦遇到转移指令时，这种方法效果就不明显了。</p>
</blockquote>
</li>
<li><p><strong>多体并行存储器</strong></p>
<blockquote>
<p><strong>前提：</strong></p>
<blockquote>
<p>首先先回忆一下，存储体的访问周期分为<strong>存取时间</strong>与<strong>恢复时间</strong>，即</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%8F%96%E5%91%A8%E6%9C%9F.png" alt="存取周期"></p>
<p>读取时，使用CPU的是<strong>存取时间</strong>，恢复时间并不占用CPU（低位交叉编址会用到）</p>
<p><strong>注意：</strong></p>
<blockquote>
<p>下面会讲到的三个词：</p>
<ul>
<li><p><strong>存储单元：</strong>指一个存储格子</p>
</li>
<li><p><strong>存储体：</strong>指同一列的存储单元</p>
</li>
<li><p><strong>存储器：</strong>指整个图的存储单元的集合</p>
</li>
</ul>
</blockquote>
</blockquote>
<p>多体并行存储器是由多个存储模块组成，每个模块都有相同的容量以及存取速度，且各模块之间都有独立的控制电路、地址线路和数据存储器，它们既可以独立工作又可以交叉工作。</p>
<p>多体并行存储器可以分为两类：<strong>高位交叉编址</strong>和<strong>低位交叉编址</strong></p>
<ul>
<li><p><strong>高位交叉编址：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%AB%98%E4%BD%8D%E4%BA%A4%E5%8F%89%E7%BC%96%E5%9D%80.png" alt="高位交叉编址"></p>
<p>存储体号在前，存储体内地址在后，且编址方式按<strong>顺序编址</strong>，<strong>先编满一个存储体后再到下一个存储体</strong>。</p>
<p><strong>特点：</strong></p>
<blockquote>
<p>进行顺序存取时，如果要读取n个存储单元，那么就要用到n个存取周期，时间上并没有改进，如图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%AB%98%E4%BD%8D%E4%BA%A4%E5%8F%89%E7%BC%96%E5%9D%80%E7%9A%84%E4%BE%8B%E5%AD%90.png" alt="高位交叉编址的例子"></p>
<p>连续访问5个存储单元就会花费5个存储周期，因此不会改进读取存储器的吞吐率。</p>
</blockquote>
</blockquote>
</li>
<li><p><strong>低位交叉编址</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E4%BD%8E%E4%BD%8D%E4%BA%A4%E5%8F%89%E7%BC%96%E5%9D%80.png" alt="低位交叉编址"></p>
<p>存储体内地址在前，而存储体号在后。编址方式<strong>交叉编址</strong>，每<strong>对一个存储体编完一个址，就换下一个存储体继续编址</strong>。</p>
<p><strong>特点：</strong></p>
<blockquote>
<p>由于对存储器进行读取时，真正占用CPU时间的只有一部分，只要读取完成了，CPU就可以换一个存储体进行读取，因此如果是低位交叉编址的存储器，读取一段连续的地址时，时间如图所示</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E4%BD%8E%E4%BD%8D%E4%BA%A4%E5%8F%89%E7%BC%96%E5%88%B6%E7%9A%84%E4%BE%8B%E5%AD%90.png" alt="低位交叉编制的例子"></p>
<p>相邻两个周期重叠的部分就是前一个存储体的恢复时间。由图可以明显看出，存储器的读取效率大幅度提升了，因此缩减了CPU读取存储器的时间。且读取时间满足以下公式<br>$$<br>t&#x3D;T+(m-1)r\quad(其中T为一个存储周期，m为存储体数量，r为传送时间或恢复时间)<br>$$<br><strong>注意：</strong></p>
<p>存储器交叉模块的数量m只有在<strong>大于等于T&#x2F;r</strong>（T为存储周期，r为传送周期）时，<strong>才满足上面的公式</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E5%99%A8%E4%BA%A4%E5%8F%89%E6%A8%A1%E5%9D%97%E6%95%B0%E9%87%8F.png" alt="存储器交叉模块数量"></p>
<p>因为如果m小于T&#x2F;r，那么就会导致读取完最后一个存储体后，第一个存储体仍未完成恢复。（即上图中存储体最后会多等待r的时间）</p>
</blockquote>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="4、高速缓存Cache"><a href="#4、高速缓存Cache" class="headerlink" title="4、高速缓存Cache"></a>4、高速缓存Cache</h3><h4 id="4-1、局部性原理"><a href="#4-1、局部性原理" class="headerlink" title="4.1、局部性原理"></a>4.1、局部性原理</h4><blockquote>
<p>局部性原理就是程序访问的局部性原理，其中可以分为：</p>
<ul>
<li><strong>时间局部性：</strong>指最近未来要用到的信息，很可能时现在正在使用的信息（因为程序中存在循环），但空间上不一定连续</li>
<li><strong>空间局部性：</strong>指未来要用到的信息，很可能与现在正在用的信息在存储空间上是临近的。</li>
</ul>
<p><strong>应用实例：</strong>编程语言中的数组等数据结构</p>
</blockquote>
<h4 id="4-2、基本的工作原理"><a href="#4-2、基本的工作原理" class="headerlink" title="4.2、基本的工作原理"></a>4.2、基本的工作原理</h4><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="高速缓存工作原理"></p>
<p>Cache位于存储器层次结构的顶层，通常由SRAM组成。</p>
<p>为了方便主存与Cache之间交换信息，Cache与主存被化成<strong>大小相同、数量不同</strong>的小块，Cache的容量远小于主存，且Cache只按某种策略存放经常用的<strong>主存块的副本</strong>。</p>
<p>Cache与CPU交换的单位是<strong>字</strong>，Cache与主存交换的单位是<strong>存储块</strong></p>
<p>当CPU需要访问某个数据的时候，它会优先访问Cache，如果Cache中存在该数据，那么此时称为<strong>命中</strong>；如果Cache中不存在改数据，那么<strong>CPU会直接访问主存（然后将改存储块调入Cache中）</strong>或者<strong>等主存的存储调入Cache中后再访问</strong>。</p>
<p>CPU欲访问的信息已在Cache中的比率称为Cache的<strong>命中率</strong>，公式为<br>$$<br>H&#x3D;N_c&#x2F;(N_c+N_m)\quad\quad (N_c为命中次数，N_m为未命中的次数)<br>$$</p>
</blockquote>
<h4 id="4-3、Cache与主存的映射方式"><a href="#4-3、Cache与主存的映射方式" class="headerlink" title="4.3、Cache与主存的映射方式"></a>4.3、Cache与主存的映射方式</h4><blockquote>
<p>由于Cache块数比主存的块数要少得少，因此主存中只有一部分块的信息能够放到Cache中，所以主存块怎么放到Cache中就是一个问题了。常用的映射方式有以下3种：</p>
<ul>
<li><p><strong>直接映射：</strong></p>
<blockquote>
<p><strong>主存种每一块只能装入Cache中的唯一位置</strong>，如果这个位置已经有内容了，则<strong>将原来的块无条件地替换掉</strong>（无需使用替换算法），形式如下图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84.png" alt="直接映射"></p>
<p>这种映射方式实现简单，但不够灵活，即有可能导致Cache中有许多空位不能使用，而又有较高的冲突概率，空间利用率在三种映射中最低。</p>
<p><strong>直接映射的地址结构：</strong></p>
<table>
<thead>
<tr>
<th align="center">主存中的块号</th>
<th align="center">Cache行号</th>
<th align="center">块内地址</th>
</tr>
</thead>
</table>
<p><strong>CPU访问数据的顺序</strong>：先访问Cache行号，找到相应Cache块；然后对主存中的块号进行匹配，如果匹配上就读取块内地址，否则就”不命中“然后读取主存中的信息，并将其数据块一并放入Cache中。</p>
</blockquote>
</li>
<li><p><strong>全相联映射：</strong></p>
<blockquote>
<p>主存中每一块都可以装入Cache中的<strong>任何位置</strong>，每行的标记用于指出该行来至主存的哪一块，形式如下图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%85%A8%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84.png" alt="全相联映射"></p>
<p><strong>优点：</strong>比较灵活，Cache冲突概率低，空间利用率高，命中率也高。</p>
<p><strong>缺点：</strong>标记的配对时间长</p>
<p><strong>地址结构：</strong></p>
<table>
<thead>
<tr>
<th align="center">标记（标识主存中的不同块）</th>
<th align="center">块内地址</th>
</tr>
</thead>
</table>
</blockquote>
</li>
<li><p><strong>组相联映射</strong></p>
<blockquote>
<p>将Cache分成大小相同的组，主存中的块可以放入某一个组中的任意位置，即<strong>组内使用全相联映射，组外使用直接映射</strong>，其形式如下图：</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84.png" alt="组相联映射"></p>
<p>组相联映射的关系可以用以下公式表示：<br>$$<br>j&#x3D;i\ mod\ Q \quad(j为Cahce的组号，i为主存的块号，Q为Cahce的组数)<br>$$<br><strong>地址结构：</strong></p>
<table>
<thead>
<tr>
<th align="center">标记</th>
<th align="center">组号</th>
<th align="center">块内地址</th>
</tr>
</thead>
</table>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="4-4、Cache的替换算法"><a href="#4-4、Cache的替换算法" class="headerlink" title="4.4、Cache的替换算法"></a>4.4、Cache的替换算法</h4><blockquote>
<p>当Cache或Cache组中的空间已已经被占满时，就需要使用替换算法置换Cache行，除了直接映射以外，其余两种都需要使用替换算法进行Cache块的更换。常用的Cache块更换算法有：<strong>随机算法（RAND）、先进先出算法（FIFO）、近期最少使用算法（LRU）</strong>和<strong>最不经常使用算法（LFU）</strong>。</p>
<ul>
<li><strong>随机算法（RAND）：</strong>随机地确定取代的Cache块。实现简单，但命中率会较低。</li>
<li><strong>先进先出算法（FIFO）：</strong>选择最早调入的块进行替代。</li>
<li><strong>近期最少使用算法（LRU）：</strong>根据局部性原理，选择<strong>近期内</strong>最久未访问过的Cache块作为替换的块。</li>
<li><strong>最不经常使用算法（LFU）：</strong>将一段时间内被访问次数最少的块进行替换。</li>
</ul>
<p><strong>注意：</strong>以上内容可以结合操作系统中内存管理那一部分进行理解。</p>
</blockquote>
<h4 id="4-5、Cache的写策略"><a href="#4-5、Cache的写策略" class="headerlink" title="4.5、Cache的写策略"></a>4.5、Cache的写策略</h4><blockquote>
<p>由于Cache中存放的是主存的副本，因此如果Cache中的内容发生变化，那么主存中的内容也要发生相应变化，而这个时候就需要一定的方法来将Cache的内容写入主存中。</p>
<p>而写回的情况分为两类：<strong>写命中</strong>和<strong>写不命中</strong>（即CPU要写的块不在Cache中）</p>
<ul>
<li><p><strong>写命中：</strong></p>
<blockquote>
<p>当CPU写命中时，又可以分为两类：<strong>全写法</strong>和<strong>写回法</strong></p>
<ul>
<li><p><strong>全写法：</strong></p>
<blockquote>
<p> 当CPU写命中的时候，直接将数据同时写入Cache和主存中。当然为了节省时间，也可以在CPU和主存之间加入一个写缓存，CPU同时将数据写到Cache和写缓存中，然后再由写缓存写到主存中。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%86%99%E7%BC%93%E5%AD%98.png" alt="写缓存"></p>
</blockquote>
</li>
<li><p><strong>写回法：</strong></p>
<blockquote>
<p>当CPU对Cache写命中时，只修改Cache的内容，而不立即修改主存中的内容，只有在进行块替换的时候才将修改后的数据块写回主存中。</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>写不命中：</strong></p>
<blockquote>
<p>当Cache写不命中时，也有两类：写<strong>分配法</strong>和<strong>非写分配法</strong></p>
<ul>
<li><p><strong>分配法：</strong></p>
<blockquote>
<p>将主存中的数据块加载到Cache中，然后更新相应的数据。</p>
</blockquote>
</li>
<li><p><strong>非写分配法：</strong></p>
<blockquote>
<p>直接将数据写入主存中。</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="5、虚拟存储器"><a href="#5、虚拟存储器" class="headerlink" title="5、虚拟存储器"></a>5、虚拟存储器</h3><h4 id="5-1、基本概念"><a href="#5-1、基本概念" class="headerlink" title="5.1、基本概念"></a>5.1、基本概念</h4><blockquote>
<p><strong>主存</strong>和<strong>联机工作的辅存</strong>共同构成了虚拟存储器，二者在硬件和系统软件的共同管理下工作。对于<strong>应用程序员而言，虚拟存储器是透明的</strong>。</p>
<p>虚拟存储器将主存或辅存的地址空间<strong>统一编址</strong>，形成一个巨大的地址空间。在这个空间里，用户可以自由使用，无需在乎实际的主存容量，以及实际的物理位置。</p>
<p>用户编程允许涉及的地址称为<strong>虚地址</strong>或<strong>逻辑地址</strong>，虚地址对应的存储空间称为<strong>虚拟空间</strong>或<strong>程序空间</strong>。</p>
<p>实际的主存单元地址称为<strong>实地址</strong>或<strong>物理地址</strong>，实地址对应的存储空间被称为<strong>主存空间</strong>或<strong>实地址空间</strong>。</p>
<p><strong>虚拟存储的作用：</strong>利用辅存对运行的存储空间进行扩展</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png" alt="虚拟存储器的地址空间"></p>
<p><strong>CPU使用虚地址的过程：</strong></p>
<blockquote>
<ul>
<li>由辅助硬件找出虚地址与实地址的对应关系</li>
<li>判断这个虚地址对应的存储单元是否已经装入内存</li>
<li>若已在内存中，通过地址转换，CPU直接访问主存所指示的实际单元</li>
<li>若不在主存中，则将包含这个字的一页或一段调入主存后再由CPU访问（必要时使用算法置换相应的页或着段）</li>
</ul>
</blockquote>
</blockquote>
<h4 id="5-2、页式虚拟存储器"><a href="#5-2、页式虚拟存储器" class="headerlink" title="5.2、页式虚拟存储器"></a>5.2、页式虚拟存储器</h4><blockquote>
<p>以页为基本单位的虚拟存储器称为<strong>页式虚拟存储器</strong>。</p>
<p><strong>虚拟空间</strong>与<strong>主存空间</strong>都被划分成同样大小的页（这里的页是一个计量单位，类似于Cache中的Cache块）</p>
<p>主存中的页称为<strong>实页</strong>，虚存中的页称为<strong>虚页</strong>。<strong>页表</strong>则是一张存放在主存中的虚页号和实页号的对照表，用于<strong>实现虚拟地址到物理地址的转换</strong>，一般长久地保存在内存中。</p>
<p><strong>页表：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt="页表结构"></p>
<ul>
<li>页表的地址包括主存地址和辅存地址</li>
<li><strong>有效位：</strong>也称为<strong>装入位</strong>，<strong>用来表示对应页面是否在主存</strong>。若为1，则表示虚拟页已从外存调入主存，此时页表项存放的是该页的物理地址（主存地址）；若为0，则表示该页没有调入主存，此时页表项存放的是该页的磁盘地址。</li>
<li><strong>脏位：</strong>也称为<strong>修改位</strong>，用来表示页面是否被修改</li>
<li><strong>引用位：</strong>也称为<strong>使用位</strong>，用来配合替换策略进行设置，例如是否实现最先调入（FIFO位）或最近最少用（LRU位）策略</li>
</ul>
<p>CPU执行指令时，需要先将虚拟地址转换为主存物理地址，其过程如下，</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E9%A1%B5%E8%A1%A8%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png" alt="页表地址转换"></p>
<ul>
<li>假设有一个<strong>虚拟地址</strong>，它可以分为<strong>虚拟页号</strong>和<strong>页内地址</strong></li>
<li><strong>虚拟页号</strong>和<strong>页表基地址（页表起始地址）</strong>拼接起来，得到<strong>页表地址</strong></li>
<li>查询页表的<strong>装入位</strong>，如果装入位是1，那么直接将对应的<strong>物理页号</strong>与虚拟地址中的<strong>页内地址</strong>拼接从而得到<strong>物理地址</strong>；如果装入位是0，那么进行缺页处理（详情可见操作系统）</li>
</ul>
<p><strong>优点：</strong>页面的长度固定，页表简单，调入方便。</p>
<p><strong>缺点：</strong>程序不可能正好是页面的整数倍，可能造成一些空间浪费（解决方法也在操作系统中）。并且页不是逻辑上独立的实体，所以处理、保护和共享都不及段式虚拟存储器方便。</p>
</blockquote>
<p><strong>快表（TLB）：</strong></p>
<blockquote>
<p>由地址转换过程可知，访存是先访问一次主存去查页表，再访问主存才能得到数据，如果缺页那么访问次数就更多了。</p>
<p>根据局部性原理，再一段时间内总是经常访问某些页是，如果将这些页对应的页表项放在高速缓存组成<strong>快表</strong>，明显可以提高效率。与主存和Cache的关系一样，快表的容量也是远小于页表的。</p>
<p>快表通常采用全相联或组相联方式，<strong>每个TLB项</strong>由<strong>页表表项内容加上一个TLB标志字段</strong>组成，<strong>TLB标记</strong>用来<strong>表示该表项曲子页表中哪个虚页号对应的页表项</strong>。</p>
<p>TLB标记的内容在全相联方式下就是该页表项对应的虚页号；组相联方式下则是对应虚页号的高位部分，虚页低位部分用于选择TLB组的组索引。</p>
</blockquote>
<p><strong>具有TLB和Cache的多级存储系统：</strong></p>
<blockquote>
<p>带TLB虚拟存储器的CPU访问过程：</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%B8%A6TLB%E7%9A%84%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84CPU%E8%AE%BF%E5%AD%98%E8%BF%87%E7%A8%8B.png" alt="带TLB的虚拟存储器的CPU访存过程"></p>
<p><strong>三种缺失情况：</strong></p>
<ul>
<li><strong>TLB缺失：</strong>要访问的页面对应的页表项不在TLB中</li>
<li><strong>Cache缺失：</strong>要访问的主存块不在Cache中</li>
<li><strong>页缺失：</strong>要访问的页面不在主存中</li>
</ul>
</blockquote>
</blockquote>
<h4 id="5-3、段式虚拟存储器"><a href="#5-3、段式虚拟存储器" class="headerlink" title="5.3、段式虚拟存储器"></a>5.3、段式虚拟存储器</h4><blockquote>
<p>段式虚拟存储器中的段是按<strong>程序的逻辑结构</strong>划分的，<strong>各个段的长度因程序而异</strong>。</p>
<p>段式存储器的虚拟地址分为两部分：<strong>段号</strong>和<strong>段内地址</strong>。</p>
<p>与页式虚拟存储器一样，虚拟地址与实地址之间的转换式由<strong>段表</strong>来实现的。</p>
<p>段表的每行记录：<strong>段号</strong>、<strong>装入位</strong>、<strong>段起点</strong>和<strong>段长</strong>等信息。</p>
<p><strong>段式虚拟存储器的地址变换过程：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E6%AE%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2.png" alt="段式虚拟存储器的地址变换"></p>
<ul>
<li>根据<strong>段号</strong>和<strong>段表基地址</strong>拼接成对应的<strong>段表行</strong></li>
<li>根据该段表行的装入位判断该段是否已经装入主存</li>
<li>查询段表的<strong>装入位</strong>，如果装入位是1，那么直接将对应的<strong>物理段号</strong>与虚拟地址中的<strong>段内地址</strong>拼接从而得到<strong>物理地址</strong>；如果装入位是0，那么进行缺段处理（详情可见操作系统）</li>
</ul>
</blockquote>
<p><strong>优点：</strong>段的分界与程序的自然分界相对应，因而具有逻辑独立性，使得它易于编译、管理、修改和保护，也便于多道程序的共享</p>
<p><strong>缺点：</strong>因为段的长度可变，分配空间时容易留下段间碎片</p>
</blockquote>
<h4 id="5-4、段页式虚拟存储器"><a href="#5-4、段页式虚拟存储器" class="headerlink" title="5.4、段页式虚拟存储器"></a>5.4、段页式虚拟存储器</h4><blockquote>
<p><strong>把程序按逻辑结构分段，每段在划分为固定大小的页，主存空间也划分为大小相等的页</strong>。</p>
<p>程序对主存的调入、调出仍<strong>以页为基本单位</strong>。</p>
<p>在段页式虚拟存储器中，每个程序对应一个段表，每段对应一个页表，<strong>段的长度必须是页长的整数倍，段的起点也是某一页的起点</strong></p>
<p><strong>虚地址：</strong>段号、段内页号、页内地址。</p>
<p><strong>CPU访问虚地址：</strong></p>
<blockquote>
<ul>
<li>根据段号得到段表地址</li>
<li>从段表中取出该段的页表起始地址</li>
<li>与虚地址段内页号拼接，得到页表地址</li>
<li>从页表中取出实页号，与页内地址拼接形成主存地址</li>
</ul>
</blockquote>
<p><strong>优点：</strong>结合了页式、段式虚拟存储器的优点</p>
<p><strong>缺点：</strong>在地址转换过程中需要两次查表，系统开销较大</p>
</blockquote>
<h4 id="5-5、虚拟存储器与Cache的比较"><a href="#5-5、虚拟存储器与Cache的比较" class="headerlink" title="5.5、虚拟存储器与Cache的比较"></a>5.5、虚拟存储器与Cache的比较</h4><blockquote>
<ul>
<li><p><strong>相同之处：</strong></p>
<blockquote>
<ul>
<li>最终目标都是提高系统性能</li>
<li>都把数据划分为小信息块，并作为基本的传递单位，虚拟系统的信息块更大</li>
<li>都有地址映射、替换算法、更新策略等</li>
<li>都依据程序的局部性原理应用</li>
</ul>
</blockquote>
</li>
<li><p><strong>不同之处：</strong></p>
<blockquote>
<ul>
<li><strong>Cache主要解决系统速度</strong>，<strong>虚拟存储器主要解决主存容量</strong></li>
<li>Cache全由硬件实现，是硬件存储器，<strong>对所有程序员都是透明的</strong>；而虚拟存储器由操作系统和硬件共同实现，是逻辑上的存储器，对<strong>系统程序员不透明，对应用程序员透明</strong></li>
<li>虚拟存储器系统不命中时对系统性能影响更大</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="四、其他补充"><a href="#四、其他补充" class="headerlink" title="四、其他补充"></a>四、其他补充</h2><blockquote>
<ul>
<li><p>本章将的主存、内存都是同一个东西。</p>
</li>
<li><p><strong>多级缓存：</strong></p>
<blockquote>
<p>在现代计算机系统中经常设立多级Cache（与存储器的分级系统一样，越高的速度越快，容量越小），如</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98.png" alt="多级缓存"></p>
<p>这样设置可以使得在CPU写回时避免与主存接触，从而降低效率。</p>
</blockquote>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>基础学科</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机系统概述</title>
    <url>/2022/08/08/1%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="一、计算机发展历程"><a href="#一、计算机发展历程" class="headerlink" title="一、计算机发展历程"></a>一、计算机发展历程</h2><h3 id="1、计算机硬件的发展历程"><a href="#1、计算机硬件的发展历程" class="headerlink" title="1、计算机硬件的发展历程"></a>1、计算机硬件的发展历程</h3><blockquote>
<p><strong>计算机四代变化：</strong></p>
<blockquote>
<ul>
<li><strong>电子管时代</strong></li>
<li><strong>晶体管时代</strong></li>
<li><strong>中小规模集成电路时代</strong></li>
<li><strong>超大规模集成电路时代</strong></li>
</ul>
</blockquote>
</blockquote>
<h3 id="2、计算机的分类和发展方向"><a href="#2、计算机的分类和发展方向" class="headerlink" title="2、计算机的分类和发展方向"></a>2、计算机的分类和发展方向</h3><blockquote>
<ul>
<li><strong>单指令流和单数据流</strong>系统（SISD），即传统冯 · 诺伊曼体系结构</li>
<li><strong>单指令流和多数据流</strong>系统（SIMD），包括阵列处理器和向量处理器系统</li>
<li><strong>多指令流和单数据流</strong>系统，不存在的系统</li>
<li><strong>多指令流和多数据流</strong>系统（MIMD），包括多处理器和多计算机系统</li>
</ul>
</blockquote>
<h2 id="二、计算机系统层次结构"><a href="#二、计算机系统层次结构" class="headerlink" title="二、计算机系统层次结构"></a>二、计算机系统层次结构</h2><h3 id="1、计算机硬件的基本组成"><a href="#1、计算机硬件的基本组成" class="headerlink" title="1、计算机硬件的基本组成"></a>1、计算机硬件的基本组成</h3><h4 id="1-1、早期的冯·诺依曼机"><a href="#1-1、早期的冯·诺依曼机" class="headerlink" title="1.1、早期的冯·诺依曼机"></a>1.1、早期的冯·诺依曼机</h4><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E5%86%AF%E8%AF%BA%E5%9F%BA%E6%9B%BC%E6%9C%BA.png" alt="冯诺基曼机"></p>
<ul>
<li>计算机硬件系统由<strong>运算器、存储器、控制器、输入和输出设备</strong>五个部分组成</li>
<li>指令和数据以<strong>同等地位</strong>存储在存储器中，并可<strong>按地址寻访</strong></li>
<li>指令和数据都以二进制代码表示</li>
<li>指令由<strong>操作码</strong>和<strong>地址码</strong>组成，操作码指出操作的类型，地址码指出操作数的地址</li>
<li>指令在存储器内按顺序存放</li>
<li><strong>早期冯·诺依曼机以运算器为中心</strong>，输入&#x2F;输出设备通过运算器和存储器传送数据</li>
</ul>
<p><strong>注意：</strong>”存储程序“的概念是指将指令以代码的形式事先输入计算机的主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序规定的顺序执行其他指令，直到程序执行结束。</p>
</blockquote>
<h4 id="1-2、现代计算机的组织结构"><a href="#1-2、现代计算机的组织结构" class="headerlink" title="1.2、现代计算机的组织结构"></a>1.2、现代计算机的组织结构</h4><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84.png" alt="现代计算机结构"></p>
<ul>
<li><strong>现代计算机以存储器为中心，其余部分与冯·诺依曼结构一致</strong></li>
<li>此结构让I&#x2F;O设备绕过了运算器，直接与存储器接触，从而提高整体的运行效率</li>
</ul>
</blockquote>
<h4 id="1-3、计算机的功能部件"><a href="#1-3、计算机的功能部件" class="headerlink" title="1.3、计算机的功能部件"></a>1.3、计算机的功能部件</h4><blockquote>
<img src="/picture/学习/计算组成原理上的图/计算机系统概述/现代计算机结构.png" alt="现代计算机结构" style="zoom:60%;" />

<ul>
<li><p><strong>输入设备</strong></p>
<blockquote>
<p>输入设备的主要功能是将程序和数据以机器所能识别和接受的信息形式输入计算机，常见的有鼠标、键盘等</p>
</blockquote>
</li>
<li><p><strong>输出设备</strong></p>
<blockquote>
<p>输出设备的主要功能是将计算机处理的结果以人们所能接受的形式进行输出，常见的有显示器、打印机等。</p>
</blockquote>
</li>
<li><p><strong>存储器</strong></p>
<blockquote>
<p>存储器是计算机的存储部件，用于存放数据和程序。</p>
<p>存储器又可以分为：<strong>主存储器</strong>和****。</p>
<ul>
<li><p><strong>主存储器</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8.png" alt="主存储器"></p>
<p>主存储器的工作方式是按存储单元的地址进行存取，这种存取方式称为<strong>按地址存取方式</strong></p>
<ul>
<li><strong>MAR（地址寄存器）：</strong>存放访存地址，经过地址译码后可以将数据从存储体中拿到MDR（数据寄存器）中。</li>
<li><strong>存储体：</strong>存储体由许多<strong>存储单元</strong>组成，每个存储单元又包含若干<strong>存储元件</strong>，每个存储元件可以存储<strong>一位0或1</strong>.</li>
<li><strong>MDR（数据寄存器）：</strong>暂时存储从存储体中读到的数据，位数和存储字长相等。</li>
</ul>
<p><strong>注意：</strong>MAR和MDR虽然属于存储器的一部分，但现代计算机却将其整合到了CPU上。</p>
</blockquote>
</li>
<li><p><strong>辅助存储器</strong></p>
<blockquote>
<p>辅助存储器实际就是硬盘、软盘、U盘等存储器，<strong>对于计算机来说属于外设</strong>。</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>运算器</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E8%BF%90%E7%AE%97%E5%99%A8.png" alt="运算器"></p>
<p>运算器是计算机的执行部件，用于进行<strong>算术运算</strong>和<strong>逻辑运算</strong>。算术运算是按算术规则进行的运算，如加、减、乘、除；逻辑运算包括，与、或、非、异或、比较、移位等。</p>
<ul>
<li><strong>ALU（算术逻辑单元）：</strong>运算器的<strong>核心</strong>，运算器的运算就是在这个元件上执行的。</li>
<li><strong>X（通用寄存器）：</strong>在原算器中有若干个，用于<strong>存放运算的操作数或中间结果</strong>。</li>
<li><strong>ACC（累加器）：</strong>用于<strong>存放操作数或运算结果</strong></li>
<li><strong>MQ（乘商寄存器）：</strong>在乘、除运算时，用于<strong>存放操作数或运算结果</strong></li>
</ul>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E8%BF%90%E7%AE%97%E5%99%A8%E4%B8%AD%E5%90%84%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt="运算器中各寄存器的作用"></p>
<p><strong>注意：</strong>除了上述三个必要的寄存器以外，还有<strong>IX（变址寄存器）</strong>、<strong>BR（基址寄存器）</strong>和<strong>PSW（程序状态寄存器）</strong>等。</p>
</blockquote>
</li>
<li><p><strong>控制器</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E6%8E%A7%E5%88%B6%E5%99%A8.png" alt="控制器"></p>
<ul>
<li><strong>CU（控制单元）：</strong>分析指令，给出相应的控制信号。</li>
<li><strong>IR（指令寄存器）：</strong>存放当前执行的指令。</li>
<li><strong>PC（程序计数器）：</strong>存放下一条指令的地址，并且有自动加1的功能。</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>指令执行的一个例子：</strong></p>
<blockquote>
<ul>
<li><strong>高级语言：</strong></li>
</ul>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png" alt="计算机的工作过程"></p>
</blockquote>
<ul>
<li><strong>编译并装入内存：</strong></li>
</ul>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98.png" alt="内存"></p>
</blockquote>
<ul>
<li><p><strong>读取操作数：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E8%AF%BB%E5%8F%96%E6%93%8D%E4%BD%9C%E6%95%B0.png" alt="读取操作数"></p>
<ul>
<li>起始：{PC}&#x3D;0，指向第一条指令的存储地址</li>
<li>1、PC的值转移到MAR中，此时{MAR}&#x3D;0</li>
<li>2、MAR根据数值去存储体中读取相应的存储空间</li>
<li>3、将读到的数据放到MDR中，此时{MDR}&#x3D;000001 0000000101</li>
<li>4、MDR将数据传送到IR中，IR将指令分成两部分</li>
<li>5、操作码部分被IR放到CU中进行解析，解析出结果为“读数”指令</li>
<li>6、地址码部分被IR传送至MAR中进行读数</li>
<li>7、MAR根据地址码去存储体中读取数据</li>
<li>8、将读到的数据放入MDR中，此时{MDR}&#x3D;0000000000000010&#x3D;2</li>
<li>9、MDR的数就被传送到了ACC中，{ACC}&#x3D;2</li>
</ul>
</blockquote>
</li>
<li><p><strong>乘积操作：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E4%B9%98%E7%A7%AF%E6%93%8D%E4%BD%9C.png" alt="乘积操作"></p>
<ul>
<li>状态：上一条取数指令完成后PC自动加1，{PC}&#x3D;1;{ACC}&#x3D;2</li>
<li>1、2、3：与上面的相似，将第二条指令读取到MDR中，</li>
<li>4、MDR将读取到的指令发送到IR中，此时{IR}&#x3D;000100 0000000110</li>
<li>5、IR将操作码发送到CU中，CU得到这是”乘法指令“</li>
<li>6、7、8、地址码-&gt;MAR，MAR根据地址读到数据并放到MDR中，此时{MDR}&#x3D;0000000000000011&#x3D;3</li>
<li>9、{MDR}-&gt;MQ，此时{MQ}&#x3D;3</li>
<li>10、{ACC}-&gt;X，此时{X}&#x3D;2</li>
<li>11、{MQ}通过ACC在ALU中实现了{MQ}*{X}&#x3D;6，并将结果放入ACC中</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>补充：</strong>后续操作就不写了，都是类似的操作：读指令-&gt;分析指令-&gt;读操作数-&gt;运算</p>
</blockquote>
</blockquote>
<h3 id="2、计算机软件的分类"><a href="#2、计算机软件的分类" class="headerlink" title="2、计算机软件的分类"></a>2、计算机软件的分类</h3><blockquote>
<ul>
<li><p><strong>系统软件</strong></p>
<blockquote>
<p>系统软件是一组保证计算机高效、正确运行的基础软件，通常作为系统资源提供给用户使用。如，</p>
<p>操作系统、数据库管理系统、语言处理系统、分布式软件系统、网络软件系统、标准库程序、服务性程序等。</p>
</blockquote>
</li>
<li><p><strong>应用软件</strong></p>
<blockquote>
<p>应用软件是用户为解决某个应用领域中的各类问题而编制的程序。如，</p>
<p>聊天软件、各类电子邮件软件、工程设计类软件等。</p>
</blockquote>
</li>
<li><p><strong>三个级别的语言</strong></p>
<blockquote>
<p>这虽然不属于计算机的软件，但也分类到这了</p>
<ul>
<li><p><strong>高级语言：</strong>为方便编程人员写出解决问题的处理方案和解题过程的程序。通常高级语言也分为两类：</p>
<blockquote>
<ul>
<li><p><strong>编译型语言：</strong>一类是经过编译程序译成<strong>汇编语言</strong>，然后经过汇编操作得到<strong>机器语言程序</strong>（如，C、C++、JAVA等），这类语言的程序称为<strong>编译程序</strong>。</p>
</li>
<li><p><strong>解释性语言：</strong>另一类则是直接由<strong>高级语言</strong>翻译成<strong>机器语言程序</strong>（如，shell、python等），这类语言的程序称为<strong>解释程序</strong>。</p>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="3、计算机的工作过程"><a href="#3、计算机的工作过程" class="headerlink" title="3、计算机的工作过程"></a>3、计算机的工作过程</h3><blockquote>
<ul>
<li><strong>把程序和数据装入主存储器</strong></li>
<li><strong>把源程序转换成可执行文件</strong></li>
<li><strong>从可执行文件的首地址开始逐条执行指令</strong></li>
</ul>
</blockquote>
<h4 id="3-1、从源程序到可执行文件"><a href="#3-1、从源程序到可执行文件" class="headerlink" title="3.1、从源程序到可执行文件"></a>3.1、从源程序到可执行文件</h4><blockquote>
<p>以下以GCC编译器为例：</p>
<ul>
<li><strong>预处理阶段：</strong>预处理器（cpp）对源程序中以字符#开头的命令进行处理，例如将**#include<strong>命令后面的</strong>.h文件<strong>内容插入程序文件中，输出一个以</strong>.i为拓展名的源文件**</li>
<li><strong>编译阶段：</strong>编译器（ccl）对预处理后的源程序进行编译，生成一个<strong>汇编语言程序xxx.s</strong></li>
<li><strong>汇编阶段：</strong>汇编器（as）将xxx.s翻译成机器语言指令，并把这些指令打包成一个称为<strong>可重定位目标文件的xxx.o</strong>（一种二进制文件）。</li>
<li><strong>链接阶段：</strong>连接器（ld）将多个可重定位目标文件和标准库函数合并为一个可执行目标文件，即<strong>可执行文件xxx.exe</strong>。</li>
</ul>
</blockquote>
<h4 id="3-2、指令执行过程的描述"><a href="#3-2、指令执行过程的描述" class="headerlink" title="3.2、指令执行过程的描述"></a>3.2、指令执行过程的描述</h4><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/CPU%E5%86%85%E9%83%A8.png" alt="读取操作数"></p>
<ul>
<li><strong>取指令：</strong>PC—&gt;MAR—&gt;M(存储体)—&gt;MDR—&gt;IR</li>
<li><strong>分析指令：</strong>OP(IR)—&gt;CU</li>
<li><strong>执行指令：</strong>Ad(IR)—&gt;MAR—&gt;M(存储体)—&gt;MDR—&gt;ACC</li>
</ul>
</blockquote>
<h3 id="4、计算机系统的多级层次结构"><a href="#4、计算机系统的多级层次结构" class="headerlink" title="4、计算机系统的多级层次结构"></a>4、计算机系统的多级层次结构</h3><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="计算机系统的层次结构"></p>
</blockquote>
<h2 id="三、计算机性能指标"><a href="#三、计算机性能指标" class="headerlink" title="三、计算机性能指标"></a>三、计算机性能指标</h2><blockquote>
<ul>
<li><p><strong>机器字长：</strong>指计算机进行一次整数运算（即定点数运算）所能处理的二进制数据的位数，通常与CPU的寄存器位数、加法器有关。</p>
</li>
<li><p><strong>数据通路带宽：</strong>指数据总线一次所能并行传送信息的位数。</p>
</li>
<li><p><strong>主存容量：</strong>指主存所能存储信息的最大容量，通常以字节为单位。</p>
<blockquote>
<p><strong>MAR的位数</strong>反映存储单元<strong>数量</strong></p>
<p><strong>MDR</strong>反映每个<strong>存储单元的大小</strong></p>
</blockquote>
</li>
<li><p><strong>CPU运行速度：</strong></p>
<blockquote>
<ul>
<li><p><strong>吞吐量：</strong>指系统在单位时间内处理请求的数量。</p>
</li>
<li><p><strong>响应时间：</strong>指用户发送一个请求到系统对该请求做出响应并获得所需结果的等待时间。（包括CPU时间与等待时间）</p>
</li>
<li><p><strong>CPU时钟周期：</strong>指节拍脉冲或T周期，即<strong>主频的倒数</strong>，是CPU中<strong>最小的时间单位</strong>，执行指令中每个动作至少需要一个时钟周期。</p>
</li>
<li><p><strong>主频（CPU时钟频率）：</strong>机器内主时钟的频率，其主频越高，完成指令的一个执行步骤所需的时间就越少。</p>
</li>
<li><p><strong>CPI：</strong>指运行一个程序所花费的时间</p>
</li>
<li><p><strong>CPU执行时间：</strong>指运行一个程序所花费的时间</p>
<blockquote>
<p>$$<br>CPU执行时间&#x3D;CPU时钟周期数&#x2F;主频&#x3D;(指令条数*CPI)&#x2F;主频<br>$$</p>
</blockquote>
</li>
<li><p><strong>MIPS：</strong>每秒执行多少百万条指令</p>
<blockquote>
<p>$$<br>MIPS&#x3D;指令跳数&#x2F;(执行时间 \times 10^6)&#x3D;主频&#x2F;(CPI \times 10^6)<br>$$</p>
<p><strong>注意：</strong>每台机器上CPI和主频都不一致，因此一条指令在不同机器上所用的时间也有所不同。</p>
</blockquote>
</li>
<li><p>MFLOPS、GFLOPS、TFLOPS、PFLOPS、EFLOPS和ZFLOPS</p>
<blockquote>
<p>MFLOPS：百万次浮点运算</p>
<p>GFLOPS：十亿次浮点运算</p>
<p>TFLOPS：万亿次浮点运算</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>基准程序：</strong>专门用来进行性能测试的一组程序。</p>
</li>
</ul>
<p><strong>注意：</strong>在描述<strong>存储容量、文件大小</strong>时，K、M、G、T等通常用<strong>2的幂次</strong>表示，如$1Kb&#x3D;2^{10}b$，而描述<strong>速率、频率</strong>时，k、M、G、T通常用<strong>10的幂次表示</strong>，如$1kb&#x2F;s&#x3D;10^3b&#x2F;s$.</p>
</blockquote>
<h2 id="四、一些补充"><a href="#四、一些补充" class="headerlink" title="四、一些补充"></a>四、一些补充</h2><blockquote>
<ul>
<li><p><strong>在CPU中，IR、MAR和MDR对程序员都是透明的</strong></p>
</li>
<li><p><strong>机器字长、指令字长、存储字长的区别与连系</strong></p>
<blockquote>
<p><strong>机器字长：</strong>计算机能直接处理的二进制数据的位数</p>
<p><strong>指令字长：</strong>一个指令字中包含的二进制代码的位数</p>
<p><strong>存储字长：</strong>一个存储单元存储的二进制代码的长度</p>
<p><strong>补充：</strong></p>
<ul>
<li><strong>它们都必须是字节的整数倍</strong></li>
<li><strong>指令字长一般取存储字长的整数倍</strong></li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>基础学科</tag>
      </tags>
  </entry>
  <entry>
    <title>数据的表示和运算</title>
    <url>/2022/08/08/2%E3%80%81%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h2 id="一、数制和编码"><a href="#一、数制和编码" class="headerlink" title="一、数制和编码"></a>一、数制和编码</h2><h3 id="1、数制"><a href="#1、数制" class="headerlink" title="1、数制"></a>1、数制</h3><blockquote>
<ul>
<li><strong>二进制：</strong>计算机中用的最多的计数制。二级制只有0和1两种数字符号，计数“逢二进一”，它的任意树为的权为$2^i$，其中i为所在位</li>
<li><strong>八进制：</strong>八进制是二进制的一种书写形式，其基数为8，共有0~7共8个不同的数字符号，计数“逢八进一”，只需要把二进制中的3位数码编制为一组就可以表示一位八进制</li>
<li><strong>十六进制：</strong>十六进制也是二进制的一种书写形式，基数为16，“逢十六进一”，共有0~9,A,B,C,D,E,F六个字符。只需要把二进制中的4位数码编制为一组就可以表示一位十六进制</li>
</ul>
</blockquote>
<h3 id="2、进制数之间的转换"><a href="#2、进制数之间的转换" class="headerlink" title="2、进制数之间的转换"></a>2、进制数之间的转换</h3><blockquote>
<ul>
<li><p><strong>二进制转八进制或十六进制：</strong></p>
<blockquote>
<p> 对于一个二进制混合数（既有整数部分，又有小数部分），在转换时以小数点为界，向高位（小数部分则向低位）补0至整数部分的位数为3或4的倍数，然后将其分成3位或4位一组，然后将各分组转换成八进制或十六进制数。</p>
<p><strong>例子：</strong></p>
<blockquote>
<p>00111100001.00110</p>
<p><strong>转八进制：</strong>000 111 100 001 . 001 100 —&gt; 0 7 4 .1 4 —&gt;74.14(八进制数)</p>
<p><strong>转十六进制：</strong>0001 1110 0001 . 0011 0000 —&gt; 1 E 1 . 3 0 —&gt; 1E1.3（十六进制数）</p>
</blockquote>
</blockquote>
</li>
<li><p><strong>数任意数制转换成十进制：</strong></p>
<blockquote>
<p>将任意进制的各位数码与它们的权值相乘，再把乘积相加即可</p>
<p><strong>例子：</strong></p>
<blockquote>
<p>$$<br>(11011.1)_2 &#x3D; 1 \times2^4 + 1\times2^3+0\times2^2+1\times2^1+1\times2^0+1\times2^{-1}&#x3D;27.5<br>$$</p>
</blockquote>
</blockquote>
</li>
<li><p><strong>十进制数转换成任意数制：</strong></p>
<blockquote>
<p>一个十进制数转换成任意数制，常采用<strong>基数乘除法</strong>，对于一个十进制数，需要将其分成整数部分和小数部分：<strong>整数部分则用除基取余法</strong>，<strong>小数部分则用乘积取正法</strong>。</p>
<ul>
<li><p><strong>除基取余法（整数部分）：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E9%99%A4%E5%9F%BA%E5%8F%96%E4%BD%99%E6%B3%95.png" alt="除基取余法"></p>
<p>例如图上的例子，将<strong>十进制的75</strong>转成<strong>二进制数</strong>，每除完一次后得到的余数记录下来，最后将余数<strong>从下往上取</strong>，即在本例中$(75)_{10}$—&gt; $(1001011)_2$</p>
</li>
<li><p><strong>乘基取整法（小数部分）：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E4%B9%98%E5%9F%BA%E5%8F%96%E6%95%B4%E6%B3%95.png" alt="乘基取整法"></p>
<p>例如图上的例子，将<strong>十进制的0.3</strong>转换成<strong>二进制数</strong>，每<strong>乘完一次后就取一次结果的整数部分（无论0或1）</strong>，最后将取得数<strong>从上往下取</strong>，即在本例中$(0.3)_{10}$—&gt;$(0.01001..)_2$，实际上无法用有限位小数表示出来。</p>
</blockquote>
</li>
</ul>
<p><strong>补充：</strong>在计算机中整数可以连续表示，但小数却是离散的，因此<strong>不是所有的十进制小数都可以用二进制数表示出来，但所有的二进制小数都可以用十进制数表示</strong>。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="3、真值和机器数"><a href="#3、真值和机器数" class="headerlink" title="3、真值和机器数"></a>3、真值和机器数</h3><blockquote>
<ul>
<li><strong>真值：</strong>在生活中可以用正负号来分别表示正负数，如+12，-11等，这种带正负号的数被称为<strong>真值</strong>，<strong>真值是机器数所代表的实际值</strong>。</li>
<li><strong>机器数：</strong>在计算机中，通常采用数符和数值一起编码的方法来表示数值，常有原码、反码、补码等，例如-5的原码为1,101，6的原码为0,110等，<strong>把符号数字化的数称为机器数</strong>。</li>
</ul>
</blockquote>
<h3 id="4、字符和字符串"><a href="#4、字符和字符串" class="headerlink" title="4、字符和字符串"></a>4、字符和字符串</h3><h4 id="4-1、字符编码ASCII码"><a href="#4-1、字符编码ASCII码" class="headerlink" title="4.1、字符编码ASCII码"></a>4.1、字符编码ASCII码</h4><blockquote>
<p>国际上普遍采用的一种字符系统是<strong>7位二进制</strong>编码的ASCII码（每个字节的最高位保持为0）</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/ascii%E8%A1%A8.png" alt="除基取余法"></p>
<ul>
<li>其中0<del>31号为<strong>控制字符</strong>，用于通信系统或设备的功能控制（<strong>无法打印</strong>）；编码127是DEL码；编码32是空格码；编码32</del>126为<strong>可印刷字符</strong>。</li>
<li>0<del>9的ASCII码为48(011 0000) ~ 57(011 1001)，即去掉高3位，只保留低4位，正好是二进制形式的0</del>9.</li>
</ul>
</blockquote>
<h4 id="4-2、汉字的表示与编码"><a href="#4-2、汉字的表示与编码" class="headerlink" title="4.2、汉字的表示与编码"></a>4.2、汉字的表示与编码</h4><blockquote>
<p>在1981年所实施的国家标准中，每个编码用两个字节表示。</p>
<p>目前最新的汉字编码是2000年公布的GB 18030，它收录了27484个汉字，编码标准采用1B、2B和4B。</p>
<p>汉字的编码包括汉字的<strong>输入编码</strong>、<strong>汉字内码</strong>、<strong>汉字字形码</strong>三种，它们分别是计算机中用于<strong>输入、内部处理、输出</strong>三种用途的编码。</p>
<p>其中<strong>输入编码</strong>又分为：<strong>区位码</strong>和<strong>国标码</strong></p>
<ul>
<li><strong>区位码：</strong></li>
</ul>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E5%8C%BA%E4%BD%8D%E7%A0%81.png" alt="区位码"></p>
<p>在区位码中，1980年的标准是将汉字和图形符号排列在一个94行94列的二维代码表中，一共4位十进制数，前两位是<strong>区码</strong>，后两位是<strong>位码</strong>。</p>
</blockquote>
<ul>
<li><p><strong>国标码：</strong>为了防止区位码的区码或位码与ASCII码中的控制字符混淆，因此在原基础上+20H，因此形成了国标码。</p>
</li>
<li><p><strong>汉字内码：</strong>为了方便计算机区分中文字符和英文字符，将国标码两字节的最高位都改成了1，这就是汉字内码。</p>
</li>
</ul>
<p>$$<br>国标码&#x3D;(区位码)<em>{16}+2020H\<br>汉字内码&#x3D;(国标码)</em>{16}+8080H<br>$$</p>
</blockquote>
<h2 id="二、定点数的表示与运算"><a href="#二、定点数的表示与运算" class="headerlink" title="二、定点数的表示与运算"></a>二、定点数的表示与运算</h2><h3 id="1、定点数的表示"><a href="#1、定点数的表示" class="headerlink" title="1、定点数的表示"></a>1、定点数的表示</h3><blockquote>
<ul>
<li><p><strong>有符号数和无符号数的表示：</strong></p>
<blockquote>
<ul>
<li><strong>无符号数：</strong>指整个机器字长全部二进制位都是数值位，没有符号位，且默认为正数。如，$(110010)<em>2$—&gt;$(50)</em>{10}$</li>
<li><strong>有符号数：</strong>机器字长有一定的数值位作符号位，<strong>有符号数用1来表示负数，用0来表示正数</strong>。有符号数约定符号位在最左端，后面跟着的是数值位。如，$(1,001)<em>2$—&gt;$(-1)</em>{10}$，$(0,001)<em>2$—&gt;$(+1)</em>{10}$。（机器中二进制有符号数是没有逗号的，这里加上仅为了方便查看）</li>
</ul>
</blockquote>
</li>
<li><p><strong>机器数的定点表示：</strong></p>
<blockquote>
<ul>
<li><p><strong>定点小数：</strong></p>
<blockquote>
<p>定点小数就是纯小数，约定<strong>小数点在符号位之后、有效数值部分最高位之前</strong>。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E5%AE%9A%E7%82%B9%E5%B0%8F%E6%95%B0.png" alt="定点小数"></p>
<ul>
<li><strong>最大值：</strong>当$x_0&#x3D;0$，其余位全为1时，能取到定点小数的最大值：$1-2^{-n}$</li>
<li><strong>最小值：</strong>当$x_0&#x3D;1$，其余位全为1时，能取到定点小数的最小值：$-(1-2^{-n})$</li>
</ul>
</blockquote>
</li>
<li><p><strong>定点整数：</strong></p>
<blockquote>
<p>定点整数就是纯整数，约定<strong>小数点在最低有效位之后</strong>。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E5%AE%9A%E7%82%B9%E6%95%B4%E6%95%B0.png" alt="定点整数"></p>
<ul>
<li><strong>最大值：</strong>当$x_0&#x3D;0$，其余位全为1时，能取到定点整数的最大值：$2^n-1$</li>
<li><strong>最小值：</strong>当$x_0&#x3D;1$，其余位全为1时，能取到定点整数的最大值：$-(2^n-1)$</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>原码、反码、补码、移码</strong></p>
<blockquote>
<ul>
<li><p><strong>几种码之间的转换：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E5%87%A0%E7%A7%8D%E7%A0%81%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.png" alt="几种码之间的转换"></p>
</blockquote>
</li>
<li><p><strong>原码：</strong></p>
<blockquote>
<p>原码是最简单的一种编码，<strong>除了第一位是符号位以外，其余位都是数的绝对值</strong>。如，$(1,101.11)<em>2&#x3D;(-5.75)</em>{10}$，$(0,110.01)<em>2&#x3D;(6.25)</em>{10}$</p>
<p><strong>补充：</strong></p>
<ul>
<li><strong>原码表示0有两种方式：</strong>$[0]_原&#x3D;0,0000&#x3D;1,0000$</li>
<li><strong>原码的取值范围关于原点对称</strong>。</li>
</ul>
</blockquote>
</li>
<li><p><strong>反码：</strong></p>
<blockquote>
<p>反码是原码转换成补码的中间过渡的阶段，其中规定：</p>
<ul>
<li><strong>正数的反码就是它的原码</strong>。如，$[0,1010]_原&#x3D;[0,1010]_反&#x3D;+10$</li>
<li><strong>负数的反码是将其数值位全部颠倒</strong>。如，$[1,1010]_原&#x3D;[1,0101]_反&#x3D;-10$</li>
</ul>
<p><strong>补充：</strong></p>
<ul>
<li><strong>反码表示0也有两种方式：</strong>$[0]_反&#x3D;0,0000&#x3D;1,1111$</li>
<li>因此反码与原码有类似性质，取值范围也是关于原点对称的</li>
</ul>
</blockquote>
</li>
<li><p><strong>补码：</strong></p>
<blockquote>
<p>由于原码作减法太过复杂，因此发明了补码来<strong>将加减法统一做成加法</strong>。补码与反码类似：</p>
<ul>
<li><strong>正数的反码就是它的原码</strong>。如，$[0,1010]_原&#x3D;[0,1010]_补&#x3D;+10$</li>
<li><strong>负数的补码就是其反码+1。</strong>如，$[1,1010]_原&#x3D;[1,0110]_补&#x3D;-10$</li>
</ul>
<p><strong>补充：</strong></p>
<ul>
<li><strong>补码的0只有1种表达方式：</strong>$[+0]&#x3D;[-0]&#x3D;[0.0000]_补$</li>
<li><strong>若字长为n+1，可以表示的小数范围：</strong>$-1 \le x \le 1-2^{-n}$（比原码多一个-1）;<strong>可以表示的整数范围：</strong>$-2^n \le x \le 2^n-1$（比原码多一个-2）</li>
<li><strong>技巧1</strong>  $[X]_补$求$[-X]_补$d的快速方法：将<strong>符号位、数值位全部取反，末位+1</strong>。</li>
<li><strong>技巧2</strong> 补码和原码的快速转换：<strong>在数值位上从右往左找到第一个1，以此为界，左边的位数全部取反，右边的位数全部不变。</strong>（如果数值位全为0，那它的补码就是0）</li>
</ul>
</blockquote>
</li>
<li><p><strong>移码：</strong></p>
<blockquote>
<p><strong>移码的定义</strong>：真值+偏置值（通常为$2^n$，n为真值的最高位，因此一般移码就是补码的基础上将符号位颠倒）。如，</p>
<ul>
<li><strong>正数的移码：</strong>$+0010101&#x3D;[1,0010101]_移$</li>
<li><strong>负数的移码：</strong>$-0010101&#x3D;[0,1101011]_移$</li>
</ul>
<p><strong>补充：</strong></p>
<ul>
<li>移码通常用于表示浮点数的阶码部分</li>
<li><strong>移码只能表示整数</strong></li>
<li><strong>移码可以使得正负整数进行排序</strong></li>
<li><strong>移码与补码有相似的性质，0的表示方式唯一，取值范围关于原点不对称</strong></li>
</ul>
</blockquote>
</li>
</ul>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E5%87%A0%E7%A7%8D%E7%A0%81%E8%A1%A8%E7%A4%BA%E5%AE%9A%E7%82%B9%E6%95%B4%E6%95%B0.png" alt="几种码表示定点整数"></p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="2、定点数的运算"><a href="#2、定点数的运算" class="headerlink" title="2、定点数的运算"></a>2、定点数的运算</h3><h4 id="2-1、定点数的移位运算"><a href="#2-1、定点数的移位运算" class="headerlink" title="2.1、定点数的移位运算"></a>2.1、定点数的移位运算</h4><blockquote>
<ul>
<li><p><strong>算术移位：</strong></p>
<blockquote>
<p>算术移位的对象是<strong>有符号数</strong>，在移位过程中<strong>符号位不变</strong>的移位操作被称作<strong>算术移位</strong>，例如：</p>
<p>$[1,1001]_原 (算术左移一位)—&gt; [1,0010]_原$</p>
<p><strong>注：</strong> <strong>原码</strong>的左移和右移时，最低&#x2F;高位都是补0，<strong>负数的补码、移码</strong>左右移时，最高位补1，最低位补0.</p>
<p><strong>算术移位的应用：二进制中算术左移就相当于乘以2，右移就相当于除以2（在不溢出的情况下）</strong></p>
</blockquote>
</li>
<li><p><strong>逻辑移位：</strong></p>
<blockquote>
<p><strong>逻辑移位将操作数视作无符号数</strong>，即逻辑左移的时候，最低位补0；逻辑右移的时候，最高位补0.</p>
<p><strong>注意：逻辑移位无论左移还是右移，都是补0</strong></p>
</blockquote>
</li>
<li><p><strong>循环移位：</strong></p>
<blockquote>
<p><strong>循环移位将操作数的最高位与最低位连接起来</strong>，即在循环左移时，最高位会去到最低位上；在循环右移时，最低位会去到最高位上，例如（无进位的循环移位）</p>
<p>$[1,0010]_原 (循环左移一位)—&gt; [0,0101]_原$</p>
<p><strong>循环移位的类型：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E5%BE%AA%E7%8E%AF%E7%A7%BB%E4%BD%8D.png" alt="循环移位"></p>
<ul>
<li><strong>补充：</strong>进位位(CF)类似于符号位，是用于表示上一级计算是否产生了进位。</li>
<li><strong>循环移位的应用：大端存储与小端存储的转换</strong></li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="2-2、定点数的加减法运算"><a href="#2-2、定点数的加减法运算" class="headerlink" title="2.2、定点数的加减法运算"></a>2.2、定点数的加减法运算</h4><blockquote>
<ul>
<li><p><strong>原码定点数的加减法：</strong></p>
<blockquote>
<ul>
<li><strong>加法原则：</strong> <strong>先判定符号位</strong>，若<strong>相同</strong>，则<strong>绝对值相加</strong>，结果符号位不变；若<strong>不同</strong>，则<strong>做减法</strong>，<strong>绝对值大的数减去绝对值小的数</strong>，结果的符号位取绝对值大的数。</li>
<li><strong>减法原则：</strong>两个原码数相减，首先将减数的<strong>符号位取反</strong>，然后<strong>将被减数与减数按原码作加法</strong>运算。</li>
</ul>
</blockquote>
</li>
<li><p><strong>补码定点数的加减法：</strong></p>
<blockquote>
<p>补码的加减法运算规则简单，且加法与减法的步骤一致，因此<strong>计算机更常用补码的加减法运算</strong></p>
<p><strong>特点：</strong></p>
<ul>
<li><p>参与运算的操作数都用补码表示</p>
</li>
<li><p>按二进制的运算规则进行运算</p>
</li>
<li><p><strong>符号位与操作数一起参与运算，符号位运算产生的进位需要丢弃，且结果的符号位由运算得出</strong></p>
</li>
<li><p><strong>补码加减法运算的公式：</strong><br>$$<br>加法:[A+B]_补 &#x3D; [A]_补+[B]_补\<br>减法:[A-B]_补&#x3D;[A]_补+[-B]_补<br>$$</p>
</li>
<li><p>补码运算后的结果也是补码。</p>
</li>
</ul>
<p><strong>例子：</strong></p>
<blockquote>
<p>$A&#x3D;15,B&#x3D;24,求[A+B]_补和[A-B]_补$</p>
<ul>
<li>$[A]_补&#x3D;0,0001111,[B]_补&#x3D;0,0011000,[-B]_补&#x3D;[1,1101000]$</li>
<li>$[A+B]_补&#x3D;[A]_补+[B]_补&#x3D;0,0001111+0,0011000&#x3D;0,0100111&#x3D;+39$</li>
<li>$[A-B]_补[A]_补+[-B]_补&#x3D;0,0001111+1,1101000&#x3D;1,1110111&#x3D;-9$</li>
</ul>
</blockquote>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="2-3、符号扩展"><a href="#2-3、符号扩展" class="headerlink" title="2.3、符号扩展"></a>2.3、符号扩展</h4><blockquote>
<p><strong>定义：</strong>在8位数（低位数）与32位数（高位数）相互运算时，8位数（低位数）需要扩展到32位（高位数）的操作被称为符号扩展。</p>
<ul>
<li><strong>原码：</strong>在原来的基础上直接补0，符号位提到扩展后的最高位。</li>
<li><strong>补码：</strong>如果在左侧进行扩展，则补1；在右侧进行扩展，则补0，符号位提到扩展后的最高位。</li>
</ul>
</blockquote>
<h4 id="2-4、溢出的概念与溢出的判断"><a href="#2-4、溢出的概念与溢出的判断" class="headerlink" title="2.4、溢出的概念与溢出的判断"></a>2.4、溢出的概念与溢出的判断</h4><blockquote>
<p><strong>概念：</strong></p>
<blockquote>
<ul>
<li><strong>上溢：</strong>运算结果<strong>超过</strong>机器所能表达的<strong>最大正数</strong>.</li>
<li><strong>下溢：</strong>运算结果<strong>超过</strong>机器所能表达的<strong>最大负数</strong>.</li>
</ul>
</blockquote>
<p><strong>溢出判断：</strong></p>
<blockquote>
<ul>
<li><p><strong>采用一位符号位：</strong></p>
<blockquote>
<p>由于在补码的运算中，无论是加法还是减法，都是通过加法运算，因此<strong>如果两个操作数的符号位相同，而结果的符号位不同，那么判断为溢出。</strong></p>
<p><strong>判断公式：</strong></p>
<blockquote>
<p> 设A的符号为$A_S$，B的符号为$B_S$，结果的符号为$R_S$，那么有：<br>$$<br>V&#x3D;A_SB_S\overline{R_S}(判断上溢)+\overline{A_SB_S}R_S(判断下溢)<br>$$<br><strong>若V&#x3D;1那么就发生溢出；V&#x3D;0就无溢出</strong></p>
</blockquote>
</blockquote>
</li>
<li><p><strong>采用一位符号位根据数据位的进位情况判断溢出：</strong></p>
<blockquote>
<p>设<strong>符号位的进位</strong>为$C_s$，<strong>最高位的进位</strong>为$C_h$.</p>
<ul>
<li>若$C_s$与$C_h$相同，那么说明没有溢出</li>
<li>若$C_s$与$C_h$不相同，那么说明发生溢出</li>
</ul>
</blockquote>
</li>
<li><p><strong>采用双符号位：</strong></p>
<blockquote>
<p>每个操作数拥有两个符号位$S_1S_2$，当$S_1S_2&#x3D;11$时表示负数，$S_1S_2&#x3D;00$时表示正数。</p>
<p><strong>双符号位也称为模4补码</strong>，运算结果的两个符号位$S_1S_2$相同则表示没有溢出，不同则表示发生溢出。</p>
<ul>
<li>$S_1S_2&#x3D;00$，表示结果为正数，且没发生溢出。</li>
<li>$S_1S_2&#x3D;01$，表示本应得到正数，实际得到了负数，发生上溢。</li>
<li>$S_1S_2&#x3D;10$，表示本应得到负数，实际得到了正数，发生下溢。</li>
<li>$S_1S_2&#x3D;11$，表示结果为负数，且没有发生溢出。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<h4 id="2-5、定点数的乘法运算"><a href="#2-5、定点数的乘法运算" class="headerlink" title="2.5、定点数的乘法运算"></a>2.5、定点数的乘法运算</h4><blockquote>
<ul>
<li><p><strong>原码一位乘法</strong></p>
<blockquote>
<p><strong>特点：</strong></p>
<blockquote>
<ul>
<li>原码一位乘法分为两部分处理：<strong>符号位处理</strong>和<strong>数值位处理</strong></li>
<li><strong>两个数值位都视作无符号数来进行操作</strong></li>
</ul>
</blockquote>
<p><strong>符号位处理：</strong></p>
<blockquote>
<p>设$s_1$为第一个数的符号位，$s_2$为第二个数的符号位，$R$为结果的符号位：<br>$$<br>R&#x3D;s_1 \oplus s_2<br>$$<br><strong>结果的符号位可以由两个操作数进行异或运算得出</strong></p>
</blockquote>
<p><strong>数值位处理：</strong></p>
<blockquote>
<ul>
<li>从乘数$x_1$的最低位开始判断：若$y_n&#x3D;1$，则<strong>部分积加上被乘数</strong>$|x_2|$，<strong>然后右移一位</strong>；若$y_n&#x3D;0$，则<strong>部分积加上0，然后右移一位</strong></li>
<li>乘数有多少位，上述步骤就重复多少遍。</li>
</ul>
<p><strong>例子：</strong></p>
<blockquote>
<p><strong>乘数</strong>$x_1&#x3D;00.1011$，<strong>被乘数</strong>$x_2&#x3D;00.1101$</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E5%8E%9F%E7%A0%81%E4%B9%98%E6%B3%95%E4%BE%8B%E5%AD%90.png" alt="原码乘法例子"></p>
<p><strong>符号位：</strong>$00 \oplus 00&#x3D;00$,所以结果为$00.1000 1111$</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><p><strong>补码一位乘法</strong></p>
<blockquote>
<p>补码的一位乘法比较简单，<strong>符号位与数值位一起运算</strong></p>
<p><strong>补码的一位乘法在乘数的最后面多加了一位辅助位</strong>$y_2$(且一开始默认为0)，设<strong>乘数的最后一位</strong>为$y_1$</p>
<p><strong>运算规则：</strong></p>
<blockquote>
<ul>
<li>如果$y_1&#x3D;0,y_2&#x3D;0$，那么部分积直接右移一位</li>
<li>如果$y_1&#x3D;0,y_2&#x3D;1$，那么部分积加$[x]_补$，然后右移一位</li>
<li>如果$y_1&#x3D;1,y_2&#x3D;0$，那么部分积加$[-x]_补$，然后右移一位</li>
<li>如果$y_1&#x3D;1,y_2&#x3D;1$，那么部分积直接右移一位</li>
</ul>
</blockquote>
<p><strong>例子：</strong></p>
<blockquote>
<p><strong>乘数</strong>$s_1&#x3D;0.1011$，<strong>被乘数</strong>$s_2&#x3D;00.1101$</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E8%A1%A5%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95%E7%9A%84%E4%BE%8B%E5%AD%90.png" alt="补码一位乘法的例子"></p>
<p><strong>所以最后结果为</strong>$[11.0111 0001]_补$</p>
</blockquote>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="2-6、定点数的除法运算"><a href="#2-6、定点数的除法运算" class="headerlink" title="2.6、定点数的除法运算"></a>2.6、定点数的除法运算</h4><blockquote>
<ul>
<li><p><strong>恢复余数法</strong></p>
<blockquote>
<p>恢复余数法属于一种试错的方法，每一次做除法时都默认上商1，如果余数为负数（表明不够除了），那么就加回被除数再运算。</p>
<p><strong>运算步骤：</strong></p>
<blockquote>
<ul>
<li>上商1，除数减去被除数</li>
<li>如果余数为正，那么左移一位；如果余数为负，那么余数加回被除数，上商0，再左移</li>
<li>重复上述两步</li>
</ul>
<p><strong>例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E6%81%A2%E5%A4%8D%E4%BD%99%E6%95%B0%E6%B3%95%E4%BE%8B%E5%AD%90.png" alt="恢复余数法例子"></p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><p><strong>原码加减交替法（不恢复余数法）</strong></p>
<blockquote>
<p>加减交替法又称不恢复余数法，<strong>加减交替法实际上是根据优化恢复余数得来的</strong></p>
<p>原码的加减交替法也是分开<strong>符号位</strong>和<strong>数值位</strong>两部分的操作</p>
<p><strong>运算步骤：</strong></p>
<blockquote>
<ul>
<li><strong>符号位</strong>进行<strong>异或运算</strong>，得到商的符号位</li>
<li><strong>数值位</strong>先用<strong>被除数</strong>减去<strong>除数</strong></li>
<li>当余数为正时，上商1，余数和商左移一位，再减去除数（即加上除数负数的补码）</li>
<li>当余数为负时，上商0，余数和商左移一位，再加上除数</li>
<li>当第n+1步余数为负时，需要加上除数得到第n+1步正确的余数（保证余数不是负数）</li>
</ul>
</blockquote>
<p><strong>例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E5%8A%A0%E5%87%8F%E4%BA%A4%E6%9B%BF%E6%B3%95%E4%BE%8B%E5%AD%90.png" alt="加减交替法例子"></p>
</blockquote>
</blockquote>
</li>
<li><p><strong>补码的加减交替法</strong></p>
<blockquote>
<p>补码的加减交替法的特点是<strong>符号位与数值位一起参与运算，商自然形成</strong></p>
<p><strong>运算步骤：</strong></p>
<blockquote>
<ul>
<li>若<strong>被除数与除数同号</strong>，则被除数减去除数；若<strong>被除数与除数异号</strong>，则被除数加上除数</li>
<li>若<strong>余数与除数同号</strong>，则上商1，余数左移一位减去除数；若<strong>余数与除数异号</strong>，则上商0，余数左移一位加上除数</li>
<li>重复上步骤n次</li>
<li>如果对商的精度没有特殊要求，则一般采用“<strong>末位恒置1</strong>”法。</li>
</ul>
</blockquote>
<p><strong>例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E8%A1%A5%E7%A0%81%E5%8A%A0%E5%87%8F%E4%BA%A4%E6%9B%BF%E6%B3%95%E7%9A%84%E4%BE%8B%E5%AD%90.png" alt="补码加减交替法的例子"></p>
</blockquote>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="3、C语言中整数类型的转换"><a href="#3、C语言中整数类型的转换" class="headerlink" title="3、C语言中整数类型的转换"></a>3、C语言中整数类型的转换</h3><h4 id="3-1、有符号数与无符号数的转换"><a href="#3-1、有符号数与无符号数的转换" class="headerlink" title="3.1、有符号数与无符号数的转换"></a>3.1、有符号数与无符号数的转换</h4><blockquote>
<p>C语言允许在不同的数据类型之间做强制转换，<strong>而有符号数与无符号数的转换则是：二进制的位数不变，但首位的意义变了</strong></p>
<ul>
<li><p><strong>有符号数转无符号数：</strong></p>
<blockquote>
<p> 有符号数的符号位并入了数值位，即<br>$$<br>-3&#x3D;[1,0011]<em>{有符号} \to [1 0011]</em>{无符号}&#x3D;19<br>$$</p>
</blockquote>
</li>
<li><p><strong>无符号数转有符号数：</strong></p>
<blockquote>
<p>无符号数的第一位变成了符号位</p>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="3-2、不同字长整数间的转换"><a href="#3-2、不同字长整数间的转换" class="headerlink" title="3.2、不同字长整数间的转换"></a>3.2、不同字长整数间的转换</h4><blockquote>
<p>不同字长正数间的转换分为两类：<strong>长—&gt;短</strong>与<strong>短—&gt;长</strong></p>
<ul>
<li><p><strong>长—&gt;短</strong></p>
<blockquote>
<p>高位截断，保留低位，如</p>
<p>b—&gt;a,b&#x3D;0x 00007751,a&#x3D;0x 7751</p>
</blockquote>
</li>
<li><p><strong>短—&gt;长</strong></p>
<blockquote>
<p>直接高位补0（负数的补码就补1）即可，如</p>
<p>a—&gt;b,a&#x3D;0x 7751,b&#x3D;0x 00007751</p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="4、数据的存储和排列"><a href="#4、数据的存储和排列" class="headerlink" title="4、数据的存储和排列"></a>4、数据的存储和排列</h3><h4 id="4-1、大小端存储"><a href="#4-1、大小端存储" class="headerlink" title="4.1、大小端存储"></a>4.1、大小端存储</h4><blockquote>
<ul>
<li><p><strong>大端存储</strong></p>
<blockquote>
<p>按<strong>从最高有效字节到最低有效字节的顺序存储数据</strong>，即<strong>最高位有效数字放在前面</strong></p>
<p><strong>例如采用大端存储的方式来存储：</strong>01234567H</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E5%A4%A7%E7%AB%AF%E5%AD%98%E5%82%A8.png" alt="大端存储"></p>
</blockquote>
</li>
<li><p><strong>小端存储</strong></p>
<blockquote>
<p>按<strong>从最低位有效数字到最高有效数字的顺序存储数据</strong>，即<strong>最低位有效数字在前面</strong></p>
<p><strong>例如采用小端存储的方式来存储：</strong>01234567H</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E5%B0%8F%E7%AB%AF%E5%AD%98%E5%82%A8.png" alt="小端存储"></p>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="4-2、数据的”边界对齐“存储"><a href="#4-2、数据的”边界对齐“存储" class="headerlink" title="4.2、数据的”边界对齐“存储"></a>4.2、数据的”边界对齐“存储</h4><blockquote>
<p>对于计算机，每次读取数据的时候都是直接读取一个字长的数据（这里假设字长为32位），存储单元也是按照字长的长度来规定一行占多少位。有时候存储某些数据的时候，可能会碰到某一行放不下某个数据了，如果将这个数据分两行放，每次读取时又要读两次，从而陷入尴尬的情况。</p>
<p>为了解决这个问题，有人提出了“边界对齐”的存储方式，即<strong>通过填充空字符，让原本要分两行放的数据，全部放到下一行里</strong>，即</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E8%BE%B9%E7%95%8C%E5%AF%B9%E9%BD%90.png" alt="边界对齐"></p>
<p><strong>优点：</strong>每次读取数据的时候都是读取了一整个的数据，不会出现读取某个数据要分两次读取，使得每次读取时都是一整个字。</p>
<p><strong>缺点：</strong>造成部分存储空间的浪费</p>
</blockquote>
<h2 id="三、浮点数的表示和运算"><a href="#三、浮点数的表示和运算" class="headerlink" title="三、浮点数的表示和运算"></a>三、浮点数的表示和运算</h2><h3 id="1、浮点数的表示"><a href="#1、浮点数的表示" class="headerlink" title="1、浮点数的表示"></a>1、浮点数的表示</h3><blockquote>
<p><strong>浮点数的表示格式：</strong></p>
<blockquote>
<p>通常浮点数表示为：<br>$$<br>N&#x3D;r^E \times M<br>$$<br>其中，</p>
<ul>
<li><strong>N为浮点数的真实值</strong></li>
<li><strong>r为浮点数表示的基数</strong>，如$1.2 \times 10^2$中的10</li>
<li><strong>E称为阶码，在浮点数中为定点整数</strong></li>
<li><strong>M称为尾数，在浮点数中一般为定点小数</strong></li>
</ul>
<p><strong>计算机存储浮点数的格式：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA.png" alt="浮点数的表示"></p>
<ul>
<li><strong>阶码为整数</strong>，阶码的大小表示了浮点数的<strong>表示范围</strong></li>
<li><strong>阶符表示阶码的正负性</strong></li>
<li><strong>尾数为小数，</strong>尾数的大小表示了浮点数的<strong>精确度</strong></li>
<li><strong>数符表示浮点数的正负性</strong></li>
</ul>
</blockquote>
<p><strong>规格化浮点数</strong></p>
<blockquote>
<p>为了使得浮点数的位数得到充分利用（使得精确度达到最大），通常需要规格化来对浮点数进行调整，最后<strong>使得尾数的数值部分的最高位上是一个有效数字</strong>。</p>
<ul>
<li><p><strong>左规：</strong></p>
<blockquote>
<ul>
<li><strong>尾数算术左移一位</strong></li>
<li><strong>阶码部分减一</strong></li>
</ul>
</blockquote>
</li>
<li><p><strong>右规：</strong></p>
<blockquote>
<ul>
<li><strong>尾数算术右移一位</strong></li>
<li><strong>阶码部分加一</strong></li>
</ul>
</blockquote>
</li>
</ul>
<p>当浮点数的基数为2时，<strong>原码在规格化后，尾数的最高位一定是1（小数点右边第一位）</strong>；<strong>补码在规格化后，尾数的最高位一定与数符位相反</strong>。</p>
<p>当然，如果浮点数的基数为4时，原码在规格化后，<strong>尾数最高的两位一定为1</strong>；基数为8时以此类推。</p>
</blockquote>
<p><strong>IEEE 754标准</strong></p>
<blockquote>
<p>按照IEEE 754标准，常用的浮点数的格式如图所示，</p>
<blockquote>
<p>![IEEE 754标准](&#x2F;picture&#x2F;学习&#x2F;计算组成原理上的图&#x2F;数据的表示和运算&#x2F;IEEE 754标准.png)</p>
<ul>
<li><strong>数符表示为该浮点数的正负性</strong></li>
<li><strong>阶码部分用移码表示，偏置值为+127（float类型）</strong>，即对于每一个<strong>阶码只要减去127</strong>就是该浮点数的阶数（float类型）</li>
<li><strong>尾数部分用原码表示，且尾数隐藏了一个最高位，其默认值为1</strong></li>
</ul>
<p><strong>注意：</strong> <strong>阶码为全1的时候表示无穷大</strong></p>
</blockquote>
<p><strong>不同类型的浮点数：</strong></p>
<blockquote>
<p> <img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/IEEE754%E6%A0%87%E5%87%86%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B1%BB%E5%9E%8B.png" alt="IEEE754标准的浮点数类型"></p>
<p><strong>以短浮点数为例：</strong></p>
<ul>
<li><strong>最高位为数值的符号位</strong></li>
<li>阶码有8位，<strong>偏置值为</strong>$2^8-1&#x3D;127$</li>
<li>后23位为尾数位，但通过规格化后，<strong>尾数总是1.xxx，因此通常尾数都会省略小数点左边的那一位</strong>。（所以说23位的尾数可以表示24位的数）</li>
</ul>
</blockquote>
<p><strong>IEEE 754浮点数的表示范围：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/IEEE754%E7%9A%84%E8%A1%A8%E7%A4%BA%E8%8C%83%E5%9B%B4.png" alt="IEEE754的表示范围"></p>
<p><strong>最大绝对值：</strong>尾数部分为 1.11…1&#x3D;$2-2^{-23}$；阶数部分为 $2^{254-127}&#x3D;2^{127}$;所以合起来就等于$2^{127} \times (2-2^{-23})$</p>
</blockquote>
</blockquote>
<p><strong>浮点数与定点数的表示（相同位数下）：</strong></p>
<blockquote>
<ul>
<li><strong>数值的表示范围：</strong>浮点数的表示范围远大于定点数的表示范围。</li>
<li><strong>数值的精确度：</strong>浮点数的精确度不及定点数的精确度。</li>
<li><strong>数的运算：</strong>浮点数的运算远比定点数的运算复杂。</li>
<li><strong>溢出问题：</strong>浮点数只有在规格化时出现的溢出才是真正的溢出，定点数在计算时发生溢出就是真正的溢出了。</li>
</ul>
</blockquote>
</blockquote>
<h3 id="2、浮点数的加减运算"><a href="#2、浮点数的加减运算" class="headerlink" title="2、浮点数的加减运算"></a>2、浮点数的加减运算</h3><blockquote>
<p><strong>浮点数的运算特点是：阶码运算和尾数运算分开</strong></p>
<p><strong>浮点数的加减法统一使用补码运算</strong>，以下是浮点数的加减运算：</p>
<ul>
<li><p><strong>对阶</strong></p>
<blockquote>
<p>浮点数的对阶目的是<strong>使两个操作数的小数点对齐</strong>，即<strong>阶码相同</strong>。</p>
<p><strong>浮点数的对阶是：小阶向大阶对齐</strong>（反过来的话会导致大阶的精度下降）</p>
</blockquote>
</li>
<li><p><strong>尾数求和</strong></p>
<blockquote>
<p>两个操作数的尾数<strong>按照定点数的加减运算来求和（补码运算）</strong>。</p>
</blockquote>
</li>
<li><p><strong>规格化</strong></p>
<blockquote>
<p>将浮点数进行规格化，详细可参考前面的<strong>规格化浮点数</strong>。</p>
<p>主要是：<strong>左规</strong>和<strong>右规</strong></p>
</blockquote>
</li>
<li><p><strong>舍入</strong></p>
<blockquote>
<p>在<strong>对阶</strong>和<strong>规格化</strong>的过程中，可能会将尾数低位丢失，从而引起误差。因此这里介绍两种常见的舍入方式：</p>
<ul>
<li><p><strong>“0”舍“1”入法：</strong></p>
<blockquote>
<p>类似于十进制的“四舍五入”法，即在尾数右移时，<strong>被移去的最高位数值为0，则舍去</strong>；<strong>被移去的最高位数值为1，则在尾数末位加1</strong>（如果这样导致溢出，则需要再做一次右规）</p>
</blockquote>
</li>
<li><p><strong>恒置“1”法：</strong></p>
<blockquote>
<p>尾数右移时，<strong>无论丢掉的最高位是“0”还是“1”，都使右移后的尾数末位恒置“1”</strong>。</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>溢出判断</strong></p>
<blockquote>
<p>浮点数的溢出判断需要在两个地方进行：<strong>尾数部分</strong>与<strong>阶码部分</strong></p>
<ul>
<li><strong>尾数部分：</strong>尾数部分的溢出不代表着结果就是溢出的，需要<strong>通过规格化操作</strong>，最后判断阶码部分是否产生溢出。</li>
<li><strong>阶码部分：</strong>当阶码大于最大阶码时，表示<strong>上溢</strong>，此时<strong>进入中断处理</strong>；当阶码小于最小阶码时，表示<strong>下溢</strong>，此时<strong>按机器零处理</strong>。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="3、C语言强制类型转换"><a href="#3、C语言强制类型转换" class="headerlink" title="3、C语言强制类型转换"></a>3、C语言强制类型转换</h3><blockquote>
<p>在C语言中<strong>float</strong>和<strong>double</strong>类型对应着IEEE 754<strong>单精度浮点数</strong>和<strong>双精度浮点数</strong>。<strong>long double</strong>类型对应于<strong>拓展双精度浮点数</strong>（长度和格式随着编译器和处理器类型的不同而不同）。</p>
<p>在C语言中等式的赋值和判断中常会出现强制类型转换，以<strong>char-&gt;int-&gt;long double</strong>和<strong>float-&gt;double</strong>，从前往后范围和精度都逐渐增大，转化过程没有损失。</p>
<ul>
<li><strong>从int转为float时：</strong> <strong>不产生溢出</strong>，但int保留32位，float保留24位（尾数位），因此会有数据舍入，导致<strong>精度缺失</strong>。</li>
<li><strong>从int或float转为double时：</strong>由于double的位数较多（尾数52位），因此<strong>不会造成溢出以及精度缺失</strong>。</li>
<li><strong>从double转为float或int时：</strong>由于位数的差距，因此既<strong>有可能造成溢出，也可能造成精度缺失</strong>。</li>
<li><strong>从float转成int时：</strong>由于浮点数的表示范围远大于整型，因此<strong>可能造成溢出</strong>，由于int只能表示整数，因此小数部分可能会被截去，从而造成<strong>精度缺失</strong>。</li>
</ul>
</blockquote>
<h2 id="四、算术逻辑单元"><a href="#四、算术逻辑单元" class="headerlink" title="四、算术逻辑单元"></a>四、算术逻辑单元</h2><h3 id="1、算术逻辑单元的功能和结构"><a href="#1、算术逻辑单元的功能和结构" class="headerlink" title="1、算术逻辑单元的功能和结构"></a>1、算术逻辑单元的功能和结构</h3><blockquote>
<p>运算器由<strong>算术逻辑单元（ALU）、累加器、状态寄存器和通用寄存器组成</strong>，其中最重要的是<strong>算术逻辑单元（ALU）</strong>，ALU的基本功能包括<strong>加、减、乘、除</strong>四则运算，<strong>与、或、非、异或</strong>等逻辑运算，以及<strong>移位、求补</strong>等操作。</p>
<p><strong>ALU结构图：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/ALU.png" alt="ALU"></p>
<p><strong>基本的逻辑运算：</strong></p>
<blockquote>
<ul>
<li><p><strong>与运算</strong></p>
<blockquote>
<p><strong>表达式：</strong>$Y&#x3D;A \cdot B $</p>
<p><strong>真值表：</strong></p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">Y</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p><strong>门电路：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E4%B8%8E%E9%97%A8.png" alt="与门"></p>
</blockquote>
</li>
<li><p><strong>或运算</strong></p>
<blockquote>
<p><strong>表达式：</strong>$Y&#x3D;A+B$</p>
<p><strong>真值表：</strong></p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">Y</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p><strong>门电路：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E6%88%96%E9%97%A8.png" alt="或门"></p>
</blockquote>
</li>
<li><p><strong>非运算</strong></p>
<blockquote>
<p><strong>表达式：</strong>$Y&#x3D;\overline{A}$</p>
<p><strong>真值表：</strong></p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">Y</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p><strong>门电路：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E9%9D%9E%E9%97%A8.png" alt="非门"></p>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>复合逻辑运算：</strong></p>
<blockquote>
<ul>
<li><p><strong>与非运算</strong></p>
<blockquote>
<p><strong>表达式：</strong>$Y&#x3D;\overline{A\cdot B}$</p>
<p><strong>真值表：</strong></p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">Y</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p><strong>门电路：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E4%B8%8E%E9%9D%9E%E9%97%A8.png" alt="与非门"></p>
</blockquote>
</li>
<li><p><strong>或非运算</strong></p>
<blockquote>
<p><strong>表达式：</strong>$Y&#x3D;\overline{A+B}$</p>
<p><strong>真值表：</strong></p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">Y</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p><strong>门电路：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E6%88%96%E9%9D%9E%E9%97%A8.png" alt="或非门"></p>
</blockquote>
</li>
<li><p><strong>异或运算</strong></p>
<blockquote>
<p><strong>表达式：</strong>$Y&#x3D;A \oplus B$</p>
<p><strong>真值表：</strong></p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">Y</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p><strong>门电路：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E5%BC%82%E6%88%96%E9%97%A8.png" alt="异或门"></p>
</blockquote>
</li>
<li><p><strong>同或运算</strong></p>
<blockquote>
<p><strong>表达式：</strong>$Y&#x3D;A⊙B$</p>
<p><strong>真值表：</strong></p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">Y</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p><strong>门电路：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E5%90%8C%E6%88%96%E9%97%A8.png" alt="同或门"></p>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>补充：</strong></p>
<blockquote>
<p>对于一切的逻辑运算，都可以用上述的逻辑门来表示，<strong>不同的表达式有不同的门电路</strong>，因此门电路的优化可以通过表达式的优化来达成（不过这是离散数学的内容了）</p>
</blockquote>
<p><strong>ALU的基本结构</strong></p>
</blockquote>
<h3 id="2、串行加法器和并行加法器"><a href="#2、串行加法器和并行加法器" class="headerlink" title="2、串行加法器和并行加法器"></a>2、串行加法器和并行加法器</h3><blockquote>
<p><strong>一位全加器：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E4%B8%80%E4%BD%8D%E5%85%A8%E5%8A%A0%E5%99%A8.png" alt="一位全加器"></p>
<ul>
<li><strong>A和B是两个加数</strong></li>
<li><strong>C为进位</strong></li>
<li><strong>S为本为和</strong></li>
</ul>
<p><strong>和表达式：</strong>$S_i&#x3D;A_i\oplus B_i\oplus C_{i-1}$</p>
<p><strong>进位表达式：</strong>$C_i&#x3D;A_iB_i+(A_i \oplus B_i)C_{i-1}$</p>
</blockquote>
<p><strong>串行加法器：</strong></p>
<blockquote>
<p>串行加法器<strong>只有一个全加器</strong>，数据逐位送到加法器中计算，其中外接一个进位信号的暂存器。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E4%B8%B2%E8%A1%8C%E5%8A%A0%E6%B3%95%E5%99%A8.png" alt="串行加法器"></p>
<p>如果要计算最少n位的数相加，那么加法器就要循环n次。</p>
<p><strong>优点：</strong>器件少、成本低</p>
<p><strong>缺点：</strong>运算速度慢</p>
</blockquote>
<p><strong>并行加法器：</strong></p>
<blockquote>
<p>并行加法器由<strong>若干个全加器</strong>组成，其数量与机器的字长相同；各位数据同时进行运算。</p>
<p>虽然并行加法器可以使得各位同时运算，但<strong>低位运算的结果也会对高位的运算产生影响</strong>（进位等），因此并行加法器的最长运行时间<strong>主要由进位信号的传递时延</strong>有关，各位的求和延迟只是次要原因。</p>
<p>因此并行加法器的进位可以分为两类：<strong>串行进位</strong>和<strong>并行进位</strong></p>
<ul>
<li><p><strong>串行进位：</strong></p>
<blockquote>
<p>把n个全加器以进位串联起来，这样的并行加法器就称为<strong>串行进位的并行加法器</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E4%B8%B2%E8%A1%8C%E8%BF%9B%E4%BD%8D.png" alt="串行进位"></p>
<p>由图易得，如果位数越多，那么进位的时延就越长，加法运算的时间就越多。</p>
<p><strong>优点：</strong>设计简单，电路简单</p>
<p><strong>缺点：</strong>随着位数的增加，运行速度就会下降</p>
</blockquote>
</li>
<li><p><strong>并行进位：</strong></p>
<blockquote>
<p>并行进位又称<strong>先行进位、同时进位</strong>，即<strong>在求和的过程中就可以直接将是否进位求出</strong></p>
<p>根据进位的表达式可得：<br>$$<br>C_1&#x3D;G_1+P_1C_0\<br>C_2&#x3D;G_2+P_2C_1&#x3D;G_2+P_2(G_1+P_1C_0)\<br>C_3&#x3D;G_3+P_3C_2&#x3D;G_3+P_3(G_2+P_2(G_1+P_1C_0))<br>$$</p>
<ul>
<li>$G_i&#x3D;A_iB_i$</li>
<li>$P_i&#x3D;A_i\oplus B_i$</li>
</ul>
<p>上式格式可以表明所有的<strong>进位输出</strong>都只与$A_i,B_i$以及最低进位输入$C_0$决定，因此<strong>各级的进位输出可以同时产生</strong>。</p>
<p><strong>注意：</strong>这种进位的产生方式与字长无关，只与其内部的电路结构有关，但随着位数越高，其内部的进位电路就会越复杂。</p>
<p><strong>优点：</strong>进位产生的速度快</p>
<p><strong>缺点：</strong>越高位器件的电路就越复杂</p>
</blockquote>
</li>
<li><p><strong>分组并行进位：</strong></p>
<blockquote>
<p>分组并行进位可以分为：<strong>单级并行进位</strong>和<strong>多级先行进位</strong></p>
<ul>
<li><p><strong>单级并行进位</strong></p>
<blockquote>
<p><strong>单级并行进位</strong>又称<strong>组内并行、组间串行进位</strong>，它实际上就是将串行进位与并行进位结合起来。</p>
<p>以16位加法器为例，可分为4组，每组4位。每组内的4位使用并行进位，组间的进位则使用串行进位，如下图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E5%8D%95%E7%BA%A7%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D.png" alt="单级先行进位"></p>
</blockquote>
</li>
<li><p><strong>多级先行进位</strong></p>
<blockquote>
<p><strong>多级先行进位</strong>又称<strong>组内并行、组间并行进位</strong>，它在并行进位的基础上，将多位划分为各组，然后这各组再进行并行计算。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E5%A4%9A%E7%BA%A7%E5%B9%B6%E8%A1%8C%E8%BF%9B%E4%BD%8D.png" alt="多级并行进位"></p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h2 id="五、其他补充"><a href="#五、其他补充" class="headerlink" title="五、其他补充"></a>五、其他补充</h2><blockquote>
<ul>
<li><strong>unsigned型数据：</strong>unsigned型数据为<strong>无符号整数</strong>，它的存储方式与int一致，都是用<strong>补码</strong>来存储。<strong>最大的区别：</strong>int型数据最高位为符号位，unsigned型数据最高位为数值位。</li>
<li><strong>判断浮点数是否是规格化数：</strong>观察尾数第一位是否为0，为0则不是规格化数，不为0则是规格化数（IEEE754标准除外）。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>基础学科</tag>
      </tags>
  </entry>
  <entry>
    <title>总线</title>
    <url>/2022/08/08/6%E3%80%81%E6%80%BB%E7%BA%BF/</url>
    <content><![CDATA[<h2 id="一、总线概述"><a href="#一、总线概述" class="headerlink" title="一、总线概述"></a>一、总线概述</h2><h3 id="1、总线基本概念"><a href="#1、总线基本概念" class="headerlink" title="1、总线基本概念"></a>1、总线基本概念</h3><blockquote>
<p>为了更好地解决I&#x2F;O设备和主机之间的连接灵活性问题，计算机结构从分散结构发展为总线结构。</p>
<ul>
<li><p><strong>总线的定义：</strong></p>
<blockquote>
<p>总线是一组能为多个部件分时共享的公共信息传送线路。</p>
<p><strong>分时</strong>和<strong>共享</strong>是总线的两个<strong>特点</strong></p>
<p><strong>分时：</strong>指同一时刻只允许有一个部件向总线发送信息，如果系统中有多个部件需要用到总线，那么它们只能分时地向总线发送信息。</p>
<p><strong>共享：</strong>指总线上可以连接多个设备，各个设备之间互相交换的信息可以通过这组线路分时共享</p>
</blockquote>
</li>
<li><p><strong>总线结构图：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%80%BB%E7%BA%BF/%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png" alt="总线结构"></p>
</blockquote>
</li>
<li><p><strong>总线设备</strong></p>
<blockquote>
<ul>
<li><strong>主设备：</strong>指获得总线控制权的设备</li>
<li><strong>从设备：</strong>指被主设备访问的设备，它只能响应从主设备发来的各种总线命令</li>
</ul>
</blockquote>
</li>
<li><p><strong>总线特性：</strong></p>
<blockquote>
<ul>
<li><strong>机械特性：</strong>总线的尺寸、形状</li>
<li><strong>电气特性：</strong>总线的传输方向和有效电平范围</li>
<li><strong>功能特性：</strong>每根传输线的功能</li>
<li><strong>时间特性：</strong>总线中信号和时序的关系</li>
</ul>
</blockquote>
</li>
<li><p><strong>总线的猝发式传输：</strong>在一个总线周期内传输<strong>存储地址连续</strong>的多个数据字的总线传输方式</p>
</li>
</ul>
</blockquote>
<h3 id="2、总线的分类"><a href="#2、总线的分类" class="headerlink" title="2、总线的分类"></a>2、总线的分类</h3><blockquote>
<ul>
<li><p><strong>按数据传输格式分类</strong></p>
<blockquote>
<ul>
<li><strong>串行总线</strong></li>
<li><strong>并行总线</strong></li>
</ul>
</blockquote>
</li>
<li><p><strong>按总线功能分类</strong></p>
<blockquote>
<ul>
<li><p><strong>片内总线</strong>：片内总线式芯片内部的总线，是CPU内部各寄存器与寄存器之间、寄存器与ALU之间的公共线路（与内部总线作区分）</p>
</li>
<li><p><strong>系统总线</strong></p>
<blockquote>
<p>系统总线是计算机内部各功能部件（CPU、主存、I&#x2F;O设备等）之间相互连接的总线</p>
<ul>
<li><strong>数据总线：</strong>用于传输各功能部件之间的数据信息，它是<strong>双向传输</strong>总线，其位数与<strong>机器字长</strong>、<strong>存储字长</strong>有关</li>
<li><strong>地址总线：</strong>指出数据总线上的源数据或目的数据所在<strong>主存单元的地址</strong>或<strong>I&#x2F;O端口的地址</strong>，它是<strong>单向传输总线</strong>，地址总线的位数<strong>与主存地址空间大小</strong>有关</li>
<li><strong>控制总线：</strong>传输的是<strong>控制信息</strong>，包括CPU送出的控制命令和主存（或外设）返回给CPU的反馈信息</li>
</ul>
</blockquote>
</li>
<li><p><strong>通信总线</strong>：通信总线是在计算机系统之间或计算机系统与其他系统之间传送信息的总线，通信总线也被称为“外部总线”</p>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>按时序控制方式分类</strong></p>
<blockquote>
<ul>
<li><strong>同步总线</strong></li>
<li><strong>异步总线</strong></li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="3、系统总线结构"><a href="#3、系统总线结构" class="headerlink" title="3、系统总线结构"></a>3、系统总线结构</h3><blockquote>
<ul>
<li><p><strong>单总线结构：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%80%BB%E7%BA%BF/%E5%8D%95%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png" alt="单总线结构"></p>
<p>单总线结构将CPU、主存、I&#x2F;O设备都挂在同一组总线上，允许I&#x2F;O设备之间、I&#x2F;O设备与主存之间的数据交互。</p>
<p><strong>注意：</strong>单总线不是指只有一根信号线，而是指一组线，单总线可以根据用途的不同，分为地址总线、数据总线和控制总线</p>
<p><strong>优点：</strong>结构简单、成本低，易接入新设备</p>
<p><strong>缺点：</strong>带宽低、负载重（总线上电流大），多个部件只能竞争使用唯一的总线，不支持并发传送</p>
</blockquote>
</li>
<li><p><strong>双总线结构：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%80%BB%E7%BA%BF/%E5%8F%8C%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png" alt="双总线结构"></p>
<p><strong>通道：</strong>特殊的处理器，有CPU的部分功能，用于管理I&#x2F;O设备。</p>
<p>双总线结构的两条总线：一条是主存总线，用于CPU、主存和通道之间传送数据；另一条是I&#x2F;O总线，用于在多个外部设备与通道之间传送数据。</p>
<p><strong>优点：</strong>实现了存储总线和I&#x2F;O总线分离，将低速的I&#x2F;O设备从单总线上分离出来，提高了整体效率；支持突发（猝发）传送。</p>
<p><strong>缺点：</strong>需要增加通道等额外的硬件设备</p>
</blockquote>
</li>
<li><p><strong>三总线结构：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%80%BB%E7%BA%BF/%E4%B8%89%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png" alt="三总线结构"></p>
<p><strong>主存总线</strong>：用于CPU和主存之间传送地址、数据和控制信息。</p>
<p><strong>I&#x2F;O总线</strong>：用于在CPU和各类外设之间通信</p>
<p><strong>DMA总线：</strong>用于在主存和<strong>高速外设</strong>之间直接传送数据</p>
<p><strong>优点：</strong>提高了I&#x2F;O设备的性能，提高系统的吞吐量</p>
<p><strong>缺点：</strong>系统工作效率较低（同一时刻只能由一套总线工作）</p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="4、总线的性能指标"><a href="#4、总线的性能指标" class="headerlink" title="4、总线的性能指标"></a>4、总线的性能指标</h3><blockquote>
<ul>
<li><p><strong>总线工作速度：</strong></p>
<blockquote>
<ul>
<li><strong>总线的传输周期：</strong>指一次总线操作所需的时间。（包括申请阶段、寻址阶段、传输阶段和结束阶段）总线传输通常由若干个时钟周期组成</li>
<li><strong>总线时钟周期：</strong>即机器的时钟周期，即计算机内部的统一时钟。</li>
<li><strong>总线的工作频率：</strong>总线上各种操作的频率，即总线周期的倒数</li>
<li><strong>总线的时钟频率：</strong>机器的时钟频率，是总线时钟周期的倒数</li>
</ul>
</blockquote>
</li>
<li><p><strong>总线工作流量：</strong></p>
<blockquote>
<ul>
<li><strong>总线宽度：</strong>又称总线<strong>位宽</strong>，即总线上能够同时传输的位数</li>
<li><strong>总线带宽：</strong>总线的<strong>最大数据传输速率</strong>，即单位时间内总线上最多可传输的数据量。</li>
</ul>
</blockquote>
</li>
<li><p><strong>总线复用：</strong>指一种信号线在不同时间传输多少不同的信息。（即信号线的复用情况）</p>
</li>
<li><p><strong>信号线数：</strong>地址总线、数据总线和控制总线3种总线数的总和称为信号线数</p>
</li>
</ul>
</blockquote>
<h2 id="二、总线仲裁"><a href="#二、总线仲裁" class="headerlink" title="二、总线仲裁"></a>二、总线仲裁</h2><blockquote>
<p>为了解决多个主设备同时竞争总线的问题，对于总线使用权的分配，则可以通过总线仲裁的方式来决定哪个设备可以获得总线的使用权。总线仲裁按照其控制结构可以分为：<strong>集中仲裁方式</strong>和<strong>分布仲裁方式</strong></p>
</blockquote>
<h3 id="1、集中仲裁方式"><a href="#1、集中仲裁方式" class="headerlink" title="1、集中仲裁方式"></a>1、集中仲裁方式</h3><blockquote>
<p>总线控制逻辑集中在一个设备上（如CPU）中，将所有的总线请求集中起来，利用一个特定的裁决算法进行裁决，这样称为<strong>集中仲裁方式</strong>。集中仲裁方式有<strong>链式查询方式</strong>、<strong>计数器定时查询方式</strong>和<strong>独立请求方式</strong>三种</p>
<ul>
<li><p><strong>链式查询方式：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%80%BB%E7%BA%BF/%E9%93%BE%E5%BC%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F.png" alt="链式查询方式"></p>
<p>总线上所有的部件共用一根<strong>总线请求线</strong>，当有部件请求使用总线时，需要经过此线将总线请求信号送到总线控制器。</p>
<p>由总线控制器检查总线是否忙，若总线不忙，则立即发送响应信号，经总线响应线BG串行地从一个部件传送到下一个部件，依次查询</p>
<p>若响应信号到达的部件无总线请求，则该信号立即传送到下一个部件</p>
<p>若响应信号到达的部件有总线请求，则信号被截住，不再传下去</p>
<p><strong>特点：</strong>在链式查询中，部件离总线控制器越近，其优先级就越高；</p>
<p><strong>优点：</strong>I&#x2F;O设备的优先级固定</p>
<p><strong>缺点：</strong>对硬件故障敏感，BG上如果出现一个部件故障，那么整个系统可能就会瘫痪。优先级较低的I&#x2F;O设备会很久都得不到总线使用权</p>
</blockquote>
</li>
<li><p><strong>计数器定时查询方式</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%80%BB%E7%BA%BF/%E8%AE%A1%E6%95%B0%E5%99%A8%E5%AE%9A%E6%97%B6%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F.png" alt="计数器定时查询方式"></p>
<p>它采用一个计数器来控制总线的使用权，</p>
<p>当总线控制器收到总线请求信号并判断总线空闲时，计数器开始计数，计数值通过<strong>设备地址线</strong>发向各个部件</p>
<p>当地址线上的计数值与请求使用总线设备的地址一致时，该设备获得总线的控制权</p>
<p>同时终止计数器的计数及查询</p>
<p><strong>优点：</strong>计数器可以灵活多变，既可以从0开始，逐渐递增；也可以从上一次的终点开始</p>
<p><strong>缺点：</strong>增加了控制线数，控制也比相对链式查询要复杂</p>
</blockquote>
</li>
<li><p><strong>独立请求</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%80%BB%E7%BA%BF/%E7%8B%AC%E7%AB%8B%E8%AF%B7%E6%B1%82.png" alt="独立请求"></p>
<p>当总线上的部件需要使用总线时，经各自的总线请求线发送总线请求信号，在总线控制器中排队</p>
<p>当总线控制器按一定的优先次序决定批准某个部件的请求时，给该部件发送总线响应信号</p>
<p>该部件接收到此信号后就得到了总线使用权</p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="2、分布仲裁方式"><a href="#2、分布仲裁方式" class="headerlink" title="2、分布仲裁方式"></a>2、分布仲裁方式</h3><blockquote>
<p>分布仲裁方式不需要中央仲裁器，每个潜在的主模块都有自己的仲裁号和仲裁器。</p>
<p><strong>过程：</strong></p>
<blockquote>
<ul>
<li>当它们有总线请求时，就会把它们各自唯一的仲裁号发送到共享的仲裁总线上</li>
<li>每个仲裁器将从仲裁总线上得到的仲裁号与自己的总裁号进行比较</li>
<li>若仲裁总线上的总裁号优先级比它的高，那么它的总线请求不给予响应，并撤销它的仲裁号</li>
<li>最后，获胜者的仲裁号保留在仲裁总线上</li>
</ul>
</blockquote>
</blockquote>
<h2 id="三、总线操作和定时"><a href="#三、总线操作和定时" class="headerlink" title="三、总线操作和定时"></a>三、总线操作和定时</h2><blockquote>
<p>总线定时是指总线在双方交换数据的过程中需要时间上配合关系的控制，这种控制称为<strong>总线定时</strong></p>
</blockquote>
<h3 id="1、总线传输"><a href="#1、总线传输" class="headerlink" title="1、总线传输"></a>1、总线传输</h3><blockquote>
<p>一个总线周期通常可以分为以下4个阶段：</p>
<ul>
<li><strong>申请分配阶段：</strong>由需要使用总线的主模块（或主设备）提出申请，经总线仲裁机制决定将下一传输周期的总线使用权赋予某一申请者。</li>
<li><strong>寻址阶段：</strong>取得使用权的主模块通过总线发出本次要访问的从模块的地址及其相关命令，<strong>启动参与本次传输的从模块</strong>。</li>
<li><strong>传输阶段：</strong>主模块与从模块进行数据交流</li>
<li><strong>结束阶段：</strong>主模块的相关信息均从系统总线上撤除，让出总线使用权</li>
</ul>
</blockquote>
<h3 id="2、同步定时方式"><a href="#2、同步定时方式" class="headerlink" title="2、同步定时方式"></a>2、同步定时方式</h3><blockquote>
<p><strong>定义：</strong>指采用一个统一的时钟信号来协调发送和接受双方的传送定时关系。</p>
<p>时钟产生相同的时间间隔，每一个时间间隔构成一个总线周期，在一个总线周期中，发送方接收方可以进行一次数据传输。</p>
<p>因为采用统一的时钟，每个部件或设备发送或接收信息都在固定的总线传送周期中，一个总线的传送周期结束，下一个总线的传送周期开始</p>
<p><strong>使用范围：</strong>总线长度较短及总线所接部件的存取时间比较近的系统</p>
<p><strong>优点：</strong>传送速度快，具有较高的传输速率；总线控制逻辑简单<br><strong>缺点：</strong>主从设备属于强制性同步；不能及时进行数据通信的有效性检验，可靠性差</p>
</blockquote>
<h3 id="3、异步定时方式"><a href="#3、异步定时方式" class="headerlink" title="3、异步定时方式"></a>3、异步定时方式</h3><blockquote>
<p>在异步定时方式中，没有统一的时钟，也没有固定的时间间隔，完全依靠传送双方相互制约的“握手”信号来实现定时控制。</p>
<p>把交换信息的两个部件或设备分为主设备和从设备，主设备提出交换信息的“请求”信号，经接口传送到从设备；从设备收到主设备的请求后，通过接口向主设备发出”回答“信号。</p>
<p><strong>优点：</strong>总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换。</p>
<p><strong>缺点：</strong>比同步控制方式要复杂一些，速度比同步定时方式要慢</p>
<p>异步定时方式可以分为以下三种：</p>
<blockquote>
<ul>
<li><strong>不互锁方式：</strong>主设备发送”请求“信号后，不必等到从设备的“回答”信号，而是经过一段时间后就撤销“请求”信号。而从设备在接到“请求”信号后，发出“回答”信号，而且过一段时间后也撤销了。双方不存在互锁关系。</li>
<li><strong>半互锁方式：</strong>主设备发出“请求”信号后，必须在接到从设备的”回答“信号后，才撤销“请求”信号，有互锁关系。而从设备在接到“请求”信号后，发出“回答”信号，经过一段时间后就撤销“回答”信号，不存在互锁关系。</li>
<li><strong>全互锁方式：</strong>主设备发出“请求”信号后，必须在接到从设备的”回答“信号后，才撤销“请求”信号，从设备在接收到“请求”信号后，发出“回答”信号，必须在获知主设备“请求”信号撤销后，才能撤销“回答”信号。</li>
</ul>
</blockquote>
</blockquote>
<h2 id="四、总线标准"><a href="#四、总线标准" class="headerlink" title="四、总线标准"></a>四、总线标准</h2><blockquote>
<p>总线标准是国际上公布或推荐的互连各个模块的标准。</p>
<p><strong>常见的总线标准：</strong></p>
<blockquote>
<ul>
<li><strong>ISA：</strong>是最早出现的微型计算机的系统总线</li>
<li><strong>EISA：</strong>是为配合32位CPU而设计的扩展总线</li>
<li><strong>VESA：</strong>是一个32位标准的计算机局部总线，针对多媒体PC要求高速传送活动的大量数据应运而生</li>
<li><strong>PCI：</strong>高性能的32位或64位总线，专为高度集成的外围部件、扩充插板和处理器&#x2F;存储器系统设计的互连机制</li>
<li><strong>PCI-Express：</strong>是最新的总线和接口标准，全面取代现行的PCI和AGP，最终统一总线标准</li>
<li><strong>AGP：</strong>是一种视频接口标准，专用于连接主存和图形存储器，属于局部总线</li>
<li><strong>RS-232C：</strong>是一种串行通信总线</li>
<li><strong>USB：</strong>是一种连接外部设备的I&#x2F;O总线，属于设备总线，拥有即插即用、热插拔等优点</li>
<li><strong>PCMCIA：</strong>是广泛用于笔记本电脑的一种接口标准，是一个用于拓展功能的小型插槽，也有即插即用的优点</li>
<li><strong>IDE：</strong>也称为ATA，是一种IDE接口磁盘驱动器接口类型，硬盘和光驱通过IDE与主板连接</li>
<li><strong>SCSI：</strong>是一种用于计算机和智能设备之间系统级接口的独立处理器标准</li>
<li><strong>SATA：</strong>是一种基于行业标准的串行硬件驱动器接口</li>
</ul>
</blockquote>
</blockquote>
<h2 id="五、补充说明"><a href="#五、补充说明" class="headerlink" title="五、补充说明"></a>五、补充说明</h2>]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>基础学科</tag>
      </tags>
  </entry>
  <entry>
    <title>指令系统</title>
    <url>/2022/08/08/4%E3%80%81%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="一、指令格式"><a href="#一、指令格式" class="headerlink" title="一、指令格式"></a>一、指令格式</h2><blockquote>
<p><strong>指令（机器指令）</strong>是指计算机执行某种操作的命令。一台计算机的所有指令集合构成该机器的<strong>指令系统</strong>，也称为<strong>指令集</strong>。指令系统位于计算机的硬件和软件的交界面上，是计算机的主要属性</p>
</blockquote>
<h3 id="1、指令的基本格式"><a href="#1、指令的基本格式" class="headerlink" title="1、指令的基本格式"></a>1、指令的基本格式</h3><blockquote>
<p>一条指令就是机器语言的一个语句。一条指令通常由两部分组成：<strong>操作码字段</strong>和<strong>地址码字段</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F.png" alt="指令格式"></p>
<ul>
<li><strong>操作码字段：</strong>指明该指令应该执行什么性质的操作以及具有什么功能</li>
<li><strong>地址码字段：</strong>指明被操作的信息（指令或数据）的地址</li>
</ul>
<p><strong>补充：</strong></p>
<blockquote>
<p>指令长度是指一条指令中所包含的二进制代码的<strong>位数</strong>。</p>
<p>指令字长与机器字长没有固定关系，指令指出可以小于机器字长，也可以大于机器字长。</p>
</blockquote>
<p>根据指令中操作数地址的个数，可以将指令分成以下几种格式：</p>
<ul>
<li><p><strong>零地址指令：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4.png" alt="零地址指令"></p>
<p>只有操作码OP，没有显示地址，这种指令有两种可能</p>
<ul>
<li><strong>不需要操作数的指令：</strong>如空操作指令、停机指令、关中断指令等</li>
<li><strong>运行在堆栈计算机中：</strong>指令的操作数地址默认存储在栈顶中，执行指令时自动在栈顶中获取</li>
</ul>
</blockquote>
</li>
<li><p><strong>一地址指令：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E4%B8%80%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4.png" alt="一地址指令"></p>
<p>这种指令也有两种常见形态：</p>
<ul>
<li><p><strong>只有目的操作数的单操作数指令：</strong>按$A_1$地址读取操作数，进行OP操作后，将结果存回原地址。</p>
<p><strong>指令含义：</strong>$OP(A_1) \to A_1$</p>
<p><strong>常见操作：</strong>加1、减1、求反、求补等</p>
</li>
<li><p><strong>隐含约定目的地址的双操作数指令：</strong>按按$A_1$地址读取源操作数，指令可隐含约定另一个操作数由<strong>累加器（ACC）</strong>提供，运算结果也存到累加器中。</p>
<p><strong>指令含义：</strong>$(ACC)OP(A_1) \to ACC$</p>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>二地址指令：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E4%BA%8C%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4.png" alt="二地址指令"></p>
<ul>
<li><strong>指令含义：</strong>$(A_1)OP(A_2) \to A_1$</li>
<li><strong>常见操作：</strong>算术运算、逻辑运算，其中目的操作数地址还用于保存本次运算结果。</li>
</ul>
</blockquote>
</li>
<li><p><strong>三地址指令：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E4%B8%89%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4.png" alt="三地址指令"></p>
<ul>
<li><strong>指令含义：</strong>$(A_1)OP(A_2) \to A_3$</li>
</ul>
<p>如果三个地址都是主存地址，则完成一条三地址指令需要进行4次访存（读取指令1次，读取两个操作数2次，存放结果1次）</p>
</blockquote>
</li>
<li><p><strong>四地址指令：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E5%9B%9B%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4.png" alt="四地址指令"></p>
<ul>
<li><strong>指令含义：</strong>$(A_1)OP(A_2) \to A_3,A_4&#x3D;下一条指令的地址$</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="2、定长操作码指令格式"><a href="#2、定长操作码指令格式" class="headerlink" title="2、定长操作码指令格式"></a>2、定长操作码指令格式</h3><blockquote>
<p>定长操作码指令在指令字的最高位部分<strong>分配若干位（定长）表示操作码</strong>，即一共n位操作码字段的治理系统最大能表示$2^n$条指令。</p>
<p>定长操作码有利于计算机硬件设计与提高译码速度，但缺点是操作码长度固定不变，有时会造成不必要的浪费。</p>
</blockquote>
<h3 id="3、扩展操作码指令格式"><a href="#3、扩展操作码指令格式" class="headerlink" title="3、扩展操作码指令格式"></a>3、扩展操作码指令格式</h3><blockquote>
<p>为了在指令字长有限的前提下仍能保持丰富的指令种类，可采用可变长度操作码，即<strong>指令操作码字段位数不固定</strong>。例如，</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C%E7%A0%81%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F.png" alt="扩展操作码指令格式"></p>
<p>在上例中，<strong>16位</strong>长度的指令可以表示：15条三地址指令、15条二地址指令、15条一地址指令和16条零地址指令。</p>
<p>且，<strong>三地址指令</strong>的操作码取值：$0000—1110$；<strong>二地址指令</strong>的操作码取值：$1111\ 0000—1111\ 1110$；<strong>一地址指令</strong>的操作码取值：$1111\ 1111\ 0000—1111\ 1111\ 1110$；<strong>零地址指令</strong>的操作码取值：$1111\ 1111\ 1111\ 0000—1111\ 1111\ 1111\ 1110$；</p>
<p>通常情况下，对使用频率较高的指令分配较短的操作码，对使用频率较低的指令分配较长的操作码。（哈夫曼编码）</p>
<p><strong>注意：</strong></p>
<blockquote>
<ul>
<li><strong>短码的前缀不能是长码的前缀</strong>，即短码短码操作码不能与长码操作码前面重合</li>
<li><strong>各指令的操作码不能重复</strong></li>
</ul>
</blockquote>
</blockquote>
<h3 id="4、指令的操作类型"><a href="#4、指令的操作类型" class="headerlink" title="4、指令的操作类型"></a>4、指令的操作类型</h3><blockquote>
<ul>
<li><p><strong>数据传送</strong></p>
<blockquote>
<ul>
<li><strong>寄存器之间的传送（MOV）</strong></li>
<li><strong>从内存单元读取数据到CPU寄存器（LOAD）</strong></li>
<li><strong>从CPU寄存器写数据到内存单元（STORE）</strong></li>
</ul>
</blockquote>
</li>
<li><p><strong>算术与逻辑运算</strong></p>
<blockquote>
<ul>
<li><strong>加（ADD）</strong></li>
<li><strong>减（SUB）</strong></li>
<li><strong>比较（CMP）</strong></li>
<li><strong>乘（MUL）</strong></li>
<li><strong>除（DIV）</strong></li>
<li><strong>加1（INC）</strong></li>
<li><strong>减1（DEC）</strong></li>
<li><strong>与（AND）</strong></li>
<li><strong>或（OR）</strong></li>
<li><strong>取反（NOT）</strong></li>
<li><strong>异或（XOR）</strong></li>
</ul>
</blockquote>
</li>
<li><p><strong>移位操作</strong></p>
<blockquote>
<ul>
<li><strong>算术移位</strong></li>
<li><strong>逻辑移位</strong></li>
<li><strong>循环移位</strong></li>
</ul>
</blockquote>
</li>
<li><p><strong>转移操作</strong></p>
<blockquote>
<ul>
<li><strong>无条件转移（JMP）</strong></li>
<li><strong>条件转移（BRANCH）</strong></li>
<li><strong>调用（CALL）</strong></li>
<li><strong>返回（RET）</strong></li>
<li><strong>陷阱（TRAP）</strong></li>
</ul>
</blockquote>
</li>
<li><p><strong>输入输出操作</strong></p>
<blockquote>
<p>用于完成CPU与外部设备交换数据或传送控制命令及状态信息</p>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="二、指令的寻址方式"><a href="#二、指令的寻址方式" class="headerlink" title="二、指令的寻址方式"></a>二、指令的寻址方式</h2><h3 id="1、指令寻址和数据寻址"><a href="#1、指令寻址和数据寻址" class="headerlink" title="1、指令寻址和数据寻址"></a>1、指令寻址和数据寻址</h3><blockquote>
<p>寻址方式是寻找指令或操作数有效地址的方式，即确定本条指令的数据地址及下一条待执行指令的地址的方式。寻址方式分为<strong>指令寻址</strong>和<strong>数据寻址</strong>两大类。</p>
<ul>
<li><p><strong>指令寻址：</strong></p>
<blockquote>
<p>指令寻址方式有两种：一种是<strong>顺序寻址方式</strong>，另一种是<strong>跳跃寻址方式</strong></p>
<ul>
<li><strong>顺序寻址：</strong>通过程序计数器（PC）加1（1个指令字长），自动形成下一条指令的地址。</li>
<li><strong>跳跃寻址：</strong>通过转移类指令实现，即下一条指令的地址码不由程序计数器给出，而由本条指令给出下条指令地址的计算方式。给出的地址也有<strong>绝对地址</strong>和<strong>相对地址</strong>，不过跳跃结果都是通过程序计数器（PC）给出。</li>
</ul>
</blockquote>
</li>
<li><p><strong>数据寻址：</strong></p>
<blockquote>
<p>数据寻址是指如何在指令中表示一个操作数的地址，如何用这种表示得到操作数或算出操作数的地址。</p>
<p>数据寻址方式较多，为了区分各种方式，通常在指令中设一个字段，用于表示寻址方式，格式如下</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E6%8C%87%E4%BB%A4%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%AF%BB%E5%9D%80%EF%BC%89.png" alt="指令模式（寻址）"></p>
<ul>
<li><strong>操作码：</strong>本条指令要执行的操作</li>
<li><strong>寻址特征：</strong>寻址的方式</li>
<li><strong>形式地址A：</strong>指令的操作数地址，有可能是有效地址、间接地址、寄存器号等</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="2、常见的数据寻址方式"><a href="#2、常见的数据寻址方式" class="headerlink" title="2、常见的数据寻址方式"></a>2、常见的数据寻址方式</h3><blockquote>
<p><strong>补充：</strong>以下指令都假设只有一个操作数。</p>
<ul>
<li><p><strong>立即（数）寻址</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%80.png" alt="立即寻址"></p>
<p>这种类型的指令的<strong>地址字段</strong>给出的不是操作数地址，而是操作数本身，又称<strong>立即数</strong>。</p>
<p>数据采取<strong>补码</strong>形式存放。</p>
<p><strong>访问内存次数：</strong>取指令1次，共1次。</p>
<p><strong>优点：</strong>指令在<strong>执行阶段</strong>不访问主存，指令执行时间最短</p>
<p><strong>缺点：</strong>A的位数限制了立即数的范围</p>
</blockquote>
</li>
<li><p><strong>直接寻址</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.png" alt="直接寻址"></p>
<p>指令字中的形式地址A是操作数的真实地址EA，即<strong>EA&#x3D;A</strong></p>
<p><strong>访问内存次数：</strong>取指令1次，取操作数1次，一共2次。</p>
<p><strong>优点：</strong>指令在<strong>执行阶段</strong>仅访问一次内存，不需要专门计算操作数的地址</p>
<p><strong>缺点：</strong>A的位数决定了该指令操作数的寻址范围，操作数的地址不易修改。</p>
</blockquote>
</li>
<li><p><strong>间接寻址：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.png" alt="间接寻址"></p>
<p>间接寻址是相对直接寻址而言的，指令的地址字段给出的形式地址不是操作数的真实地址，而是操作数有效地址所在的存储单元的地址，即<strong>EA&#x3D;(A)</strong></p>
<p><strong>访问内存次数：</strong>取指令1次，取有效地址1次，取操作数1次，一共3次。</p>
<p><strong>优点：</strong>扩大寻址范围，便于编址程序（用间接地址方便子程序返回）</p>
<p><strong>缺点：</strong>指令在执行阶段要多次访存</p>
<p><strong>补充：</strong></p>
<blockquote>
<ul>
<li>在间接寻址中，主存第一位为1时，表示取出的仍不是操作数的地址，此时为多次间址；主存第一位为0时，才表示取得的是操作数的地址。</li>
<li>由于间接寻址的速度较慢（因为要多次访存），因此<strong>问道扩大寻址范围时，通常指的是寄存器间接寻址</strong></li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>隐含寻址：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E9%9A%90%E5%90%AB%E5%AF%BB%E5%9D%80.png" alt="隐含寻址"></p>
<p>这种类型的指令不明显地给出操作数的地址，而是在指令中隐含操作数的地址。如，一条加法指令中，可以规定累加器（ACC）作为第二操作数的地址，指令仅给出第一个操作数的地址。</p>
<p><strong>访问内存次数：</strong>取指令1次，一共1次。</p>
<p><strong>优点：</strong>有利于缩短指令字长</p>
<p><strong>缺点：</strong>需要增加<strong>存储操作数或隐含地址的硬件</strong></p>
</blockquote>
</li>
<li><p><strong>寄存器寻址</strong>：</p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80.png" alt="寄存器寻址"></p>
<p>寄存器寻址是指指令地址字段中直接给出操作数所在的<strong>寄存器编号</strong>，即<strong>EA&#x3D;R</strong>，器操作数在由R所指示的寄存器内。</p>
<p><strong>访问内存次数：</strong>取指令1次，一共1次。</p>
<p><strong>优点</strong>：指令执行过程不访问内存，只访问寄存器</p>
<p><strong>缺点：</strong>寄存器价格昂贵，且数量有限</p>
</blockquote>
</li>
<li><p><strong>寄存器间接寻址</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.png" alt="寄存器间接寻址"></p>
<p>在该指令类型中，寄存器R中给出的不是一个操作数，而是操作数所在内存单元的地址，即<strong>EA&#x3D;（R）</strong></p>
<p><strong>特点：</strong>与间接寻址已知，但由于少访问了1次内存，因此速度快于间接寻址</p>
</blockquote>
</li>
<li><p><strong>偏移寻址</strong></p>
<blockquote>
<ul>
<li><p><strong>相对寻址（指令寻址）：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80.png" alt="相对寻址"></p>
<p>相对寻址是把<strong>程序计数器（PC）</strong>的内容加上指令格式中的形式地址A而形成操作数的有效地址，即<strong>EA&#x3D;(PC)+A</strong>，其中A是相对与当前指令地址的为一类，可正可负，用<strong>补码</strong>表示</p>
<p><strong>访问内存次数：</strong>取指令1次，取操作数1次，一共2次。</p>
<p><strong>优点：</strong>操作数的地址不是固定的，它虽PC值的变化而变化，且与指令地址总是相差一个固定值，便于程序浮动。</p>
<p><strong>补充：</strong>相对寻址被广泛用于<strong>转移指令</strong></p>
</blockquote>
</li>
<li><p><strong>基址寻址</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80.png" alt="基址寻址"></p>
<p>基址寻址是指将CPU中<strong>基址寄存器（BR）</strong>的内容加上指令格式中的形式地址A而形成操作数的有效地址，即<strong>EA&#x3D;(BR)+A</strong>。其中基址寄存器既可以采用专用寄存器，又可以采用通用寄存器。</p>
<p><strong>优点：</strong>扩大寻址范围；用户不必考虑自己的程序存在于内存上的哪个空间，利于多道程序设计，并可用于编址浮动程序</p>
<p><strong>特点：</strong> </p>
<blockquote>
<p> <strong>基址寄存器是面向操作系统</strong>的，其内容由操作系统或管理程序确定。</p>
<p>采用<strong>通用寄存器</strong>作为基址地址时，<strong>可由用户决定</strong>哪个寄存器作为基址寄存器，<strong>但其内容仍由操作系统确定</strong>。</p>
</blockquote>
</blockquote>
</li>
<li><p><strong>变址寻址：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80.png" alt="变址寻址"></p>
<p>变址寻址是指有效地址EA等于指令中的形式地址A于<strong>变址寄存器IX</strong>的内容之和，即<strong>EA&#x3D;(IX)+A</strong>，其中变址寄存器既可以采用专用寄存器，又可以采用通用寄存器。</p>
<p><strong>优点：</strong>可扩大寻址范围；在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器IX的内容，从而适合编址循环程序。</p>
<p><strong>特点：</strong></p>
<blockquote>
<p><strong>变址寄存器是面向用户的</strong>，在程序执行过程中，变址寄存器的内容可由用户改变（作为偏移量），形式地址A不变（作为基地址）。</p>
<p><strong>基址寻址与变址寻址的区别：</strong>基址寄存器中的内容由系统决定，变址寄存器的内容可以由用户在执行程序中改变</p>
</blockquote>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>堆栈寻址：</strong></p>
<blockquote>
<p>堆栈式存储器（或专用寄存器组）中一块特定、按<strong>后进先出（LIFO）</strong>原则管理的存储区，<strong>该存储区中读&#x2F;写单元的地址使用一个特定的寄存器给出</strong>，该寄存器称为<strong>堆栈指针（SP）</strong>。堆栈可分为<strong>硬堆栈</strong>与<strong>软堆栈</strong>两类。</p>
<ul>
<li><strong>硬堆栈：</strong>寄存器堆栈</li>
<li><strong>软堆栈：</strong>从内存中划出一段区域</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>寻址总结：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E5%AF%BB%E5%9D%80%E6%80%BB%E7%BB%93.png" alt="寻址总结"></p>
</blockquote>
<h3 id="3、x86汇编指令入门"><a href="#3、x86汇编指令入门" class="headerlink" title="3、x86汇编指令入门"></a>3、x86汇编指令入门</h3><blockquote>
<ul>
<li><p><strong>相关寄存器</strong></p>
<blockquote>
<p>x86处理器有8个32位的<strong>通用寄存器</strong>，分别为：</p>
<ul>
<li><strong>累加寄存器（EAX）</strong></li>
<li><strong>基地址寄存器（EBX）</strong></li>
<li><strong>计数寄存器（ECX）</strong></li>
<li><strong>数据寄存器（EDX）</strong></li>
<li><strong>变址寄存器（两个）（ESI和EDI）</strong></li>
<li><strong>堆栈基寄存器（EBP）</strong></li>
<li><strong>堆栈顶寄存器（ESP）</strong></li>
</ul>
</blockquote>
</li>
<li><p><strong>寻址模式与内存分配</strong></p>
<blockquote>
<ul>
<li><p><strong>寻址模式</strong></p>
<blockquote>
<p>x86提供了一种灵活的内存寻址方式，这里以mov指令为例，mov用于在内存和寄存器之间移动数据，它的两个参数：第一个为目的地址，第二个为源地址，以下为常见例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mov eax, [ebx]					;将ebx值所指示的内存地址中的<span class="number">4</span>字节传送到eax中</span><br><span class="line">   	mov [var], ebx					;将ebx值传送到var的值所指示的内存地址中</span><br><span class="line">   	mov eax, [esi<span class="number">-4</span>]				;将esi<span class="number">-4</span>值所指示的内存地址中的<span class="number">4</span>字节传送到eax中</span><br><span class="line">mov [esi+eax], cl				;将cl值传送到esi+eax值所指示的内存地址中</span><br><span class="line">   	mov edx, [esi+<span class="number">4</span>*ebx]			;将esi+<span class="number">4</span>*ebx值所指示的内存中的<span class="number">4</span>字节传送到edx</span><br><span class="line">       </span><br><span class="line">   	<span class="comment">//错误例子</span></span><br><span class="line">   	mov eax, [ebx-ecx]				;错误，寄存器只能参与加法计算</span><br><span class="line">   	mov [eax+esi+edi], ebx			;错误，最多只能有两个寄存器参与运算</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>数据类型长度规定</strong></p>
<blockquote>
<p>在汇编语言中声明内存大小时，一般显式地使用DB（Data Byte）、DW（Data Word，2Byte）和DD（Double Word，4Byte）等标记来指导编译器分配内存空间。</p>
<p>对于物特殊表示的指令，x86提供了三个指示规则标记，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mov byte ptr [ebx], <span class="number">2</span>			;将<span class="number">2</span>以单字节形式传送到ebx值所指示的内存地址中</span><br><span class="line">   	mov word ptr [ebx], <span class="number">2</span>			;将<span class="number">2</span>以双字节形式传送到ebx值所指示的内存地址中</span><br><span class="line">   	mov dword ptr [ebx], <span class="number">2</span>			;将<span class="number">2</span>以四字节形式传送到ebx值所指示的内存地址中</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>常用指令</strong></p>
<blockquote>
<p>汇编指令通常可以分为<strong>数据传输指令</strong>、<strong>逻辑计算指令</strong>和<strong>控制流指令</strong>。其中以下操作数的标记分别表示寄存器、内存和常数</p>
<ul>
<li>**<reg>**：表示任意寄存器，若其后带数字，则代表指定其位数，如<reg32>表示32位寄存器</li>
<li><strong><mem>：</strong>表示内存地址</li>
<li><con>：表示常数，若其后带数字，则代表指定其位数，如<con32>表示32位常数</li>
</ul>
<p><strong>数据传输指令：</strong></p>
<blockquote>
<ul>
<li><p><strong>mov指令：</strong></p>
<blockquote>
<p>mov指令将第二个操作数（寄存器、内存中的内容）复制到第一个操作数（寄存器或内存）中。<strong>但不能直接从内存复制到内存</strong>，其语法如下：</p>
<pre><code class="c">    mov &lt;reg&gt;,&lt;reg&gt;
    mov &lt;reg&gt;,&lt;mem&gt;
    mov &lt;mem&gt;,&lt;reg&gt;
    mov &lt;reg&gt;,&lt;con&gt;
    mov &lt;mem&gt;,&lt;con&gt;
</code></pre>
</blockquote>
</li>
<li><p><strong>push指令</strong></p>
<blockquote>
<p>push指令将操作数压入内存的栈，常用于函数调用。ESP是栈顶，压栈前<strong>先将ESP值减4</strong>（字节，<strong>栈的增长方向与内存的增长方向相反</strong>），<strong>然后将操作数压入</strong>ESP指示的地址，其语法如下：</p>
<pre><code class="c">    push &lt;reg32&gt;
        push &lt;mem&gt;
        push &lt;con32&gt;
</code></pre>
</blockquote>
</li>
<li><p><strong>pop指令</strong></p>
<blockquote>
<p>与push指令相反，pop指令执行的工作是出栈，出栈前先将ESP所指示的地址中的内容<strong>出</strong>栈，然后将ESP值加4，其语法如下：</p>
<pre><code class="c">    pop &lt;reg32&gt;
        pop &lt;mem&gt;
        pop &lt;con32&gt;
</code></pre>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>算术和逻辑运算指令：</strong></p>
<blockquote>
<ul>
<li><p><strong>add&#x2F;sub指令</strong></p>
<blockquote>
<p>add指令将两个操作数相加，相加的<strong>结果保存到第一个操作数中</strong>。sub与add指令类似，唯一区别是两操作数相减，语法如下：</p>
<pre><code class="c">    add &lt;reg&gt;,&lt;reg&gt;	/ sub &lt;reg&gt;,&lt;reg&gt;
    add &lt;reg&gt;,&lt;mem&gt;	/ sub &lt;reg&gt;,&lt;mem&gt;
    add &lt;mem&gt;,&lt;reg&gt;	/ sub &lt;mem&gt;,&lt;reg&gt;
    add &lt;reg&gt;,&lt;con&gt;	/ sub &lt;reg&gt;,&lt;con&gt;
    add &lt;mem&gt;,&lt;con&gt;	/ sub &lt;mem&gt;,&lt;con&gt;
</code></pre>
</blockquote>
</li>
<li><p><strong>inc&#x2F;dec指令</strong></p>
<blockquote>
<p>inc、dec指令分别表示将操作数自加1、自减1，其语法如下：</p>
<pre><code class="c">    inc &lt;reg&gt; / dec &lt;reg&gt;
        inc &lt;mem&gt; / dec &lt;mem&gt;
</code></pre>
</blockquote>
</li>
<li><p><strong>imul指令</strong></p>
<blockquote>
<p><strong>带符号整数乘法</strong>指令，有两种格式：</p>
<p>①两个操作数，将两个操作数相乘，并将<strong>结果存放到第一个操作数中，第一个操作数必须为寄存器</strong>；</p>
<p>②三个操作数，将第二个和第三个操作数相乘，将<strong>结果存放到第一个操作数中，第一个操作数必须为寄存器</strong>。其语法如下：</p>
<pre><code class="c">    imul &lt;reg32&gt;,&lt;reg32&gt;
        imul &lt;reg32&gt;,&lt;mem&gt;
        imul &lt;reg32&gt;,&lt;reg32&gt;,&lt;con&gt;
        imul &lt;reg32&gt;,&lt;mem&gt;,&lt;con&gt;
</code></pre>
<p>乘法操作容易造成溢出，因此编译器置溢出位OF&#x3D;1，使得CPU可以调出溢出异常处理程序</p>
</blockquote>
</li>
<li><p><strong>idiv指令</strong></p>
<blockquote>
<p>idiv是带符号整数除法指令，<strong>它只有一个操作数</strong>，即除数，而<strong>被除数则为edx&#x2F;eax中的内容</strong>，操作结果有两部分：商和余数，<strong>商送到eax，余数则送到edx</strong>。其语法如下：</p>
<pre><code class="c">    idiv &lt;reg32&gt;
        idiv &lt;mem&gt;
</code></pre>
</blockquote>
</li>
<li><p><strong>and&#x2F;or&#x2F;xor指令</strong></p>
<blockquote>
<p>and、or、xor指令分别是逻辑与、逻辑或、逻辑异或操作指令，用于操作数的<strong>位操作</strong>，<strong>操作结果放在第一个操作数中</strong>。其语法如下：</p>
<pre><code class="c">    add &lt;reg&gt;,&lt;reg&gt; / or &lt;reg&gt;,&lt;reg&gt; / xor &lt;reg&gt;,&lt;reg&gt;
        add &lt;reg&gt;,&lt;mem&gt; / or &lt;reg&gt;,&lt;mem&gt; / xor &lt;reg&gt;,&lt;mem&gt;
        add &lt;mem&gt;,&lt;reg&gt; / or &lt;mem&gt;,&lt;reg&gt; / xor &lt;mem&gt;,&lt;reg&gt;
        add &lt;reg&gt;,&lt;con&gt; / or &lt;reg&gt;,&lt;con&gt; / xor &lt;reg&gt;,&lt;con&gt;
        add &lt;mem&gt;,&lt;con&gt; / or &lt;mem&gt;,&lt;con&gt; / xor &lt;mem&gt;,&lt;con&gt;
</code></pre>
</blockquote>
</li>
<li><p><strong>not指令</strong></p>
<blockquote>
<p>not指令是位翻转指令，将操作数中的每一位翻转，即$1 \to 0$，$0 \to 1$。其语法如下：</p>
<pre><code class="c">    not &lt;reg&gt;
        not &lt;mem&gt;
</code></pre>
</blockquote>
</li>
<li><p><strong>neg指令</strong></p>
<blockquote>
<p>neg指令是取负指令（$n \to -n$）。其语法如下：</p>
<pre><code class="c">    neg &lt;reg&gt;
        neg &lt;mem&gt;
</code></pre>
</blockquote>
</li>
<li><p><strong>shl&#x2F;shr指令</strong></p>
<blockquote>
<p>shl、shr是<strong>逻辑移位指令</strong>，<strong>shl是逻辑左移指令</strong>，<strong>shr是逻辑右移指令</strong>，第一个操作数表示被操作数，第二个操作数表示移位的位数。其语法如下：</p>
<pre><code class="c"> shl &lt;reg&gt;,&lt;con8&gt; / shr &lt;reg&gt;,&lt;con8&gt;
    shl &lt;mem&gt;,&lt;con8&gt; / shr &lt;mem&gt;,&lt;con8&gt;
    shl &lt;reg&gt;,&lt;cl&gt; / shr &lt;reg&gt;,&lt;cl&gt;			;cl表示循环逻辑位移
    shl &lt;mem&gt;,&lt;cl&gt; / shr &lt;mem&gt;,&lt;cl&gt;
</code></pre>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>控制流指令：</strong></p>
<blockquote>
<p>x86处理器维持着一个当前执行指令的指令指针（IP），当一条指令执行后，此指针自动指向下一条指令。<strong>IP寄存器不能直接操作，</strong>但可以通过控制流指令更新。通常用标签（label）指示程序中的指令地址，在x86汇编代码中，可以在任何指令前加入标签。如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	mov esi, [ebp+<span class="number">8</span>]</span><br><span class="line">begin: 	xor ecx, ecx</span><br><span class="line">    		mov eax, [esi]</span><br></pre></td></tr></table></figure>

<p>这样利用转跳指令时，可以直接转跳到begin所指的位置</p>
<ul>
<li><p><strong>jump指令</strong></p>
<blockquote>
<p>jump指令控制IP转移到label所指示的地址。其语法如下，</p>
<pre><code class="c">    jmp &lt;label&gt;
</code></pre>
</blockquote>
</li>
<li><p><strong>jcondition指令</strong></p>
<blockquote>
<p>条件转移指令，它根据处理机状态字中的条件进行转移。处理机状态包括算术运算结果是否为0，运算结果是否为负数等。其语法如下：</p>
<pre><code class="c"> je &lt;label&gt;				;jump when qeual
    jne &lt;label&gt;				;jump when not qeual
    jz &lt;label&gt;				;jump when last result was zero
    jg &lt;label&gt;				;jump when greater than
    jge &lt;label&gt;				;jump when greater than or equal to
    jl &lt;label&gt;				;jump when less than
    jle &lt;label&gt;				;jump when less than or equal to
</code></pre>
</blockquote>
</li>
<li><p><strong>cmp指令</strong></p>
<blockquote>
<p>cmp指令用于比较两个操作数的值，并根据比较结果设置处理机状态字中的条件码。其语法如下：</p>
<pre><code class="c">    cmp &lt;reg&gt;,&lt;reg&gt;
     cmp &lt;reg&gt;,&lt;mem&gt;
        cmp &lt;mem&gt;,&lt;reg&gt;
        cmp &lt;reg&gt;,&lt;con&gt;
</code></pre>
<p>其中cmp常与jcondition指令一起使用，如</p>
<pre><code class="c">    cmp dword ptr [var], 10
        jne loop				;如果var所指示的内存地址的4字节内容等于10，则继续执行下一跳指令；否则转跳							 到loop所指示的指令中
</code></pre>
</blockquote>
</li>
<li><p><strong>call&#x2F;ret指令</strong></p>
<blockquote>
<p>call和ret指令分别实现子程序（过程、函数等）的调用及返回。</p>
<p>call指令将当前执行指令地址入栈，然后无条件转移到标签所指的指令。</p>
<p>ret指令则可以弹出栈中保存的指令地址，然后无条件转移到保存的指令地址执行。其语法如下：</p>
<pre><code class="c">    call &lt;label&gt;
        ret
</code></pre>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="三、CISC和RISC的基本概念"><a href="#三、CISC和RISC的基本概念" class="headerlink" title="三、CISC和RISC的基本概念"></a>三、CISC和RISC的基本概念</h2><blockquote>
<p>指令系统分为两种不同的发展方向：</p>
<blockquote>
<ul>
<li>增强原有指令功能，设置更为复杂的辛芷蕾来实现软件功能的硬件化，这类机器称为<strong>复杂指令系统计算机（CISC）</strong>，如采用x86架构的计算机</li>
<li>减少指令种类和简化指令功能，提高指令的执行速度，这类机器称为<strong>精简指令系统计算机（RISC）</strong>，典型的有ARM、MIPS架构的计算机</li>
</ul>
</blockquote>
</blockquote>
<h3 id="1、复杂指令系统计算机（CISC）"><a href="#1、复杂指令系统计算机（CISC）" class="headerlink" title="1、复杂指令系统计算机（CISC）"></a>1、复杂指令系统计算机（CISC）</h3><blockquote>
<p>随着技术的不断发展，硬件成本不断下降，而软件成本不断上升，促使人们在指令系统中增加更多、更复杂的指令，这样就构成了<strong>复杂指令系统计算机（CISC）</strong></p>
<p><strong>特点：</strong></p>
<blockquote>
<ul>
<li>指令系统复杂庞大，指令数目较多</li>
<li>指令的长度不固定，指令格式多，寻址方式多</li>
<li>访存的指令不受限制</li>
<li>各指令使用频率相差较大</li>
<li>各种指令执行时间相差较大</li>
<li>控制器大多数采用微程序控制</li>
<li>难以用优化编译生成高效的代码程序</li>
</ul>
</blockquote>
</blockquote>
<h3 id="2、精简指令系统计算机（RISC）"><a href="#2、精简指令系统计算机（RISC）" class="headerlink" title="2、精简指令系统计算机（RISC）"></a>2、精简指令系统计算机（RISC）</h3><blockquote>
<p><strong>精简指令系统计算机（RISC）</strong>的中心思想是要求指令系统简化，尽量使用寄存器-寄存器操作指令，指令格式力求一致。</p>
<p><strong>特点：</strong></p>
<blockquote>
<ul>
<li>选取使用频率最高的一些简单指令，复杂指令的功能由简单指令的组合来实现</li>
<li>指令长度固定，指令格式种类少，寻址方式种类少</li>
<li>只有Load&#x2F;Store（取数&#x2F;存数）指令访存，其余指令都在寄存器之间操作</li>
<li>CPU中通用寄存器的数量相当多</li>
<li>RISC一定采用指令流水线技术，大部分指令在一个时钟周期内完成</li>
<li>以硬布线控制为主，少数使用微程序控制（PS：第五章会讲两者区别）</li>
<li>重视编译优化工作，减少程序执行时间</li>
</ul>
</blockquote>
</blockquote>
<h3 id="3、CISC和RISC的比较"><a href="#3、CISC和RISC的比较" class="headerlink" title="3、CISC和RISC的比较"></a>3、CISC和RISC的比较</h3><blockquote>
<ul>
<li>CISC大多数实现软件兼容，新机器包含了旧机器的全部指令，且可以扩充；RISC简化了指令系统，指令条数少，因此大多数RISC机不能与老机器兼容。</li>
<li>RISC更充分利用芯片的面积。CISC的控制器多采用微程序控制，其控制存储器栈CPU芯片的50%以上，而RISC采用组合逻辑控制，其硬布线只占CPU面积的10%</li>
<li>RISC能提高运算速度。（指令少，格式统一，能访存的指令少）</li>
<li>RISC便于设计，可降低成本、</li>
</ul>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/CISC%E4%B8%8ERISC%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="CISC与RISC的区别"></p>
</blockquote>
<h2 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h2>]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>基础学科</tag>
      </tags>
  </entry>
  <entry>
    <title>中央处理器</title>
    <url>/2022/08/08/5%E3%80%81%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<h2 id="一、CPU的功能与基本结构"><a href="#一、CPU的功能与基本结构" class="headerlink" title="一、CPU的功能与基本结构"></a>一、CPU的功能与基本结构</h2><h3 id="1、CPU的功能"><a href="#1、CPU的功能" class="headerlink" title="1、CPU的功能"></a>1、CPU的功能</h3><blockquote>
<p><strong>中央处理器（CPU）</strong>是由<strong>运算器</strong>和<strong>控制器</strong>组成。</p>
<p>其中<strong>控制器</strong>的功能是：负责协调并控制计算机各部件执行程序的指令序列，包括取指令、分析指令和执行指令</p>
<p>其中<strong>运算器</strong>的功能是：对数据进行加工</p>
<p><strong>CPU的具体功能包括：</strong></p>
<blockquote>
<ul>
<li><strong>指令控制</strong>：完成取指令、分析指令和执行指令，即程序的顺序控制</li>
<li><strong>操作控制：</strong>管理并产生由内存取出的每条指令的操作信号，把各个信号送往相应的部件，从而控制这些部件按指令的要求进行动作</li>
<li><strong>时间控制：</strong>对各操作加以时间上的控制</li>
<li><strong>数据加工：</strong>对数据进行算术和逻辑运算</li>
<li><strong>中断处理：</strong>对计算机进行过程中出现的异常情况和特殊请求进行处理</li>
</ul>
</blockquote>
</blockquote>
<h3 id="2、CPU的基本结构"><a href="#2、CPU的基本结构" class="headerlink" title="2、CPU的基本结构"></a>2、CPU的基本结构</h3><blockquote>
<p><strong>结构图：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/CPU%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" alt="CPU的基本结构"></p>
<p>在计算机系统中，中央处理器主要由<strong>运算器</strong>和<strong>控制器</strong>组成。</p>
<p><strong>运算器：</strong></p>
<blockquote>
<p>运算器接收从控制器送来的命令并执行相应的动作，对数据进行加工和处理。</p>
<ul>
<li><strong>算术逻辑单元（ALU）：</strong>主要功能是进行算术&#x2F;逻辑运算</li>
<li><strong>暂存寄存器：</strong>可以用于<strong>暂存从主存读来的数据</strong>，该数据不能存放到通用寄存器中，否则会破坏其内容。<strong>（暂存寄存器对程序员来说是透明的）</strong></li>
<li><strong>累加寄存器（ACC）：</strong>它是一个通用寄存器，用于<strong>暂时存放ALU运算的结果</strong>信息，也可以<strong>作为加法运算的一个输入端</strong>。</li>
<li><strong>通用寄存器：</strong>如AX（累加器）、BX（基地址寄存器）、CX（计数寄存器）、DX（数据寄存器）、SP（堆栈指针）等，用于<strong>存放操作数</strong>和<strong>各种地址信息</strong>。</li>
<li><strong>程序状态字寄存器（PSW）：</strong>保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，如<strong>溢出标志（OF）</strong>、<strong>符号标志（SF）</strong>、<strong>零标志（ZF）</strong>、<strong>进位标志（CF）</strong></li>
<li><strong>移位器：</strong>对操作数或结果进行移位操作</li>
<li><strong>计数器：</strong>控制乘除运算的操作步数</li>
</ul>
</blockquote>
<p><strong>控制器：</strong></p>
<blockquote>
<p>控制器的基本功能就是执行指令，每条指令的执行就是控制器发出的一组微操作实现的。</p>
<p>控制器可以分为：<strong>硬布线控制器</strong>和<strong>微程序控制器</strong></p>
<ul>
<li><strong>程序计数器（PC）：</strong>用于指出下一条指令在主存存放地址。（每次读完一条非跳转指令后会自增）</li>
<li><strong>指令寄存器（IR）：</strong>用于保存当前正在执行的那条指令</li>
<li><strong>指令译码器：</strong>对指令的操作码字段进行译码，向控制器提供特定的操作信号</li>
<li><strong>存储地址寄存器（MAR）：</strong>用于存放要访问的主存单元的地址</li>
<li><strong>存储数据寄存器（MDR）：</strong>用于存放要访问的主存单元的数据</li>
<li><strong>时序系统：</strong>用于产生各种时序信号，它由统一时钟（CLOCK）分频得到</li>
<li><strong>微操作信号发生器：</strong>根据IR的内容、PSW的内容及时序信号，产生控制整个计算机系统所需的各种控制信号。</li>
</ul>
<p><strong>控制器的工作原理：</strong>根据<strong>指令操作码</strong>、<strong>指令的执行步骤（微命令序列）</strong>和<strong>条件信号</strong>来形成当前计算机各部件要用到的控制信号。计算机整体各硬件系统在这些控制信号的控制下协同运行，产生预期的结果。</p>
</blockquote>
</blockquote>
<h2 id="二、指令执行过程"><a href="#二、指令执行过程" class="headerlink" title="二、指令执行过程"></a>二、指令执行过程</h2><h3 id="1、指令周期"><a href="#1、指令周期" class="headerlink" title="1、指令周期"></a>1、指令周期</h3><blockquote>
<p><strong>指令周期：</strong>CPU从主存<strong>取出</strong>并<strong>执行</strong>一条指令的时间。</p>
<p><strong>指令周期</strong>通常用若干<strong>机器周期</strong>来表示，一个<strong>机器周期</strong>又包含若干个<strong>时钟周期</strong>（也称<strong>节拍</strong>或<strong>T周期</strong>，是CPU操作的基本单位）</p>
<p><strong>指令周期、机器周期和时钟周期的关系：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E3%80%81%E6%9C%BA%E5%99%A8%E5%91%A8%E6%9C%9F%E3%80%81%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9F.png" alt="指令周期、机器周期、时钟周期"></p>
</blockquote>
<p>完整的指令周期应该包含：<strong>取指、间址（间接寻址）、执行</strong>和<strong>中断</strong>，即</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F.png" alt="指令周期"></p>
<p>不过，并不是所有指令都会有上面的四个周期，如跳转指令只有取指周期和执行周期。</p>
<p><strong>指令周期流程：</strong></p>
<blockquote>
<img src="/picture/学习/计算组成原理上的图/中央处理器/指令周期流程.png" alt="指令周期流程" style="zoom: 67%;" />

<p>其中这四个周期都有CPU访存操作，取指周期为了获得指令，间址周期为了取得有效地址，执行周期进行了取数，中断周期为了保存程序断点。</p>
<p>为了区分不同的工作周期，在CPU内部设置<strong>4个标志触发器FE、IND、EX</strong>和<strong>INT</strong>，它们分别对应<strong>取指、间址、执行</strong>和<strong>中断周期</strong>，并且以“1”状态表示有效，分别由$1 \to FE$、$1 \to IND$、$1 \to EX$、$1 \to INT$这四个信号表示。</p>
</blockquote>
</blockquote>
<h3 id="2、指令周期的数据流"><a href="#2、指令周期的数据流" class="headerlink" title="2、指令周期的数据流"></a>2、指令周期的数据流</h3><h4 id="2-1、取指周期"><a href="#2-1、取指周期" class="headerlink" title="2.1、取指周期"></a>2.1、取指周期</h4><blockquote>
<p><strong>取指周期的任务就是根据PC中的内容，从主存中取出指令并存到IR中。</strong></p>
<p><strong>具体流程图：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E5%8F%96%E6%8C%87%E5%91%A8%E6%9C%9F.png" alt="取指周期"></p>
<ul>
<li>$PC \to MAR \to 地址总线 \to 主存$（根据当前指令地址PC访问主存中相应的存储块）</li>
<li>$CU发出读命令 \to 控制总线 \to 主存$（控制单元告诉主存进行读操作）</li>
<li>$主存 \to 数据总线 \to MDR \to IR$（主存将要读的指令通过数据总线读到IR中）</li>
<li>$CU发出控制信号 \to PC+1$（PC+1）</li>
</ul>
</blockquote>
</blockquote>
<h4 id="2-2、间址周期"><a href="#2-2、间址周期" class="headerlink" title="2.2、间址周期"></a>2.2、间址周期</h4><blockquote>
<p><strong>间址周期的任务就是读取操作数的有效地址</strong>，这里以一次间址为例。</p>
<p><strong>具体流程图：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E9%97%B4%E5%9D%80%E5%91%A8%E6%9C%9F.png" alt="间址周期"></p>
<ul>
<li>$Ad(IR)或Ad(MDR)\to MAR \to 地址总线 \to 主存$（IR根据形式地址读取操作数的有效地址，这也是<strong>与取指周期的最大区别之一</strong>）</li>
<li>$CU发出读命令 \to 控制总线 \to 主存$​（控制单元告诉主存进行读操作）</li>
<li>$主存 \to 数据总线 \to MDR$（主存将要读的操作数的有效地址通过数据总线读到MDR中）</li>
</ul>
</blockquote>
</blockquote>
<h4 id="2-3、执行周期"><a href="#2-3、执行周期" class="headerlink" title="2.3、执行周期"></a>2.3、执行周期</h4><blockquote>
<p>执行周期就是<strong>根据指令的操作码部分进行相应操作</strong>，不同指令有不同的执行周期操作，没有统一的数据流向。</p>
</blockquote>
<h4 id="2-4、中断周期"><a href="#2-4、中断周期" class="headerlink" title="2.4、中断周期"></a>2.4、中断周期</h4><blockquote>
<p>中断周期的<strong>任务是处理中断请求</strong>。假设程序断点是存入堆栈中，并用SP指示栈顶指针，而且<strong>进栈操作是先修改栈顶指针，后存入数据</strong></p>
<p><strong>具体流程图：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E4%B8%AD%E6%96%AD%E5%91%A8%E6%9C%9F.png" alt="中断周期"></p>
<ul>
<li>$CU控制将SP减1，SP\to MAR \to 地址总线 \to 主存$（先修改栈顶指针，然后将栈顶指针存入主存中）</li>
<li>$CU发出写命令\to 控制总线 \to 存储器$（CU向主存发出写命令）</li>
<li>$PC\to MDR \to 数据总线 \to 主存$（保存断点）</li>
<li>$CU(断点的入口地址)\to PC$（将中断服务程序的入口地址放入PC）</li>
</ul>
</blockquote>
</blockquote>
<h3 id="3、指令执行方案"><a href="#3、指令执行方案" class="headerlink" title="3、指令执行方案"></a>3、指令执行方案</h3><blockquote>
<p>一个指令周期包含几个时间段（如取指、间址、执行、中断），每个步骤完成一部分内容，几个依次执行的步骤完成这条指令的全部功能。根据性能和硬件等因素，可以得到以下不同的方案来安排指令的执行步骤。</p>
<p><strong>单指令周期：</strong></p>
<blockquote>
<p>对所有指令都用相同的执行时间来完成。<strong>指令间串行执行</strong>，即下一条指令只能在前一条指令执行结束后才能启动。</p>
<p><strong>指令周期取决于时间最长的指令的执行时间</strong>。</p>
<p>因此对于一些较短的指令，也需要使用这个较长的时间来执行，会降低整个系统的运行效率。</p>
</blockquote>
<p><strong>多指令周期：</strong></p>
<blockquote>
<p><strong>对不同类型的指令选用不同的执行步骤来完成</strong>，指令间<strong>依旧串行执行</strong>，但每一条指令的执行时间可以不一致。</p>
</blockquote>
<p><strong>流水线方案：</strong></p>
<blockquote>
<p><strong>指令之间可以一定程度上地并行执行</strong>，即在硬件上不冲突时，可以安排多条指令执行各自的阶段。</p>
</blockquote>
</blockquote>
<h2 id="三、数据通路的功能与基本结构"><a href="#三、数据通路的功能与基本结构" class="headerlink" title="三、数据通路的功能与基本结构"></a>三、数据通路的功能与基本结构</h2><h3 id="1、数据通路的功能"><a href="#1、数据通路的功能" class="headerlink" title="1、数据通路的功能"></a>1、数据通路的功能</h3><blockquote>
<p><strong>数据通路：</strong>数据在功能部件之间传送的路径</p>
<p>数据通路描述了信息从什么地方开始，中间经过哪个寄存器或开关，最后到达哪个寄存器。</p>
<p>数据通路中专门用于数据运算的部件称为<strong>执行部件</strong>或<strong>功能部件</strong>。数据通路由控制部件控制，控制部件根据每条指令功能的不同生成对数据通路的控制信号（这在下节会重点讲述）</p>
<p><strong>数据通路的功能是将CPU中的运算器与寄存器或寄存器与寄存器之间的数据进行交换（不涉及主存的存取）</strong></p>
</blockquote>
<h3 id="2、数据通路的基本结构"><a href="#2、数据通路的基本结构" class="headerlink" title="2、数据通路的基本结构"></a>2、数据通路的基本结构</h3><blockquote>
<p>数据通路的基本结构主要有以下几种：</p>
<blockquote>
<ul>
<li><strong>CPU内部单总线方式：</strong>将所有寄存器的输入端和输出端都连到同一条数据总线上。</li>
<li><strong>CPU内部三总线方式：</strong>将所有寄存器的输入端和输出端都连到多 条数据总线上</li>
<li><strong>专用数据通路方式：</strong>根据指令执行过程中的数据和地址流动方向安排连接线路。</li>
</ul>
<p><strong>CPU内部单总线型的数据通路：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E5%8D%95%E6%80%BB%E7%BA%BF%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF.png" alt="单总线数据通路"></p>
<p><strong>补充：</strong></p>
<ul>
<li>单词加in表示该部件允许输入信号，单词加out表示该部件允许输出信号。</li>
<li>内部总线负责CPU运算部件与各寄存器之间的数据交流；系统总线（如数据总线）是负责连接计算机内部各部件的。</li>
</ul>
</blockquote>
</blockquote>
<p><strong>寄存器之间的数据传送：</strong></p>
<blockquote>
<p>寄存器之间的数据传送可通过CPU内部总线完成。以PC为例，将PC的数据传送到MAR中。</p>
<ul>
<li>$(PC)\to Bus \quad \quad PC_{out}有效，PC内容送到总线$</li>
<li>$Bus\to MAR \quad \quad MAR_{in}有效，总线内容送至MAR$</li>
</ul>
</blockquote>
<p><strong>主存与CPU之间的数据传送：</strong></p>
<blockquote>
<p>主存与CPU之间的数据传送也需要借助CPU内部总线完成。以CPU读取主存中的指令为例，将指令从主存读取到IR寄存器中</p>
<ul>
<li>$PC\to BUS\to MAR\quad\quad PC_{out}和MAR_{in}有效，现将指令地址\to MAR$</li>
<li>$1\to R$                                     CU发出读命令</li>
<li>$MEM(MAR)\to MDR \quad MDR_{in}有效$</li>
<li>$MDR\to Bus \to IR \quad\quad MDR_{out}和IR_{in}有效，现将指令\to IR$</li>
</ul>
</blockquote>
<p><strong>执行算术或逻辑运算：</strong></p>
<blockquote>
<p>以加法为例，</p>
<ul>
<li>$Ad(IR)\to Bus \to MAR$			将指令中操作数的有效地址放入MAR中</li>
<li>$1\to R$                                               CU发出读信号</li>
<li>$MEM\to 数据总线 \to MDR$      数据暂时放入MDR中</li>
<li>$MDR \to Bus \to Y$				       MDR再通过内部总线放入暂存器Y中（暂存器不能直接读取主存中的数据）</li>
<li>$(ACC)+(Y) \to Z$                        ACC与Y进行计算，结果放入暂存器Z中</li>
<li>$Z \to ACC$                                        最后再将结果放回ACC中</li>
</ul>
</blockquote>
<p><strong>补充：</strong></p>
<blockquote>
<p>数据通路结构直接影响CPU内各种信息的传送路径，数据通路不同，指令执行过程中的微操作序列也不同，它关系着微操作信号形成部件的设计。 	</p>
</blockquote>
</blockquote>
<p>​	</p>
<h2 id="四、控制器的功能与工作原理"><a href="#四、控制器的功能与工作原理" class="headerlink" title="四、控制器的功能与工作原理"></a>四、控制器的功能与工作原理</h2><h3 id="1、控制器的结构和功能"><a href="#1、控制器的结构和功能" class="headerlink" title="1、控制器的结构和功能"></a>1、控制器的结构和功能</h3><blockquote>
<img src="/picture/学习/计算组成原理上的图/中央处理器/控制器结构.png" alt="控制器结构" style="zoom:67%;" />

<p>计算机五大部件之间的连接关系如图所示。其中虚线框内的就是控制器部件。</p>
<p><strong>控制器的功能：</strong></p>
<blockquote>
<ul>
<li>从主存中取出一条指令，并指出下一条指令的位置</li>
<li>对指令进行进行译码或测试，<strong>产生相应的操作控制信号</strong></li>
<li>控制并指挥CPU、主存、输入和输出部件之间的数据流动情况</li>
</ul>
</blockquote>
<p><strong>控制器的信号：</strong></p>
<blockquote>
<ul>
<li><p><strong>信号输入源：</strong></p>
<blockquote>
<ul>
<li><strong>指令寄存器</strong></li>
<li><strong>时钟</strong></li>
<li><strong>标志（程序状态字寄存器）</strong></li>
<li><strong>外来信号</strong></li>
</ul>
</blockquote>
</li>
<li><p><strong>信号输出点：</strong></p>
<blockquote>
<ul>
<li><strong>CPU的内部控制信号</strong></li>
<li><strong>到控制总线的控制信号</strong></li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>控制器的分类：</strong></p>
<blockquote>
<ul>
<li><strong>硬布线控制器</strong></li>
<li><strong>微程序控制器</strong></li>
</ul>
</blockquote>
</blockquote>
<h3 id="2、硬布线控制器"><a href="#2、硬布线控制器" class="headerlink" title="2、硬布线控制器"></a>2、硬布线控制器</h3><blockquote>
<p>硬布线控制器主要由<strong>组合逻辑电路</strong>和<strong>触发器</strong>组成。</p>
<p><strong>控制单元结构图：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8.png" alt="硬布线控制器"></p>
</blockquote>
<p><strong>硬布线控制器的时序系统概念：</strong></p>
<blockquote>
<ul>
<li><strong>时钟周期：</strong>用时钟信号控制节拍发生器，可以产生节拍，每个节拍的宽度正好对应一个时钟周期。</li>
<li><strong>机器周期：</strong>机器周期是指令执行过程中的一个基准时间。</li>
<li><strong>指令周期：</strong>一条指令从取指到指令执行完成的时间。</li>
<li><strong>微操作命令：</strong>控制单元具有发出各种<strong>操作命令（控制信号）</strong>序列的功能。这些命令与指令有关。</li>
</ul>
</blockquote>
<p><strong>硬布线控制器设计步骤：</strong></p>
<blockquote>
<ul>
<li><p><strong>分析每个阶段的微操作序列</strong></p>
<blockquote>
<p><strong>例如：</strong>取指周期</p>
<blockquote>
<p>PC —&gt; MAR				现指令地址—&gt;MAR</p>
<p>1 —&gt;R						  命令存储器进行读操作</p>
<p>M(MAR) —&gt; MDR	   将指令从主存中读到MDR中</p>
<p>OP(IR) —&gt; CU			  指令操作码进行译码</p>
<p>PC+1 —&gt; PC				PC加1</p>
</blockquote>
<p>上面每一步就是一个微操作序列（微程序），此外还有<strong>间址、执行、中断</strong>等微操作序列。</p>
</blockquote>
</li>
<li><p><strong>选择CPU的控制方式</strong></p>
<blockquote>
<p>控制单元控制一条指令执行的过程，实际上是依次执行一个确定的微操作序列的过程。</p>
<p>根据指令的和每个微操作的所需时间不同，可以分为以下三种：</p>
<ul>
<li><strong>同步控制方式：</strong>系统有一个统一的时钟，<strong>所有信号据来自统一的时钟信号</strong>。（时钟周期通常以最长的微操作序列所需的时间为标准）</li>
<li><strong>异步控制方式：</strong>异步控制不存在基准时标信号。<strong>各部件按自身固有的速度工作</strong>。通过应答方式进行联络。</li>
<li><strong>联合控制方式：</strong>大部分使用同步控制，小部分采用异步控制方式。</li>
</ul>
</blockquote>
</li>
<li><p><strong>安排微操作时序</strong></p>
<blockquote>
<p><strong>安排原则：</strong></p>
<blockquote>
<ul>
<li><strong>微操作的先后顺序不能随意改变</strong></li>
<li><strong>操作对象不同的微操作，应尽量安排在一个节拍内完成</strong>（可以节省操作时间）</li>
<li><strong>占用时间短的微操作可以安排在一个节拍内完成，且可以有先后顺序</strong></li>
</ul>
</blockquote>
<p><strong>例如：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E5%AE%89%E6%8E%92%E5%BE%AE%E6%93%8D%E4%BD%9C%E6%97%B6%E5%BA%8F_%E5%8F%96%E6%8C%87%E5%91%A8%E6%9C%9F.png" alt="安排微操作时序_取指周期"></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E5%AE%89%E6%8E%92%E5%BE%AE%E6%93%8D%E4%BD%9C%E6%97%B6%E5%BA%8F_%E5%8F%96%E6%8C%87%E5%91%A8%E6%9C%9F_%E5%90%8E.png" alt="安排微操作时序_取指周期_后"></p>
<p>因此可以根据微操作的安排原则得到上图的安排，一共安排为三个机器周期。</p>
</blockquote>
</blockquote>
</li>
<li><p><strong>组合逻辑电路设计</strong></p>
<blockquote>
<ul>
<li><p><strong>列出操作时间表</strong></p>
<blockquote>
<p><strong>取指周期时间表：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E5%8F%96%E6%8C%87%E5%91%A8%E6%9C%9F%E6%97%B6%E9%97%B4%E8%A1%A8.png" alt="取指周期时间表"></p>
<p><strong>间址周期时间表：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E9%97%B4%E5%9D%80%E5%91%A8%E6%9C%9F%E6%97%B6%E9%97%B4%E8%A1%A8.png" alt="间址周期时间表"></p>
<p><strong>执行周期时间表：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E6%89%A7%E8%A1%8C%E5%91%A8%E6%9C%9F%E6%97%B6%E9%97%B4%E8%A1%A8.png" alt="执行周期时间表"></p>
</blockquote>
</li>
<li><p><strong>写微操作命令的最简表达式</strong></p>
<blockquote>
<p><strong>以$M(MAR) \to MDR$为例：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E5%BE%AE%E6%93%8D%E4%BD%9C%E4%BF%A1%E5%8F%B7%E7%BB%BC%E5%90%88.png" alt="微操作信号综合"></p>
<p>由上图可以得到产生$M(MAR) \to MDR$信号的电路表达式为：</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F.png" alt="逻辑表达式"></p>
</blockquote>
</li>
<li><p><strong>画出电路逻辑图</strong></p>
<blockquote>
<p>根据表达式可以得到产生$M(MAR) \to MDR$信号的电路逻辑图为：</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1.png" alt="电路设计"></p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<h3 id="3、微程序控制器"><a href="#3、微程序控制器" class="headerlink" title="3、微程序控制器"></a>3、微程序控制器</h3><blockquote>
<p><strong>微程序工作原理：</strong></p>
<blockquote>
<p>事先把<strong>微操作控制信号</strong>存储在一个专门的存储器中（<strong>控制存储器</strong>），将每一条机器指令编写成一个微程序，这些微程序可以存到<strong>控制存储器</strong>中，用寻址用户程序机器指令的办法来寻址每个微程序中的微指令。</p>
</blockquote>
<p><strong>微程序控制的基本概念：</strong></p>
<blockquote>
<ul>
<li><p><strong>微操作：</strong>一条机器指令可以分解成一个微操作序列，微操作序列是计算机中最基本、不可再分的操作。如$PC \to MAR$就属于一个微操作。</p>
</li>
<li><p><strong>微命令：</strong>在进行微操作的时候所产生的各种控制信号，如$1 \to R$产生的读信号。微命令就是微操作的控制信号。<strong>微命令根据相容性可以分为</strong>：<strong>相容性微命令</strong>和<strong>互斥性微命令</strong></p>
</li>
<li><p><strong>微指令：</strong>是若干微命令的集合。微指令通常分为两部分：<strong>操作控制字段</strong>（存放产生某一步所需的各种操作的控制信号）、<strong>顺序控制字段</strong>（存放下一条要执行的微指令的控制存储器地址）</p>
</li>
<li><p><strong>控制存储器（CM）：</strong>用于存放<strong>微程序</strong>，在CPU内部，<strong>用ROM实现</strong>。（与主存储器作区别）</p>
</li>
<li><p><strong>微程序：</strong>是微指令的有序集合，一条指令的功能由一段微程序来实现。</p>
</li>
<li><p><strong>寄存器：</strong></p>
<blockquote>
<ul>
<li><strong>微地址寄存器（CMAR）：</strong>用于存放<strong>控制存储器（CM）</strong>的读&#x2F;写微指令的地址</li>
<li><strong>微指令寄存器（CMDR或$\mu IR$）</strong>：用于存放从<strong>控制存储器（CM）</strong>读出的指令</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>注意：</strong></p>
<blockquote>
<p>对于程序员来说，计算机系统中<strong>微程序</strong>的结构和功能是<strong>透明的</strong>，无须知道。</p>
<p>而程序的结构和功能是由软件设计人员实现编制好并存放在主存或辅存中的。</p>
</blockquote>
</blockquote>
<p><strong>微程序控制器组成和工作过程：</strong></p>
<blockquote>
<p><strong>结构：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" alt="微程序控制器的基本结构"></p>
<ul>
<li><strong>控制存储器（CM）：</strong>是微程序控制器的核心部件，用于存放各指令对应的微程序，<strong>控制存储器用只读存储器ROM构成</strong></li>
<li><strong>微指令寄存器（CMDR）：</strong>用于存放从CM中取出的微指令，位数与微指令字长相等</li>
<li><strong>微地址形成部件：</strong>用于<strong>产生初始微地址</strong>和<strong>后续微地址</strong>，以保证微指令的连续执行</li>
<li><strong>微地址寄存器（CMAR）：</strong>接收微地址形成部件送来的微地址，为在CM中读取微地址作准备</li>
<li><strong>地址译码：</strong>将地址转化为存储单元控制信号</li>
</ul>
<p><strong>控制存储器（CM）的结构：</strong></p>
<blockquote>
<img src="/picture/学习/计算组成原理上的图/中央处理器/控制存储器（CM）的结构.png" alt="控制存储器（CM）的结构" style="zoom:50%;" />

<p>控制存储器中存放了每条指令中各个阶段所需的<strong>微指令</strong>或<strong>微程序</strong>，其结构图如上</p>
<ul>
<li><strong>取指周期：</strong>这是所有指令都需要的实现周期，因此在控制存储器的公共部分可以写入取指周期的微程序。</li>
<li><strong>间址周期&amp;&amp;中断周期：</strong>有些地方会将这两个机器周期也写入控制存储器的公共部分。</li>
<li><strong>执行周期：</strong>微指令的控制执行字段放的都是下一条微指令的地址，最后一条微指令则存放取指周期微程序的起始地址。</li>
</ul>
</blockquote>
</blockquote>
<p><strong>微指令格式：</strong></p>
<blockquote>
<p>微指令格式与微指令的编码方式有关，根据不同的编码方式，可以分为两类：<strong>水平型微指令</strong>和<strong>垂直型微指令</strong></p>
<ul>
<li><p><strong>水平型微指令</strong></p>
<blockquote>
<p><strong>基本格式图：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E6%B0%B4%E5%B9%B3%E5%9E%8B%E5%BE%AE%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F.png" alt="水平型微指令格式"></p>
<p>一次可以定义并执行多个并行操作（其中A就是操作类型）</p>
<p><strong>优点：</strong>程序短，执行速度快</p>
<p><strong>缺点：</strong>微指令长，编写微程序复杂</p>
</blockquote>
</li>
<li><p><strong>垂直型微指令</strong></p>
<blockquote>
<p><strong>基本格式图：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E5%9E%82%E7%9B%B4%E5%9E%8B%E5%BE%AE%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F.png" alt="垂直型微指令格式"></p>
<p>采用类似机器指令操作码的方式，在微指令中设置微操作码字段</p>
<p><strong>优点：</strong>指令短，简单，便于微程序的编写</p>
<p><strong>缺点：</strong>微程序长，执行速度慢，工作效率低</p>
</blockquote>
</li>
<li><p><strong>混合型微指令</strong></p>
<blockquote>
<p>在垂直型微指令的基础上加入一些不太复杂的并行操作，从而使微指令同时具备水平型微指令和垂直型微指令的特点。</p>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>微指令的编码方式</strong></p>
<blockquote>
<p>微指令的编码方式又称微指令的控制方式，是指如何<strong>对微指令的控制字段进行编码</strong>，从而形成控制信号。</p>
<ul>
<li><p><strong>直接编码（直接控制）：</strong></p>
<blockquote>
<p>对控制字段直接编码，无需译码，即<strong>在控制字段中，每一位都代表一个微操作命令</strong>，如图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E7%9B%B4%E6%8E%A5%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F.png" alt="直接编码方式"></p>
<p>在设置微指令的时候，可以直接将对应位的微命令信号设置为0&#x2F;1即可</p>
<p><strong>优点：</strong>简单、直观，执行速度快，操作并行性好</p>
<p><strong>缺点：</strong>微指令字长过长。</p>
</blockquote>
</li>
<li><p><strong>字段直接编码：</strong></p>
<blockquote>
<p>将微指令的微命令字段分成若干小字段，<strong>每段经过编码后再发出控制信号</strong>，如图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E5%AD%97%E6%AE%B5%E7%9B%B4%E6%8E%A5%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F.png" alt="字段直接编码方式"></p>
<p><strong>注意：</strong>每一段中的微命令都是互斥的。（如$(PC)\to MAR和PC+1 \to PC$这一类信号不可能同时发出）</p>
<p><strong>微命令字段分段原则：</strong></p>
<blockquote>
<ul>
<li><strong>互斥性微命令分在同一段内，相容性微命令分在不同段内</strong></li>
<li><strong>每个小段中包含的信息位不能太多</strong>（会加重译码的复杂度和译码时间）</li>
<li><strong>一般每个小段还要留出一个状态，表示本字段不发出任何微命令信号</strong></li>
</ul>
</blockquote>
<p><strong>优点：</strong>缩短了微指令的长度</p>
<p><strong>缺点：</strong>由于需要编码，因此使用此编码后，微命令信号发出的速度会下降</p>
</blockquote>
</li>
<li><p><strong>字段间接编码：</strong></p>
<blockquote>
<p>在分字段编码的基础之上，<strong>由多个译码结果最后再决定发出的信号</strong>，如图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E5%AD%97%E6%AE%B5%E9%97%B4%E6%8E%A5%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F.png" alt="字段间接编码方式"></p>
<p>一个字段的某些微命令需要另一些字段的微命令来解释，因此也称为<strong>隐式编码</strong>。</p>
<p><strong>优点：</strong>进一步削减了微指令的长度</p>
<p><strong>缺点：</strong>降低微指令的并行控制能力，因此只作于字段直接编码的辅助手段</p>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>微指令的地址形成方式：</strong></p>
<blockquote>
<ul>
<li><p><strong>直接由微指令的下地址字段指出：</strong>微指令格式中设置一个下地址字段，由微指令的下地址字段直接指出后续微指令的地址，这种方式也称为<strong>断定方式</strong></p>
</li>
<li><p><strong>根据机器指令的操作码形成：</strong>指令取到指令寄存器后，微指令的地址由操作码经过微地址形成部件形成。</p>
</li>
<li><p><strong>其余方式：</strong></p>
<blockquote>
<ul>
<li>增量计数器法：即$(CMAR)+1 \to CMAR$</li>
<li>根据各种标志决定微指令分支转移的地址</li>
<li>通过测试网络形成（即通过硬件形成）</li>
<li>由硬件直接产生微程序入口地址</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<p><strong>微程序控制单元的设计</strong></p>
<blockquote>
<ul>
<li><p><strong>分析每个阶段的微操作序列</strong></p>
<blockquote>
<p><strong>例如：</strong>取指周期</p>
<blockquote>
<p>PC —&gt; MAR				现指令地址—&gt;MAR</p>
<p>1 —&gt;R						  命令存储器进行读操作</p>
<p>M(MAR) —&gt; MDR	   将指令从主存中读到MDR中</p>
<p>OP(IR) —&gt; CU			  指令操作码进行译码</p>
<p>PC+1 —&gt; PC				PC加1</p>
</blockquote>
<p>上面每一步就是一个微操作序列（微程序），此外还有<strong>间址、执行、中断</strong>等微操作序列。</p>
</blockquote>
</li>
<li><p><strong>写出对应机器指令的微操作命令及节拍安排</strong></p>
<blockquote>
<ul>
<li>写出每个周期所需要的微操作</li>
<li>补充微程序控制器特有的微操作</li>
</ul>
<p><strong>例如：</strong>取指周期</p>
<blockquote>
<ul>
<li><strong>写出每个周期所需要的微操作</strong></li>
</ul>
<blockquote>
<p>PC —&gt; MAR				现指令地址—&gt;MAR<br>1 —&gt;R						  命令存储器进行读操作</p>
<p>M(MAR) —&gt; MDR	   将指令从主存中读到MDR中<br>(PC)+1 —&gt; PC				PC加1</p>
<p>MDR —&gt; IR<br>OP (IR) —&gt; 微地址形成部件</p>
</blockquote>
<ul>
<li><strong>补充微程序控制器特有的微操作</strong></li>
</ul>
<blockquote>
<p>由上述形成三条微指令，但是还需要考虑如何读出这三条微指令以及如何转入下一周期，即</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E7%9A%84%E5%BE%AE%E6%8C%87%E4%BB%A4%E8%AE%BE%E8%AE%A1.png" alt="微程序控制单元的微指令设计"></p>
<p>因此在对取指令设计其微指令时，我们可以设计6条微指令来实现取指令这一操作</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><p><strong>确定微指令格式</strong></p>
<blockquote>
<p>采用微指令的格式，然后确定微指令的编码方式。</p>
</blockquote>
</li>
<li><p><strong>编写微指令码点</strong></p>
<blockquote>
<p>根据操作控制字段每一位代表的微操作命令，编写每一条微指令的码点</p>
</blockquote>
</li>
</ul>
<p><strong>补充：</strong></p>
<blockquote>
<ul>
<li><p><strong>静态微程序设计和动态微程序设计</strong></p>
<blockquote>
<p><strong>静态：</strong>微程序无需改变，使用ROM作控制存储器（CM）</p>
<p><strong>动态：</strong>通过改变微指令和微程序改变机器指令，因此采用EPROM作控制存储器（CM）</p>
</blockquote>
</li>
<li><p><strong>毫微程序设计：</strong>在微指令的基础上再设计一层来解释微指令。（关系类似于指令和微指令的关系）</p>
</li>
</ul>
</blockquote>
</blockquote>
<p><strong>硬布线和微程序的比较</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E7%A1%AC%E5%B8%83%E7%BA%BF%E5%92%8C%E5%BE%AE%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="硬布线和微程序的比较"></p>
</blockquote>
</blockquote>
<h2 id="五、指令流水线"><a href="#五、指令流水线" class="headerlink" title="五、指令流水线"></a>五、指令流水线</h2><h3 id="1、指令流水线的基本概念"><a href="#1、指令流水线的基本概念" class="headerlink" title="1、指令流水线的基本概念"></a>1、指令流水线的基本概念</h3><blockquote>
<p>一条指令执行的过程可以分解为若干个阶段（取指周期、间址周期、执行周期、中断周期等），而每个阶段所用到的硬件设备各不相同，因此可以将各阶段视作流水线，那么指令就形成了一条指令流水线。</p>
<p><strong>定义：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="指令执行过程"></p>
<ul>
<li><strong>取指：</strong>根据PC内容访问主存储器，取出一条指令送到IR中</li>
<li><strong>分析：</strong>对指令操作码进行译码，按照给定的寻址方式和地址字段中的内容形成操作数的有效地址，并从有效地址中取出操作数</li>
<li><strong>执行：</strong>根据操作数字段，完成指令规定的功能</li>
</ul>
</blockquote>
<p><strong>指令执行方式：</strong></p>
<blockquote>
<ul>
<li><p><strong>顺序执行方式：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C.png" alt="顺序执行"></p>
<p>这是早期的冯·诺依曼机采取的执行方式，又称作<strong>串行执行方式</strong>。所需要的执行时间为：<br>$$<br>T&#x3D;3nt\quad \quad \quad (其中n为指令数量，t为一个阶段所花费的时间，3是指令分成的3个阶段)<br>$$<br><strong>优点：</strong>控制简单，硬件代价小</p>
<p><strong>缺点：</strong>执行指令的速度较慢，任何时刻在机器中只有一条指令在执行，部件利用效率低</p>
</blockquote>
</li>
<li><p><strong>流水线执行方式：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F.png" alt="流水线执行方式"></p>
<p>在将指令分成各个阶段后，由于每个阶段使用的硬件设备不同，因此在上一条指令完成当前阶段的任务后，可以立即去完成下一条指令这一阶段的任务。从而提升运行速度以及部件的利用率。所需要的执行时间为：<br>$$<br>T&#x3D;3t+(n-1)t&#x3D;(2+n)t\quad \quad (其中n为指令数量，t为一个阶段所花费的时间，3是指令分成的3个阶段)<br>$$<br><strong>解释：</strong>可以理解为，除去第一条指令外，所有指令都是在上一条指令完成后一个阶段就完成的，因此可以看作除第一条指令与最后一条指令外，机器同时执行三条指令。</p>
<p><strong>注意：</strong>为了进一步提升运算速度，还可以将指令拆分为5个阶段（常见的也是4、5个阶段）</p>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>流水线的表示方式：</strong></p>
<blockquote>
<ul>
<li><p><strong>指令执行过程图</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%9B%BE.png" alt="指令执行过程图"></p>
<p>可以用于分析指令执行过程和影响流水线的因素</p>
</blockquote>
</li>
<li><p><strong>指令流水线时空图</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%97%B6%E7%A9%BA%E5%9B%BE.png" alt="指令流水线时空图"></p>
<p>用于衡量指令流水线的性能</p>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<h3 id="2、流水线的分类"><a href="#2、流水线的分类" class="headerlink" title="2、流水线的分类"></a>2、流水线的分类</h3><blockquote>
<ul>
<li><strong>部件功能级、处理机级</strong>和<strong>处理机间级流水线</strong></li>
<li><strong>单功能流水线</strong>和<strong>多功能流水线</strong></li>
<li><strong>动态流水线</strong>和<strong>静态流水线</strong></li>
<li><strong>线性流水线</strong>和<strong>非线性流水线</strong></li>
</ul>
</blockquote>
<h3 id="3、影响流水线的因素"><a href="#3、影响流水线的因素" class="headerlink" title="3、影响流水线的因素"></a>3、影响流水线的因素</h3><blockquote>
<p>在指令流水线中，可能会出现一些状况（如所需要的操作数未产生、指令分阶后长度不一样之类的）导致流水线无法正确执行后续指令而引起流水线阻塞或停顿，这种现象被称为<strong>流水线冲突（冒险）</strong>。导致流水线冲突的原因有三种：<strong>资源冲突（结构冒险）</strong>、<strong>数据冲突（数据冒险）</strong>和<strong>控制冲突（控制冒险）</strong></p>
<ul>
<li><p><strong>资源冲突：</strong></p>
<blockquote>
<p><strong>指多条指令同一时刻争用同一资源（一般为硬件资源）而产生的冲突</strong></p>
<img src="/picture/学习/计算组成原理上的图/中央处理器/结构冲突.png" alt="结构冲突" style="zoom:50%;" />

<p>如图，Load指令和Instr3指令同时需要操作主存，因此产生了资源冲突。</p>
<p><strong>解决办法：</strong></p>
<blockquote>
<ul>
<li><strong>后一个指令暂停一个周期，即Instr3延后一个周期来执行</strong></li>
<li><strong>单独设置数据存储器和指令存储器，使得取指和取数操作各自分开</strong></li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>数据冲突：</strong></p>
<blockquote>
<p><strong>指在一个程序中，下一条指令会用到当前指令计算出的结果</strong></p>
<img src="/picture/学习/计算组成原理上的图/中央处理器/数据冲突.png" alt="数据冲突" style="zoom: 67%;" />

<p>如图，后面的sub、and、or指令中都需要用到r1，但是r1在使用时并未放回主存，因此产生了数据冲突</p>
<p><strong>数据冲突的三种类型：</strong></p>
<blockquote>
<ul>
<li><strong>写后读（RAW）：</strong>当前指令将数据写入寄存器后，下一条指令才能从该寄存器读取数据。否则会使得下一条指令读出旧数据。</li>
<li><strong>读后写（WAR）：</strong>当前指令读出数据后，下一条指令才能写该寄存器。否则会读到错误数据（新数据）。</li>
<li><strong>写后写（WAW）：</strong>当前指令写入寄存器后，下一条指令才能写该寄存器。否则，下一条指令在当前指令之前写，会使得寄存器的值不是最新值。（下一条指令的才是最新值）</li>
</ul>
</blockquote>
<p><strong>解决办法：</strong></p>
<blockquote>
<ul>
<li><p><strong>把遇到数据相关的指令及其后续指令都暂停一个或多个时钟周期</strong>，直到数据相关问题消失后才继续执行</p>
<blockquote>
<ul>
<li><p><strong>硬件阻塞（stall）：</strong>在硬件的层面上塞入空白周期，如</p>
<img src="/picture/学习/计算组成原理上的图/中央处理器/硬件阻塞.png" alt="硬件阻塞" style="zoom:50%;" />
</li>
<li><p><strong>软件插入：</strong>在设计指令集时，使用软件塞入”NOP“指令，如</p>
<img src="/picture/学习/计算组成原理上的图/中央处理器/软件插入.png" alt="软件插入" style="zoom:50%;" />

<p><strong>两者区别：</strong>硬件是自动插入的空指令，指令周期不完整；软件插入是手动插入空指令，而且每条空指令都有完整周期（但不做任何操作）。</p>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>数据旁路技术：</strong> 在数据产生的第一时间不是放回主存中，而是<strong>发送给下面需要用到这个数的指令</strong></p>
</li>
<li><p><strong>编译优化：</strong>通过调整指令顺序来解决冲突，即先将不用该操作数的指令先提前执行（这个只能适度调整，应保持整体功能不变的情况下调整）</p>
</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>控制冲突：</strong></p>
<blockquote>
<p><strong>当流水线遇到转移或其它改变PC值的指令时，造成断流</strong>，如</p>
<img src="/picture/学习/计算组成原理上的图/中央处理器/控制冲突.png" alt="控制冲突" style="zoom:60%;" />

<p>Beq指令可能会进行跳转，如果进行跳转，那么执行阶段在第四阶段，而到了第四阶段后，已经开始了三条指令的执行（而这三条指令在原本意愿中不需要执行），因此会造成混乱。</p>
<p><strong>解决办法：</strong></p>
<blockquote>
<ul>
<li><strong>对转移指令进行分支预测，尽早生成转移目标的地址</strong>，又分为静态预测（默认条件不满足）和动态预测（根据历史进行预测）</li>
<li><strong>对转移成功和转移失败上的指令都预先获取</strong></li>
<li><strong>加快和提前形成条件码</strong></li>
<li><strong>根据概率统计，对转移方向进行猜测</strong></li>
</ul>
</blockquote>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="4、流水线的性能指标"><a href="#4、流水线的性能指标" class="headerlink" title="4、流水线的性能指标"></a>4、流水线的性能指标</h3><blockquote>
<p>衡量流水线性能指标主要有<strong>吞吐率</strong>、<strong>加速比</strong>和<strong>效率</strong>，这些都是指令流水线常见的性能指标</p>
<ul>
<li><p><strong>流水线的吞吐率：</strong></p>
<blockquote>
<p>在指令流水线中，吞吐率是指<strong>在单位时间内流水线所完成的任务数量，或输出结果的数量</strong>。其公式为：<br>$$<br>TP &#x3D; \frac{n}{T_k}<br>$$<br>其中，n是任务数，$T_k$是处理完n个任务所用的时间。</p>
<p>在<strong>理想</strong>（不出差错，所有阶段的时间都一样）的情况下，流水线的时空图如下，</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E5%90%9E%E5%90%90%E7%8E%87.png" alt="吞吐率"></p>
<p>设一个分<strong>k段</strong>的指令流水线能够在$(k+n-1)$个时钟周期内完成<strong>n个</strong>任务，$\Delta t$为时钟周期，可以得到流水线的实际吞吐率为<br>$$<br>TP&#x3D;\frac{n}{(k+n-1)\Delta t}<br>$$<br>当连续输入的任务数$n \to \infty$时，得到最大吞吐率为$TP_{max}&#x3D;\frac{1}{\Delta t}$</p>
<p><strong>补充：</strong>在指令流水线中，从第一条指令取指到第一条指令结束这一段时间被称为<strong>装入时间</strong>；从最后一条指令取指到最后一条指令结束这一段时间被称为<strong>排空时间</strong>。</p>
</blockquote>
</li>
<li><p><strong>流水线的加速比：</strong></p>
<blockquote>
<p><strong>定义：</strong>完成同一批任务，不使用流水线所用时间与使用流水线所用的时间之比，公式为：<br>$$<br>S&#x3D;\frac{T_0}{T_k}<br>$$<br>其中$T_0$为不使用流水线的时间，$T_k$为使用流水线的时间。</p>
<p>假设有n条分为k段的指令，每一段使用$\Delta t$的时间，那么流水线的加速比可以写成<br>$$<br>S&#x3D;\frac{kn\Delta t}{(k+n-1)\Delta t}&#x3D;\frac{kn}{k+n-1}<br>$$<br>当连续输入的任务数$n \to \infty$时，得到最大加速比为$S_{max}&#x3D;k$</p>
</blockquote>
</li>
<li><p><strong>流水线的效率：</strong></p>
<blockquote>
<p><strong>定义</strong>：流水线设备利用率</p>
<p>在时空图上，流水线的效率定义为完成n个任务占用的时空区有效面积，即n个任务所用时间和k个流水段所围成的时空区总面积之比，如图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E6%95%88%E7%8E%87.png" alt="流水线的效率"></p>
<p>蓝色的为完成n个任务所用的总时间，红色部分为k个流水段所围成的面积，表达式为：<br>$$<br>E&#x3D;\frac{T_0}{kT_k}<br>$$<br>其中，$T_0$为完成n个任务所花费的时间；$T_k$为流水线完成n个任务所使用的总时间（对应图中的横轴），k为一条指令分成的阶段数（对应图中的纵轴）</p>
<p>当连续输入的任务数$n \to \infty$时，最高效率为$E_{max}&#x3D;1$</p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="5、超标量流水线的基本概念"><a href="#5、超标量流水线的基本概念" class="headerlink" title="5、超标量流水线的基本概念"></a>5、超标量流水线的基本概念</h3><blockquote>
<ul>
<li><p><strong>超标量流水线技术</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E8%B6%85%E6%A0%87%E9%87%8F%E6%8A%80%E6%9C%AF.png" alt="超标量技术"></p>
<p>每个时钟周期内可<strong>并发多条独立指令</strong>，并以<strong>并行操作方式</strong>将多条指令编译并执行，因此需要配备多个功能部件。</p>
<p><strong>注意：</strong>不能调整指令的执行顺序，只能通过编译优化技术，将可以并行的指令搭配起来从而提高运行效率。</p>
</blockquote>
</li>
<li><p><strong>超流水线技术</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E8%B6%85%E6%B5%81%E6%B0%B4%E6%8A%80%E6%9C%AF.png" alt="超流水技术"></p>
<p>在<strong>一个时钟周期内再分段</strong>，即<strong>一个时钟周期内一个功能部件使用多次</strong></p>
<p><strong>注意：</strong>也是不能调整指令的执行顺序，只能通过编译器来解决优化问题</p>
</blockquote>
</li>
<li><p><strong>超长指令字</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/%E8%B6%85%E9%95%BF%E6%8C%87%E4%BB%A4%E5%AD%97.png" alt="超长指令字"></p>
<p>由编译程序挖掘指令间潜在的并行性，将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字（如多条指令同时取指等），因此需要配备多个功能部件。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="六、其他补充"><a href="#六、其他补充" class="headerlink" title="六、其他补充"></a>六、其他补充</h2><blockquote>
<ul>
<li><p><strong>流水线并不是越多越好：</strong>流水线越多，所需要的控制部件就越复杂，且出现冲突的概率就会越高。</p>
</li>
<li><p><strong>微指令与指令：</strong>在采用微程序控制的CPU中，一条指令对应一个微程序，一个微程序由多个微指令组成。（一条微指令又可以发出多个微命令信号）</p>
</li>
<li><p><strong>指令周期、机器周期和时钟周期：</strong></p>
<blockquote>
<ul>
<li><strong>指令周期：</strong>指令从取出到执行完成所需要的所有时间</li>
<li><strong>机器周期：</strong>在同步控制的机器中，执行指令周期中一步相对完整的操作（如取指阶段）所需的时间（一般安排机器周期长度为：主存周期）</li>
<li><strong>时钟周期：</strong>是计算机主时钟的周期时间，是计算机运行时最基本的时间单位，对应完成一个微操作的时间。通常$时钟周期&#x3D;\frac{1}{计算机主频}$</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>基础学科</tag>
      </tags>
  </entry>
  <entry>
    <title>BILSTM-CRF模型</title>
    <url>/2023/04/24/BILSTM-CRF%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="BILSTM-CRF模型是什么："><a href="#BILSTM-CRF模型是什么：" class="headerlink" title="BILSTM-CRF模型是什么："></a><strong>BILSTM-CRF模型是什么：</strong></h3><p>BILSTM-CRF模型是用于处理自然语言序列中命名实体识别问题，其构成为：<strong>双向长短时记忆网络（Bi-LSTM）</strong>和<strong>条件随机场（CRF）</strong>构成。</p>
<p><strong>模型输入</strong>：字符特征；<strong>模型输出</strong>：预测标签</p>
<img src="/picture/学习/自然语言处理/BILSTM-CRF模型/模型结构.png" alt="模型结构" style="zoom:67%;" />



<h3 id="BILSTM-CRF的构造："><a href="#BILSTM-CRF的构造：" class="headerlink" title="BILSTM-CRF的构造："></a><strong>BILSTM-CRF的构造：</strong></h3><ul>
<li><p><strong>模型输入：</strong></p>
<p>对于输入的自然语言序列，可通过<strong>特征工程</strong>的方法定义序列字符的特征。现在更多的做法是：直接选择句子中每个字符的嵌入或词嵌入向量，可以是事先训练好的或随机初始化。对于中文，可以将字符向量和其所属的词向量进行拼接，词嵌入使用预训练好的，字嵌入随机初始化。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/BILSTM-CRF%E6%A8%A1%E5%9E%8B/%E6%A8%A1%E5%9E%8B%E8%BE%93%E5%85%A5.png" alt="模型输入"></p>
<p>双向LSTM接收每个字符的embdding，并预测每个字符对5个标签的概率。</p>
<p>LSTM是一种特殊的<strong>循环神经网络</strong>（RNN）</p>
</li>
</ul>
<h3 id="循环神经网络（RNN）"><a href="#循环神经网络（RNN）" class="headerlink" title="循环神经网络（RNN）"></a>循环神经网络（RNN）</h3><p>RNN对具有<strong>序列特性</strong>的数据非常有效，它能挖掘数据中的<strong>时序信息</strong>及<strong>语义信息</strong></p>
<p><strong>序列特性：</strong>指符合时间顺序、逻辑顺序、或者其他顺序的特性。比如人的自然语言，语音等</p>
<h4 id="循环神经网络的结构及其原理"><a href="#循环神经网络的结构及其原理" class="headerlink" title="循环神经网络的结构及其原理"></a>循环神经网络的结构及其原理</h4><img src="/picture/学习/自然语言处理/BILSTM-CRF模型/循环神经元.png" alt="循环神经元" style="zoom:50%;" />

<p>其中输入层X是一个向量，即一个字或词的特征向量；U是输入层到隐藏层的参数矩阵；V是隐藏层到输出层的参数矩阵；w是RNN为序列特性所作的一个变化，下面详细阐述</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/BILSTM-CRF%E6%A8%A1%E5%9E%8B/w.png" alt="w"></p>
<p>W表示每个事件点之间的权重矩阵，即通过W记住了每一时刻的信息，<strong>每一时刻的隐藏层不仅由该时刻的输入层决定，还由上一时刻的隐藏层决定</strong>，即<br>$$<br>S_t&#x3D;f(U\cdot X_t+W\cdot S_{t-1})\<br>O_t &#x3D; g(V\cdot S_t)<br>$$<br>例如，我是谁，在使用RNN时，$X_{t-1}$就是”我“的特征向量，$X_t$就是“是”的特征向量 ，$X_{t+1}$就是谁的特征向量。“谁”的输出层明显受“我”和“是”的影响；“是”的输出层受“我”的影响</p>
<p><strong>注意：</strong>在整个训练过程中，每一时刻所用的W都是相同的</p>
<p><strong>例子：</strong></p>
<blockquote>
<p>假设有一个RNN模型如下图，</p>
<img src="/picture/学习/自然语言处理/BILSTM-CRF模型/RNN例子.png" alt="RNN例子" style="zoom:75%;" />

<p>$S_t&#x3D;U\cdot X_t+W\cdot S_{t-1}$，$O_t&#x3D;V\cdot S_t$，W默认为$[1\ 1]$，权重U，V都为1</p>
<p><strong>输入向量</strong>：$[1\ 1],[1\ 1],[2\ 2]$</p>
<ul>
<li>$S_1&#x3D;(1<em>1+1</em>1)+(1<em>0+1</em>0)&#x3D;2$</li>
<li>$O_1&#x3D;2<em>1+2</em>1&#x3D;4$</li>
<li>输出向量：$[4\ 4]$</li>
<li>$S_2&#x3D;(1<em>1+1</em>1)+(1<em>2+1</em>2)&#x3D;6$</li>
<li>$O_2&#x3D;6<em>1+6</em>1&#x3D;12$</li>
<li>输出向量：$[12\ 12]$</li>
<li>$S_3&#x3D;(1<em>2+1</em>2)+(1<em>6+1</em>6)&#x3D;16$</li>
<li>$O_3&#x3D;16<em>1+16</em>1&#x3D;32$</li>
<li>输出向量：$[32\ 32]$</li>
</ul>
<p>很明显，如果输入向量顺序不同，得到的结果也会不同，这就是RNN的特点：可以处理序列数据，同时对序列也很敏感</p>
</blockquote>
<h3 id="长短期记忆（LSTM）"><a href="#长短期记忆（LSTM）" class="headerlink" title="长短期记忆（LSTM）"></a>长短期记忆（LSTM）</h3><p>LSTM是RNN的一种，比普通的RNN更加高级，一般情况下LSTM要比RNN效果要好。</p>
<p>LSTM通过“门控装置“有效地缓解了<strong>梯度消失</strong>与<strong>梯度爆炸</strong>的问题。</p>
<h4 id="LSTM的结构"><a href="#LSTM的结构" class="headerlink" title="LSTM的结构"></a>LSTM的结构</h4><p>RNN是一个可以记住前面信息的模型，但是它无差别地去记住所有的信息；LSTM则可以在RNN的基础上，有选择地记住之前的信息。设定RNN存储信息的模块叫Memory Cell，那么LSTM比RNN多了三个门，用于选择性遗忘部分信息</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/BILSTM-CRF%E6%A8%A1%E5%9E%8B/Memory_Cell.png" alt="Memory_Cell"></p>
<ul>
<li><strong>Input Gate：</strong>即<strong>输入门</strong>，从输入层输入的信息都会先经过输入门，输入门的开关会决定信息是否能输入到记忆细胞（Memory Cell）中</li>
<li><strong>Output Gate：</strong>即<strong>输出门</strong>，输出门决定了是否会有信息从记忆细胞（Memory Cell）中输出</li>
<li><strong>Forget Gate：</strong>即遗忘门，遗忘门决定了记忆细胞（Memory Cell）里的数据是否要被遗忘，如果选择遗忘，记忆细胞里的数据则会清空</li>
</ul>
<p><strong>信息输入顺序：</strong>先经过输入门，看是否有信息输入，再判断遗忘门是否选择遗忘Memory Cell里的信息，最后再经过输出门，判断是否将这一时刻的信息进行输出</p>
<p>下面的结构是一个时间点上的内部结构，就是整个工作流程中的其中一个时间点，</p>
<img src="/picture/学习/自然语言处理/BILSTM-CRF模型/LSTM内部结构.png" alt="LSTM内部结构" style="zoom:67%;" />

<ul>
<li><strong>Cell：</strong>就是记忆细胞，类似于普通RNN的$S_t$，都是存储中间的信息（即隐藏层），而且存储的信息都有可能保存到下一时刻</li>
<li>$\alpha$：即输出，对应于普通RNN的$O_t$</li>
<li>$\int_g$：表示的是一个激活函数，LSTM中常用的激活函数有两个：$tanh()$和$sigmoid()$</li>
<li>$Z$：最普通的输入，$Z&#x3D;tanh(W\cdot[x_t,S_{t-1}])$，即$Z$的激活函数为$tanh()$，而且$Z$是真正的输出，对应于普通RNN的$x_t$</li>
<li>$Z_i$：输入门的门控装置，$Z_i$同样也是通过该时刻的输入$x_t$和上一时刻的隐藏状态$S_{t-1}$向量拼接再与权重向量$W_i$点积（注意门个门的权重向量都不一样），即$Z_i&#x3D;\sigma(W_i\cdot[x_t,S_{t-1}])$</li>
<li>$Z_f$：与$Z_i$类似，$Z_f&#x3D;\sigma(W_f\cdot[x_t,S_{t-1}])$</li>
<li>$Z_o$：与$Z_i$类似，$Z_o&#x3D;\sigma(W_o\cdot[x_t,S_{t-1}])$</li>
</ul>
<p><strong>LSTM的计算阶段：</strong></p>
<blockquote>
<p><strong>总结构：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/BILSTM-CRF%E6%A8%A1%E5%9E%8B/LSTM%E6%80%BB%E4%BD%93%E6%A1%86%E6%9E%B6.png" alt="LSTM总体框架"></p>
<ul>
<li><p><strong>计算遗忘门：</strong></p>
<blockquote>
<p><strong>输入：</strong>前一时刻的隐藏层状态$h_{t-1}$，当前时刻的输入向量$X_t$</p>
<p><strong>输出：</strong>遗忘门的值$f_t$</p>
</blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/BILSTM-CRF%E6%A8%A1%E5%9E%8B/%E8%AE%A1%E7%AE%97%E9%81%97%E5%BF%98%E9%97%A8.png" alt="计算遗忘门"></p>
</li>
<li><p><strong>计算记忆门，选择要记忆的信息</strong></p>
<blockquote>
<p><strong>输入：</strong>前一时刻的隐藏层状态$h_{t-1}$，当前时刻的输入向量$X_t$</p>
<p><strong>输出：</strong>记忆门的值$i_t$，临时记忆细胞状态$C’_t$</p>
</blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/BILSTM-CRF%E6%A8%A1%E5%9E%8B/%E8%AE%A1%E7%AE%97%E8%AE%B0%E5%BF%86%E9%97%A8.png" alt="计算记忆门"></p>
</li>
<li><p><strong>计算当前时刻的记忆细胞状态</strong></p>
<blockquote>
<p><strong>输入：</strong>记忆门的值$i_t$，遗忘门的值$f_i$，临时记忆细胞状态$C_t’$，上一刻记忆细胞状态$C_{t-1}$</p>
<p><strong>输出：</strong>当前时刻记忆细胞状态$C_t$</p>
</blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/BILSTM-CRF%E6%A8%A1%E5%9E%8B/%E8%AE%A1%E7%AE%97%E5%BD%93%E5%89%8D%E7%9A%84%E8%AE%B0%E5%BF%86%E7%BB%86%E8%83%9E%E7%8A%B6%E6%80%81.png" alt="计算当前的记忆细胞状态"></p>
</li>
<li><p><strong>计算输出门和当前隐藏层状态</strong></p>
<blockquote>
<p><strong>输入：</strong>前一时刻的隐藏层状态$h_{t-1}$，当前时刻的输入向量$X_t$，当前时刻记忆细胞状态$C_t$</p>
<p><strong>输出：</strong>输出门的值$O_t$，隐藏层状态$h_t$</p>
</blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/BILSTM-CRF%E6%A8%A1%E5%9E%8B/%E8%AE%A1%E7%AE%97%E8%BE%93%E5%87%BA%E5%B1%82.png" alt="计算输出层"></p>
</li>
</ul>
<p>这样一来就能得到与句子长度相同的隐藏层状态序列$(h_0,h_1,…,h_{n-1})$</p>
</blockquote>
<h4 id="BiLSTM（双向长短期记忆）"><a href="#BiLSTM（双向长短期记忆）" class="headerlink" title="BiLSTM（双向长短期记忆）"></a>BiLSTM（双向长短期记忆）</h4><p>由向前的LSTM与向后的LSTM结合形成的BiLSTM，比如，将”我爱中国“</p>
<p>这句话放进BiLSTM中进行编码</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/BILSTM-CRF%E6%A8%A1%E5%9E%8B/%E5%8F%8C%E5%90%91LSTM%E7%BC%96%E7%A0%81%E5%8F%A5%E5%AD%90.png" alt="双向LSTM编码句子"></p>
<p>向前的$LSTM_L$依次输入”我“，”爱“，”中国“得到三个向量${h_{L0},h_{L1},h_{L2}}$。向后的$LSTM_R$依次输入”中国“，”爱“，”我“得到三个向量${h_{R0},h_{R1},h_{R2}}$。最后将这两组的隐向量进行拼接得到${[h_{L0},h_{R2}],[h_{L1},h_{R1}],[h_{L2},h_{R0}]}$，即${h_0,h_1,h_2}$</p>
<h3 id="条件随机场（CRF）"><a href="#条件随机场（CRF）" class="headerlink" title="条件随机场（CRF）"></a>条件随机场（CRF）</h3><p>CRF是一个序列化标注算法，接收一个输入序列如$X&#x3D;(x_1,x_2,…,x_n)$并且输出目标序列$Y&#x3D;(y_1,y_2,…,y_n)$.（即对输入序列进行标注的算法）</p>
<h4 id="CRF基础"><a href="#CRF基础" class="headerlink" title="CRF基础"></a>CRF基础</h4><ul>
<li><p><strong>无向图：</strong>指边没有方向的图</p>
</li>
<li><p><strong>马尔可夫随机场：</strong>（概率图模型，即图论+概率）</p>
<ul>
<li><p><strong>场：</strong>在空间某一区域内，除个别点外，如果对于该区域的每一点P都定义了一个确定的量$f(P)$，该区域就称为$f(P)$的场（与域作区分）</p>
</li>
<li><p><strong>随机过程：</strong>设T是一个无限实数集，把依赖于参数$t\in T$的一族（无限多个）随机变量称为随机过程，记作${X(t),t\in T}$（比如随时间变化而变化的随机现象）</p>
</li>
<li><p><strong>随机场：</strong>若T是n维空间的某个子集，即t是一个n维向量，此时随机过程又称为随机场（从平面的随机过程到向量空间的随机场）</p>
</li>
<li><p><strong>马尔可夫随机场：（概率无向图模型）</strong></p>
<p>具有马尔可夫性的随机场</p>
<p>马尔可夫性：<br>$$<br>P(y_v|X,Y_w,w\neq v)&#x3D;P(Y_v|X,Y_w,w\sim v)<br>$$<br>其中：</p>
<p>$w\sim v$表示在图$G&#x3D;(V,E)$中<strong>与顶点v有边连接</strong>的所有顶点w</p>
<p>$w\neq v$表示顶点v以外的所有顶点</p>
<p>$Y_v$与$Y_w$为顶点v与顶点w的随机变量</p>
</li>
</ul>
</li>
<li><p><strong>最大团</strong></p>
<ul>
<li><strong>团：</strong>对于图中结点的一个子集，其中<strong>任意两结点间都有边连接</strong>，则称该结点子集为团</li>
<li><strong>最大团：</strong>若一个团中加入另外任何其他结点都不再形成团，则称该团为最大团</li>
</ul>
</li>
<li><p><strong>势函数：</strong>定义再变量子集上的非负实函数，用于相乘生成联合概率分布函数，也称为因子记作$\psi(x)$</p>
</li>
<li><p><strong>无向图的因子分解（Hammersley-Clifford）：</strong></p>
<p>给定概率无向图模型，设其无向图为G，C为G上的最大团，$Y_C$表示C对应的随机变量。那么概率无向图模型的联合概率分布$P(Y)$可写作图中<strong>所有最大团C</strong>上的函数$\psi_C(Y_C)$的<strong>乘积形式</strong>，即<br>$$<br>P(Y)&#x3D;\frac{1}{Z}\psi_C(Y_C)\<br>Z&#x3D;\sum \sum_c \psi_C(Y_C)<br>$$<br>其中，$\psi_C(Y_C)$是C上定义的严格正函数，通常取指数函数</p>
<p>例子，</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/BILSTM-CRF%E6%A8%A1%E5%9E%8B/%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E5%9B%A0%E5%AD%90%E5%88%86%E8%A7%A3.png" alt="无向图的因子分解"></p>
</li>
</ul>
<h4 id="CRF原理"><a href="#CRF原理" class="headerlink" title="CRF原理"></a>CRF原理</h4><p>条件随机场定义如下：</p>
<blockquote>
<p>设X与Y是随机变量，$P(Y|X)$是在<strong>给定X的条件下</strong>Y的条件概率分布</p>
<p>若随机变量Y构成一个由<strong>无向图</strong>$G&#x3D;(V,E)$表示的<strong>马尔可夫随机场</strong>，即<br>$$<br>P(y_v|X,Y_w,w\neq v)&#x3D;P(Y_v|X,Y_w,w\sim v)<br>$$<br>对任意顶点v成立，则称条件概率分布$P(Y|X)$为条件随机场</p>
<p>其中：</p>
<ul>
<li><p>$w\sim v$表示在图$G&#x3D;(V,E)$中<strong>与顶点v有边连接</strong>的所有顶点w</p>
</li>
<li><p>$w\neq v$表示顶点v以外的所有顶点</p>
</li>
<li><p>$Y_v$与$Y_w$为顶点v与顶点w的随机变量</p>
</li>
</ul>
</blockquote>
<ul>
<li><p><strong>线性链条件随机场</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/BILSTM-CRF%E6%A8%A1%E5%9E%8B/%E7%BA%BF%E6%80%A7%E9%93%BE%E6%9D%A1%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%9C%BA.png" alt="线性链条件随机场"></p>
<p><strong>定义：</strong></p>
<blockquote>
<p>设$X&#x3D;(X_1,X_2,…,X_n),Y&#x3D;(Y_1,Y_2,…,Y_n)$均为线性表示的随机变量序列</p>
<p>若在给定随机变量序列X的条件下，</p>
<p>随机变量序列Y的条件概率分布$P(Y|X)$构成条件随机场，即满足马尔可夫性<br>$$<br>P(Y_i|X,Y_1,…,Y_{i-1},…,Y_n)&#x3D;P(Y_i|X,Y_{i-1},Y_{i+1})<br>$$<br>则称$P(Y|X)$为线性链条件随机场</p>
<p>其中$i&#x3D;1,2,…,n$，在$i&#x3D;1$和n时只考虑单边</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>自然语言处理</category>
      </categories>
      <tags>
        <tag>深渊巨坑</tag>
        <tag>算法模型</tag>
        <tag>自然语言处理</tag>
      </tags>
  </entry>
  <entry>
    <title>输入输出系统</title>
    <url>/2022/08/08/7%E3%80%81%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="一、I-O系统的基本概念"><a href="#一、I-O系统的基本概念" class="headerlink" title="一、I&#x2F;O系统的基本概念"></a>一、I&#x2F;O系统的基本概念</h2><h3 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h3><blockquote>
<ul>
<li><p><strong>I&#x2F;O硬件：</strong>包括外部设备、设备控制器和接口、I&#x2F;O总线等。通过设备控制器来控制I&#x2F;O设备的具体动作。</p>
<blockquote>
<ul>
<li><strong>外部设备：</strong>包括输入&#x2F;输出设备及通过输入&#x2F;输出接口才能访问的外存储器设备</li>
<li><strong>I&#x2F;O接口：</strong>又称<strong>I&#x2F;O控制器、设备控制器</strong>，负责协调主机和外部设备之间的数据传输。（I&#x2F;O控制器本质就是一块芯片，一般集成在主板上）</li>
</ul>
</blockquote>
</li>
<li><p><strong>I&#x2F;O软件：</strong>包括驱动程序、用户程序、管理程序、升级补丁等。通常采用I&#x2F;O指令和通道指令（这两与CPU指令有所区别）实现CPU和I&#x2F;O设备的信息交换。</p>
</li>
</ul>
</blockquote>
<h3 id="2、I-O控制方式"><a href="#2、I-O控制方式" class="headerlink" title="2、I&#x2F;O控制方式"></a>2、I&#x2F;O控制方式</h3><blockquote>
<ul>
<li><p><strong>程序查询方式：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/IO%E8%AE%BE%E5%A4%87/%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F.png" alt="程序查询方式"></p>
<p>由CPU通过程序<strong>不断</strong>查询I&#x2F;O设备是否已经做好准备，从而控制I&#x2F;O设备与主机交换信息</p>
</blockquote>
</li>
<li><p><strong>程序中断方式：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/IO%E8%AE%BE%E5%A4%87/%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F.png" alt="程序中断方式"></p>
<p>只在I&#x2F;O设备准备就绪并向CPU发出中断请求时才给予响应</p>
</blockquote>
</li>
<li><p><strong>DMA方式：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/IO%E8%AE%BE%E5%A4%87/DMA%E6%96%B9%E5%BC%8F.png" alt="DMA方式"></p>
<p>主存与I&#x2F;O设备之间有一条直接数据通路，当主存和I&#x2F;O设备交换信息时，无需调用中断服务程序</p>
</blockquote>
</li>
<li><p><strong>通道方式：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/IO%E8%AE%BE%E5%A4%87/%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F.png" alt="通道控制方式"></p>
<p>在系统中设有通道控制部件，每个通道都挂接若干外设，主机在执行I&#x2F;O命令时，只需启动有关通道，通道只需通道程序，从而完成I&#x2F;O操作</p>
</blockquote>
</li>
</ul>
<p>其中，<strong>程序查询方式</strong>和<strong>程序中断方式</strong>主要用于数据传输率较低的外部设备，<strong>DMA方式</strong>和<strong>通道方式</strong>主要用于传输速率较高的设备。</p>
</blockquote>
<h2 id="二、外部设备"><a href="#二、外部设备" class="headerlink" title="二、外部设备"></a>二、外部设备</h2><h3 id="1、输入设备"><a href="#1、输入设备" class="headerlink" title="1、输入设备"></a>1、输入设备</h3><blockquote>
<ul>
<li><p><strong>键盘：</strong></p>
<blockquote>
<p> 键盘通常以矩阵的形式排列按键，每个键用符号表明其含义和作用。每个键相当于一个开关，按下按键时，电信号接通；松开键时，弹簧弹起键，电信号断开。</p>
<p><strong>输入信息的步骤：</strong>①、查出按下的是哪个键；②、将该键翻译成能被主机接收的编码；③、将编码传送给主机</p>
</blockquote>
</li>
<li><p><strong>鼠标：</strong></p>
<blockquote>
<p><strong>工作原理：</strong>鼠标在平面上移动时，其底部传感器把运动的方向和距离检测出来，从而控制光标做相应的运动</p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="2、输出设备"><a href="#2、输出设备" class="headerlink" title="2、输出设备"></a>2、输出设备</h3><blockquote>
<ul>
<li><p><strong>显示器：</strong></p>
<blockquote>
<p>显示设备种类很多，按显示设备所用的显示器分类，有阴极射线管显示器，液晶显示器，发光二极管显示器等。显示器属于点阵方式运行的设备，有以下主要参数：</p>
<ul>
<li><p><strong>屏幕大小：</strong>以屏幕对角线长度表示</p>
</li>
<li><p><strong>分辨率：</strong>所能表示的像素个数，以宽和高的像素数的乘积表示，如$1024 \times 768$</p>
</li>
<li><p><strong>灰度级</strong>：指黑白显示器中所显示的像素点的亮暗差别，在彩电中则是表示为颜色的不同，灰度级越多，图像层次就越清楚、逼真。</p>
</li>
<li><p><strong>刷新：</strong>光点消失前再重新扫描显示一遍的过程</p>
</li>
<li><p><strong>刷新频率：</strong>指单位时间内扫描整个屏幕的次数，当刷新频率大于30Hz时，人眼才不会看出卡顿</p>
</li>
<li><p><strong>显示存储器：</strong>也称刷新存储器，用于存储每帧图像的信息，其存储容量由分辨率和灰度级决定，<br>$$<br>VRAM容量&#x3D;分辨率 \times 灰度级位数 \<br>VRAM带宽&#x3D;分辨率 \times 灰度级位数 \times 帧频<br>$$</p>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="3、外存储器"><a href="#3、外存储器" class="headerlink" title="3、外存储器"></a>3、外存储器</h3><blockquote>
<ul>
<li><strong>磁表面存储器：</strong>指某些磁性材料薄薄地涂在金属铝或塑料表面上作为载磁体来存储信息。磁盘存储器、磁带存储器和磁鼓存储器均属于磁表面存储器</li>
<li><strong>固态硬盘：</strong>采用高性能Flash存储器作为组成元件</li>
<li><strong>光盘存储器：</strong>利用光学原理读&#x2F;写信息的存储装置，采用计较激光束对盘式介质以非接触方式记录信息。</li>
</ul>
</blockquote>
<h2 id="三、I-O接口"><a href="#三、I-O接口" class="headerlink" title="三、I&#x2F;O接口"></a>三、I&#x2F;O接口</h2><h3 id="1、I-O接口的功能"><a href="#1、I-O接口的功能" class="headerlink" title="1、I&#x2F;O接口的功能"></a>1、I&#x2F;O接口的功能</h3><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/IO%E8%AE%BE%E5%A4%87/IO%E6%8E%A5%E5%8F%A3%E7%BB%93%E6%9E%84.png" alt="IO接口结构"></p>
<ul>
<li><strong>数据缓冲：</strong>通过数据缓冲寄存器（DBR）达到主机和外设工作速度的匹配</li>
<li><strong>错误信息或工作状态监测：</strong>通过状态寄存器反馈设备的各种错误、状态信息，供CPU查用</li>
<li><strong>控制和定时：</strong>接收从控制总线发来的控制信号、时钟信号</li>
<li><strong>数据格式转换：</strong>串-并、并-串等格式转换</li>
<li><strong>与主机和设备通信：</strong>实现 主机-I&#x2F;O接口-I&#x2F;O设备 之间的通信</li>
</ul>
</blockquote>
<h3 id="2、I-O接口的基本结构"><a href="#2、I-O接口的基本结构" class="headerlink" title="2、I&#x2F;O接口的基本结构"></a>2、I&#x2F;O接口的基本结构</h3><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/IO%E8%AE%BE%E5%A4%87/IO%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" alt="IO接口的基本结构"></p>
<ul>
<li><strong>主机侧：</strong>指通过总线连接计算机系统的一侧</li>
<li><strong>设备侧：</strong>指与外部设备进行连接的一侧，设备侧可以有多个外部设备的控制逻辑</li>
<li><strong>数据缓冲寄存器：</strong>连接CPU和外设数据交互的一个中间媒介</li>
<li><strong>状态&#x2F;控制寄存器：</strong>状态寄存器：存取设备的状态字；控制寄存器：存放从CPU发送过来的控制命令</li>
<li><strong>I&#x2F;O控制逻辑：</strong>根据主机侧发送过来的命令字，向设备发送相对应的命令（需要驱动程序的协助）</li>
<li><strong>数据线：</strong>读写数据、状态字、控制字、中断类型</li>
<li><strong>地址线：</strong>传送CPU要读取的寄存器的地址（I&#x2F;O端口）</li>
<li><strong>控制线：</strong>读写IO端口的信号、中断请求的信号</li>
</ul>
<p><strong>I&#x2F;O端口：</strong>IO控制器中的各种寄存器的统称</p>
</blockquote>
<h3 id="3、I-O接口类型"><a href="#3、I-O接口类型" class="headerlink" title="3、I&#x2F;O接口类型"></a>3、I&#x2F;O接口类型</h3><blockquote>
<p>根据不同的角度来看，I&#x2F;O接口可以分为不同的类型。</p>
<ul>
<li>按数据传输方式：<strong>并行接口</strong>和<strong>串行接口</strong></li>
<li>按主机访问I&#x2F;O设备的控制方式：<strong>程序查询接口</strong>、<strong>中断接口</strong>和<strong>DMA接口</strong></li>
<li>按功能选择的灵活性：<strong>可编程接口</strong>和<strong>不可编程接口</strong></li>
</ul>
</blockquote>
<h3 id="4、I-O端口机器编址"><a href="#4、I-O端口机器编址" class="headerlink" title="4、I&#x2F;O端口机器编址"></a>4、I&#x2F;O端口机器编址</h3><blockquote>
<p>I&#x2F;O端口是指接口电路中可被CPU直接访问的寄存器，主要有数据端口（读&#x2F;写）、状态端口（读）、控制端口（写）。</p>
<p>I&#x2F;O端口需要能够被访问，就需要对各个端口进行编号，每个端口对应一个地址，而对I&#x2F;O端口的编址方式可以分为<strong>存储器统一编址</strong>和<strong>独立编址</strong></p>
<ul>
<li><strong>存储器统一编址：</strong>又称<strong>存储器映射方式</strong>，指把I&#x2F;O端口当作存储器的单元进行地址分配（即将I&#x2F;O端口的地址放入内存中）。这种方式CPU无需额外设置专门的I&#x2F;O指令，用统一的访存指令就可以访问I&#x2F;O端口。</li>
<li><strong>独立编址：</strong>又称<strong>I&#x2F;O映射方式</strong>，I&#x2F;O端口的地址空间与内存空间是两个独立的地址空间（I&#x2F;O端口的地址与内存分开）。采用这种方式的话CPU需要专门设计相应的I&#x2F;O指令来访问I&#x2F;O端口。</li>
</ul>
</blockquote>
<h2 id="四、I-O控制方式"><a href="#四、I-O控制方式" class="headerlink" title="四、I&#x2F;O控制方式"></a>四、I&#x2F;O控制方式</h2><h3 id="1、程序查询方式"><a href="#1、程序查询方式" class="headerlink" title="1、程序查询方式"></a>1、程序查询方式</h3><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/IO%E8%AE%BE%E5%A4%87/%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F.png" alt="程序查询方式"></p>
<p>信息交换的控制完全由CPU执行程序实现，程序查询方式接口中设置了一组数据缓冲寄存器（数据端口）和一个设备状态寄存器（状态端口）。</p>
<p>主机进行I&#x2F;O操作时，先发出询问信号，读取设备的状态，并根据设备的状态决定下一步操作时进行数据传送还是等待。</p>
<p><strong>程序查询方式的工作流程图：</strong></p>
<blockquote>
<img src="/picture/学习/计算组成原理上的图/IO设备/程序查询方式流程图.png" alt="程序查询方式流程图" style="zoom:50%;" />

<ul>
<li>CPU执行初始化程序，并预置传送参数</li>
<li>向I&#x2F;O接口发出命令字，并启动I&#x2F;O设备</li>
<li>从外设接口读取器状态信息</li>
<li><strong>CPU不断查询I&#x2F;O设备的状态，直至外设准备就绪</strong></li>
<li>传送一次数据</li>
<li>修改地址和计数器参数</li>
<li>判断是否传送完成，如果未完成则返回第三步，直到计数器为0</li>
</ul>
</blockquote>
<p>在这种控制方式下，CPU一旦启动I&#x2F;O，就必须停止现行程序的运行。程序查询的特点时<strong>CPU有“踏步”等待现象</strong>。</p>
<p><strong>优点：</strong>接口设计简单、设备量少</p>
<p><strong>缺点：</strong>CPU需要花大量时间进行查询和等待，且一段时间内只能与一台外设进行交换信息，效率太低</p>
</blockquote>
<h3 id="2、程序中断方式"><a href="#2、程序中断方式" class="headerlink" title="2、程序中断方式"></a>2、程序中断方式</h3><blockquote>
<p><strong>程序中断：</strong>指在计算机执行程序的过程中，出现某些急需处理的异常情况或特殊请求，CPU暂时终止现行程序，转而去对这些异常情况或特殊请求进行处理，在处理完成后CPU又自动返回到原来程序的断点处，继续执行原来的程序。</p>
<p><strong>概念：</strong></p>
<blockquote>
<ul>
<li><strong>中断源：</strong>请求CPU中断的设备或事件。</li>
<li><strong>开中断：</strong>允许CPU处理中断请求</li>
<li><strong>关中断：</strong>不允许CPU处理中断请求</li>
<li><strong>非屏蔽中断：</strong>关中断时也会被影响（如，断点）</li>
<li><strong>可屏蔽中断：</strong>关中断时不会被响应</li>
<li><strong>中断请求标记：</strong>用于区分不同的中断源的一个标记，一般存放在中断请求标记寄存器中</li>
<li><strong>中断向量：</strong>中断服务程序的入口地址</li>
<li><strong>中断向量表：</strong>全部中断向量集中存放的区域</li>
</ul>
</blockquote>
<p><strong>工作流程：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/IO%E8%AE%BE%E5%A4%87/%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B.png" alt="程序中断流程"></p>
<ul>
<li><p><strong>中断请求：</strong></p>
<blockquote>
<p> 即中断源向CPU提出中断信号</p>
<p><strong>CPU响应中断的条件：</strong></p>
<blockquote>
<ul>
<li>中断源有中断请求</li>
<li>CPU允许中断及开中断（异常和不可屏蔽中断不受此限制）</li>
<li>一条指令执行完毕（异常不受此限制），且没有迫切的任务</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>中断响应判优：</strong></p>
<blockquote>
<p>由于中断类型千差万别，因此对于不同的中断信号可以划分不同的优先级（中断判优通常是通过硬件排队器实现的）</p>
<p>一般来说，不可屏蔽中断 &gt; 内部异常 &gt; 可屏蔽中断</p>
<p>内部异常中，硬件故障 &gt; 软件中断</p>
<p>DMA中断请求要优于I&#x2F;O设备传送的中断请求；高速设备优于低速设备；输入设备高于输出设备；实时设备高于普通设备。</p>
<p><strong>注意：</strong>中断请求的优先级可以使用关中断和开中断进行动态调整</p>
</blockquote>
</li>
<li><p><strong>保存现场：</strong></p>
<blockquote>
<p>CPU响应中断后，需要进行一些操作方便呆会回到源程序，这些操作是<strong>由硬件直接实现</strong>的，被称为<strong>中断隐指令</strong>。中断隐指令不是CPU具体的某一条指令，而是一系列操作的统称，其操作如下：</p>
<ul>
<li><strong>关中断：</strong>CPU响应中断后，首先要做的是保护程序的断点以及现场信息。而在保存现场信息的过程是不能中断的，因此需要使用关中断和开中断进行原子操作。</li>
<li><strong>保存断点与保存现场：</strong>将源程序的断点以及所有寄存器的内容存到特定的栈中。</li>
<li><strong>开中断</strong></li>
</ul>
</blockquote>
</li>
<li><p><strong>引出中断服务程序：</strong></p>
<blockquote>
<p>识别中断源，将对应的服务程序入口地址送入程序计数器中。常用的识别方法有：<strong>硬件向量法</strong>和<strong>软件查询法</strong></p>
<p>在保存完断点以后，需要的就是找到中断向量，从而进入中断服务程序。</p>
<p>在排队器输出向量地址后，根据向量地址去查找中断向量表来得到中断向量。</p>
<p><strong>硬件向量法：</strong>中断向量则是由排队器输出的<strong>向量地址</strong>（中断向量的地址，也称为<strong>中断类型号</strong>）所形成。</p>
</blockquote>
</li>
<li><p><strong>执行中断服务程序</strong></p>
</li>
<li><p><strong>恢复现场</strong></p>
<blockquote>
<p>恢复现场也是一个原子操作，因此需要用到开中断和关中断。恢复现场就是将保存现场中存入栈的数据恢复到原来的位置，而且程序计数器也要指回断点处。</p>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>总结：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/IO%E8%AE%BE%E5%A4%87/%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.png" alt="中断处理过程"></p>
<p>程序中断处理时由硬件和软件共同完成的，如图，至中断服务程序寻址之前的步骤都是由硬件实现的，后面一系列操作则是由中断程序完成的。</p>
</blockquote>
<p><strong>多重中断和中断屏蔽技术：</strong></p>
<blockquote>
<ul>
<li><p><strong>多重中断：</strong></p>
<blockquote>
<p>如果CPU在执行中断服务程序的过程中，又出现了更高优先级的中断请求，CPU暂停现行的中断服务程序，转而处理新的中断请求，这就称作<strong>多重中断</strong>（类似函数嵌套）</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/IO%E8%AE%BE%E5%A4%87/%E5%A4%9A%E9%87%8D%E4%B8%AD%E6%96%AD.png" alt="多重中断"></p>
</blockquote>
</li>
<li><p><strong>中断屏蔽技术：</strong></p>
<blockquote>
<p>中断屏蔽技术主要用于多重中断。</p>
<p>每个中断源都会设置一个<strong>屏蔽触发器</strong>，1表示屏蔽该中断源的请求，0表示可以正常发出中断请求，所有屏蔽触发器组合在一起，就会构成一个屏蔽字寄存器，这个寄存器被称为<strong>屏蔽字</strong>，如</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/IO%E8%AE%BE%E5%A4%87/%E5%B1%8F%E8%94%BD%E5%AD%97.png" alt="屏蔽字"></p>
<p><strong>屏蔽字规律：</strong></p>
<blockquote>
<ul>
<li>一般用“1”表示屏蔽，”0“则表示正常申请</li>
<li>每个中断源对应一个屏蔽字，即在处理该中断源时，屏蔽寄存器中的内容为该中断源对应的内容</li>
<li>屏蔽字中“1”越多，优先级越高。每个中断源必须屏蔽它本身</li>
</ul>
<p>例如，当A在进行中断服务时，如果此时D也发送中断请求，由表可知，A不能屏蔽D，那么此时进入多重中断，先执行D的中断服务</p>
</blockquote>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<h3 id="3、DMA方式"><a href="#3、DMA方式" class="headerlink" title="3、DMA方式"></a>3、DMA方式</h3><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/IO%E8%AE%BE%E5%A4%87/DMA%E6%96%B9%E5%BC%8F.png" alt="DMA方式"></p>
<p>DMA方式是一种完全由硬件进行信息传递的控制方式。DMA方式在外设与内存之间开辟一条“直接数据通道”，信息传送不再经过CPU，降低了CPU在传输数据时的开销。</p>
<p>这种方式适用于磁盘、显卡、声卡、网卡等高速设备大批量数据的传送。</p>
<p>在DMA方式中，中断的作用仅限于故障和正常传送结束时的处理</p>
<p><strong>DMA方式的特点：</strong></p>
<blockquote>
<p>主存和DMA接口之间有一条直接数据通路。由于DMA方式传送数据不需要经过CPU，因此不必中断现行程序，I&#x2F;O与主机并行工作，程序和传送并行工作</p>
<ul>
<li>它使主存与CPU的固定联系脱钩，主存既可被CPU访问，也可以被外设访问</li>
<li>在数据传输，主存地址的确定，传输数据的计数等都由硬件电路直接实现</li>
<li>主存中有一块专用缓冲区，及时供给和接收外设的数据</li>
<li>DMA可以使得CPU和外设同时工作</li>
<li>DMA在传输开始前需要通过程序进行预处理，结束后需要通过中断方式进行后处理</li>
</ul>
</blockquote>
<p><strong>DMA控制器的结构：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/IO%E8%AE%BE%E5%A4%87/DMA%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="DMA控制器的结构"></p>
<p>在DMA方式中，对数据传输过程进行控制的硬件称为DMA控制器（DMA接口）。当I&#x2F;O设备需要进行数据传输时，通过DMA控制器向CPU发送传送请求，CPU响应后让出总线。由DMA控制器接管总线从而进行数据传输。</p>
<ul>
<li><strong>控制&#x2F;状态逻辑：</strong>用于指定传送方向，修改传送参数，并对DMA请求信号和CPU响应信号进行协调和同步</li>
<li><strong>主存地址计数器：</strong>存放要交换数据的主存地址</li>
<li><strong>传递长度计数器：</strong>记录传送数据的长度。计数器溢出时，就代表传送完毕，自动发出中断请求信号</li>
<li><strong>数据缓冲寄存器：</strong>暂存每次传送的数据</li>
<li><strong>DMA请求触发器：</strong>当数据缓冲寄存器存好数据后，发出信号，通过控制&#x2F;状态逻辑告知CPU数据已经准备好了</li>
<li><strong>中断机构：</strong>当一个数据块传送完毕后除法中断机构，从而向CPU提出中断请求</li>
</ul>
</blockquote>
<p><strong>DMA的传送方式</strong></p>
<blockquote>
<p>在主存和I&#x2F;O设备之间交换信息时，如果CPU和I&#x2F;O设备同时访问主存，可能会发生冲突，因此DMA可以有以下3种方式使用主存：</p>
<ul>
<li><p><strong>停止CPU访存：</strong>在外设通过DMA访问主存时，直接禁止CPU访问主存，直到外设访问结束后，才将总线控制权交还给CPU</p>
</li>
<li><p><strong>周期挪用（周期窃取）：</strong></p>
<blockquote>
<ul>
<li>当CPU没有访问主存时，外设正常访问主存</li>
<li>当CPU正在访问主存时，等CPU访问完成后，外设才访问CPU</li>
<li>CPU和外设同时都要访问主存时，让外设优先访问，等到外设访问完一个数据后，立即将数据交还给CPU</li>
</ul>
</blockquote>
</li>
<li><p><strong>DMA与CPU交替访存：</strong>将一个周期分成两部分，一半给外设使用，另一半给CPU使用。这种方法不需要总线使用权的申请、建立和归还过程。常使用与CPU工作周期比主存存取周期长的情况</p>
</li>
</ul>
</blockquote>
<p><strong>DMA的传送过程</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%9B%BE/IO%E8%AE%BE%E5%A4%87/DMA%E4%BC%A0%E9%80%81%E6%B5%81%E7%A8%8B.png" alt="DMA传送流程"></p>
<ul>
<li><p><strong>预处理：</strong></p>
<blockquote>
<p>由CPU完成一些必要工作，如执行几条I&#x2F;O指令，测试I&#x2F;O设备的状态，向与DMA控制器有关的寄存器置初值、设置传送方向、启动设备等。然后，CPU就可以继续去做自己的事了，直到I&#x2F;O设备准备好要发送的数据时，I&#x2F;O设备向DMA控制器发送DMA请求，再由DMA控制器向CPU发送总线请求。</p>
</blockquote>
</li>
<li><p><strong>数据传输：</strong></p>
<blockquote>
<p>传输的循环过程如上图所示。</p>
<p><strong>注意：</strong>这一循环过程时由DMA控制器实现的，即<strong>数据传输阶段都是由DMA控制器完成的</strong></p>
</blockquote>
</li>
<li><p><strong>后处理：</strong></p>
<blockquote>
<p>DMA控制器向CPU发送中断请求，CPU执行中断服务程序。</p>
<p><strong>包括：</strong>校验送入主存的数据是否正确，测试传送过程种是否出错，决定是否继续使用DMA传送其他数据</p>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>DMA方式与中断方式的区别：</strong></p>
<blockquote>
<ul>
<li>中断方式是CPU程序的切换；而DMA方式除了预处理和后处理，其他时间不占用CPU任何资源</li>
<li>对中断请求的响应只能发生在每条指令执行完毕之后；而对DMA请求的响应可以发生在每个机器周期结束时</li>
<li>中断传输过程需要CPU的干预；DMA传输过程不需要CPU的干预</li>
<li><strong>DMA请求的优先级高于中断请求</strong></li>
<li>中断方式可以对异常事件进行处理；而DMA方式只能用于数据传输</li>
<li>中断方式靠程序传递；而DMA方式靠硬件传递</li>
</ul>
</blockquote>
</blockquote>
<h2 id="五、其他补充"><a href="#五、其他补充" class="headerlink" title="五、其他补充"></a>五、其他补充</h2><blockquote>
<ul>
<li><p><strong>通道：</strong>可以理解为一个弱化版的CPU，可以识别并执行一系列<strong>通道指令</strong>（提前编制好，存放在内存中），通道指令种类、功能都比较单一。</p>
</li>
<li><p><strong>I&#x2F;O指令与通道指令：</strong></p>
<blockquote>
<p>I&#x2F;O指令是CPU指令的一部分，而通道指令是通道能识别的指令。</p>
<p>I&#x2F;O指令的格式：<strong>操作码|命令码|设备码</strong>。操作码：识别I&#x2F;O指令；命令码：做什么操作；设备码：对哪个设备进行操作</p>
</blockquote>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>基础学科</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣刷题-Day1</title>
    <url>/2023/03/02/Day1/</url>
    <content><![CDATA[<h4 id="1、两数之和"><a href="#1、两数之和" class="headerlink" title="1、两数之和"></a>1、两数之和</h4><blockquote>
<p><strong>题目：</strong></p>
<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<blockquote>
<ul>
<li><strong>暴力求解：</strong>设置两个循环，遍历所有数的组合（稍微省点时间的方法：第二层循环j从i+1开始）</li>
<li><strong>哈希表简化</strong>：设置一个哈希表，遍历一遍数组，每趟循环都用target减去num[i]，并在哈希表中查找是否存在target-num[i]的值，如果没有，则将当前num[i]存入哈希表中；如果找到了，那么当前的num[i]与哈希表中的值就是答案</li>
</ul>
</blockquote>
<p><strong>代码：</strong></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暴力求解</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; index;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br><span class="line">                    index.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    index.<span class="built_in">push_back</span>(j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>踩的坑：</strong>一开始以为数组全为正整数，多设置了一个条件判断if(nums[i]&gt;target)，导致负数的数组会找不到答案</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//哈希查找</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; index;</span><br><span class="line">        <span class="type">int</span> lenght = nums.<span class="built_in">size</span>();</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lenght;i++)&#123;</span><br><span class="line">            <span class="comment">// 如果哈希表内没有当前的nums[i]，则将当前的nums[i]存到哈希表中</span></span><br><span class="line">            <span class="comment">// 其中nums[i]为键，i为值</span></span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">find</span>(target-nums[i])==map.<span class="built_in">end</span>())</span><br><span class="line">                map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(nums[i],i));</span><br><span class="line">            <span class="comment">//当在哈希表内发现target-nums[i]的值时，代表找到了另一个符合的值</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                index.<span class="built_in">push_back</span>(map.<span class="built_in">at</span>(target-nums[i]));</span><br><span class="line">                index.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在该方法中，哈希表的作用是加快了比较时的查找时间。</p>
</blockquote>
<p>链接：<a href="https://leetcode.cn/problems/two-sum">https://leetcode.cn/problems/two-sum</a></p>
</blockquote>
<h4 id="2、有效的括号"><a href="#2、有效的括号" class="headerlink" title="2、有效的括号"></a>2、有效的括号</h4><blockquote>
<p><strong>题目：</strong>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ul>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;()&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;(]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong>使用栈结构，当’(‘、’[‘、’{‘时进栈，遇到匹配的’)‘、’]‘、’}‘时就出栈，查看最后栈是否为空，如果为空则所有括号都匹配上了；若不为空则有括号未匹配上</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; stack;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                stack.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                stack.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                stack.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(stack.<span class="built_in">empty</span>()||stack.<span class="built_in">top</span>()!=s[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                stack.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>问题：</strong>一开始字符串的下标没有处理好，出现了将’)‘、’]‘、’}‘进栈的操作</p>
<p>链接：<a href="https://leetcode.cn/problems/valid-parentheses">https://leetcode.cn/problems/valid-parentheses</a></p>
</blockquote>
<p><strong>时间：</strong>2023&#x2F;3&#x2F;2  21:18</p>
]]></content>
      <categories>
        <category>力扣例题</category>
      </categories>
      <tags>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>B树</title>
    <url>/2023/05/13/B%E6%A0%91/</url>
    <content><![CDATA[<h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a><strong>B树</strong></h4><blockquote>
<p><strong>定义：</strong></p>
<ul>
<li>每个结点最多只有m个子结点</li>
<li>除根节点外，每个非叶子结点具有<strong>至少</strong>有m&#x2F;2（向下取整）个子结点</li>
<li>非叶子节点的根节点<strong>至少有两个子节点</strong></li>
<li>有k棵子树的非叶节点有<strong>k-1个键</strong>，键按照递增顺序排序</li>
<li>叶结点都在同一层中</li>
</ul>
<p>如下图所示</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/B%E6%A0%91/B%E6%A0%91%E7%BB%93%E6%9E%84.png" alt="B树结构"></p>
<p><strong>B树的优势：</strong></p>
<blockquote>
<p>B树的出现，很好地解决树过深的情况，同时保留了查找树的便利，从而常用于搜索模型的建立。</p>
</blockquote>
</blockquote>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a><strong>B+树</strong></h4><blockquote>
<p>B+树是B树的一种变体，也是一种多路搜索树，与B树的不同之处在于：</p>
<ul>
<li>所有关键字存储在叶子节点，内部的根节点不存储真正的数据</li>
<li>所有的叶子节点增加了一个链指针</li>
</ul>
<p>如下图所示</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/B%E6%A0%91/B+%E6%A0%91.png" alt="B+树"></p>
</blockquote>
<h4 id="B树与B-树的区别"><a href="#B树与B-树的区别" class="headerlink" title="B树与B+树的区别"></a><strong>B树与B+树的区别</strong></h4><blockquote>
<ul>
<li>B+树内部根节点不存储数据，所有数据储存在叶子节点中，因此查找的时间复杂度为$\log n$，而B树查找时间复杂度不固定，与数据在树的位置中有关</li>
<li>B+树的叶节点两两相连增加了区间访问性，B树的节点和数据混在一起，无法做到区间查询</li>
<li>B+树更适合外部存储，由于内节点无数据域，每个节点能索引的范围更大更精确</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>基础学科</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣刷题-Day2</title>
    <url>/2023/03/23/Day2/</url>
    <content><![CDATA[<h4 id="1、反转链表"><a href="#1、反转链表" class="headerlink" title="1、反转链表"></a>1、反转链表</h4><blockquote>
<p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<blockquote>
<ul>
<li>使用一个栈，将链表读到栈里面，在将栈的元素读回链表里</li>
<li><strong>三指针原地反转：</strong>设置三个指针，pre、cur、next。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。</li>
</ul>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//栈的使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stack;</span><br><span class="line">        ListNode * init_head=head;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stack.<span class="built_in">push</span>(head-&gt;val);</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head=init_head;</span><br><span class="line">        <span class="keyword">while</span>(!stack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            head-&gt;val=stack.<span class="built_in">top</span>();</span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head=init_head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>踩的坑：</strong>c++中读完栈顶后记得删掉栈顶元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原地反转</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *pre=<span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *cur=head;</span><br><span class="line">        ListNode *next=head;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            next=cur-&gt;next;</span><br><span class="line">            cur-&gt;next=pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>时间：</strong>2023&#x2F;3&#x2F;3  17:18</p>
]]></content>
      <categories>
        <category>力扣例题</category>
      </categories>
      <tags>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣刷题-Day10</title>
    <url>/2023/06/05/Day10/</url>
    <content><![CDATA[<h4 id="对数组执行操作"><a href="#对数组执行操作" class="headerlink" title="对数组执行操作"></a>对数组执行操作</h4><blockquote>
<p><strong>题目：</strong>给你一个下标从 0 开始的数组 nums ，数组大小为 n ，且由 非负 整数组成。</p>
<p>你需要对数组执行 n - 1 步操作，其中第 i 步操作（从 0 开始计数）要求对 nums 中第 i 个元素执行下述指令：</p>
<ul>
<li><p>如果 nums[i] &#x3D;&#x3D; nums[i + 1] ，则 nums[i] 的值变成原来的 2 倍，nums[i + 1] 的值变成 0 。否则，跳过这步操作。<br>在执行完 全部 操作后，将所有 0 移动 到数组的 末尾 。</p>
</li>
<li><p>例如，数组 [1,0,2,0,0,1] 将所有 0 移动到末尾后变为 [1,2,1,0,0,0] 。<br>返回结果数组。</p>
</li>
</ul>
<p>注意 操作应当 依次有序 执行，而不是一次性全部执行。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,2,1,1,0]</span><br><span class="line">输出：[1,4,2,0,0,0]</span><br><span class="line">解释：执行以下操作：</span><br><span class="line">- i = 0: nums[0] 和 nums[1] 不相等，跳过这步操作。</span><br><span class="line">- i = 1: nums[1] 和 nums[2] 相等，nums[1] 的值变成原来的 2 倍，nums[2] 的值变成 0 。数组变成 [1,4,0,1,1,0] 。</span><br><span class="line">- i = 2: nums[2] 和 nums[3] 不相等，所以跳过这步操作。</span><br><span class="line">- i = 3: nums[3] 和 nums[4] 相等，nums[3] 的值变成原来的 2 倍，nums[4] 的值变成 0 。数组变成 [1,4,0,2,0,0] 。</span><br><span class="line">- i = 4: nums[4] 和 nums[5] 相等，nums[4] 的值变成原来的 2 倍，nums[5] 的值变成 0 。数组变成 [1,4,0,2,0,0] 。</span><br><span class="line">执行完所有操作后，将 0 全部移动到数组末尾，得到结果数组 [1,4,2,0,0,0] 。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1]</span><br><span class="line">输出：[1,0]</span><br><span class="line">解释：无法执行任何操作，只需要将 0 移动到末尾。</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong>分两个步骤，第一，执行操作；第二，将0移到最后</p>
<blockquote>
<ul>
<li><strong>原本的思路：</strong>在遍历执行操作的过程中将非0的数放到一个队列中，将0的数放到另一个队列中。在执行完第一步后，再使用一个遍历将数据进行重新分配。时间复杂度为$O(n)$，空间复杂度为$O(n)$</li>
<li><strong>答案思路：</strong>在遍历数组时将前后相等的两个元素直接进行交换，即在遍历过程的同时进行原地交换，将所有非零元素移到数组的头部。时间复杂度为$O(n)$，空间复杂度为$O(1)$</li>
</ul>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">applyOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span>&lt;len &amp;&amp; nums[i]==nums[i+<span class="number">1</span>])&#123;		<span class="comment">//将边界检测写入循环中</span></span><br><span class="line">                nums[i]=<span class="number">2</span>*nums[i];</span><br><span class="line">                nums[i+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//原地交换</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i],nums[j]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>补充：</strong></p>
<blockquote>
<p>上面将0移到数组后面的时间复杂度为$O(n)$空间复杂度为$O(1)$，使用的是一个<strong>双指针思路</strong>，i为遍历指针，j为从左边开始第一个0的指针，$i-j$为当前遍历位置之前0的个数。</p>
<p><strong>例子：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1,0,3,2,0,0,4		i=0,j=0			(nums[i]与nums[j]进行交换,1和1)</span><br><span class="line">1,0,3,2,0,0,4		i=1,j=1			(nums[i]与nums[j]不交换)</span><br><span class="line">1,3,0,2,0,0,4		i=2,j=1			(nums[i]与nums[j]进行交换,3和0)</span><br><span class="line">1,3,2,0,0,0,4		i=3,j=2			(nums[i]与nums[j]进行交换,2和0)</span><br><span class="line">1,3,2,0,0,0,4		i=4,j=3			(nums[i]与nums[j]不交换)</span><br><span class="line">1,3,2,0,0,0,4		i=5,j=3			(nums[i]与nums[j]不交换)</span><br><span class="line">1,3,2,0,0,0,4		i=6,j=3			(nums[i]与nums[j]进行交换,4和0)</span><br><span class="line">1,3,2,4,0,0,0		i=6,j=4</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>链接</strong>：<a href="https://leetcode.cn/problems/apply-operations-to-an-array">https://leetcode.cn/problems/apply-operations-to-an-array</a></p>
</blockquote>
]]></content>
      <categories>
        <category>力扣例题</category>
      </categories>
      <tags>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣刷题-Day3</title>
    <url>/2023/03/24/Day3/</url>
    <content><![CDATA[<h4 id="1、数据流中的第K大元素"><a href="#1、数据流中的第K大元素" class="headerlink" title="1、数据流中的第K大元素"></a>1、数据流中的第K大元素</h4><blockquote>
<p><strong>题目：</strong></p>
<p>设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。</p>
<p>请实现 KthLargest 类：</p>
<ul>
<li>KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。</li>
<li>int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;KthLargest&quot;</span>, <span class="string">&quot;add&quot;</span>, <span class="string">&quot;add&quot;</span>, <span class="string">&quot;add&quot;</span>, <span class="string">&quot;add&quot;</span>, <span class="string">&quot;add&quot;</span>]</span><br><span class="line">[[<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>]], [<span class="number">3</span>], [<span class="number">5</span>], [<span class="number">10</span>], [<span class="number">9</span>], [<span class="number">4</span>]]</span><br><span class="line">输出：</span><br><span class="line">[null, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">KthLargest kthLargest = <span class="keyword">new</span> <span class="built_in">KthLargest</span>(<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>]);</span><br><span class="line">kthLargest.<span class="built_in">add</span>(<span class="number">3</span>);   <span class="comment">// return 4</span></span><br><span class="line">kthLargest.<span class="built_in">add</span>(<span class="number">5</span>);   <span class="comment">// return 5</span></span><br><span class="line">kthLargest.<span class="built_in">add</span>(<span class="number">10</span>);  <span class="comment">// return 5</span></span><br><span class="line">kthLargest.<span class="built_in">add</span>(<span class="number">9</span>);   <span class="comment">// return 8</span></span><br><span class="line">kthLargest.<span class="built_in">add</span>(<span class="number">4</span>);   <span class="comment">// return 8</span></span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<blockquote>
<p>对数组进行升序排序，将前k个数全部出队，然后返回剩下中的第一个就是第k大元素</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KthLargest</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="built_in">KthLargest</span>(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k=k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="built_in">add</span>(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(q.<span class="built_in">size</span>()&gt;k)</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>踩的坑：</strong>一开始压根不知道可以使用优先队列，傻傻地排序再读取第k个数</p>
</blockquote>
<h4 id="2、用栈实现队列"><a href="#2、用栈实现队列" class="headerlink" title="2、用栈实现队列"></a>2、用栈实现队列</h4><blockquote>
<p><strong>题目：</strong></p>
<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p>
<p>实现 MyQueue 类：</p>
<ul>
<li>void push(int x) 将元素 x 推到队列的末尾</li>
<li>int pop() 从队列的开头移除并返回元素</li>
<li>int peek() 返回队列开头的元素</li>
<li>boolean empty() 如果队列为空，返回 true ；否则，返回 false</li>
</ul>
<p><strong>说明：</strong></p>
<ul>
<li>你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek&#x2F;pop from top, size, 和 is empty 操作是合法的。</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可</li>
</ul>
<p><strong>示例1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 1, 1, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyQueue myQueue = new MyQueue();</span><br><span class="line">myQueue.push(1); // queue is: [1]</span><br><span class="line">myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)</span><br><span class="line">myQueue.peek(); // return 1</span><br><span class="line">myQueue.pop(); // return 1, queue is [2]</span><br><span class="line">myQueue.empty(); // return false</span><br></pre></td></tr></table></figure>

<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack_top;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack_back;</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack_back.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack_top.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                stack_back.<span class="built_in">push</span>(stack_top.<span class="built_in">top</span>());</span><br><span class="line">                stack_top.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stack_back.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack_top.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack_back.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                stack_top.<span class="built_in">push</span>(stack_back.<span class="built_in">top</span>());</span><br><span class="line">                stack_back.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> top = stack_top.<span class="built_in">top</span>();</span><br><span class="line">        stack_top.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> top;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack_top.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack_back.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                stack_top.<span class="built_in">push</span>(stack_back.<span class="built_in">top</span>());</span><br><span class="line">                stack_back.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack_top.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack_top.<span class="built_in">empty</span>()&amp;&amp;stack_back.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>链接</strong>：<a href="https://leetcode.cn/problems/implement-queue-using-stacks">https://leetcode.cn/problems/implement-queue-using-stacks</a></p>
</blockquote>
<p><strong>时间：</strong>2023.3.6    19:30</p>
]]></content>
      <categories>
        <category>力扣例题</category>
      </categories>
      <tags>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣刷题-Day1</title>
    <url>/2023/03/22/Day4/</url>
    <content><![CDATA[<h4 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h4><blockquote>
<p><strong>题目：</strong>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MinStack minStack = <span class="keyword">new</span> <span class="built_in">MinStack</span>();</span><br><span class="line">minStack.<span class="built_in">push</span>(<span class="number">-2</span>);</span><br><span class="line">minStack.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">minStack.<span class="built_in">push</span>(<span class="number">-3</span>);</span><br><span class="line">minStack.<span class="built_in">min</span>();   --&gt; 返回 <span class="number">-3.</span></span><br><span class="line">minStack.<span class="built_in">pop</span>();</span><br><span class="line">minStack.<span class="built_in">top</span>();      --&gt; 返回 <span class="number">0.</span></span><br><span class="line">minStack.<span class="built_in">min</span>();   --&gt; 返回 <span class="number">-2.</span></span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong>设置两个栈，一个正常存储，另一个最小值栈；入栈时，栈1正常入栈，栈2只有在小于等于栈2的栈顶元素时才入栈；出栈时，栈1正常出栈，栈2在栈顶元素等于栈1要出栈的元素时才出栈</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;normalstack,minstack;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;minstack.<span class="built_in">push</span>(INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(normalstack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            normalstack.<span class="built_in">push</span>(x);</span><br><span class="line">            minstack.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            normalstack.<span class="built_in">push</span>(x);</span><br><span class="line">            <span class="keyword">if</span>(minstack.<span class="built_in">top</span>() &gt;= x)</span><br><span class="line">                minstack.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(minstack.<span class="built_in">top</span>()==normalstack.<span class="built_in">top</span>())</span><br><span class="line">            minstack.<span class="built_in">pop</span>();</span><br><span class="line">        normalstack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> normalstack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minstack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>链接：</strong><a href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/">https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/</a></p>
</blockquote>
<p><strong>时间：</strong>2023.3.22 18: 00</p>
]]></content>
      <categories>
        <category>力扣例题</category>
      </categories>
      <tags>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣刷题-Day5</title>
    <url>/2023/03/23/Day5/</url>
    <content><![CDATA[<h4 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h4><blockquote>
<p><strong>题目：</strong>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong>使用栈存放一开始的链表元素，再输出栈的元素即可将链表序列倒置（时间复杂度在O(n)之内）</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            s.<span class="built_in">push</span>(head-&gt;val);</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">invert</span><span class="params">(s.size())</span></span>;	<span class="comment">//容器类可以创建固定大小的数组</span></span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            invert[i] = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> invert;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>链接：</strong><a href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/</a></p>
</blockquote>
<h4 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h4><blockquote>
<p><strong>题目：</strong>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null</p>
<p><strong>示例：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E5%8A%9B%E6%89%A3/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E5%A4%8D%E5%88%B6_%E7%A4%BA%E4%BE%8B1.png" alt="复杂链表复制_示例1"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：head = [[<span class="number">7</span>,null],[<span class="number">13</span>,<span class="number">0</span>],[<span class="number">11</span>,<span class="number">4</span>],[<span class="number">10</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">输出：[[<span class="number">7</span>,null],[<span class="number">13</span>,<span class="number">0</span>],[<span class="number">11</span>,<span class="number">4</span>],[<span class="number">10</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">0</span>]]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路：</strong></p>
<blockquote>
<ul>
<li><p><strong>哈希表法</strong>：</p>
<p>1、若头节点为空节点，直接返回null</p>
<p>2、初始化：哈希表dic，节点cur指向头节点</p>
<p>3、复制链表：将原链表的节点以及random存放到dic中</p>
<p>4、构造新链表：遍历哈希表逐步构造新链表</p>
</li>
</ul>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        Node* cur = head;</span><br><span class="line">        unordered_map&lt;Node*, Node*&gt; map;</span><br><span class="line">        <span class="comment">// 3. 复制各节点，并建立 “原节点 -&gt; 新节点” 的 Map 映射</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            map[cur] = <span class="keyword">new</span> <span class="built_in">Node</span>(cur-&gt;val);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="comment">// 4. 构建新链表的 next 和 random 指向</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            map[cur]-&gt;next = map[cur-&gt;next];</span><br><span class="line">            map[cur]-&gt;random = map[cur-&gt;random];</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5. 返回新链表的头节点</span></span><br><span class="line">        <span class="keyword">return</span> map[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>链接：</strong><a href="https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/?envType=study-plan&id=lcof&plan=lcof&plan_progress=xx0qcuht">https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/?envType=study-plan&amp;id=lcof&amp;plan=lcof&amp;plan_progress=xx0qcuht</a></p>
</blockquote>
<p><strong>时间：</strong>2023.3.23  17:30</p>
]]></content>
      <categories>
        <category>力扣例题</category>
      </categories>
      <tags>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣刷题-Day7</title>
    <url>/2023/03/25/Day7/</url>
    <content><![CDATA[<h4 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h4><blockquote>
<p><strong>题目：</strong>找出数组中重复的数字。</p>
<p>在一个<strong>长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内</strong>。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li><p><strong>哈希表：</strong>遍历时将元素放入哈希表中，当遇到重复的元素时直接返回</p>
</li>
<li><p><strong>原地交换：</strong>因为长度为n的数组里所有数字都在0~n-1的范围内，因此只需要将对应的值放到对应的索引下即可找到重复值</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E5%8A%9B%E6%89%A3/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%E6%80%9D%E8%B7%AF2.png" alt="数组中重复的数字思路2"></p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//哈希表法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findRepeatNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">           <span class="comment">//m.insert(nums[i],true);			//用个屁的insert </span></span><br><span class="line">            <span class="keyword">if</span>(m[nums[i]])</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            m[nums[i]]=<span class="literal">true</span>;                    <span class="comment">//看好了，哈希表是这样用的.jpg  </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//原地交换法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findRepeatNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == i) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[nums[i]] == nums[i])</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            <span class="built_in">swap</span>(nums[i],nums[nums[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>链接</strong>：<a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof">https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof</a></p>
</blockquote>
<h4 id="在排序数组中查找数字"><a href="#在排序数组中查找数字" class="headerlink" title="在排序数组中查找数字"></a>在排序数组中查找数字</h4><blockquote>
<p><strong>题目</strong>：统计一个数字在排序数组中出现的次数。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">输入: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong>先二分查找，再找目标数字的边界，再统计数字的数量</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> high = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="type">int</span> times=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//折半</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target&lt;nums[mid])</span><br><span class="line">                high = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;nums[mid])</span><br><span class="line">                low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                times+=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向两边扩散查找</span></span><br><span class="line">        <span class="type">int</span> mid_L=mid;<span class="type">int</span> mid_R=mid; </span><br><span class="line">        <span class="keyword">while</span>(nums[mid_L]==target||nums[mid_R]==target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mid_L<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; nums[--mid_L]==target)&#123;</span><br><span class="line">                times+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mid_R+<span class="number">1</span>&lt;=nums.<span class="built_in">size</span>()<span class="number">-1</span> &amp;&amp; nums[++mid_R]==target)&#123;</span><br><span class="line">                times+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mid_L&lt;<span class="number">0</span>||mid_R&gt;=nums.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> times;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>问题：</strong>数组的边界问题（真的难处理）</p>
<p><strong>链接：</strong><a href="https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>力扣例题</category>
      </categories>
      <tags>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣刷题-Day6</title>
    <url>/2023/03/24/Day6/</url>
    <content><![CDATA[<h4 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h4><blockquote>
<p><strong>题目：</strong>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong>使用C++库函数将空格字符替换</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                s.<span class="built_in">replace</span>(i,<span class="number">1</span>,<span class="string">&quot;%20&quot;</span>);       <span class="comment">//replace(位置,代替数量,代替的字符串)</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>链接：</strong><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">https://leetcode.cn/problems/ti-huan-kong-ge-lcof/</a></p>
</blockquote>
<h4 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h4><blockquote>
<p><strong>题目：</strong>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<p><strong>示例：</strong></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br><span class="line"></span><br><span class="line">输入: s = &quot;lrloseumgh&quot;, k = 6</span><br><span class="line">输出: &quot;umghlrlose&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路：</strong>字符串字串的操作</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// string substr = s.substr(n,s.size()-n);</span></span><br><span class="line">        <span class="comment">// s.erase(n,s.size()-n);</span></span><br><span class="line">        <span class="comment">// return substr+s;</span></span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(n,s.<span class="built_in">size</span>()-n)+s.<span class="built_in">substr</span>(<span class="number">0</span>,n);    <span class="comment">//省流版</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>链接</strong>：<a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof">https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof</a></p>
</blockquote>
<p><strong>时间：</strong>2023.3.24   17:53</p>
]]></content>
      <categories>
        <category>力扣例题</category>
      </categories>
      <tags>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣刷题-Day8</title>
    <url>/2023/03/26/Day8/</url>
    <content><![CDATA[<h4 id="0-n-1中缺失的数字"><a href="#0-n-1中缺失的数字" class="headerlink" title="0~n-1中缺失的数字"></a>0~n-1中缺失的数字</h4><blockquote>
<p><strong>题目：</strong>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [0,1,3]</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">输入: [0,1,2,3,4,5,6,7,9]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<blockquote>
<ul>
<li>正常for循环思路，一路循环下去找到与下标不一致的数为止</li>
<li>二分法思路，使用二分查找，查看mid的值是否等于mid，相等则缺失值在mid右边，否则在左边</li>
</ul>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通循环</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==i)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 边界</span></span><br><span class="line">        <span class="keyword">return</span> nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> low=<span class="number">0</span>;<span class="type">int</span> high = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==mid)          <span class="comment">//表示缺失值一定在mid的右边</span></span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high = mid<span class="number">-1</span>;           <span class="comment">//表示缺失值一定在mid的左边</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>链接</strong>：<a href="https://leetcode.cn/problems/que-shi-de-shu-zi-lcof">https://leetcode.cn/problems/que-shi-de-shu-zi-lcof</a></p>
</blockquote>
<h4 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h4><blockquote>
<p><strong>题目：</strong>在一个 n * m 的二维数组中，每一行都按照从左到右 非递减 的顺序排序，每一列都按照从上到下 非递减 的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">给定 target = 5，返回 true。</span><br><span class="line">给定 target = 20，返回 false</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<blockquote>
<ul>
<li><p>使用一般循环找到目标数可能在的行号，再使用二分查找在这一行中找目标数</p>
</li>
<li><p>将数组逆时针转45度，就可以得到一棵类二叉搜索树（左节点&lt;中间节点&lt;右节点）</p>
<img src="/picture/学习/力扣/二维数组的查找_图论.png" alt="二维数组的查找_图论" style="zoom:48%;" /></li>
</ul>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//for+二分查找</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>()==<span class="number">0</span>||matrix[<span class="number">0</span>].<span class="built_in">size</span>()==<span class="number">0</span>)      <span class="comment">//特殊情况特殊处理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;matrix.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>]&gt;target)     <span class="comment">//如果每行中第一个数都大于目标，那么就直接判断找不到</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][matrix[i].<span class="built_in">size</span>()<span class="number">-1</span>]&lt;target)    <span class="comment">//如果某一行最后一个数都小于目标，那么直接跳过检查这一行</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//折半查找</span></span><br><span class="line">            <span class="type">int</span> low = <span class="number">0</span>;<span class="type">int</span> high = matrix[i].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="type">int</span> mid;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">                mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][mid]==target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][mid]&lt;target)</span><br><span class="line">                    low = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    high = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//神奇的思路</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = matrix.<span class="built_in">size</span>() - <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] &gt; target) i--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &lt; target) j++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>链接</strong>：<a href="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof">https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof</a></p>
</blockquote>
<h4 id="第一只出现一次的字符"><a href="#第一只出现一次的字符" class="headerlink" title="第一只出现一次的字符"></a>第一只出现一次的字符</h4><blockquote>
<p><strong>题目：</strong>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abaccdeff&quot;</span><br><span class="line">输出：&#x27;b&#x27;</span><br><span class="line"></span><br><span class="line">输入：s = &quot;&quot; </span><br><span class="line">输出：&#x27; &#x27;</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong>与查找重复数类似，建立一个哈希表，最后查找哈希表中哪个字符第一次出现一次</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">length</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">find</span>(s[i])!=map.<span class="built_in">end</span>())&#123;</span><br><span class="line">                map[s[i]]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map[s[i]]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map[s[i]]==<span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span> s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>链接：</strong><a href="https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>力扣例题</category>
      </categories>
      <tags>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣刷题-Day9</title>
    <url>/2023/03/27/Day9/</url>
    <content><![CDATA[<h4 id="从上到下打印二叉树"><a href="#从上到下打印二叉树" class="headerlink" title="从上到下打印二叉树"></a>从上到下打印二叉树</h4><blockquote>
<p><strong>题目：</strong>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定二叉树: [3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">返回：</span><br><span class="line">[3,9,20,15,7]</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong>使用队列进行树的层次遍历</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode&gt; sq;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;nums;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)          <span class="comment">//注意特殊情况</span></span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        sq.<span class="built_in">push</span>(*root);</span><br><span class="line">        <span class="keyword">while</span>(!sq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(sq.<span class="built_in">front</span>().left!=<span class="literal">NULL</span>)</span><br><span class="line">                sq.<span class="built_in">push</span>(*sq.<span class="built_in">front</span>().left);</span><br><span class="line">            <span class="keyword">if</span>(sq.<span class="built_in">front</span>().right!=<span class="literal">NULL</span>)</span><br><span class="line">                sq.<span class="built_in">push</span>(*sq.<span class="built_in">front</span>().right);</span><br><span class="line">            nums.<span class="built_in">insert</span>(nums.<span class="built_in">end</span>(),sq.<span class="built_in">front</span>().val);</span><br><span class="line">            sq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>链接：</strong><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/</a></p>
</blockquote>
<h4 id="从上到下打印二叉树Ⅱ"><a href="#从上到下打印二叉树Ⅱ" class="headerlink" title="从上到下打印二叉树Ⅱ"></a>从上到下打印二叉树Ⅱ</h4><blockquote>
<p><strong>题目：</strong>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
<p><strong>示例：</strong></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt;例如:</span><br><span class="line">&gt;给定二叉树: [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,null,null,<span class="number">15</span>,<span class="number">7</span>],</span><br><span class="line"></span><br><span class="line">   <span class="number">3</span></span><br><span class="line">  / \</span><br><span class="line"> <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">   /  \</span><br><span class="line">  <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">&gt;返回其层次遍历结果:</span><br><span class="line">&gt;[</span><br><span class="line"> [<span class="number">3</span>],</span><br><span class="line"> [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line"> [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">&gt;]</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong>在上一题的基础上，加入一个循环进行逐层读取</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">*     int val;</span></span><br><span class="line"><span class="comment">*     TreeNode *left;</span></span><br><span class="line"><span class="comment">*     TreeNode *right;</span></span><br><span class="line"><span class="comment">*     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">       vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 返回值</span></span><br><span class="line">       queue&lt;TreeNode*&gt; que; <span class="comment">// 队列</span></span><br><span class="line">       <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123; <span class="comment">// 判空 加入头结点</span></span><br><span class="line">           que.<span class="built_in">push</span>(root);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123; <span class="comment">// 逐层遍历</span></span><br><span class="line">           <span class="type">int</span> size = que.<span class="built_in">size</span>(); <span class="comment">// 每层大小</span></span><br><span class="line">           vector&lt;<span class="type">int</span>&gt; vec; <span class="comment">// 每层结果</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;    <span class="comment">//多加一个循环遍历每一层的子树</span></span><br><span class="line">               TreeNode* temp = que.<span class="built_in">front</span>();</span><br><span class="line">               que.<span class="built_in">pop</span>();</span><br><span class="line">               <span class="keyword">if</span> (temp-&gt;left) &#123;</span><br><span class="line">                   que.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (temp-&gt;right) &#123;</span><br><span class="line">                   que.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">               &#125;</span><br><span class="line">               vec.<span class="built_in">push_back</span>(temp-&gt;val);   </span><br><span class="line">           &#125;</span><br><span class="line">           result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>链接：</strong><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>力扣例题</category>
      </categories>
      <tags>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>Github使用文档</title>
    <url>/2022/04/17/github%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h4 id="一、创建github仓库"><a href="#一、创建github仓库" class="headerlink" title="一、创建github仓库"></a><b>一、创建github仓库</b></h4><blockquote>
<p> <img src="/picture/%E5%AD%A6%E4%B9%A0/GitHub%E7%9A%84%E4%BD%BF%E7%94%A8/%E5%88%9B%E5%BB%BAGitHub%E4%BB%93%E5%BA%93.png" alt="创建GitHub仓库"></p>
<p>点进去以后有一个必填项就是仓库名了，其他都是可选项，填写完后可以直接找到最底下点击创建。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/GitHub%E7%9A%84%E4%BD%BF%E7%94%A8/%E5%88%9B%E5%BB%BAGitHub%E4%BB%93%E5%BA%931.png" alt="创建GitHub仓库1"></p>
<p>创建完后记住这个地址，这个就是仓库的地址了（后面会用到）。</p>
</blockquote>
<h4 id="二、使用git上传文件"><a href="#二、使用git上传文件" class="headerlink" title="二、使用git上传文件"></a><b>二、使用git上传文件</b></h4><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">git init 	<span class="comment">//把当前目录变成Git可以管理的仓库</span></span><br><span class="line">git add README.md <span class="comment">//文件添加到仓库</span></span><br><span class="line">git add . <span class="comment">//不但可以跟单一文件，还可以跟通配符，更可以跟目录。一个点就把当前目录下所有未追踪的文件全部add了 </span></span><br><span class="line">git commit -m <span class="string">&quot;first commit&quot;</span> <span class="comment">//把文件提交到仓库</span></span><br><span class="line"><span class="function">git remote add origin <span class="title">xx</span><span class="params">(远程仓库的地址)</span> <span class="comment">//关联远程仓库</span></span></span><br><span class="line"><span class="function">git push -u origin master <span class="comment">//把本地库的所有内容推送到远程库上</span></span></span><br></pre></td></tr></table></figure>

<p><b>顺序：</b></p>
<blockquote>
<p> <b>绑定账号（新安装Git时用）：</b></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config –global user.name &quot;xx&quot;	//绑定Github的用户名</span><br><span class="line">git config –global user.email &quot;xx&quot;	//绑定Github的注册邮箱</span><br></pre></td></tr></table></figure>

<ul>
<li><p><b>为Github账号设置ssh key（新安装Git时用）：</b></p>
<blockquote>
<ul>
<li><p>生成ssh key：</p>
<blockquote>
<p>打开 C:\Users\xxx\ .ssh，如果有这两个文件</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/GitHub%E7%9A%84%E4%BD%BF%E7%94%A8/%E5%AF%86%E9%92%A5.png" alt="密钥"></p>
<p>那么密钥已经生成，id_rsa.pub就是公钥（复制好里面的内容）</p>
<p>如果没有可以通过 ssh-keygen -t rsa -C “xxx”（xxx代表邮箱）来生成</p>
</blockquote>
</li>
<li><p>为Github账户配置ssh key</p>
<blockquote>
<ul>
<li>打开Github里的Settings：</li>
</ul>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/GitHub%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%B7%BB%E5%8A%A0%E5%AF%86%E9%92%A5.png" alt="添加密钥"></p>
<ul>
<li>将id_rsa.pub里的内容粘贴进去</li>
</ul>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/GitHub%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%B7%BB%E5%8A%A0%E5%AF%86%E9%92%A51.png" alt="添加密钥1"></p>
<ul>
<li>这样就算完成第一步了</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p>创建本地仓库</p>
<blockquote>
<ul>
<li><p>随便创建一个文件夹，并用git控制台打开这个文件</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/GitHub%E7%9A%84%E4%BD%BF%E7%94%A8/%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9.png" alt="创建文件夹"></p>
</li>
<li><p>利用“git init”创建一个本地仓库</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/GitHub%E7%9A%84%E4%BD%BF%E7%94%A8/%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93.png" alt="创建本地仓库"></p>
</li>
<li><p>将文件添加进仓库（实际上可以直接用”git add .“来将当前文件夹中所有文件添加到仓库）</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/GitHub%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%B7%BB%E5%8A%A0%E8%BF%9B%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93.png" alt="添加进本地仓库"></p>
</li>
<li><p>把文件提交到仓库中：git commit -m “提交文件”（双引号内的是提交注释，一定要写的）</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/GitHub%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%8F%90%E4%BA%A4.png" alt="提交"></p>
</li>
<li><p>这样本地仓库算是创建好了</p>
</li>
</ul>
</blockquote>
</li>
<li><p><b>关联Github仓库</b></p>
<blockquote>
<ul>
<li><p>找到并复制仓库地址</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/GitHub%E7%9A%84%E4%BD%BF%E7%94%A8/%E5%88%9B%E5%BB%BAGitHub%E4%BB%93%E5%BA%931.png" alt="创建GitHub仓库1"></p>
</li>
<li><p>执行关联命令：git remote add origin xxx(刚刚复制的地址)</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/GitHub%E7%9A%84%E4%BD%BF%E7%94%A8/%E5%85%B3%E8%81%94%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93.png" alt="关联远程仓库"></p>
</li>
</ul>
</blockquote>
</li>
<li><p><b>上传本地代码</b></p>
<blockquote>
<p>执行命令：git push -u origin master</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/GitHub%E7%9A%84%E4%BD%BF%E7%94%A8/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6.png" alt="上传文件"></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/GitHub%E7%9A%84%E4%BD%BF%E7%94%A8/%E7%BB%93%E6%9E%9C.png" alt="结果"></p>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<h4 id="三、后记"><a href="#三、后记" class="headerlink" title="三、后记"></a>三、<b>后记</b></h4><blockquote>
<p>如果要将新的文件上传到GitHub上：重复git add xxx（文件名）、git commit -m “提交文件”、git push -u origin master（上传文件）即可。</p>
<p>注意：如果要上传到不同的仓库的时候，则需要重新关联一个仓库。</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机使用基础</category>
      </categories>
      <tags>
        <tag>计算机使用基础</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML常用元素</title>
    <url>/2021/04/06/HTML%E5%B8%B8%E7%94%A8%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h4 id="HTML参考标签"><a href="#HTML参考标签" class="headerlink" title="HTML参考标签"></a><b>HTML参考标签</b></h4><blockquote>
<table>
<thead>
<tr>
<th align="center">标签</th>
<th align="center">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><b>基础</b></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>&lt;!DOCTYPE&gt;</code></td>
<td align="center">定义文档类型</td>
</tr>
<tr>
<td align="center"><code>&lt;html&gt;</code></td>
<td align="center">定义一个HTML文档</td>
</tr>
<tr>
<td align="center"><code>&lt;title&gt;</code></td>
<td align="center">定义一个网页的标题</td>
</tr>
<tr>
<td align="center"><code>&lt;head&gt;</code></td>
<td align="center">该元素必须包括文档的标题，可以包括脚本、样式、meta信息等</td>
</tr>
<tr>
<td align="center"><code>&lt;body&gt;</code></td>
<td align="center">定义文档的主体</td>
</tr>
<tr>
<td align="center"><code>&lt;h1&gt;～&lt;h6&gt;</code></td>
<td align="center">定义一个HTML标题</td>
</tr>
<tr>
<td align="center"><code>&lt;p&gt;</code></td>
<td align="center">定义一个文章段落</td>
</tr>
<tr>
<td align="center"><code>&lt;br&gt;</code></td>
<td align="center">定义简单的换行</td>
</tr>
<tr>
<td align="center"><code>&lt;hr&gt;</code></td>
<td align="center">定义水平线</td>
</tr>
<tr>
<td align="center"><code>&lt;!--..--&gt;</code></td>
<td align="center">定义一个注释</td>
</tr>
<tr>
<td align="center"><b>格式</b></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>&lt;abbr&gt;</code></td>
<td align="center">定义一个缩写</td>
</tr>
<tr>
<td align="center"><code>&lt;address&gt;</code></td>
<td align="center">定义文档作者或拥有者的联系信息</td>
</tr>
<tr>
<td align="center"><code>&lt;b&gt;</code></td>
<td align="center">定义粗体文字</td>
</tr>
<tr>
<td align="center"><code>&lt;bdi&gt;</code></td>
<td align="center">允许设置一段文本，使其脱离其父元素的文本方向设置</td>
</tr>
<tr>
<td align="center"><code>&lt;bdo&gt;</code></td>
<td align="center">定义文本的方向</td>
</tr>
<tr>
<td align="center"><code>&lt;blockquote&gt;</code></td>
<td align="center">定义块引用</td>
</tr>
<tr>
<td align="center"><code>&lt;cite&gt;</code></td>
<td align="center">定义引用</td>
</tr>
<tr>
<td align="center"><code>&lt;code&gt;</code></td>
<td align="center">定义计算机代码文本</td>
</tr>
<tr>
<td align="center"><code>&lt;del&gt;</code></td>
<td align="center">定义被删除文本</td>
</tr>
<tr>
<td align="center"><code>&lt;dfn&gt;</code></td>
<td align="center">定义定义项目</td>
</tr>
<tr>
<td align="center"><code>&lt;em&gt;</code></td>
<td align="center">定义强调文本</td>
</tr>
<tr>
<td align="center"><code>&lt;i&gt;</code></td>
<td align="center">定义斜体文本</td>
</tr>
<tr>
<td align="center"><code>&lt;ins&gt;</code></td>
<td align="center">定义被插入文本</td>
</tr>
<tr>
<td align="center"><code>&lt;kbd&gt;</code></td>
<td align="center">定义键盘文本</td>
</tr>
<tr>
<td align="center"><code>&lt;mark&gt;</code></td>
<td align="center">定义带有标记的文本</td>
</tr>
<tr>
<td align="center"><code>&lt;meter&gt;</code></td>
<td align="center">定义度量衡，仅用于已知最大、最小值的度量</td>
</tr>
<tr>
<td align="center"><code>&lt;pre&gt;</code></td>
<td align="center">定义预格式文本</td>
</tr>
<tr>
<td align="center"><code>&lt;progress&gt;</code></td>
<td align="center">定义运行中的任务进程</td>
</tr>
<tr>
<td align="center"><code>&lt;q&gt;</code></td>
<td align="center">定义短的引用</td>
</tr>
<tr>
<td align="center"><code>&lt;rp&gt;</code></td>
<td align="center">定义不支持ruby元素的浏览器所显示的内容</td>
</tr>
<tr>
<td align="center"><code>&lt;rt&gt;</code></td>
<td align="center">定义字符的解释或发音</td>
</tr>
<tr>
<td align="center"><code>&lt;ruby&gt;</code></td>
<td align="center">定义ruby注释</td>
</tr>
<tr>
<td align="center"><code>&lt;s&gt;</code></td>
<td align="center">定义加删除线的文本</td>
</tr>
<tr>
<td align="center"><code>&lt;samp&gt;</code></td>
<td align="center">定义计算机代码样本</td>
</tr>
<tr>
<td align="center"><code>&lt;small&gt;</code></td>
<td align="center">定义小号文本</td>
</tr>
<tr>
<td align="center"><code>&lt;strong&gt;</code></td>
<td align="center">定义语气更为强烈的强调文本</td>
</tr>
<tr>
<td align="center"><code>&lt;sub&gt;</code></td>
<td align="center">定义下标文本</td>
</tr>
<tr>
<td align="center"><code>&lt;sup&gt;</code></td>
<td align="center">定义上标文本</td>
</tr>
<tr>
<td align="center"><code>&lt;time&gt;</code></td>
<td align="center">定义一个日期&#x2F;时间</td>
</tr>
<tr>
<td align="center"><code>&lt;u&gt;</code></td>
<td align="center">定义下划线文本</td>
</tr>
<tr>
<td align="center"><code>&lt;var&gt;</code></td>
<td align="center">定义文本的变量部分</td>
</tr>
<tr>
<td align="center"><code>&lt;wbr&gt;</code></td>
<td align="center">规定在文本中的何处适合添加换行符</td>
</tr>
<tr>
<td align="center"><b>控件</b></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>&lt;form&gt;</code></td>
<td align="center">定义一个HTML表单，用于用户输入</td>
</tr>
<tr>
<td align="center"><code>&lt;input&gt;</code></td>
<td align="center">定义一个输入控件</td>
</tr>
<tr>
<td align="center"><code>&lt;textarea&gt;</code></td>
<td align="center">定义多行的文本输入控件</td>
</tr>
<tr>
<td align="center"><code>&lt;button&gt;</code></td>
<td align="center">定义按钮</td>
</tr>
<tr>
<td align="center"><code>&lt;select&gt;</code></td>
<td align="center">定义选择列表（下拉列表）</td>
</tr>
<tr>
<td align="center"><code>&lt;optgroup&gt;</code></td>
<td align="center">定义选择列表中相关选项的组合</td>
</tr>
<tr>
<td align="center"><code>&lt;option&gt;</code></td>
<td align="center">定义选择列表中的选项</td>
</tr>
<tr>
<td align="center"><code>&lt;label&gt;</code></td>
<td align="center">定义input元素的标注</td>
</tr>
<tr>
<td align="center"><code>&lt;fieldset&gt;</code></td>
<td align="center">定义围绕表单中元素的边框</td>
</tr>
<tr>
<td align="center"><code>&lt;legend&gt;</code></td>
<td align="center">定义fieldset元素的标题</td>
</tr>
<tr>
<td align="center"><code>&lt;datalist&gt;</code></td>
<td align="center">规定了input元素可能的选项列表</td>
</tr>
<tr>
<td align="center"><code>&lt;keygen&gt;</code></td>
<td align="center">规定用于表单的密钥对生成器字段</td>
</tr>
<tr>
<td align="center"><code>&lt;output&gt;</code></td>
<td align="center">定义一个计算的结果</td>
</tr>
<tr>
<td align="center"><b>框架</b></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>&lt;iframe&gt;</code></td>
<td align="center">定义内联框架</td>
</tr>
<tr>
<td align="center"><b>图像</b></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>&lt;img&gt;</code></td>
<td align="center">定义图像</td>
</tr>
<tr>
<td align="center"><code>&lt;map&gt;</code></td>
<td align="center">定义图像映射</td>
</tr>
<tr>
<td align="center"><code>&lt;area&gt;</code></td>
<td align="center">定义图像地图内部的区域</td>
</tr>
<tr>
<td align="center"><code>&lt;canvas&gt;</code></td>
<td align="center">通过脚本来绘制图形</td>
</tr>
<tr>
<td align="center"><code>&lt;figcaption&gt;</code></td>
<td align="center">定义一个caption for a <figure> element</td>
</tr>
<tr>
<td align="center"><code>&lt;figure&gt;</code></td>
<td align="center">figure标签用于对元素进行组合</td>
</tr>
<tr>
<td align="center"><b>影像&#x2F;录音</b></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>&lt;audio&gt;</code></td>
<td align="center">定义音乐或其他音频流</td>
</tr>
<tr>
<td align="center"><code>&lt;source&gt;</code></td>
<td align="center">定义medida元素（<code>&lt;video&gt;</code>和<code>&lt;audio&gt;</code>）的媒体资源</td>
</tr>
<tr>
<td align="center"><code>&lt;track&gt;</code></td>
<td align="center">为媒体(<code>&lt;video&gt;</code>和<code>&lt;audio&gt;</code>)元素定义外部文本轨道</td>
</tr>
<tr>
<td align="center"><code>&lt;video&gt;</code></td>
<td align="center">定义一个音频或者视频</td>
</tr>
<tr>
<td align="center"><b>链接</b></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>&lt;a&gt;</code></td>
<td align="center">定义一个链接</td>
</tr>
<tr>
<td align="center"><code>&lt;link&gt;</code></td>
<td align="center">定义文档与外部资源的关系</td>
</tr>
<tr>
<td align="center"><code>&lt;main&gt;</code></td>
<td align="center">定义文档的主体部分</td>
</tr>
<tr>
<td align="center"><code>&lt;nav&gt;</code></td>
<td align="center">定义导航链接</td>
</tr>
<tr>
<td align="center"><b>列表</b></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>&lt;ul&gt;</code></td>
<td align="center">定义一个无序列表</td>
</tr>
<tr>
<td align="center"><code>&lt;ol&gt;</code></td>
<td align="center">定义一个有序列表</td>
</tr>
<tr>
<td align="center"><code>&lt;li&gt;</code></td>
<td align="center">定义一个列表项</td>
</tr>
<tr>
<td align="center"><code>&lt;dl&gt;</code></td>
<td align="center">定义一个定义列表</td>
</tr>
<tr>
<td align="center"><code>&lt;dt&gt;</code></td>
<td align="center">定义一个定义定义列表中的项目</td>
</tr>
<tr>
<td align="center"><code>&lt;dd&gt;</code></td>
<td align="center">定义定义列表中项目的描述</td>
</tr>
<tr>
<td align="center"><code>&lt;menu&gt;</code></td>
<td align="center">定义菜单列表</td>
</tr>
<tr>
<td align="center"><code>&lt;command&gt;</code></td>
<td align="center">定义用户可能调用的命令(如单选按钮\复选框或按钮)</td>
</tr>
<tr>
<td align="center"><b>表格</b></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>&lt;table&gt;</code></td>
<td align="center">定义一个表格</td>
</tr>
<tr>
<td align="center"><code>&lt;caption&gt;</code></td>
<td align="center">定义表格标题</td>
</tr>
<tr>
<td align="center"><code>&lt;th&gt;</code></td>
<td align="center">定义表格中的表头单元格</td>
</tr>
<tr>
<td align="center"><code>&lt;tr&gt;</code></td>
<td align="center">定义表格中的行</td>
</tr>
<tr>
<td align="center"><code>&lt;td&gt;</code></td>
<td align="center">定义表格中的单元</td>
</tr>
<tr>
<td align="center"><code>&lt;thead&gt;</code></td>
<td align="center">定义表格中的表头内容</td>
</tr>
<tr>
<td align="center"><code>&lt;tbody&gt;</code></td>
<td align="center">定义表格中的主体内容</td>
</tr>
<tr>
<td align="center"><code>&lt;tfoot&gt;</code></td>
<td align="center">定义表格中的表注内容(脚注)</td>
</tr>
<tr>
<td align="center"><code>&lt;col&gt;</code></td>
<td align="center">定义表格中一个或多个列的属性值</td>
</tr>
<tr>
<td align="center"><code>&lt;colgroup&gt;</code></td>
<td align="center">定义表格中供格式化的列组</td>
</tr>
<tr>
<td align="center"><b>样式</b></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>&lt;slyle&gt;</code></td>
<td align="center">定义文档的样式信息</td>
</tr>
<tr>
<td align="center"><code>&lt;div&gt;</code></td>
<td align="center">定义文档中的节</td>
</tr>
<tr>
<td align="center"><code>&lt;span&gt;</code></td>
<td align="center">定义文档中的节</td>
</tr>
<tr>
<td align="center"><code>&lt;header&gt;</code></td>
<td align="center">定义一个文档头部部分</td>
</tr>
<tr>
<td align="center"><code>&lt;footer&gt;</code></td>
<td align="center">定义一个文档底部</td>
</tr>
<tr>
<td align="center"><code>&lt;section&gt;</code></td>
<td align="center">定义了文档的某个区域</td>
</tr>
<tr>
<td align="center"><code>&lt;article&gt;</code></td>
<td align="center">定义一个文章内容</td>
</tr>
<tr>
<td align="center"><code>&lt;aside&gt;</code></td>
<td align="center">定义其所处内容</td>
</tr>
<tr>
<td align="center"><code>&lt;details&gt;</code></td>
<td align="center">定义了用户可见的或者隐藏的需求的补充细节</td>
</tr>
<tr>
<td align="center"><code>&lt;dialog&gt;</code></td>
<td align="center">定义一个对话框或者窗口</td>
</tr>
<tr>
<td align="center"><code>&lt;summary&gt;</code></td>
<td align="center">定义一个可见的标题,当用户点击标题时会显示详细信息</td>
</tr>
<tr>
<td align="center"><b>元信息</b></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>&lt;meta&gt;</code></td>
<td align="center">定义关于HTML文档的元信息</td>
</tr>
<tr>
<td align="center"><code>&lt;base&gt;</code></td>
<td align="center">定义页面中所有链接的默认地址或默认目标</td>
</tr>
<tr>
<td align="center"><b>程序</b></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>&lt;script&gt;</code></td>
<td align="center">定义用户端脚本</td>
</tr>
<tr>
<td align="center"><code>&lt;embed&gt;</code></td>
<td align="center">定义一个容器,用来嵌入外部应用或者互动程序</td>
</tr>
<tr>
<td align="center"><code>&lt;object&gt;</code></td>
<td align="center">定义嵌入的对象</td>
</tr>
<tr>
<td align="center"><code>&lt;param&gt;</code></td>
<td align="center">定义对象的参数</td>
</tr>
</tbody></table>
</blockquote>
]]></content>
      <categories>
        <category>网页设计</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>k近邻法</title>
    <url>/2021/04/12/k%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h4 id="k近邻法的介绍"><a href="#k近邻法的介绍" class="headerlink" title="k近邻法的介绍"></a><b>k近邻法的介绍</b></h4><blockquote>
<ul>
<li>k近邻法假设给定一个训练数据集，其中实例类别已定。分类时，对新的实例，根据其k个最近邻的训练实例的类别，通过多数表决等方式进行预测。</li>
<li>k近邻法实际上利用训练数据集对特征向量空间进行划分，并作为其分类的“模型”。</li>
<li>k近邻法的三个基本要素：<b>k值的选择</b>、<b>距离度量</b>和<b>分类决策规则</b></li>
</ul>
</blockquote>
<h4 id="k近邻算法"><a href="#k近邻算法" class="headerlink" title="k近邻算法"></a><b>k近邻算法</b></h4><blockquote>
<ul>
<li>k近邻算法对于新的输入实例，在训练数据集中找到与该实例<b>最近的k个实例</b>，这k个实例多数属于某个类，就把这个输入实例归为这个类。<br><b>如图：</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/k%E8%BF%91%E9%82%BB/k%E8%BF%91%E9%82%BB%E6%A8%A1%E5%9E%8B%E5%9B%BE.jpg" alt="k近邻" title="k近邻"></li>
<li>如果绿色物体的判定圈为实线圈，那么该物体为红色三角形</li>
<li>如果判定圈为虚线圈，那么该物体为蓝色方块。</li>
</ul>
</blockquote>
<blockquote>
<p><b>算法定义：</b></p>
<blockquote>
<p><b>输入</b>：训练数据集<br>$$T&#x3D;[(x_1,y_1),(x_2,y_2),…,(x_N,y_N)]$$<br>其中，$x_i{\in}\chi{\subseteq}R^n$为实例的特征向量，$y_i{\in}\gamma&#x3D;(c_1,c_2,…,c_K)$为实例的类别，$i&#x3D;1,2,…,N$;实例特征向量x;<br><b>输出</b>：实例x所属的类y<br>(1)根据给定的距离度量，在训练集T中找出x最邻近的k个点，涵盖这k个点的x的领域记作$N_k(x)$;<br>(2)在$N_k(x)$中根据分类决策规则（如多数表决）决定x的类别y：<br>$$y&#x3D;arg \max_{c_j}\sum_{x_i{\subseteq}N_k(x)}I(y_i&#x3D;c_j),i&#x3D;1,2,…,N;j&#x3D;1,2,…,K\quad \quad (1)$$<br>在（1）式中，I为指标函数，即当$y_i&#x3D;c_j$时I为1,否则I为0.</p>
</blockquote>
<ul>
<li>k近邻算法的特殊情况是k&#x3D;1的时候，这时称为<b>最近邻算法</b>。对于输入的实例点（特征向量）x，最近邻法将训练数据集中与x最近邻点的类视作x的类&#x2F;</li>
<li>k近邻法没有显式的学习过程。</li>
</ul>
</blockquote>
<h4 id="k近邻模型"><a href="#k近邻模型" class="headerlink" title="k近邻模型"></a><b>k近邻模型</b></h4><h5 id="模型"><a href="#模型" class="headerlink" title="模型"></a><b>模型</b></h5><blockquote>
<ul>
<li>当训练集、距离度量、k值及分类决策规则确定后，它所属的类唯一确定。</li>
<li>特征空间中，对每个实例点$x_i$,距离该点比其他点更近的所有点组成一个区域，叫作<b>单元</b>。</li>
<li>每个实例点拥有一个单元，所有训练实例点的单元构成对特征空间的一个<b>划分</b><br><b>如图：</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/k%E8%BF%91%E9%82%BB/k%E8%BF%91%E9%82%BB%E6%B3%95%E5%AF%B9%E5%BA%94%E7%89%B9%E5%BE%81%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%92%E5%88%86.png" alt="k近邻法对应特征空间的划分" title="k近邻法对应特征空间的划分"><br>每个点都有一个单元，测试点落在哪个单元上，那就将该测试点归为该单元的一类。</li>
</ul>
</blockquote>
<blockquote>
<h5 id="距离度量"><a href="#距离度量" class="headerlink" title="距离度量"></a><b>距离度量</b></h5><ul>
<li><p>特征空间中两个实例点的距离是两个实例点相似程度的反映。</p>
</li>
<li><p>k近邻模型的特征空间一般是n维实数向量空间$R^n$，一般使用<b>欧氏距离</b><br><b>距离定义：</b></p>
<blockquote>
<p>设特征空间$\chi$是n维实数向量空间$R^n$，$x_i,x_j{\in}\chi,x_i&#x3D;(x^{(1)}_i,x^{(2)}_i,…,x^{(n)}_i)^T,x_j&#x3D;(x^{(1)}_j,x^{(2)}_j,…,x^{(n)}_j),x_i,x_j$的$L_P$距离定义为:</p>
<p>$$L_P(x_i,x_j)&#x3D;(\sum_{l&#x3D;1}^n|x^{(l)}_i-x^{(l)}_j|^P)^{\frac{1}{P}}$$</p>
<p>这里$p \ge 1.$当$p&#x3D;2$时，称为<b>欧氏距离</b>，即<br>$$L_2(x_i,x_j)&#x3D;(\sum^n_{l&#x3D;1}|x^{(l)}_i-x^{(l)}_j|^2)^{1 \over 2}$$</p>
<p>当$p&#x3D;1$时，称为<b>曼哈顿距离</b>，即<br>$$L_1(x_i,x_j)&#x3D;(\sum^n_{l&#x3D;1}|x^{(l)}_i-x^{(l)}_j|)$$</p>
<p>当$p&#x3D;\infty$时，它是各个坐标距离的最大值，即<br>$$L_{\infty}(x_i,x_j)&#x3D;max_l \ |x^{(l)}_i-x^{(l)}_j|$$</p>
</blockquote>
</li>
<li><p><b>补充：</b>对于p值的不同取值，实例点的最邻近点也会有所不同。<br><b>如图：</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/k%E8%BF%91%E9%82%BB/%E8%B7%9D%E7%A6%BB%E5%BA%A6%E9%87%8F.png" alt="L距离间的关系" title="距离间的关系"></p>
</li>
</ul>
</blockquote>
<h5 id="k值的选择"><a href="#k值的选择" class="headerlink" title="k值的选择"></a><b>k值的选择</b></h5><blockquote>
<ul>
<li>k值为离<b>待分类实例点</b>最近的<b>已知实例点的个数</b><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/k%E8%BF%91%E9%82%BB/k%E8%BF%91%E9%82%BB%E6%A8%A1%E5%9E%8B%E5%9B%BE.jpg" alt="k近邻" title="k近邻"><br>如上图中，实线圈的k值为3,虚线圈的k值为5.</p>
</blockquote>
</li>
</ul>
<p>k值对于k近邻法的结果会产生很大影响。</p>
<ul>
<li><p>如果k值过小，</p>
<blockquote>
<ul>
<li>优点是学习的近似误差会减小，因为只有与输入实例较近的训练实例才会对预测结果产生作用。</li>
<li>但缺点是学习的估计误差会增大，因为预测结果对近邻的实例点非常敏感，如果邻近的实例点刚好是噪声点，预测就会出错。换句话说，k值越小，模型越复杂，就越容易出现过拟合。</li>
</ul>
</blockquote>
</li>
<li><p>如果k值过大，</p>
<blockquote>
<ul>
<li>优点是可以减少学习的估计误差</li>
<li>缺点是学习的近似误差会增大，此时与输入实例较远的点也会对预测起作用，使预测发生错误。</li>
</ul>
</blockquote>
</li>
</ul>
<p>在实际应用中，k值一般取一个较小的值，通常通过交叉验证法来选取最优的k值。</p>
</blockquote>
<h5 id="分类决策规则"><a href="#分类决策规则" class="headerlink" title="分类决策规则"></a><b>分类决策规则</b></h5><blockquote>
<ul>
<li>k近邻法中的分类决策规则往往是<b>多数表决</b>:<blockquote>
<p>由输入实例的k个邻近的训练实例中的多数类决定输入实例的类。</p>
</blockquote>
</li>
</ul>
<p><b>下面是从数学的角度来证明多数表决等价于经验风险最小化</b></p>
<ul>
<li><p>多数表决规则可以解释为：如果分类的损失函数为0-1损失函数，分类函数为：</p>
<blockquote>
<p>$$f:R^n \to (c_1,c_2,…,c_k)$$<br>那么误分类的概率为：<br>$$P(Y{\neq}f(x))&#x3D;1-P(Y&#x3D;f(x))$$</p>
</blockquote>
</li>
<li><p>对给定的实例$x{\in}{\chi}$，其最近邻的k个训练实例点构成集合$N_k(x)$.如果涵盖$N_k(x)$的区域的类别是$c_j$，那么误分类率是：</p>
<blockquote>
<p>$$\frac{1}{k}\sum_{x_i{\in}N_k(x)}I(y_i{\neq}c_j)&#x3D;1-\frac{1}{k}\sum_{x_i{\in}N_k(x)}I(y_i&#x3D;c_j)$$</p>
</blockquote>
</li>
</ul>
<p>要使误分类率最小即经验风险最小化，就要使$\sum_{x_i{\in}N_k(x)}I(y_i&#x3D;c_j)$最大，所以多数表决规则等价于经验风险最小化。</p>
</blockquote>
<h4 id="kd树"><a href="#kd树" class="headerlink" title="kd树"></a><b>kd树</b></h4><blockquote>
<ul>
<li>k近邻法最简单的实现方法是<b>线性扫描</b>，即对输入实例对每一个训练集点都计算距离，此时的计算量会变得非常大。所以为了减少计算量而引入了kd树。</li>
<li>kd树是一种对k维空间中的实例点进行存储，以便对其进行快速检索的树形数据结构。</li>
<li>kd树是二叉树，表示对k维空间的一个划分。</li>
<li>构建kd树相当于不断的用垂直于坐标轴的超平面将k维空间进行划分，构成一系列的k维超矩形区域。</li>
<li>kd树的每一个结点对应于一个k维超矩形区域。</li>
</ul>
</blockquote>
<h5 id="构造kd树"><a href="#构造kd树" class="headerlink" title="构造kd树"></a><b>构造kd树</b></h5><blockquote>
<p><b>算法定义：</b></p>
<blockquote>
<p><b>输入:</b>k维空间数据集$T&#x3D;(x_1,x_2,…,x_N)$,<br>其中$x_i&#x3D;(x^{(1)}_i,x^{(2)}_i,…,x^{(k)}_i)^T,i&#x3D;1,2,…,N$<br>输出：kd树<br>(1) <b>开始：</b>构造根结点，根结点对应于包含T的k维空间的超矩形区域。<br>选择$x^{(k)}$为坐标轴，以T中所有实例的$x^{(k)}$坐标的中位数为切分点，将根结点对应的超矩形区域切分为两个子区域。切分由通过切分点并与坐标轴$x^{(k)}$垂直的超平面实现<br>由根结点生成深度为1的左、右子结点：左子结点对应坐标$x^{(k)}$小于切分点的子区域，右子结点对应于坐标$x^{(k)}$大于切分点的子区域。<br><b>注：将落在切分超平面上的实例点保存在根结点.</b> </p>
<p>(2) <b>重复：</b>对深度为j的结点，选择$x^{(k)}$为切分点的坐标轴，$l&#x3D;(j \ mod \ k)+1$，以该结点的区域中所有实例的$x^{(k)}$坐标的中位数为切分点，将该结点对应的超矩形区域切分为两个子区域.切分由通过切分点并与坐标轴$x^{(k)}$垂直的超平面实现.<br>由该结点生成深度为j+1的左、右子结点：左子结点对应坐标$x^{(k)}$小于切分点的子区域，右子结点对应坐标$x^{(k)}$大于切分点的子区域。<br><b>注：将落在切分超平面上的实例点保存在该结点.</b></p>
<p>(3) 直到两个子区域没有实例存在时停止.从而形成kd树的区域划分。</p>
</blockquote>
<p><b>kd树划分例子：</b></p>
<blockquote>
<p> 给定一个二维空间的数据集：<br>$$T&#x3D;[(2,3)^T,(5,4)^T,(9,6)^T,(4,7)^T,(8,1)^T,(7,2)^T]$$<br>构造一个kd树;</p>
<ul>
<li>根结点对应包含数据集T的矩形，选择$x^{(1)}$轴，6个数据点的$x^{(1)}$坐标的<b>中位数</b>是7,所以以$x^{(1)}&#x3D;7$将空间分为左右两个矩形，</li>
<li>左矩形$x^{(2)}$的中位数为4,所以又以$x^{(2)}&#x3D;4$为平面将左矩形分为两个更小的矩形，同理，右矩形以$x^{(2)}&#x3D;6$分割右矩形。</li>
<li>由于没有$x^{(3)}$，所以重复回$x^{(1)}$，以此递归直到空间不能再被划分。<br><b>结果如图：</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/k%E8%BF%91%E9%82%BB/kd%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0.jpg" alt="kd树的构造" title="kd树"><br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/k%E8%BF%91%E9%82%BB/kd%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0-1.jpg" alt="kd树的构造" title="kd树"><br><b>注：</b>对于每一层的结点对应的特征值$x^{(i)}$来说都有：<b>左子树&lt;根结点&lt;右子树</b>。如对于第一层中的$x^{(1)}$，恒有左结点(<b>5</b>,4)&lt;根结点(<b>7</b>,2)&lt;右结点(<b>9</b>,6)</li>
</ul>
</blockquote>
</blockquote>
<h5 id="搜索kd树"><a href="#搜索kd树" class="headerlink" title="搜索kd树"></a><b>搜索kd树</b></h5><blockquote>
<p>kd树可以省去对大部分数据点的搜索,从而减少搜索的计算量,<b>以下为查找最近邻点</b>为例.同样的方法可以应用到k近邻.<br><b>算法描述:</b></p>
<blockquote>
<p><b>输入</b>:已构造的kd树;目标点x;<br><b>输出</b>:x的最近邻<br>(1) 在kd树中找出包含目标点x的叶结点：从根结点出发，递归向下访问kd树；若目标点x当前维度的坐标小于切分点的坐标，则移动到左子结点，否则移动到右子结点，直到子结点为叶子结点为止。<br>(2) 以此叶结点为“当前最近点”。<br>(3) 递归向上回溯，在每个结点进行以下操作：</p>
<blockquote>
<ul>
<li>如果<b>该结点保存的实例点</b>比<b>当前最近点</b>距离<b>目标点</b>更近，则以该实例点为“当前最近点”。</li>
<li>当前最近点一定存在于该结点一个子结点对应的区域。检查该子结点的父结点的另一个子结点对应的区域是否有更近的点。具体的，检查另一个子结点对应的区域是否与以目标点为球心、以目标点与“当前最近点”间的距离为半径的超球体相交。<br>$\quad$如果相交，可能在另一个子结点对应的区域内存在与目标点更近的点，那么移动到另一个子结点，接着，递归进行最近邻搜索;<br>$\quad$如果不相交，继续向上回溯。</li>
</ul>
</blockquote>
<p>(4) 当回退到根结点时，搜索结束，最后的“当前最近点”即为x的最近邻点</p>
</blockquote>
<p><b>例题：</b></p>
<blockquote>
<p> 给定一个二维空间的数据集：<br>$$T&#x3D;[(2,3)^T,(5,4)^T,(9,6)^T,(4,7)^T,(8,1)^T,(7,2)^T]$$<br><b>构建的kd树为：</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/k%E8%BF%91%E9%82%BB/kd%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0-%E7%BB%93%E6%9E%9C.jpg" alt="kd树的构造" title="kd树"><br><b>问题:</b>求点(2,4.5)的最邻近点。</p>
<ul>
<li>第一步,找到包含(2,4.5)的叶子结点，即找到(4,7)，此时“最近点”为(4,7).</li>
<li>第二步，进行回退，找到(4,7)的父结点(5,4),比较哪个离点(2,4.5)更近，发现(5,4)更近，将“最近点”设为(5,4)</li>
<li>第三步，计算(5,4)的另一个子结点(2,3)到目标点(2,4.5)的距离，发现(2,3)到目标点(2,4.5)的距离更近，(2,3)为叶子结点，因此将“最近点”设为(2,3)</li>
<li>第四步，继续回退，找到(5,4)的父结点(7,2)，计算目标点(2,4.5)到(7,2)的距离，这个距离大于<b>目前的最近邻点</b>，所以不用计算点目标点（2,4.5）到(7,2)的另一个子结点的距离。</li>
<li>最后，发现(7,2)就是根结点，结束回退，最终(2,3)就是最近邻点了。</li>
</ul>
</blockquote>
</blockquote>
<h4 id="k近邻的优缺点："><a href="#k近邻的优缺点：" class="headerlink" title="k近邻的优缺点："></a><b>k近邻的优缺点：</b></h4><blockquote>
<ul>
<li><p><b>优点：</b></p>
<blockquote>
<ul>
<li>无论是线性可分还是线性不可分的数据都可以进行分类</li>
<li>简单易懂，易于实现</li>
<li>可以处理多分类问题</li>
<li>只要k值合适，那么分类时对异常点不敏感</li>
</ul>
</blockquote>
</li>
<li><p><b>缺点：</b></p>
<blockquote>
<ul>
<li>计算量太大，如果不使用kd树算法，需要每次都计算测试点到所有训练点的距离</li>
<li>当训练样本不平衡时（即有一方只占极小数时），分类效果会不理想。</li>
<li>对数据依赖度极高，如果在训练数据集中有一些错误数据时，将会导致预测数据的不准确。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<hr>
<blockquote>
<p><b>后记：</b>学了k近邻算法后，当然要实践一下啦，<a href="/2021/04/18/k%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/index.html">代码实现</a><br>坑填得好慢啊！！</p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>深渊巨坑</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown的语法-续</title>
    <url>/2021/01/01/Markdown%E7%9A%84%E8%AF%AD%E6%B3%95-%E7%BB%AD/</url>
    <content><![CDATA[<h3 id="Markdown的拓展学习"><a href="#Markdown的拓展学习" class="headerlink" title="Markdown的拓展学习"></a><b>Markdown的拓展学习</b></h3><h4 id="1、实现内容的折叠"><a href="#1、实现内容的折叠" class="headerlink" title="1、实现内容的折叠"></a><b>1、实现内容的折叠</b></h4><h5 id="语法如下"><a href="#语法如下" class="headerlink" title="语法如下:"></a><b>语法如下:</b></h5><blockquote>
<p>&lt;details&gt;<br>&lt;summary&gt;标题&lt;&#x2F;summary&gt;<br>隐藏的内容!<br>&lt;&#x2F;details&gt;</p>
</blockquote>
<h5 id="效果如下："><a href="#效果如下：" class="headerlink" title="效果如下："></a><b>效果如下：</b></h5> <details>
 <summary>标题</summary>
 隐藏的内容!
 </details>

]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML(一)</title>
    <url>/2021/04/06/HTML%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h4 id="HTML介绍"><a href="#HTML介绍" class="headerlink" title="HTML介绍"></a><b>HTML介绍</b></h4><blockquote>
<p>HTML全称为<b>超文本标记语言</b>，是一种用于创建网页的标准标记语言。HTML可以创建属于自己的Web站点，并且一般由浏览器负责解析。</p>
</blockquote>
<h5 id="HTML简介"><a href="#HTML简介" class="headerlink" title="HTML简介"></a><b>HTML简介</b></h5><blockquote>
<p><b>例如：</b></p>
<blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">title</span>&gt;</span>这是网站标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是第一个标题！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是第一个段落！<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是第二级标题！<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是第二个段落！<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><b>HTML实例解析：</b></p>
<ul>
<li><code>&lt;!DOCTYPE html&gt;</code>声明该文件是一个HTML文件。</li>
<li><code>&lt;html&gt;</code>元素是HTML的根元素。</li>
<li><code>&lt;head&gt;</code>元素包含了文档的元数据，<code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>就标指了网页的编码格式为<code>utf-8</code></li>
<li><code>&lt;title&gt;</code>元素定义了网页的标题。</li>
<li><code>&lt;body&gt;</code>元素包括了网页的可见内容。</li>
<li><code>&lt;h1&gt;</code>元素定义了一个一级标题。</li>
<li><code>&lt;p&gt;</code>元素定义了一个段落。</li>
</ul>
</blockquote>
<h5 id="HTML标签"><a href="#HTML标签" class="headerlink" title="HTML标签"></a><b>HTML标签</b></h5><blockquote>
<ul>
<li>HTML标签是由尖括号包围的关键字，如<code>&lt;head&gt;</code></li>
<li>HTML标签分为<b>开放标签</b>和<b>闭合标签</b></li>
<li>HTML标签一般成对出现，如<code>&lt;head&gt;&lt;/head&gt;</code></li>
<li><b>HTML元素</b>与<b>HTML标签</b>通常是相同的意思，不过HTML元素特指<b>开始与结束的两个标签</b>。</li>
</ul>
</blockquote>
<h4 id="HTML基础"><a href="#HTML基础" class="headerlink" title="HTML基础"></a><b>HTML基础</b></h4><h5 id="标题"><a href="#标题" class="headerlink" title="标题"></a><b>标题</b></h5><blockquote>
<p>在HTML中标题有六级，<code>&lt;h1&gt;～&lt;h6&gt;</code>如：</p>
<blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一级标题！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是二级标题！<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>这是三级标题！<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>这是四级标题！<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h5</span>&gt;</span>这是五级标题！<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h6</span>&gt;</span>这是六级标题！<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><b>效果：</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/HTML/HTML%E6%A0%87%E9%A2%98.jpg" alt="HTML标题" title="标题"></p>
</blockquote>
</blockquote>
<h5 id="HTML段落"><a href="#HTML段落" class="headerlink" title="HTML段落"></a><b>HTML段落</b></h5><blockquote>
<p>在HTML中，段落可以用<code>&lt;p&gt;  &lt;/p&gt;</code>来定义，如：</p>
<blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h5 id="HTML链接"><a href="#HTML链接" class="headerlink" title="HTML链接"></a><b>HTML链接</b></h5><blockquote>
<p>在HTML中，链接可以用<code>&lt;a&gt;  &lt;/a&gt;</code>来定义，如：</p>
<blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span>&gt;</span>这是一个链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><b>补充：</b>上述元素只是稍微提及，后面会有更详细的描述。 </p>
</blockquote>
<hr>
<blockquote>
<p><b>补充：</b><br><a href="/2021/04/06/HTML%E5%B8%B8%E7%94%A8%E5%85%83%E7%B4%A0/index.html">常用元素</a></p>
</blockquote>
]]></content>
      <categories>
        <category>网页设计</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>k近邻算法代码实现</title>
    <url>/2021/04/18/k%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="k近邻一般算法的实现"><a href="#k近邻一般算法的实现" class="headerlink" title="k近邻一般算法的实现"></a><b>k近邻一般算法的实现</b></h4><blockquote>
<p>一般的方法指的是直接计算训练集中每个点到测试点的距离，然后根据排序结果进行判断。<br><b>思路：</b></p>
<blockquote>
<ul>
<li>创建一个矩阵用来容纳每个训练点到测试点的距离</li>
<li>计算每个训练点到测试点的距离</li>
<li>对距离进行排序</li>
<li>根据排序结果，对前k个训练点进行统计</li>
<li>对统计结果进行排序，并且输出统计最多的标签</li>
<li>以统计最多的标签的结果为测试点的预测结果</li>
</ul>
</blockquote>
</blockquote>
<hr>
<h4 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a><b>代码区</b></h4><blockquote>
<p><b>导入的包</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]  <span class="comment"># 用来正常显示中文标签</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span>  <span class="comment"># 用来正常显示负号</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>为导入数据准备一个函数：</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置鸢尾花数据集</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createIrisDataSet</span>():</span><br><span class="line">   data = load_iris()</span><br><span class="line">   tt = data.data</span><br><span class="line">   dt = pd.DataFrame(data=data.data, columns=data.feature_names)</span><br><span class="line">   dt[<span class="string">&#x27;species&#x27;</span>] = data.target</span><br><span class="line">   data = dt</span><br><span class="line">   data.rename(columns=&#123;<span class="string">&#x27;sepal length (cm)&#x27;</span>: <span class="string">&quot;萼片长&quot;</span>, <span class="string">&#x27;sepal width (cm)&#x27;</span>: <span class="string">&quot;萼片宽&quot;</span>,</span><br><span class="line">                        <span class="string">&#x27;petal length (cm)&#x27;</span>: <span class="string">&quot;花瓣长&quot;</span>, <span class="string">&#x27;petal width (cm)&#x27;</span>: <span class="string">&quot;花瓣宽&quot;</span>,</span><br><span class="line">                        <span class="string">&#x27;species&#x27;</span>: <span class="string">&quot;种类&quot;</span>&#125;, inplace=<span class="literal">True</span>)</span><br><span class="line">   kind_dict = &#123;<span class="number">0</span>: <span class="string">&quot;山鸢尾&quot;</span>, <span class="number">1</span>: <span class="string">&quot;杂色鸢尾&quot;</span>, <span class="number">2</span>: <span class="string">&quot;维吉尼亚鸢尾&quot;</span>&#125;</span><br><span class="line">   data[<span class="string">&quot;种类&quot;</span>] = data[<span class="string">&quot;种类&quot;</span>].<span class="built_in">map</span>(kind_dict)</span><br><span class="line">   <span class="keyword">return</span> data, tt  <span class="comment"># 返回一个带标签的数据集和一个不带标签的数据集</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>k近邻算法的核心代码：</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># K近邻算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">classify0</span>(<span class="params">inX, dataSet, labels, k</span>):</span><br><span class="line">   dataSetSize = dataSet.shape[<span class="number">0</span>]  <span class="comment"># dataSetSize写入数据的行数</span></span><br><span class="line"></span><br><span class="line">   <span class="comment"># 计算测试样本到各训练样本的距离</span></span><br><span class="line">   diffMat = tile(inX, (dataSetSize, <span class="number">1</span>)) - dataSet  <span class="comment"># 计算训练样本到训练样本之间的差</span></span><br><span class="line">   sqDiffMat = diffMat ** <span class="number">2</span>  <span class="comment"># 将差值平方</span></span><br><span class="line">   sqDistances = sqDiffMat.<span class="built_in">sum</span>(axis=<span class="number">1</span>)  <span class="comment"># 再求和</span></span><br><span class="line">   distances = sqDistances ** <span class="number">0.5</span>  <span class="comment"># 最后开方</span></span><br><span class="line"></span><br><span class="line">   <span class="comment"># 对距离进行从小到大的排序，并且输出其在矩阵中的索引值</span></span><br><span class="line">   sortedDistIndices = distances.argsort()</span><br><span class="line">   classCount = &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 对距离前k个的样本数据进行统计</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">       voteIlabel = labels[sortedDistIndices[i]]</span><br><span class="line">       classCount[voteIlabel] = classCount.get(voteIlabel, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">   <span class="comment"># 统计前k个数据的类别</span></span><br><span class="line">   sortedClassCount = <span class="built_in">sorted</span>(classCount.items(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="literal">True</span>)</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;距离为前&#x27;</span>, k ,<span class="string">&#x27;个数据的标签分布情况：&#x27;</span>, sortedClassCount)</span><br><span class="line">   <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>其中inX为测试点，dataSet为训练数据集，labels为标签，k为k近邻中的k值</li>
</ul>
</blockquote>
</li>
<li><p>画图函数</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 画散点图</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">X, Y, labels, Xt, Yt</span>):</span><br><span class="line">   a = -<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> labels:</span><br><span class="line">       a = a+<span class="number">1</span></span><br><span class="line">       <span class="keyword">if</span>(i ==<span class="string">&#x27;山鸢尾&#x27;</span>):</span><br><span class="line">           plt.scatter(X[a], Y[a], s=<span class="number">10</span>, c=<span class="string">&quot;red&quot;</span>, marker=<span class="string">&quot;.&quot;</span>, alpha=<span class="number">1</span>)</span><br><span class="line">       <span class="keyword">if</span>(i == <span class="string">&#x27;杂色鸢尾&#x27;</span>):</span><br><span class="line">           plt.scatter(X[a], Y[a], s=<span class="number">10</span>, c=<span class="string">&quot;blue&quot;</span>, marker=<span class="string">&quot;*&quot;</span>, alpha=<span class="number">1</span>)</span><br><span class="line">       <span class="keyword">if</span>(i == <span class="string">&#x27;维吉尼亚鸢尾&#x27;</span>):</span><br><span class="line">           plt.scatter(X[a], Y[a], s=<span class="number">10</span>, c=<span class="string">&quot;green&quot;</span>, marker=<span class="string">&quot;1&quot;</span>, alpha=<span class="number">1</span>)</span><br><span class="line">   plt.scatter(Xt, Yt, s=<span class="number">10</span>, c=<span class="string">&quot;black&quot;</span>, marker=<span class="string">&quot;2&quot;</span>, alpha=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   plt.xlabel(<span class="string">&quot;花瓣长&quot;</span>)</span><br><span class="line">   plt.ylabel(<span class="string">&quot;花瓣宽&quot;</span>)</span><br><span class="line">   plt.title(<span class="string">&quot;鸢尾花散点图&quot;</span>)</span><br><span class="line">   plt.show()</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<p><b>整体函数：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]  <span class="comment"># 用来正常显示中文标签</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span>  <span class="comment"># 用来正常显示负号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置鸢尾花数据集</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createIrisDataSet</span>():</span><br><span class="line">   data = load_iris()</span><br><span class="line">   tt = data.data</span><br><span class="line">   dt = pd.DataFrame(data=data.data, columns=data.feature_names)</span><br><span class="line">   dt[<span class="string">&#x27;species&#x27;</span>] = data.target</span><br><span class="line">   data = dt</span><br><span class="line">   data.rename(columns=&#123;<span class="string">&#x27;sepal length (cm)&#x27;</span>: <span class="string">&quot;萼片长&quot;</span>, <span class="string">&#x27;sepal width (cm)&#x27;</span>: <span class="string">&quot;萼片宽&quot;</span>,</span><br><span class="line">                        <span class="string">&#x27;petal length (cm)&#x27;</span>: <span class="string">&quot;花瓣长&quot;</span>, <span class="string">&#x27;petal width (cm)&#x27;</span>: <span class="string">&quot;花瓣宽&quot;</span>,</span><br><span class="line">                        <span class="string">&#x27;species&#x27;</span>: <span class="string">&quot;种类&quot;</span>&#125;, inplace=<span class="literal">True</span>)</span><br><span class="line">   kind_dict = &#123;<span class="number">0</span>: <span class="string">&quot;山鸢尾&quot;</span>, <span class="number">1</span>: <span class="string">&quot;杂色鸢尾&quot;</span>, <span class="number">2</span>: <span class="string">&quot;维吉尼亚鸢尾&quot;</span>&#125;</span><br><span class="line">   data[<span class="string">&quot;种类&quot;</span>] = data[<span class="string">&quot;种类&quot;</span>].<span class="built_in">map</span>(kind_dict)</span><br><span class="line">   <span class="keyword">return</span> data, tt  <span class="comment"># 返回一个带标签的数据集和一个不带标签的数据集</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># K近邻算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">classify0</span>(<span class="params">inX, dataSet, labels, k</span>):</span><br><span class="line">   dataSetSize = dataSet.shape[<span class="number">0</span>]  <span class="comment"># dataSetSize写入数据的行数</span></span><br><span class="line"></span><br><span class="line">   <span class="comment"># 计算测试样本到各训练样本的距离</span></span><br><span class="line">   diffMat = tile(inX, (dataSetSize, <span class="number">1</span>)) - dataSet  <span class="comment"># 计算训练样本到训练样本之间的差</span></span><br><span class="line">   sqDiffMat = diffMat ** <span class="number">2</span>  <span class="comment"># 将差值平方</span></span><br><span class="line">   sqDistances = sqDiffMat.<span class="built_in">sum</span>(axis=<span class="number">1</span>)  <span class="comment"># 再求和</span></span><br><span class="line">   distances = sqDistances ** <span class="number">0.5</span>  <span class="comment"># 最后开方</span></span><br><span class="line"></span><br><span class="line">   <span class="comment"># 对距离进行从小到大的排序，并且输出其在矩阵中的索引值</span></span><br><span class="line">   sortedDistIndices = distances.argsort()</span><br><span class="line">   classCount = &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 对距离前k个的样本数据进行统计</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">       voteIlabel = labels[sortedDistIndices[i]]</span><br><span class="line">       classCount[voteIlabel] = classCount.get(voteIlabel, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">   <span class="comment"># 统计前k个数据的类别</span></span><br><span class="line">   sortedClassCount = <span class="built_in">sorted</span>(classCount.items(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="literal">True</span>)</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;距离为前&#x27;</span>, k ,<span class="string">&#x27;个数据的标签分布情况：&#x27;</span>, sortedClassCount)</span><br><span class="line">   <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画散点图</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">X, Y, labels, Xt, Yt</span>):</span><br><span class="line">   a = -<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> labels:</span><br><span class="line">       a = a+<span class="number">1</span></span><br><span class="line">       <span class="keyword">if</span>(i ==<span class="string">&#x27;山鸢尾&#x27;</span>):</span><br><span class="line">           plt.scatter(X[a], Y[a], s=<span class="number">10</span>, c=<span class="string">&quot;red&quot;</span>, marker=<span class="string">&quot;.&quot;</span>, alpha=<span class="number">1</span>)</span><br><span class="line">       <span class="keyword">if</span>(i == <span class="string">&#x27;杂色鸢尾&#x27;</span>):</span><br><span class="line">           plt.scatter(X[a], Y[a], s=<span class="number">10</span>, c=<span class="string">&quot;blue&quot;</span>, marker=<span class="string">&quot;*&quot;</span>, alpha=<span class="number">1</span>)</span><br><span class="line">       <span class="keyword">if</span>(i == <span class="string">&#x27;维吉尼亚鸢尾&#x27;</span>):</span><br><span class="line">           plt.scatter(X[a], Y[a], s=<span class="number">10</span>, c=<span class="string">&quot;green&quot;</span>, marker=<span class="string">&quot;1&quot;</span>, alpha=<span class="number">1</span>)</span><br><span class="line">   plt.scatter(Xt, Yt, s=<span class="number">10</span>, c=<span class="string">&quot;black&quot;</span>, marker=<span class="string">&quot;2&quot;</span>, alpha=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   plt.xlabel(<span class="string">&quot;花瓣长&quot;</span>)</span><br><span class="line">   plt.ylabel(<span class="string">&quot;花瓣宽&quot;</span>)</span><br><span class="line">   plt.title(<span class="string">&quot;鸢尾花散点图&quot;</span>)</span><br><span class="line">   plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主函数</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   data, dataSet = createIrisDataSet()</span><br><span class="line">   labels = data[<span class="string">&#x27;种类&#x27;</span>]</span><br><span class="line"></span><br><span class="line">   test1 = data[<span class="number">45</span>:<span class="number">50</span>]</span><br><span class="line">   test2 = data[<span class="number">95</span>:<span class="number">100</span>]</span><br><span class="line">   test3 = data[<span class="number">145</span>:<span class="number">150</span>]</span><br><span class="line">   labels1 = test1[<span class="string">&#x27;种类&#x27;</span>]</span><br><span class="line">   labels3 = test2[<span class="string">&#x27;种类&#x27;</span>]</span><br><span class="line">   labels2 = test3[<span class="string">&#x27;种类&#x27;</span>]</span><br><span class="line">   test1 = test1.drop(<span class="string">&#x27;种类&#x27;</span>, axis=<span class="number">1</span>)</span><br><span class="line">   test2 = test2.drop(<span class="string">&#x27;种类&#x27;</span>, axis=<span class="number">1</span>)</span><br><span class="line">   test3 = test3.drop(<span class="string">&#x27;种类&#x27;</span>, axis=<span class="number">1</span>)</span><br><span class="line">   test1 = array(test1)</span><br><span class="line">   test2 = array(test2)</span><br><span class="line">   test3 = array(test3)</span><br><span class="line">   test = vstack((test1, test2, test3))    <span class="comment"># 粘合测试集</span></span><br><span class="line"></span><br><span class="line">   <span class="comment"># test = [1,1,1,1]</span></span><br><span class="line">   k = <span class="number">10</span></span><br><span class="line">   times = shape(test)</span><br><span class="line"></span><br><span class="line">   <span class="comment"># kNN分类</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(times[<span class="number">0</span>]):</span><br><span class="line">       test_class = classify0(test[i], dataSet, labels, k)</span><br><span class="line">       <span class="built_in">print</span>(test_class)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment"># show(data[&#x27;萼片长&#x27;], data[&#x27;萼片宽&#x27;], labels)</span></span><br><span class="line">   show(data[<span class="string">&#x27;花瓣长&#x27;</span>], data[<span class="string">&#x27;花瓣宽&#x27;</span>], labels, test[<span class="number">0</span>][<span class="number">2</span>], test[<span class="number">0</span>][<span class="number">3</span>])        <span class="comment"># 画图的函数</span></span><br><span class="line">   <span class="comment"># show(data[&#x27;萼片长&#x27;], data[&#x27;花瓣宽&#x27;], labels, test[2], test[3])</span></span><br><span class="line">   <span class="comment"># show(data[&#x27;花瓣长&#x27;], data[&#x27;萼片宽&#x27;], labels, test[2], test[3])</span></span><br><span class="line"></span><br><span class="line">   <span class="comment"># 打印分类结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">优点：</span></span><br><span class="line"><span class="string">简单易理解</span></span><br><span class="line"><span class="string">对噪声点不敏感</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">缺点：</span></span><br><span class="line"><span class="string">计算量大</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><b>输出结果：</b></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">距离为前 10 个数据的标签分布情况： [(&#x27;山鸢尾&#x27;, 10)]</span><br><span class="line">山鸢尾</span><br><span class="line">距离为前 10 个数据的标签分布情况： [(&#x27;山鸢尾&#x27;, 10)]</span><br><span class="line">山鸢尾</span><br><span class="line">距离为前 10 个数据的标签分布情况： [(&#x27;山鸢尾&#x27;, 10)]</span><br><span class="line">山鸢尾</span><br><span class="line">距离为前 10 个数据的标签分布情况： [(&#x27;山鸢尾&#x27;, 10)]</span><br><span class="line">山鸢尾</span><br><span class="line">距离为前 10 个数据的标签分布情况： [(&#x27;山鸢尾&#x27;, 10)]</span><br><span class="line">山鸢尾</span><br><span class="line">距离为前 10 个数据的标签分布情况： [(&#x27;杂色鸢尾&#x27;, 10)]</span><br><span class="line">杂色鸢尾</span><br><span class="line">距离为前 10 个数据的标签分布情况： [(&#x27;杂色鸢尾&#x27;, 10)]</span><br><span class="line">杂色鸢尾</span><br><span class="line">距离为前 10 个数据的标签分布情况： [(&#x27;杂色鸢尾&#x27;, 10)]</span><br><span class="line">杂色鸢尾</span><br><span class="line">距离为前 10 个数据的标签分布情况： [(&#x27;杂色鸢尾&#x27;, 10)]</span><br><span class="line">杂色鸢尾</span><br><span class="line">距离为前 10 个数据的标签分布情况： [(&#x27;杂色鸢尾&#x27;, 10)]</span><br><span class="line">杂色鸢尾</span><br><span class="line">距离为前 10 个数据的标签分布情况： [(&#x27;维吉尼亚鸢尾&#x27;, 10)]</span><br><span class="line">维吉尼亚鸢尾</span><br><span class="line">距离为前 10 个数据的标签分布情况： [(&#x27;维吉尼亚鸢尾&#x27;, 8), (&#x27;杂色鸢尾&#x27;, 2)]</span><br><span class="line">维吉尼亚鸢尾</span><br><span class="line">距离为前 10 个数据的标签分布情况： [(&#x27;维吉尼亚鸢尾&#x27;, 9), (&#x27;杂色鸢尾&#x27;, 1)]</span><br><span class="line">维吉尼亚鸢尾</span><br><span class="line">距离为前 10 个数据的标签分布情况： [(&#x27;维吉尼亚鸢尾&#x27;, 10)]</span><br><span class="line">维吉尼亚鸢尾</span><br><span class="line">距离为前 10 个数据的标签分布情况： [(&#x27;维吉尼亚鸢尾&#x27;, 8), (&#x27;杂色鸢尾&#x27;, 2)]</span><br><span class="line">维吉尼亚鸢尾</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>深渊巨坑</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Mathjax的使用</title>
    <url>/2021/01/01/Mathjax%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述:"></a><b>概述:</b></h4><blockquote>
<p>在Markdown中输入数学公式需要LaTeX语法的支持，这篇文章就是记录LaTeX语法的。</p>
</blockquote>
<h4 id="行中公式"><a href="#行中公式" class="headerlink" title="行中公式"></a><b>行中公式</b></h4><blockquote>
<ul>
<li>行中公式可以用<code>$</code>…<code>$</code>来表示如：<blockquote>
<p>这是一条<code>$ y=ax+b $</code>行中公式</p>
</blockquote>
</li>
<li>效果如下：<blockquote>
<p>这是一条$ y&#x3D;ax+b $行中公式</p>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="独立公式"><a href="#独立公式" class="headerlink" title="独立公式"></a><b>独立公式</b></h4><blockquote>
<ul>
<li>行中公式可以用<code>$$</code>…<code>$$</code>来表示如：<blockquote>
<p>这是一条独立公式：<code>$$ y=ax+b $$</code></p>
</blockquote>
</li>
<li>效果如下：<blockquote>
<p>这是一条独立公式：$$ y&#x3D;ax+b $$</p>
<p>(<b>补充：</b>每条独立公式之间要间隔一行，不然会出无法显示的问题)</p>
</blockquote>
</li>
</ul>
<p><b>上面两种的区别：</b><br>1、行内公式可以在文字中写出来<br>2、独立公式可以自动居中</p>
</blockquote>
<h4 id="多行公式"><a href="#多行公式" class="headerlink" title="多行公式"></a><b>多行公式</b></h4><blockquote>
<p>多行公式要使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">\begin&#123;equation&#125;\begin&#123;split&#125;</span><br><span class="line">...(公式内容)</span><br><span class="line">\end&#123;split&#125;\end&#123;equation&#125;</span><br></pre></td></tr></table></figure>

<p>同时<code>\\</code>表示换行，<code>&amp;</code>表示要对齐的位置，<br><b>例如：</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">\begin&#123;equation&#125;\begin&#123;split&#125;</span><br><span class="line"><span class="built_in">F</span>(X)&amp;=<span class="number">2</span>x^<span class="number">2</span>+<span class="number">4</span>x\\\\</span><br><span class="line">&amp;=<span class="number">2</span>x(x+<span class="number">2</span>)</span><br><span class="line">\end&#123;split&#125;\end&#123;equation&#125;</span><br></pre></td></tr></table></figure>

<p><b>效果如下：</b><br>\begin{equation}\begin{split}<br>F(X)&amp;&#x3D;2x^2+4x\\<br>&amp;&#x3D;2x(x+2)<br>\end{split}\end{equation}</p>
</blockquote>
<h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a><b>字体</b></h4><blockquote>
<ul>
<li>使用<code>\mathbb</code>或<code>\Bbb</code>来显示黑板粗体字，$\Bbb{ABCDE}$</li>
<li>使用<code>\mathbf</code>来显示粗体字，$\mathbf{ABCDE}$</li>
<li>使用<code>\mathtt</code>来显示打印字体，$\mathtt{ABCDE}$</li>
<li>使用<code>\mathrm</code>来显示罗马字体，$\mathrm{ABCDE}$</li>
<li>使用<code>\mathcal</code>来显示手写字体，$\mathcal{ABCDE}$</li>
<li>使用<code>\mathscr</code>来显示剧本字体，$\mathscr{ABCDE}$</li>
</ul>
</blockquote>
<h4 id="间隔"><a href="#间隔" class="headerlink" title="间隔"></a><b>间隔</b></h4><blockquote>
<p>Mathjax中空格是不会增加间隔的,$A B$</p>
<ul>
<li>使用<code>\</code>可以增加一点间隔，$A \ B$</li>
<li>使用<code>\quad</code>可以增加大量间隔，$A \quad B$</li>
</ul>
</blockquote>
<h3 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a><b>希腊字母</b></h3><blockquote>
<p>命令格式：<code>$\</code>读音<code>$</code></p>
<table>
<thead>
<tr>
<th align="center">显示</th>
<th align="center">命令</th>
<th align="center">显示</th>
<th align="center">命令</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\alpha$</td>
<td align="center"><code>$\alpha$</code></td>
<td align="center">$\beta$</td>
<td align="center"><code>$\beta$</code></td>
</tr>
<tr>
<td align="center">$\gamma$</td>
<td align="center"><code>$\gamma$</code></td>
<td align="center">$\delta$</td>
<td align="center"><code>$\delta$</code></td>
</tr>
<tr>
<td align="center">$\epsilon$</td>
<td align="center"><code>$\epsilon$</code></td>
<td align="center">$\zeta$</td>
<td align="center"><code>$\zeta$</code></td>
</tr>
<tr>
<td align="center">$\eta$</td>
<td align="center"><code>$\eta$</code></td>
<td align="center">$\theta$</td>
<td align="center"><code>$\theta$</code></td>
</tr>
<tr>
<td align="center">$\iota$</td>
<td align="center"><code>$\iota$</code></td>
<td align="center">$\kappa$</td>
<td align="center"><code>$\kappa$</code></td>
</tr>
<tr>
<td align="center">$\lambda$</td>
<td align="center"><code>$\lambda$</code></td>
<td align="center">$\mu$</td>
<td align="center"><code>$\mu$</code></td>
</tr>
<tr>
<td align="center">$\nu$</td>
<td align="center"><code>$\nu$</code></td>
<td align="center">$\xi$</td>
<td align="center"><code>$\xi$</code></td>
</tr>
<tr>
<td align="center">$\pi$</td>
<td align="center"><code>$\pi$</code></td>
<td align="center">$\rho$</td>
<td align="center"><code>$\rho$</code></td>
</tr>
<tr>
<td align="center">$\sigma$</td>
<td align="center"><code>$\sigma$</code></td>
<td align="center">$\tau$</td>
<td align="center"><code>$\tau$</code></td>
</tr>
<tr>
<td align="center">$\upsilon$</td>
<td align="center"><code>$\upsilon$</code></td>
<td align="center">$\phi$</td>
<td align="center"><code>$\phi$</code></td>
</tr>
<tr>
<td align="center">$\chi$</td>
<td align="center"><code>$\chi$</code></td>
<td align="center">$\psi$</td>
<td align="center"><code>$\psi$</code></td>
</tr>
<tr>
<td align="center">$\omega$</td>
<td align="center"><code>$\omega$</code></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
</blockquote>
<ul>
<li>如果需要大写希腊字母，只需将读音首字母换成大写<blockquote>
<blockquote>
<p><code>$\gamma$</code>&amp;<code>$\Gamma$</code><br>$\gamma$ &amp; $\Gamma$</p>
</blockquote>
</blockquote>
</li>
</ul>
<h3 id="字母修饰"><a href="#字母修饰" class="headerlink" title="字母修饰"></a><b>字母修饰</b></h3><h4 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a><b>上下标</b></h4><ul>
<li>上标：在字母后面加上<code>^</code>，如：<blockquote>
<p><code>$a^2$</code>-&gt; $a^2$</p>
</blockquote>
</li>
<li>下标：在字母后面加上<code>_</code>，如：<blockquote>
<p><code>$C_n$</code>-&gt; $C_n$</p>
</blockquote>
</li>
</ul>
<h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a><b>分组</b></h4><ul>
<li><code>&#123;&#125;</code>可以进行分组，如：<blockquote>
<p><code>$10^20$</code>与<code>$10^&#123;20&#125;$</code>-&gt; $10^20$与$10^{20}$</p>
</blockquote>
</li>
</ul>
<h4 id="括号"><a href="#括号" class="headerlink" title="括号"></a><b>括号</b></h4><ul>
<li><b>小括号</b>:<code>$()$</code>-&gt; $()$</li>
<li><b>中括号</b>:<code>$[]$</code>-&gt; $[]$</li>
<li><b>尖括号</b>:<code>$\langle\rangle$</code>-&gt; $\langle\rangle$</li>
<li><b>向上取整</b>：<code>$\lceil x \rceil$</code>-&gt; $\lceil x \rceil$</li>
<li><b>向下取整</b>:<code>$\floor x \rfloor$</code>-&gt; $\lfloor x \rfloor$</li>
</ul>
<h4 id="求和、极限、积分、连乘"><a href="#求和、极限、积分、连乘" class="headerlink" title="求和、极限、积分、连乘"></a><b>求和、极限、积分、连乘</b></h4><ul>
<li><b>求和符号：</b><blockquote>
<p><code>$\sum$</code> <code>$\sum_&#123;i=1&#125;^n&#123;a_i&#125;$</code><br>$\sum$ &amp; $\sum_{i&#x3D;1}^n{a_i}$</p>
</blockquote>
</li>
<li><b>求极限符号：</b><blockquote>
<p><code>$\lim_&#123;x\to 0&#125;$</code><br>$\lim_{x\to 0}x^2$</p>
</blockquote>
</li>
<li><b>积分符号：</b><blockquote>
<p><code>$\int_0^\infty&#123;fxdx&#125;$</code><br>$\int_0^\infty{fxdx}$<br>双重积分<br><code>$\iint&#123;x^2&#125;$</code><br>$\iint{x^2}$</p>
</blockquote>
</li>
<li><b>连乘符号：</b><blockquote>
<p><code>$\prod^n_&#123;i=1&#125;$</code><br>$\prod^n_{i&#x3D;1}$</p>
</blockquote>
</li>
</ul>
<h4 id="分式和根式"><a href="#分式和根式" class="headerlink" title="分式和根式"></a><b>分式和根式</b></h4><ul>
<li>分式：<blockquote>
<p><code>$\frac&#123;公式一&#125;&#123;公式二&#125;$</code><br>$\frac{公式一}{公式二}$</p>
</blockquote>
</li>
<li>根式：<blockquote>
<p><code>$\sqrt[x]&#123;y&#125;$</code><br>$\sqrt[x]{y}$<br>或<br><code>$x \over y$</code><br>$x \over y$</p>
</blockquote>
</li>
</ul>
<h4 id="其他公式"><a href="#其他公式" class="headerlink" title="其他公式"></a><b>其他公式</b></h4><blockquote>
<p>三角函数：<code>$\sin x$</code> &amp; 对数函数：<code>$\ln x$</code> &amp; 取最大值：<code>$\max(A,B,C)$</code><br>三角函数：$\sin x$ &amp; 对数函数：$\ln x$ &amp; 取最大值：$\max(A,B,C)</p>
</blockquote>
<h4 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a><b>数学符号</b></h4><ul>
<li><p><b>特殊符号：</b></p>
<blockquote>
<table>
<thead>
<tr>
<th align="center">显示</th>
<th align="center">命令</th>
<th align="center">显示</th>
<th align="center">命令</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\infty$</td>
<td align="center"><code>$\infty$</code></td>
<td align="center">$\cup$</td>
<td align="center"><code>$\cup$</code></td>
</tr>
<tr>
<td align="center">$\cap$</td>
<td align="center"><code>$\cap$</code></td>
<td align="center">$\subset$</td>
<td align="center"><code>$\subset$</code></td>
</tr>
<tr>
<td align="center">$\subseteq$</td>
<td align="center"><code>$\subseteq$</code></td>
<td align="center">$\supset$</td>
<td align="center"><code>$\supset$</code></td>
</tr>
<tr>
<td align="center">$\subsetneq$</td>
<td align="center"><code>$\subseteq$</code></td>
<td align="center">$\supsetneq$</td>
<td align="center"><code>$\supseteq$</code></td>
</tr>
<tr>
<td align="center">$\in$</td>
<td align="center"><code>$\in$</code></td>
<td align="center">$\notin$</td>
<td align="center"><code>$\notin$</code></td>
</tr>
<tr>
<td align="center">$\varnothing$</td>
<td align="center"><code>$\varnothing$</code></td>
<td align="center">$\forall$</td>
<td align="center"><code>$\forall$</code></td>
</tr>
<tr>
<td align="center">$\exists$</td>
<td align="center"><code>$\exists$</code></td>
<td align="center">$\lnot$</td>
<td align="center"><code>$\lnot$</code></td>
</tr>
<tr>
<td align="center">$\nabla$</td>
<td align="center"><code>$\nabla$</code></td>
<td align="center">$\partial$</td>
<td align="center"><code>$\partial$</code></td>
</tr>
<tr>
<td align="center">$\approx$</td>
<td align="center"><code>$\approx$</code></td>
<td align="center">$\sim$</td>
<td align="center"><code>$\sim$</code></td>
</tr>
<tr>
<td align="center">$\simeq$</td>
<td align="center"><code>$\simeq$</code></td>
<td align="center">$\cong$</td>
<td align="center"><code>$\cong$</code></td>
</tr>
<tr>
<td align="center">$\equiv$</td>
<td align="center"><code>$\equiv$</code></td>
<td align="center">$\prec$</td>
<td align="center"><code>$\prec$</code></td>
</tr>
<tr>
<td align="center">${x \choose y}$</td>
<td align="center"><code>&#123;x \choose y&#125;</code></td>
<td align="center">$\land$</td>
<td align="center"><code>$\land$</code></td>
</tr>
<tr>
<td align="center">$\lor$</td>
<td align="center"><code>$\lor$</code></td>
<td align="center">$\top$</td>
<td align="center"><code>$\top$</code></td>
</tr>
<tr>
<td align="center">$\bot$</td>
<td align="center"><code>$\bot$</code></td>
<td align="center">$\vdash$</td>
<td align="center"><code>$\vdash$</code></td>
</tr>
<tr>
<td align="center">$\vDash$</td>
<td align="center"><code>$\vDash$</code></td>
<td align="center">$\star$</td>
<td align="center"><code>$\star$</code></td>
</tr>
<tr>
<td align="center">$\ast$</td>
<td align="center"><code>$\ast$</code></td>
<td align="center">$\oplus$</td>
<td align="center"><code>$\oplus$</code></td>
</tr>
<tr>
<td align="center">$\circ$</td>
<td align="center"><code>$\circ$</code></td>
<td align="center">$\bullet$</td>
<td align="center"><code>$\bullet$</code></td>
</tr>
</tbody></table>
</blockquote>
</li>
<li><p><b>箭头符号：</b></p>
<blockquote>
<table>
<thead>
<tr>
<th align="center">显示</th>
<th align="center">命令</th>
<th align="center">显示</th>
<th align="center">命令</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\to$</td>
<td align="center"><code>$\to$</code></td>
<td align="center">$\rightarrow$</td>
<td align="center"><code>$\rightarrow$</code></td>
</tr>
<tr>
<td align="center">$\leftarrow$</td>
<td align="center"><code>$\leftarrow$</code></td>
<td align="center">$\Rightarrow$</td>
<td align="center"><code>$\Rightarrow$</code></td>
</tr>
<tr>
<td align="center">$\Leftarrow$</td>
<td align="center"><code>$\Leftarrow$</code></td>
<td align="center">$\mapsto$</td>
<td align="center"><code>$\mapsto$</code></td>
</tr>
<tr>
<td align="center">$\Uparrow$</td>
<td align="center"><code>$\Uparrow$</code></td>
<td align="center">$\uparrow$</td>
<td align="center"><code>$\uparrow$</code></td>
</tr>
<tr>
<td align="center">$\Downarrow$</td>
<td align="center"><code>$\Downarrow$</code></td>
<td align="center">$\downarrow$</td>
<td align="center"><code>$\downarrow$</code></td>
</tr>
</tbody></table>
</blockquote>
</li>
<li><p><b>运算符号</b></p>
<blockquote>
<table>
<thead>
<tr>
<th align="center">显示</th>
<th align="center">命令</th>
<th align="center">显示</th>
<th align="center">命令</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$+$</td>
<td align="center"><code>$+$</code></td>
<td align="center">$-$</td>
<td align="center"><code>$-$</code></td>
</tr>
<tr>
<td align="center">$\times$</td>
<td align="center"><code>$\times$</code></td>
<td align="center">$\div$</td>
<td align="center"><code>$\div$</code></td>
</tr>
<tr>
<td align="center">$\pm$</td>
<td align="center"><code>$\pm$</code></td>
<td align="center">$\mp$</td>
<td align="center"><code>$\mp$</code></td>
</tr>
<tr>
<td align="center">$\cdot$</td>
<td align="center"><code>$\cdot$</code></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
</blockquote>
</li>
<li><p><b>关系比较符号</b></p>
<blockquote>
<table>
<thead>
<tr>
<th align="center">显示</th>
<th align="center">命令</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\lt$</td>
<td align="center"><code>\lt</code></td>
</tr>
<tr>
<td align="center">$\gt$</td>
<td align="center"><code>\gt</code></td>
</tr>
<tr>
<td align="center">$\le$</td>
<td align="center"><code>\le</code></td>
</tr>
<tr>
<td align="center">$\ge$</td>
<td align="center"><code>\ge</code></td>
</tr>
<tr>
<td align="center">$\neq$</td>
<td align="center"><code>\neq</code></td>
</tr>
</tbody></table>
</blockquote>
</li>
<li><p><b>顶部符号</b></p>
<blockquote>
<table>
<thead>
<tr>
<th align="center">显示</th>
<th align="center">命令</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\hat x$</td>
<td align="center"><code>$\hat x$</code></td>
</tr>
<tr>
<td align="center">$\widehat {xy}$</td>
<td align="center"><code>$\widehat &#123;xy&#125;$</code></td>
</tr>
<tr>
<td align="center">$\overline {xyz}$</td>
<td align="center"><code>$\overline &#123;xyz&#125;$</code></td>
</tr>
<tr>
<td align="center">$\vec {ab}$</td>
<td align="center"><code>$\vec &#123;ab&#125;$</code>(最多两个字符)</td>
</tr>
<tr>
<td align="center">$\overrightarrow {abcd}$</td>
<td align="center"><code>$\overrightarrow &#123;abcd&#125;$</code></td>
</tr>
<tr>
<td align="center">$\dot a$</td>
<td align="center"><code>$\dot a$</code></td>
</tr>
<tr>
<td align="center">$\ddot a$</td>
<td align="center"><code>$\ddot a$</code></td>
</tr>
</tbody></table>
</blockquote>
</li>
</ul>
<h4 id="空格、绝对值等其他东西"><a href="#空格、绝对值等其他东西" class="headerlink" title="空格、绝对值等其他东西"></a><b>空格、绝对值等其他东西</b></h4><ul>
<li>一个空格：<blockquote>
<p><code>$a\ b$</code> -&gt; $a\ b$</p>
</blockquote>
</li>
<li>四个空格：<blockquote>
<p><code>$a\quad b$</code> -&gt; $a\quad b$</p>
</blockquote>
</li>
<li>绝对值：<blockquote>
<p><code>$\lvert x \rvert$</code> -&gt; $\lvert x \rvert$</p>
</blockquote>
</li>
<li>求向量的摸(范数)：<blockquote>
<p><code>$\lVert x \rVert$</code> -&gt; $\lVert x \rVert$</p>
</blockquote>
</li>
</ul>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a><b>矩阵</b></h3><h4 id="基本的语法"><a href="#基本的语法" class="headerlink" title="基本的语法"></a><b>基本的语法</b></h4><ul>
<li>起始标志begin{matrix}</li>
<li>结束标志end{matrix}</li>
<li>分行标记<code>\\\\</code></li>
<li>每个元素之间用<code>&amp;</code>分隔：</li>
<li>例如：<blockquote>
<p><code>$$\begin&#123;matrix&#125;</code><br><code>1&amp;2&amp;3\\\\</code><br><code>4&amp;5&amp;6\\\\</code><br><code>7&amp;8&amp;9\\\\</code><br><code>\end&#123;matrix&#125;$$</code></p>
<p>$$\begin{matrix}<br>1&amp;2&amp;3\\<br>4&amp;5&amp;6\\<br>7&amp;8&amp;9\\<br>\end{matrix}$$</p>
</blockquote>
</li>
</ul>
<h4 id="矩阵的边框"><a href="#矩阵的边框" class="headerlink" title="矩阵的边框"></a><b>矩阵的边框</b></h4><ul>
<li>只需将<code>matrix</code>换成下列词语就行了：<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">样式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">matrix</td>
<td align="center">无边框</td>
</tr>
<tr>
<td align="center">pmatrix</td>
<td align="center">小括号边框</td>
</tr>
<tr>
<td align="center">bmatrix</td>
<td align="center">中括号边框</td>
</tr>
<tr>
<td align="center">Bmatrix</td>
<td align="center">大括号边框</td>
</tr>
<tr>
<td align="center">vmatrix</td>
<td align="center">单竖线边框</td>
</tr>
<tr>
<td align="center">Vmatrix</td>
<td align="center">双竖线边框</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a><b>省略号</b></h4><ul>
<li>横省略号：<code>\cdots</code></li>
<li>竖省略号：<code>\vdots</code></li>
<li>斜省略号：<code>\ddots</code></li>
<li>如下列矩阵：<blockquote>
<p><code>$$\begin&#123;vmatrix&#125;</code><br><code>&#123;a_&#123;11&#125;&#125;&amp;&#123;a_&#123;12&#125;&#125;&amp;&#123;\cdots&#125;&amp;&#123;a_&#123;1n&#125;&#125;\\\\</code><br><code>&#123;a_&#123;21&#125;&#125;&amp;&#123;a_&#123;22&#125;&#125;&amp;&#123;\cdots&#125;&amp;&#123;a_&#123;2n&#125;&#125;\\\\</code><br><code>&#123;\vdots&#125;&amp;&#123;\vdots&#125;&amp;&#123;\ddots&#125;&amp;&#123;\vdots&#125;\\\\</code><br><code>&#123;a_&#123;m1&#125;&#125;&amp;&#123;a_&#123;m2&#125;&#125;&amp;&#123;\cdots&#125;&amp;&#123;a_&#123;mn&#125;&#125;\\\\</code><br><code>end&#123;vmatrix&#125;$$</code><br>(矩阵也分<code>$矩阵$</code>与<code>$$矩阵$$</code>)</p>
<p>$$\begin{vmatrix}<br>{a_{11}}&amp;{a_{12}}&amp;{\cdots}&amp;{a_{1n}}\\<br>{a_{21}}&amp;{a_{22}}&amp;{\cdots}&amp;{a_{2n}}\\<br>{\vdots}&amp;{\vdots}&amp;{\ddots}&amp;{\vdots}\\<br>{a_{m1}}&amp;{a_{m2}}&amp;{\cdots}&amp;{a_{mn}}\\<br>\end{vmatrix}$$</p>
</blockquote>
</li>
</ul>
<h4 id="方程组"><a href="#方程组" class="headerlink" title="方程组"></a><b>方程组</b></h4><ul>
<li><p>开始和结束都是<code>&#123;cases&#125;</code>声明</p>
</li>
<li><p>如：</p>
<blockquote>
<p><code>$$\begin&#123;cases&#125;</code><br><code>a_1x+b_1y+c_1z=d_1\\\\</code><br><code>a_2x+b_2y+c_2z=d_2\\\\</code><br><code>a_3x+b_3y+c_3z=d_3\\\\</code><br><code>\end&#123;cases&#125;$$</code></p>
<p>$$\begin{cases}<br>a_1x+b_1y+c_1z&#x3D;d_1\\<br>a_2x+b_2y+c_2z&#x3D;d_2\\<br>a_3x+b_3y+c_3z&#x3D;d_3\\<br>\end{cases}$$</p>
</blockquote>
</li>
<li><p>当然也可以在<code>\begin</code>前加一个函数式，如</p>
<blockquote>
<p><code>$$f(x)=\begin&#123;cases&#125;</code><br><code>a_1x+b_1y+c_1z=d_1\\\\</code><br><code>a_2x+b_2y+c_2z=d_2\\\\</code><br><code>a_3x+b_3y+c_3z=d_3\\\\</code><br><code>\end&#123;cases&#125;$$</code></p>
<p>$$f(x)&#x3D;\begin{cases}<br>a_1x+b_1y+c_1z&#x3D;d_1\\<br>a_2x+b_2y+c_2z&#x3D;d_2\\<br>a_3x+b_3y+c_3z&#x3D;d_3\\<br>\end{cases}$$</p>
</blockquote>
</li>
</ul>
<h4 id="阵列"><a href="#阵列" class="headerlink" title="阵列"></a><b>阵列</b></h4><ul>
<li>开始和结束都以<code>&#123;array&#125;</code>声明</li>
<li>对齐方式：在{array}后加{}逐行统一声明</li>
<li><b>左对齐：</b>1; <b>居中：</b>c; <b>右对齐：</b>r; <b>竖直线：</b>在声明对齐时，插入<code>|</code>建立竖直线; 水平线：<code>\hline</code><blockquote>
<p><code>$$\begin&#123;array&#125;&#123;c|111&#125;</code><br><code>&#123;any&#125;&amp;&#123;a&#125;&amp;&#123;b&#125;&amp;&#123;c&#125;\\</code><br><code>\hline</code><br><code>&#123;R_1&#125;&amp;&#123;c&#125;&amp;&#123;b&#125;&amp;&#123;a&#125;\\</code><br><code>&#123;R_2&#125;&amp;&#123;b&#125;&amp;&#123;c&#125;&amp;&#123;a&#125;\\</code><br><code>\end&#123;array&#125;$$</code></p>
<p>$$\begin{array}{c | 1 1 1 }<br>{any}&amp;{a}&amp;{b}&amp;{c}\\<br>\hline<br>{R_1}&amp;{c}&amp;{b}&amp;{a}\\<br>{R_2}&amp;{b}&amp;{c}&amp;{a}\\<br>\end{array}$$</p>
</blockquote>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a><b>其他</b></h3><h4 id="高亮显示："><a href="#高亮显示：" class="headerlink" title="高亮显示："></a><b>高亮显示：</b></h4><blockquote>
<p><code>\bbox</code>的使用：<br><b>例如：</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">$$ \bbox[yellow]</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">f</span>(x)=\omega x+b</span><br><span class="line">\qquad</span><br><span class="line">&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<p>$$ \bbox[yellow]<br>{<br>f(x)&#x3D;\omega x+b<br>\qquad<br>}<br>$$</p>
</blockquote>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown的语法（1）</title>
    <url>/2020/12/20/Markdown%E7%9A%84%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h3 id="什么是Markdown："><a href="#什么是Markdown：" class="headerlink" title="什么是Markdown："></a><b>什么是Markdown：</b></h3><blockquote>
<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。<br>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。<br>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。<br>Markdown 编写的文档后缀为 .md或 .markdown。</p>
</blockquote>
<h3 id="Markdown的应用"><a href="#Markdown的应用" class="headerlink" title="Markdown的应用"></a><b>Markdown的应用</b></h3><blockquote>
<p>Markdown 能被使用来撰写电子书，如：Gitbook。<br>当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。<br>例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。<br><del>(没错我就是复制过来的)</del></p>
</blockquote>
<h2 id="一、Markdown的标题"><a href="#一、Markdown的标题" class="headerlink" title="一、Markdown的标题"></a><b>一、Markdown的标题</b></h2><h4 id="1、使用-来表示不同的标题"><a href="#1、使用-来表示不同的标题" class="headerlink" title="1、使用#来表示不同的标题"></a>1、使用<code>#</code>来表示不同的标题</h4><h5 id="语法如下：（注意-后面有空格）"><a href="#语法如下：（注意-后面有空格）" class="headerlink" title="语法如下：（注意#后面有空格）"></a>语法如下：（注意#后面有空格）</h5><blockquote>
<p># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br><del>(好像有六级标题，但第六级标题与第五级标题差不多，所以就懒得写了)</del></p>
</blockquote>
<h5 id="效果如下："><a href="#效果如下：" class="headerlink" title="效果如下："></a>效果如下：</h5><blockquote>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5></blockquote>
<h4 id="2、使用-和-来表示不同的标题"><a href="#2、使用-和-来表示不同的标题" class="headerlink" title="2、使用=和-来表示不同的标题"></a>2、使用<code>=</code>和<code>-</code>来表示不同的标题</h4><h5 id="语法如下："><a href="#语法如下：" class="headerlink" title="语法如下："></a>语法如下：</h5><blockquote>
<p>这是一级标题<br>=&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>这是二级标题<br>-——–</p>
</blockquote>
<h5 id="效果如下：-1"><a href="#效果如下：-1" class="headerlink" title="效果如下："></a>效果如下：</h5><blockquote>
<h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2></blockquote>
<h2 id="二、Markdown的段落格式"><a href="#二、Markdown的段落格式" class="headerlink" title="二、Markdown的段落格式"></a><b>二、Markdown的段落格式</b></h2><h4 id="1、字体"><a href="#1、字体" class="headerlink" title="1、字体"></a>1、字体</h4><p>用<code>-</code>或<code>*</code>包裹要标注的文字<br>一个表示斜体<br>两个表示粗体<br>三个表示斜粗体</p>
<h5 id="具体语法如下："><a href="#具体语法如下：" class="headerlink" title="具体语法如下："></a>具体语法如下：</h5><blockquote>
<p>*文字* 或 _文字_<br>**文字** 或 __文字__<br>***文字*** 或 ___文字___</p>
</blockquote>
<h5 id="效果如下：-2"><a href="#效果如下：-2" class="headerlink" title="效果如下："></a>效果如下：</h5><blockquote>
<p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong>  <del>（说好的粗体字呢？？）</del><br><strong>粗体文本</strong><br><em><strong>粗斜体文本</strong></em><br><em><strong>粗斜体文本</strong></em></p>
</blockquote>
<h4 id="2、分割线"><a href="#2、分割线" class="headerlink" title="2、分割线"></a>2、分割线</h4><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<h5 id="具体语法："><a href="#具体语法：" class="headerlink" title="具体语法："></a>具体语法：</h5><blockquote>
<p>***<br>* * *<br>******<br>- - -<br>-——–</p>
</blockquote>
<h5 id="效果如下：-3"><a href="#效果如下：-3" class="headerlink" title="效果如下："></a>效果如下：</h5><blockquote>
<hr>
<hr>
<hr>
<hr>
</blockquote>
<h3 id="3、删除线"><a href="#3、删除线" class="headerlink" title="3、删除线"></a>3、删除线</h3><p>在文字两端加上两个波浪线<code>~~</code>即可</p>
<h5 id="具体语法：-1"><a href="#具体语法：-1" class="headerlink" title="具体语法："></a>具体语法：</h5><blockquote>
<p>啥东西都没有<br>~~啥东西都没有~~</p>
</blockquote>
<h5 id="效果如下：-4"><a href="#效果如下：-4" class="headerlink" title="效果如下："></a>效果如下：</h5><blockquote>
<p>啥东西都没有<br><del>啥东西都没有</del></p>
</blockquote>
<h3 id="4、下划线"><a href="#4、下划线" class="headerlink" title="4、下划线"></a>4、下划线</h3><p>下划线可以通过HTML的<code>&lt;u&gt;</code>标签来实现：</p>
<blockquote>
<p>&lt;u&gt;带下划线&lt;&#x2F;u&gt;</p>
</blockquote>
<h5 id="效果如下：-5"><a href="#效果如下：-5" class="headerlink" title="效果如下："></a>效果如下：</h5><blockquote>
<p><u>带下划线</u></p>
</blockquote>
<h3 id="5、脚注"><a href="#5、脚注" class="headerlink" title="5、脚注"></a>5、脚注</h3><p>Markdown 脚注的格式如下：</p>
<blockquote>
<p>创建一个[^脚注]<br>[^脚注]: 这是一个脚注</p>
</blockquote>
<h5 id="效果如下：-6"><a href="#效果如下：-6" class="headerlink" title="效果如下："></a>效果如下：</h5><blockquote>
<p>创建一个[^脚注]<br>[^脚注]: 这是一个脚注	<del>（可惜Hexo不支持脚注的实现）</del></p>
</blockquote>
<h2 id="三、Markdown列表"><a href="#三、Markdown列表" class="headerlink" title="三、Markdown列表"></a><b>三、Markdown列表</b></h2><h4 id="1、无序表"><a href="#1、无序表" class="headerlink" title="1、无序表"></a>1、无序表</h4><p>无序表使用星号<code>*</code>、加号<code>+</code>或者是减号<code>-</code>作为标记<b>（符号后面一定要有空格！）</b></p>
<h4 id="具体语法"><a href="#具体语法" class="headerlink" title="具体语法"></a>具体语法</h4><blockquote>
<p>* 第一项<br>* 第二项<br>* 第三项</p>
<p>+ 第一项<br>+ 第二项<br>+ 第三项</p>
<p>- 第一项<br>- 第二项<br>- 第三项</p>
</blockquote>
<h5 id="效果如下：-7"><a href="#效果如下：-7" class="headerlink" title="效果如下："></a>效果如下：</h5><blockquote>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
</blockquote>
<h4 id="2、有序列表"><a href="#2、有序列表" class="headerlink" title="2、有序列表"></a>2、有序列表</h4><p>有序列表使用数字加<code>.</code>来表示，如</p>
<blockquote>
<p>1. 第一项<br>2. 第二项<br>3. 第三项</p>
</blockquote>
<h5 id="效果如下：-8"><a href="#效果如下：-8" class="headerlink" title="效果如下："></a>效果如下：</h5><blockquote>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
</blockquote>
<h2 id="四、Markdown区块"><a href="#四、Markdown区块" class="headerlink" title="四、Markdown区块"></a><b>四、Markdown区块</b></h2><p>Markdown区块是在开头使用<code>&gt;</code>符号，然后紧跟一个空格，如：</p>
<blockquote>
<p>&gt; 区块引用<br>&gt; Markdown学习<br>&gt; 一直摸鱼</p>
</blockquote>
<h5 id="结果如下："><a href="#结果如下：" class="headerlink" title="结果如下："></a>结果如下：</h5><blockquote>
<p>区块引用<br>Markdown学习<br>一直摸鱼</p>
</blockquote>
<p>当然，区块也是可以嵌套的，<br>一个<code>&gt;</code>是最外层，两个为第一层嵌套，以此类推：</p>
<blockquote>
<p>&gt;最外层<br>&gt;&gt;第一层嵌套<br>&gt;&gt;&gt;第二层嵌套</p>
</blockquote>
<h5 id="结果如下：-1"><a href="#结果如下：-1" class="headerlink" title="结果如下："></a>结果如下：</h5><blockquote>
<p>最外层</p>
<blockquote>
<p>第一层嵌套</p>
<blockquote>
<p>第二层嵌套</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="五、Markdown代码"><a href="#五、Markdown代码" class="headerlink" title="五、Markdown代码"></a><b>五、Markdown代码</b></h2><p>如果是段落上的一个函数或片段的代码，可以用反引号（&#96;）将其包起来，如</p>
<blockquote>
<p>`printf()`函数</p>
</blockquote>
<h5 id="结果如下：-2"><a href="#结果如下：-2" class="headerlink" title="结果如下："></a>结果如下：</h5><blockquote>
<p><code>printf()</code>函数</p>
</blockquote>
<h5 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h5><p><del>代码区块可以使用<b>4个空格</b>或者一个<b>制表符(Tab键)</b>来表示:</del>	(太麻烦了)<br>(顺带提一下，这里加粗部分都是是直接用了html的语法)</p>
<p>当然也可以用(&#96;&#96;&#96;)包裹一段代码，并指定一种语言（也可以不指定）：</p>
<blockquote>
<p>```c++<br>int main()<br>{<br>  cout&lt;&lt;”Hello World!”&lt;&lt;endl;<br>}<br>```</p>
</blockquote>
<h5 id="效果如下：-9"><a href="#效果如下：-9" class="headerlink" title="效果如下："></a>效果如下：</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;Hello World!&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、Markdown链接"><a href="#六、Markdown链接" class="headerlink" title="六、Markdown链接"></a><b>六、Markdown链接</b></h2><p>链接使用方法如下：</p>
<blockquote>
<p>[链接名称](链接地址)<br>或者<br>&lt;链接地址&gt;</p>
</blockquote>
<p>用<code>[]()</code>来表示：</p>
<blockquote>
<p><b>例如：</b>这是一个链接[百度](<code>https://www.baidu.com</code>)<br><b>效果：</b>这是一个链接<a href="https://www.baidu.com/">百度</a></p>
</blockquote>
<p>直接使用链接地址：</p>
<blockquote>
<p><b>例如：</b><code>&lt;https://www.baidu.com&gt;</code><br><b>效果：</b><a href="https://www.baidu.com/">https://www.baidu.com</a></p>
</blockquote>
<p>当然也可以博客内文章之间的链接：</p>
<blockquote>
<p><b>例如：</b>转去另一篇[博客](\2021\01\01\Markdown的语法-续&#x2F;)<br><b>效果：</b>转去另一篇<a href="%5C2021%5C01%5C01%5CMarkdown%E7%9A%84%E8%AF%AD%E6%B3%95-%E7%BB%AD/">博客</a></p>
</blockquote>
<h4 id="高级链接"><a href="#高级链接" class="headerlink" title="高级链接"></a><del><b>高级链接</b></del></h4><p>(我不会！)	<del>(理直气壮)</del></p>
<h2 id="七、Markdown图片"><a href="#七、Markdown图片" class="headerlink" title="七、Markdown图片"></a><b>七、Markdown图片</b></h2><p>Markdown图片语法格式如下：</p>
<blockquote>
<p>![alt 属性文本](图片地址)	<br>![alt 属性文本](图片地址 “可选标题”)<br><b>（这个图片地址是要从服务器最开始的地址开始写起）</b></p>
</blockquote>
<blockquote>
<ul>
<li>开头一个感叹号 !</li>
<li>接着一个方括号，里面放上图片的替代文字</li>
<li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。</li>
</ul>
</blockquote>
<h5 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kano 的图片](/img/blog-background.jpg)</span><br><span class="line">![kano 的图片](/img/blog-background.jpg &quot;鹿乃！&quot;)</span><br></pre></td></tr></table></figure>
<p><a href="/img/blog-background.jpg">kano 的图片</a><br><img src="/img/blog-background.jpg" alt="kano 的图片" title="鹿乃！"></p>
<h2 id="八、Markdown表格"><a href="#八、Markdown表格" class="headerlink" title="八、Markdown表格"></a><b>八、Markdown表格</b></h2><p>Markdown 制作表格使用 <code>|</code> 来分隔不同的单元格，使用 <code>-</code> 来分隔表头和其他行。<br>语法格式如下：</p>
<blockquote>
<p>| 表头 | 表头 |<br>| --- | --- |<br>| 单元格 | 单元格 |<br>| 单元格 | 单元格 |</p>
</blockquote>
<h5 id="效果如下：-10"><a href="#效果如下：-10" class="headerlink" title="效果如下："></a>效果如下：</h5><blockquote>
<table>
<thead>
<tr>
<th>表头</th>
<th>表头</th>
</tr>
</thead>
<tbody><tr>
<td>单元格</td>
<td>单元格</td>
</tr>
<tr>
<td>单元格</td>
<td>单元格</td>
</tr>
</tbody></table>
</blockquote>
<p>当然也可以设置表格的<b>对齐方式</b>：</p>
<ul>
<li><code>-:</code>设置内容和标题栏居右对齐。</li>
<li><code>:-</code>设置内容和标题栏居左对齐。</li>
<li><code>:-:</code> 设置内容和标题栏居中对齐。</li>
</ul>
<h5 id="语法如下：-1"><a href="#语法如下：-1" class="headerlink" title="语法如下："></a>语法如下：</h5><blockquote>
<p>| 左对齐 | 右对齐 | 居中对齐 |<br>| :-----| ----: | :----: |<br>| 单元格 | 单元格 | 单元格 |<br>| 单元格 | 单元格 | 单元格 |</p>
</blockquote>
<h5 id="效果如下：-11"><a href="#效果如下：-11" class="headerlink" title="效果如下："></a>效果如下：</h5><blockquote>
<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="right">右对齐</th>
<th align="center">居中对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
<tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
</tbody></table>
<p><b>注意:</b>文字和表格最好隔开一行不然表格可能会失效。</p>
</blockquote>
<h2 id="九、拓展的东西"><a href="#九、拓展的东西" class="headerlink" title="九、拓展的东西"></a><b>九、拓展的东西</b></h2><h4 id="支持的-HTML-元素"><a href="#支持的-HTML-元素" class="headerlink" title="支持的 HTML 元素"></a><b>支持的 HTML 元素</b></h4><blockquote>
<p>目前支持的HTML元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等</p>
</blockquote>
<h4 id="转义"><a href="#转义" class="headerlink" title="转义"></a><b>转义</b></h4><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：<br>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p>
<blockquote>
<p>\  反斜杠<br>`  反引号<br>*  星号<br>_   下划线<br>{}  花括号<br>[]  方括号<br>()  小括号<br>#   井字号<br>+   加号<br>-   减号<br>.   英文句点<br>!   感叹号</p>
</blockquote>
<h4 id="改文字颜色与字体"><a href="#改文字颜色与字体" class="headerlink" title="改文字颜色与字体"></a><b>改文字颜色与字体</b></h4><p>要改变字体和颜色可以使用<b><font></b>标签<br>要改变字体大小可以用<b>size</b>属性<br>改变颜色的化要用<b>color</b>属性(支持十六进制)<br>改颜色的例子：</p>
<blockquote>
<p>&lt;font color&#x3D;blue&gt;我是蓝色&lt;&#x2F;font&gt;<br>&lt;font color&#x3D;#3366FF&gt;我是蓝色&lt;&#x2F;font&gt;</p>
</blockquote>
<p>样例如下：</p>
<blockquote>
<p><font color=blue>我是蓝色</font><br><font color=#3366FF>我是蓝色</font></p>
</blockquote>
<p>改字体大小的例子：</p>
<blockquote>
<p>&lt;font size&#x3D;5&gt;我是5号字体&#x2F;<font><br>&lt;font size&#x3D;6&gt;我是6号字体&#x2F;<font><br>&lt;font size&#x3D;7&gt;我是7号字体&#x2F;<font></p>
</blockquote>
<p>样例如下：</p>
<blockquote>
<p><font size=5>我是5号字体</font><br><font size=6>我是6号字体</font><br><font size=7>我是7号字体</font></p>
</blockquote>
<h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a><b>公式</b></h4><p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax(这玩意要手动开) 对数学公式进行渲染。如：<br>(详细情况见<a href="/2021/01/01/Mathjax%E7%9A%84%E5%AD%A6%E4%B9%A0/index.html">Mathjax的使用</a>这篇文章)</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab绘图语法</title>
    <url>/2021/03/05/Matlab%E7%BB%98%E5%9B%BE%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h4 id="二维平面绘图"><a href="#二维平面绘图" class="headerlink" title="二维平面绘图"></a><b>二维平面绘图</b></h4><blockquote>
<p><b>过程</b></p>
<blockquote>
<ul>
<li>设置x值</li>
<li>设置函数</li>
<li>建立一个figure幕布</li>
<li>绘制一个画图函数</li>
<li>给图取标题</li>
<li>给x轴，y轴取标签</li>
<li>修整图像(可选)</li>
</ul>
</blockquote>
<p><b>例子：</b> </p>
<blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = <span class="number">0</span>: <span class="number">0.01</span>: <span class="number">2</span>*<span class="built_in">pi</span>		<span class="comment">%设置x的取值，取x为0到2兀，间隔点为0.01</span></span><br><span class="line">y = <span class="built_in">sin</span>(x)			<span class="comment">%设置sin函数</span></span><br><span class="line"><span class="built_in">figure</span>			<span class="comment">%创建一个幕布</span></span><br><span class="line"><span class="built_in">plot</span>(x,y)			<span class="comment">%画图</span></span><br><span class="line">title(<span class="string">&#x27;y = sin(x)&#x27;</span>)		<span class="comment">%给图像命名</span></span><br><span class="line">xlabel(<span class="string">&#x27;x&#x27;</span>)			<span class="comment">%给x轴取名</span></span><br><span class="line">ylabel(<span class="string">&#x27;sin(x)&#x27;</span>)		<span class="comment">%给y轴取名</span></span><br><span class="line">xlim([<span class="number">0</span> <span class="number">2</span>*<span class="built_in">pi</span>])		<span class="comment">%修整图像</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><b>效果如下：</b></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/Matlab/%E4%BA%8C%E7%BB%B4%E5%9B%BE%E5%83%8F.jpg" alt="二维图像" title="二维图像"></p>
</blockquote>
<p><b>补充：</b>图像中线的颜色，线型，样本点的样式都可以自己定义。<br><b>例子：</b></p>
<blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = <span class="number">0</span>:<span class="number">0.01</span>:<span class="number">20</span></span><br><span class="line">y1 = <span class="number">200</span>*<span class="built_in">exp</span>(<span class="number">-0.05</span>*x).*<span class="built_in">sin</span>(x);</span><br><span class="line">y2 = <span class="number">0.8</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x).*<span class="built_in">sin</span>(<span class="number">10</span>*x);</span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">[AX,H1,H2] = plotyy(x,y1,x,y2,<span class="string">&#x27;plot&#x27;</span>);</span><br><span class="line">set(get(AX(<span class="number">1</span>),<span class="string">&#x27;Ylabel&#x27;</span>),<span class="string">&#x27;String&#x27;</span>,<span class="string">&#x27;Slow Decay&#x27;</span>)      <span class="comment">%设置y轴</span></span><br><span class="line">set(get(AX(<span class="number">2</span>),<span class="string">&#x27;Ylabel&#x27;</span>),<span class="string">&#x27;String&#x27;</span>,<span class="string">&#x27;Fast Decay&#x27;</span>)      <span class="comment">%设置y轴</span></span><br><span class="line">xlabel(<span class="string">&#x27;Time (\musec)&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Multiole Decay Rates&#x27;</span>)</span><br><span class="line">set(H1,<span class="string">&#x27;LineStyle&#x27;</span>,<span class="string">&#x27;--&#x27;</span>)            <span class="comment">%将H1线的风格改成虚线</span></span><br><span class="line">set(H2,<span class="string">&#x27;LineStyle&#x27;</span>,<span class="string">&#x27;:&#x27;</span>)             <span class="comment">%将H1线的风格改成点</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><b>效果如下：</b></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/Matlab/%E4%BA%8C%E7%BB%B4%E5%9B%BE%E5%83%8F-1.jpg" alt="二维图像" title="二维图像"></p>
</blockquote>
</blockquote>
<h4 id="三维立体绘图"><a href="#三维立体绘图" class="headerlink" title="三维立体绘图"></a><b>三维立体绘图</b></h4><blockquote>
<p>三维绘图与二维绘图大同小异。<br><b>例如：</b></p>
<blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">t = <span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">50</span>:<span class="number">10</span>*<span class="built_in">pi</span>;</span><br><span class="line"><span class="built_in">plot3</span>(<span class="built_in">sin</span>(t),<span class="built_in">cos</span>(t),t)      <span class="comment">%三维所以是plot3</span></span><br><span class="line">xlabel(<span class="string">&#x27;sin(t)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;cos(t)&#x27;</span>)</span><br><span class="line">zlabel(<span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">grid on                     <span class="comment">%开启网格</span></span><br><span class="line">axis square                 <span class="comment">%将图形正方形化</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><b>效果如下：</b></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/Matlab/%E4%B8%89%E7%BB%B4%E5%9B%BE%E5%83%8F.jpg" alt="三维图像" title="三维图像"></p>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab语法</title>
    <url>/2021/03/04/Matlab%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h4 id="一、界面介绍"><a href="#一、界面介绍" class="headerlink" title="一、界面介绍"></a><b>一、界面介绍</b></h4><blockquote>
<p><b>matlab软件界面：</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/Matlab/matlab%E7%95%8C%E9%9D%A2.png" alt="Matlab" title="界面"></p>
<ul>
<li>matlab一般包括两个窗口，一个是<b>编辑器窗口</b>,另一个是<b>命令行窗口</b>。</li>
<li>matlab与python一样也分<b>交互式编程</b>和<b>脚本式编程</b>。<br><b>交互式编程清屏命令：</b><blockquote>
<ul>
<li><code>clc</code>,清除命令行窗口的所有东西</li>
<li><code>clear all</code>,清除工作区中所有的变量</li>
<li><code>clear a</code>,清除工作区的a变量</li>
</ul>
</blockquote>
</li>
</ul>
<p><b>注释</b></p>
<ul>
<li><p>大段的注释<code>%% %%</code><br><b>如：</b></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%%e=3</span></span><br><span class="line"><span class="comment">%%</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>单行的注释<code>% </code><br><b>如：</b></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%这是注释</span></span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<h4 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a><b>二、数据类型</b></h4><blockquote>
<p>Matlab的数据类型包括<b>数字</b>、<b>字符与字符串</b>、<b>矩阵</b>、<b>元胞数组</b>和<b>结构体</b></p>
<ul>
<li><p><b>数字:</b></p>
<blockquote>
<p>Matlab中数字类型的变量可以类似与python中直接赋值</p>
<p><b>如，</b></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a=<span class="number">3</span></span><br><span class="line">b=<span class="number">1.2</span></span><br><span class="line">a+b</span><br></pre></td></tr></table></figure>
<p><b>结果：</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/Matlab/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E6%95%B0%E5%AD%97.jpg" alt="数字类型" title="数字"></p>
</blockquote>
</li>
<li><p><b>字符与字符串</b></p>
<blockquote>
<p>matlab中字符与字符串与C语言等赋值方法一致。</p>
<p><b>如，</b></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">s=<span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">abs</span>(s) <span class="comment">% 返回s的ascii值</span></span><br><span class="line">char(<span class="number">65</span>) <span class="comment">% 返回ascii为65的字符串</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">&#x27;这是一条字符串&#x27;</span></span><br><span class="line"><span class="built_in">length</span>(str) <span class="comment">% 返回str的长度（空格也算一个长度）</span></span><br></pre></td></tr></table></figure>
<p><b>结果：</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/Matlab/%E5%AD%97%E7%AC%A6.jpg" alt="字符类型" title="char"></p>
</blockquote>
</li>
<li><p><b>矩阵</b></p>
<blockquote>
<p>在Matlab中可以方便的对矩阵进行各种操作</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">2</span>; <span class="number">3</span> <span class="number">2</span> <span class="number">7</span>]</span><br><span class="line">B=A&#x27;		<span class="comment">% 对矩阵A求转置</span></span><br><span class="line">A(:)		<span class="comment">% 将矩阵A所有列合成一列</span></span><br><span class="line">D=inv(A)	<span class="comment">% 对方阵A求逆</span></span><br><span class="line">D*A		<span class="comment">% 矩阵相乘</span></span><br><span class="line"></span><br><span class="line">E= <span class="built_in">zeros</span>(<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>)             <span class="comment">% 创建一个3维的5行4列的全0矩阵</span></span><br><span class="line">E(:,:,<span class="number">1</span>) = <span class="built_in">rand</span>(<span class="number">5</span>,<span class="number">4</span>)        <span class="comment">% 创建一个0—1的5行4列的随机矩阵</span></span><br><span class="line">E(:,:,<span class="number">2</span>) = randi(<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>)     <span class="comment">% 创建一个小于6的5行4列的随机均匀分布整数矩阵</span></span><br><span class="line">E(:,:,<span class="number">3</span>) = <span class="built_in">randn</span>(<span class="number">5</span>,<span class="number">4</span>)       <span class="comment">% 创建一个5行4列的标准正态分布随机矩阵</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><b>元胞数组</b></p>
<blockquote>
<p>元胞数组是数组的一种,数据中可以有不同的数据类型，它类似于C语言中的结构体或C++中的对象，关键字为<code>cell</code>。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = cell(<span class="number">1</span>,<span class="number">6</span>)</span><br><span class="line">A&#123;<span class="number">2</span>&#125; = <span class="built_in">eye</span>(<span class="number">3</span>)       <span class="comment">% 生成一个3*3，对角线数值为1的矩阵</span></span><br><span class="line">A&#123;<span class="number">5</span>&#125; = <span class="built_in">magic</span>(<span class="number">5</span>)     <span class="comment">% 生成一个5阶幻方</span></span><br><span class="line">B = A&#123;<span class="number">5</span>&#125;            <span class="comment">% 幻方的行、列和斜线之和都相等</span></span><br></pre></td></tr></table></figure>
<p><b>运行结果</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/Matlab/%E5%85%83%E8%83%9E%E6%95%B0%E7%BB%84.jpg" alt="元胞数组" title="元胞数组"></p>
</blockquote>
</li>
<li><p><b>结构体</b> </p>
<blockquote>
<p>类似于python中的字典，关键字为<code>struct</code></p>
<p><b>如，</b></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">book = struct(<span class="string">&#x27;name&#x27;</span>,&#123;&#123;<span class="string">&#x27;Machine&#x27;</span>,<span class="string">&#x27;Learning&#x27;</span>&#125;&#125;,<span class="string">&#x27;price&#x27;</span>,[<span class="number">30</span>,<span class="number">40</span>])</span><br><span class="line">book.name           <span class="comment">% 取出结构体中的name项</span></span><br><span class="line">book.price          <span class="comment">% 取出结构体中的price项</span></span><br><span class="line">book.name(<span class="number">1</span>)        <span class="comment">% 取出name项的第一个，数据类型为cell</span></span><br><span class="line">book.name&#123;<span class="number">1</span>&#125;        <span class="comment">% 取出name项的第一个，数据类型为字符串</span></span><br></pre></td></tr></table></figure>
<p><b>运行结果：</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/Matlab/%E7%BB%93%E6%9E%84%E4%BD%93.jpg" alt="结构体" title="结构体"></p>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="三、矩阵操作"><a href="#三、矩阵操作" class="headerlink" title="三、矩阵操作"></a><b>三、矩阵操作</b></h4><blockquote>
<ul>
<li><b>矩阵的创建：</b><blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]	<span class="comment">% 空格分割，分号换行</span></span><br><span class="line">B = <span class="number">1</span>:<span class="number">2</span>:<span class="number">9</span>			<span class="comment">% 创建一个向量，该向量范围为1～9,步长为2</span></span><br></pre></td></tr></table></figure>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/Matlab/%E7%9F%A9%E9%98%B5%E6%93%8D%E4%BD%9C.jpg" alt="矩阵创建" title="矩阵创建"></p>
</blockquote>
</li>
</ul>
<blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">C = <span class="built_in">repmat</span>(B,<span class="number">3</span>,<span class="number">1</span>)		<span class="comment">%将矩阵B横向重复1次，纵向重复3次 </span></span><br><span class="line">D = <span class="built_in">ones</span>(<span class="number">2</span>, <span class="number">4</span>)		<span class="comment">%创建一个2行4列的全1矩阵</span></span><br></pre></td></tr></table></figure>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/Matlab/%E7%9F%A9%E9%98%B5%E6%93%8D%E4%BD%9C-2.jpg" alt="矩阵操作" title="矩阵操作"></p>
</blockquote>
<ul>
<li><p><b>矩阵的转置</b></p>
<blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>;<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line">B = A&#x27;</span><br></pre></td></tr></table></figure>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/Matlab/%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BD%AC%E7%BD%AE.jpg" alt="矩阵的转置" title="矩阵的转置"></p>
</blockquote>
</li>
<li><p><b>矩阵的逆</b></p>
<blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>;<span class="number">4</span> <span class="number">5</span> <span class="number">2</span>;<span class="number">3</span> <span class="number">2</span> <span class="number">7</span>]</span><br><span class="line">B = inv(A)</span><br></pre></td></tr></table></figure>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/Matlab/%E7%9F%A9%E9%98%B5%E7%9A%84%E9%80%86.jpg" alt="矩阵的逆" title="矩阵的逆"></p>
</blockquote>
</li>
<li><p><b>矩阵的运算</b></p>
<blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>; <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>]</span><br><span class="line">B = [<span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span>; <span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span>]</span><br><span class="line">A + B		<span class="comment">%矩阵相加</span></span><br><span class="line">A - B		<span class="comment">%矩阵相减</span></span><br><span class="line">A * B&#x27;		<span class="comment">%矩阵相乘</span></span><br><span class="line">A / B		<span class="comment">%相当于矩阵A乘以矩阵B的逆</span></span><br><span class="line">A .* B		<span class="comment">%矩阵中的对应项相乘</span></span><br><span class="line">A ./ B		<span class="comment">%矩阵中对应项相除</span></span><br></pre></td></tr></table></figure>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/Matlab/%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97-1.jpg" alt="矩阵运算" title="矩阵运算"><br><img src="/picture/%E5%AD%A6%E4%B9%A0/Matlab/%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97-2.jpg" alt="矩阵运算" title="矩阵运算"></p>
</blockquote>
</li>
<li><p><b>矩阵的下标</b></p>
<blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = <span class="built_in">magic</span>(<span class="number">5</span>)</span><br><span class="line">B = A(<span class="number">2</span>,<span class="number">3</span>)      <span class="comment">%取矩阵A中第2行第3列的数</span></span><br><span class="line">C = A(<span class="number">3</span>,:)      <span class="comment">%取矩阵A中第三行所有的数</span></span><br><span class="line">D = A(:,<span class="number">4</span>)      <span class="comment">%取矩阵A中第四列所有的数</span></span><br><span class="line">[m,n] = <span class="built_in">find</span>(A&gt;<span class="number">20</span>)      <span class="comment">%在矩阵A中找到大于20的数，并输出它的索引值</span></span><br></pre></td></tr></table></figure>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/Matlab/%E7%9F%A9%E9%98%B5%E4%B8%8B%E6%A0%87-1.jpg" alt="矩阵的下标" title="矩阵下标"><br><img src="/picture/%E5%AD%A6%E4%B9%A0/Matlab/%E7%9F%A9%E9%98%B5%E4%B8%8B%E6%A0%87-2.jpg" alt="矩阵的下标" title="矩阵下标"></p>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="Matlab简单语句"><a href="#Matlab简单语句" class="headerlink" title="Matlab简单语句"></a><b>Matlab简单语句</b></h4><blockquote>
<ul>
<li><p><b>循环语句：</b></p>
<blockquote>
<ul>
<li><p><b>for循环</b></p>
<blockquote>
<p><b>格式：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for 循环变量 = 初值: 步长: 终值（其中步长可以省略，默认为1）</span><br><span class="line">    执行语句（可以不止一条）</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p><b>例如：</b></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: <span class="number">1</span>: <span class="number">100</span></span><br><span class="line">    a=a+<span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><b>while循环</b></p>
<blockquote>
<p><b>格式：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while 条件表达式</span><br><span class="line">	  执行语句（可以不止一条）</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p><b>例如：</b></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> a&lt;<span class="number">10</span></span><br><span class="line">   a=a+<span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><b>分支语句：</b></p>
<blockquote>
<p><b>if…end语句</b></p>
<blockquote>
<p><b>格式：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if 表达式</span><br><span class="line">     执行语句</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p><b>例如：</b></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a=<span class="number">10</span></span><br><span class="line">b=<span class="number">20</span></span><br><span class="line"><span class="keyword">if</span> a&lt;b</span><br><span class="line">    <span class="string">&#x27;成立&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><b>if…else…end语句</b></p>
<blockquote>
<p><b>格式：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if 表达式</span><br><span class="line">     执行语句</span><br><span class="line">else</span><br><span class="line"> 执行语句</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p><b>例如：</b></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a=<span class="number">101</span></span><br><span class="line">b=<span class="number">20</span></span><br><span class="line"><span class="keyword">if</span> a&lt;b</span><br><span class="line">    <span class="string">&#x27;成立&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="string">&#x27;不成立&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><b>switch…case…end语句</b></p>
<blockquote>
<p><b>格式：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">switch 表达式（数值或字符串）</span><br><span class="line">	   case 数值或字符串1</span><br><span class="line">	执行语句1;</span><br><span class="line">	   case 数值或字符串2</span><br><span class="line">	执行语句2;	   </span><br><span class="line">       ...</span><br><span class="line">       otherwise</span><br><span class="line">		执行语句n</span><br><span class="line">end</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Numpy包</title>
    <url>/2021/04/19/Numpy%E5%8C%85/</url>
    <content><![CDATA[<h4 id="Numpy介绍"><a href="#Numpy介绍" class="headerlink" title="Numpy介绍"></a><b>Numpy介绍</b></h4><blockquote>
<ul>
<li>Numpy(Numerical Python)是Python语言的一个扩展程序库。</li>
<li>Numpy支持大量的维度数组与矩阵运算，同时也有大量的针对数组运算的数学函数库。</li>
</ul>
</blockquote>
<h4 id="Ndarray对象"><a href="#Ndarray对象" class="headerlink" title="Ndarray对象"></a><b>Ndarray对象</b></h4><blockquote>
<p>在Numpy中最重要的一个对象是，N维数组对象ndarray。<br>ndarray内部由以下内容组成：</p>
<blockquote>
<ul>
<li>一个指向数据的<b>指针</b>。</li>
<li>数据类型或dtype，描述在数组中的<b>固定大小值的格子</b>。</li>
<li>一个表示数组形状的元组，表示<b>各维度大小的元组</b>。</li>
<li>一个跨度元组，其中的整数指的是为了前进到当前维度下一个元素需要“跨过”的字节数。</li>
</ul>
</blockquote>
<p>创建一个ndarray只需调用Numpy的<b>array函数</b>即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.array(<span class="built_in">object</span>, dtype = <span class="literal">None</span>, copy = <span class="literal">True</span>, order = <span class="literal">None</span>, subok = <span class="literal">False</span>, ndmin = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><b>参数说明</b>：</p>
<blockquote>
<ul>
<li><code>object</code> $\quad \quad$数组或嵌套的数列，必选</li>
<li><code>dtype</code> $ \ \quad \quad $数组元素的数据类型，可选</li>
<li><code>copy</code> $ \ \ \quad \quad $对象是否需要复制，（默认为True），可选</li>
<li><code>order</code> $\ \quad \quad $创建数组的样式，C为行方向，F为列方向，A为任意方向（默认），可选</li>
<li><code>subok</code> $\ \quad \quad $默认返回一个与基类类型一致的数组（默认False），可选</li>
<li><code>ndmin</code> $\ \quad \quad $指定生成数组的最小维度，可选</li>
</ul>
</blockquote>
<p><b>例子：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=<span class="built_in">complex</span>, copy=<span class="literal">True</span>, order=<span class="literal">None</span>, subok=<span class="literal">False</span> ,ndmin=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>

<p><b>输出：</b></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[[<span class="number">1.</span>+<span class="number">0.j</span> <span class="number">2.</span>+<span class="number">0.j</span> <span class="number">3.</span>+<span class="number">0.j</span>]]]</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h4 id="Numpy数据类型"><a href="#Numpy数据类型" class="headerlink" title="Numpy数据类型"></a><b>Numpy数据类型</b></h4><blockquote>
<p>numpy支持的数据类型比Python自带的类型要多，基本上可以和C语言的数据类型对应上，下列为Numpy的基本数据类型</p>
<blockquote>
<ul>
<li><code>bool</code>$\quad$布尔型数据类型</li>
<li><code>int </code>$\quad$默认的整数类型</li>
<li><code>intc</code>$\quad$与C的int型</li>
<li><code>intp</code>$\quad$用于索引的整数类型</li>
<li><code>int8</code>$\quad$字节（-128 到 127）</li>
<li><code>int16</code>$\quad$字节（-32768 到 32767）</li>
<li><code>int32</code>$\quad$字节（-2147483648 到 2147483647）</li>
<li><code>int64</code>$\quad$字节（-9223372036854775808 到 9223372036854775807）</li>
<li><code>uint8</code>$\quad$无符号整数（0 到 255）</li>
<li><code>uint16</code>$\quad$无符号整数（0 到 65535）</li>
<li><code>uint32</code>$\quad$无符号整数（0 到 4294967295）</li>
<li><code>uint64</code>$\quad$无符号整数（0 到 18446744073709551615）</li>
<li><code>float</code>$\quad$ float64类型的简写</li>
<li><code>float16</code>$\quad$半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位</li>
<li><code>float32</code>$\quad$半精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位</li>
<li><code>float64</code>$\quad$半精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位</li>
<li><code>complex</code>$\quad$ complex128 类型的简写，即 128 位复数</li>
<li><code>complex64</code>$\quad$ 复数，表示双 32 位浮点数（实数部分和虚数部分）</li>
<li><code>complex128</code>$\quad$ 复数，表示双 64 位浮点数（实数部分和虚数部分）</li>
</ul>
</blockquote>
<p><b>注：</b>其实就是<code>bool</code>、<code>int</code>、<code>uint</code>、<code>float</code>和<code>complex</code>这几类数据。</p>
<p><b>例子：</b><br>通过设置<code>dtype</code>，让生成的数组中的元素为浮点型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr = np.array(a, dtype=np.<span class="built_in">float</span>)</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="built_in">print</span>(arr.itemsize)</span><br></pre></td></tr></table></figure>

<p><b>输出：</b></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>]</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="Numpy数组的属性"><a href="#Numpy数组的属性" class="headerlink" title="Numpy数组的属性"></a><b>Numpy数组的属性</b></h4><blockquote>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>np.ndim</code></td>
<td align="center">返回数组对象的维度</td>
</tr>
<tr>
<td align="center"><code>np.shape</code></td>
<td align="center">返回数组对象的大小，如,一个n行m列的矩阵，返回(n,m)</td>
</tr>
<tr>
<td align="center"><code>np.size</code></td>
<td align="center">返回数组对象的个数</td>
</tr>
<tr>
<td align="center"><code>np.dtype</code></td>
<td align="center">返回数组对象的数据类型</td>
</tr>
<tr>
<td align="center"><code>np.itemsize</code></td>
<td align="center">以字节为单位，返回数组对象的字节数</td>
</tr>
</tbody></table>
<p><b>例子：</b></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">arr = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(arr.shape)    <span class="comment"># 输出矩阵为n行m列</span></span><br><span class="line">brr = arr.reshape(<span class="number">3</span>, <span class="number">2</span>)     <span class="comment"># 将矩阵改成3行2列的形式</span></span><br><span class="line"><span class="built_in">print</span>(brr)</span><br><span class="line"><span class="built_in">print</span>(arr.size)     <span class="comment"># 输出矩阵的元素个数</span></span><br><span class="line"><span class="built_in">print</span>(arr.dtype)    <span class="comment"># 输出矩阵元素的数据类型</span></span><br><span class="line"><span class="built_in">print</span>(arr.ndim)     <span class="comment"># 输出矩阵的维度</span></span><br><span class="line"><span class="built_in">print</span>(arr.itemsize) <span class="comment"># 输出矩阵元素大小</span></span><br></pre></td></tr></table></figure>

<p><b>输出：</b></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt; (<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&gt;&gt; [[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line">&gt;&gt; [<span class="number">3</span> <span class="number">4</span>]</span><br><span class="line">&gt;&gt; [<span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line">&gt;&gt; <span class="number">6</span></span><br><span class="line">&gt;&gt; int32</span><br><span class="line">&gt;&gt; <span class="number">2</span></span><br><span class="line">&gt;&gt; <span class="number">4</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="Numpy常用的创建函数"><a href="#Numpy常用的创建函数" class="headerlink" title="Numpy常用的创建函数"></a><b>Numpy常用的创建函数</b></h4><blockquote>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>np.ones((m:n),dtype)</code></td>
<td align="center">生成m行n列全1的矩阵数组（需要指明数据类型dtype）</td>
</tr>
<tr>
<td align="center"><code>np.ones_like(a)</code></td>
<td align="center">生成数组a形状的全1数组</td>
</tr>
<tr>
<td align="center"><code>np.zeros((m:n),dtype)</code></td>
<td align="center">生成m行n列全0的矩阵数组(需要指明数据类型dtype)</td>
</tr>
<tr>
<td align="center"><code>np.ones_zeros(a)</code></td>
<td align="center">生成数组a形状的全0数组</td>
</tr>
<tr>
<td align="center"><code>np.full((m,n),val)</code></td>
<td align="center">生成m行n列，值为val的矩阵数组</td>
</tr>
<tr>
<td align="center"><code>np.full_like(a,val)</code></td>
<td align="center">生成数组a形状，值为val的矩阵数组</td>
</tr>
<tr>
<td align="center"><code>np.eye(n)</code></td>
<td align="center">生成n阶单位矩阵</td>
</tr>
<tr>
<td align="center"><code>np.diag([a])</code></td>
<td align="center">生成以a值为主对角线，其他值为0的矩阵数组（存在问题，不建议使用）</td>
</tr>
<tr>
<td align="center"><code>np.linspace(start,end,num)</code></td>
<td align="center">生成等间距排列的num个元素对象的数组（从start开始到end结束）</td>
</tr>
</tbody></table>
<p><b>例子：</b></p>
<ul>
<li><p><b>全1矩阵</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = np.array([[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>]])</span><br><span class="line">a = np.ones((<span class="number">3</span>,<span class="number">4</span>),<span class="built_in">int</span>)      <span class="comment"># 生成一个3行4列的全1矩阵</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">c = np.ones_like(b)         <span class="comment"># 生成一个b一样的全1矩阵</span></span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">[[<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><b>全0矩阵</b></p>
<blockquote>
<p>全0矩阵与全1矩阵相类似，因此在这里不重复实现了</p>
</blockquote>
</li>
<li><p><b>全矩阵</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = np.array([[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>]])</span><br><span class="line">a = np.full((<span class="number">3</span>,<span class="number">4</span>),<span class="number">6</span>)    <span class="comment"># 生成全为6的3行4列矩阵</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">c = np.full_like(b,<span class="number">7</span>)   <span class="comment"># 生成与b一样的全7矩阵</span></span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[<span class="number">6</span> <span class="number">6</span> <span class="number">6</span> <span class="number">6</span>]</span><br><span class="line">[<span class="number">6</span> <span class="number">6</span> <span class="number">6</span> <span class="number">6</span>]</span><br><span class="line">[<span class="number">6</span> <span class="number">6</span> <span class="number">6</span> <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line">[[<span class="number">7</span>]</span><br><span class="line">[<span class="number">7</span>]</span><br><span class="line">[<span class="number">7</span>]]</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><b>单位阵</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.eye(<span class="number">5</span>)   <span class="comment"># 生成5阶单位矩阵</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[<span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line">[<span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line">[<span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line">[<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span>]</span><br><span class="line">[<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span>]]</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><b>线性数组</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.linspace(<span class="number">1</span>,<span class="number">19</span>,<span class="number">10</span>)     <span class="comment"># 生成一个线性数组</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1.</span>  <span class="number">3.</span>  <span class="number">5.</span>  <span class="number">7.</span>  <span class="number">9.</span> <span class="number">11.</span> <span class="number">13.</span> <span class="number">15.</span> <span class="number">17.</span> <span class="number">19.</span>]</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas包</title>
    <url>/2021/04/24/Pandas%E5%8C%85/</url>
    <content><![CDATA[<h4 id="Pandas介绍"><a href="#Pandas介绍" class="headerlink" title="Pandas介绍"></a><b>Pandas介绍</b></h4><blockquote>
<ul>
<li>Pandas库主要是面向二位数据分析的第三方库。</li>
<li>他被广泛运用于数据的清洗、切片等相关数据及分析前数据的准备等方面。</li>
<li>Pandas库的数据结构是以Series（一维数组）为核心，通过其定义的索引构建二维数据框架DataFrame，然后通过该框架对数据进行一系列的检索、清洗、切片等。</li>
<li>Pandas库中的Series能自定义索引index，使之形成二维结构，然后通过索引index来访问数组中的数据。</li>
</ul>
</blockquote>
<h4 id="创建Series"><a href="#创建Series" class="headerlink" title="创建Series"></a><b>创建Series</b></h4><blockquote>
<p>在使用Pandas库之前，必须先创建一个一维数组Series，其语法为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_series = pd.Series(data,index)</span><br></pre></td></tr></table></figure>
<p>其中第一个参数<code>data</code>必须存在，它可以是任何的数据对象。<br>而第二个参数<code>index</code>是可选的，它是<code>data</code>的一个索引而已。<br><b>例子：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">name = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]</span><br><span class="line"><span class="built_in">id</span> = [<span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>]</span><br><span class="line">tb = pd.Series(name, <span class="built_in">id</span>)</span><br><span class="line"><span class="built_in">print</span>(tb)</span><br></pre></td></tr></table></figure>
<p><b>输出：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">101    A</span><br><span class="line">102    B</span><br><span class="line">103    C</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>
</blockquote>
<p><b>补充：</b>从Python的字典对象创建Series时，Pandas会自动把字典的key值设置为Series中的index，把字典中的values值放在Series对应index的data内。</p>
</blockquote>
<h4 id="DataFrame的构造"><a href="#DataFrame的构造" class="headerlink" title="DataFrame的构造"></a><b>DataFrame的构造</b></h4><blockquote>
<ul>
<li><p>Pandas中DataFrame是二维数据结构。</p>
</li>
<li><p>其内的数据常用表格形式来存储。</p>
</li>
<li><p>使用DataFrame的数据结构，可以进行常见的操作，如选取、替换、删除行或列的数据，亦或者是重构表的结构、修改索引、多重筛选等。<br>构建DataFrame的语法为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DF = pd.DataFrame(data,index,columns)</span><br></pre></td></tr></table></figure>
<p>其中<code>data</code>为数据本体（必须存在），<code>index</code>为索引值（可选），<code>columns</code>为列名（可选）<br><b>例子：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">arr = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line">DF = pd.DataFrame(arr, index=[<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>],columns=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(DF)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    a  b  c</span><br><span class="line">20  1  2  4</span><br><span class="line">30  4  5  6</span><br><span class="line">40  7  8  9</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>当然DataFrame也可以用字典类型的数据来创建</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">s1 = pd.Series([<span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>, <span class="number">104</span>])</span><br><span class="line">s2 = pd.Series([<span class="string">&#x27;Alex&#x27;</span>, <span class="string">&#x27;Peter&#x27;</span>, <span class="string">&#x27;Lisa&#x27;</span>])</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&quot;id&quot;</span> :s1, <span class="string">&quot;name&quot;</span>:s2&#125;)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   id   name</span><br><span class="line">0  101   Alex</span><br><span class="line">1  102  Peter</span><br><span class="line">2  103   Lisa</span><br><span class="line">3  104    NaN</span><br></pre></td></tr></table></figure>
<p><b>补充：</b>值得注意的是，在DataFrame中，如果缺少某个数据，系统会自动用<code>NaN</code>来替代空值。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="DataFrame的基本操作"><a href="#DataFrame的基本操作" class="headerlink" title="DataFrame的基本操作"></a><b>DataFrame的基本操作</b></h4><h5 id="获取列或行"><a href="#获取列或行" class="headerlink" title="获取列或行"></a><b>获取列或行</b></h5><blockquote>
<ul>
<li>在DataFrame中，要获取列通常使用切片的方法</li>
<li>如果需要获取行的数据则需要使用<code>.loc</code>或<code>iloc</code>方法<blockquote>
<p><code>.loc</code>与<code>.iloc</code>的最大区别：<code>iloc</code>是基于位置（必须整数型）进行搜索，<code>loc</code>基于索引的标签（可以整数也可以是字符型）进行搜索。</p>
</blockquote>
</li>
</ul>
<p><b>例子：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">s1 = pd.Series([<span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>, <span class="number">104</span>])</span><br><span class="line">s2 = pd.Series([<span class="string">&#x27;Alex&#x27;</span>, <span class="string">&#x27;Peter&#x27;</span>, <span class="string">&#x27;Lisa&#x27;</span>])</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&quot;id&quot;</span>:s1, <span class="string">&quot;name&quot;</span>:s2&#125;)</span><br><span class="line"><span class="built_in">print</span>(df[<span class="string">&#x27;name&#x27;</span>])   <span class="comment"># 查找名字那一列数据</span></span><br><span class="line"><span class="built_in">print</span>(df.loc[<span class="number">1</span>])    <span class="comment"># 查找索引值为1的那行</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0     Alex</span><br><span class="line">1    Peter</span><br><span class="line">2     Lisa</span><br><span class="line">3      NaN</span><br><span class="line">Name: name, dtype: object</span><br><span class="line"></span><br><span class="line">id        102</span><br><span class="line">name    Peter</span><br><span class="line">Name: 1, dtype: object</span><br></pre></td></tr></table></figure>
<p><b>注意：</b>对于上面这个例子的DataFrame，我没有设置索引值，<code>[101, 102, 103, 104]</code>是数据的一部分，不是索引值。</p>
</blockquote>
</blockquote>
<h5 id="增加行-列"><a href="#增加行-列" class="headerlink" title="增加行&#x2F;列"></a><b>增加行&#x2F;列</b></h5><blockquote>
<ul>
<li>新添加一列的操作为：直接在原有的DataFrame基础上添加</li>
<li>新添加一行的操作为：使用<code>.loc</code>进行添加<br><b>例子：</b><blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">s1 = pd.Series([<span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>, <span class="number">104</span>])</span><br><span class="line">s2 = pd.Series([<span class="string">&#x27;Alex&#x27;</span>, <span class="string">&#x27;Peter&#x27;</span>, <span class="string">&#x27;Lisa&#x27;</span>])</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&quot;id&quot;</span>:s1, <span class="string">&quot;name&quot;</span>:s2&#125;,index=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">df[<span class="string">&#x27;birth&#x27;</span>] = pd.Series([<span class="string">&#x27;19990102&#x27;</span>, <span class="string">&#x27;20001011&#x27;</span>, <span class="string">&#x27;20000506&#x27;</span>])       <span class="comment"># 新添加列</span></span><br><span class="line">df.loc[<span class="string">&#x27;4&#x27;</span>] = [<span class="number">105</span>,<span class="string">&#x27;Alina&#x27;</span>,<span class="string">&#x27;19991211&#x27;</span>]         <span class="comment"># 新添加一行</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   id   name     birth</span><br><span class="line">1  102  Peter  20001011</span><br><span class="line">2  103   Lisa  20000506</span><br><span class="line">3  104    NaN       NaN</span><br><span class="line">4  105  Alina  19991211</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</blockquote>
<h5 id="数据的筛选"><a href="#数据的筛选" class="headerlink" title="数据的筛选"></a><b>数据的筛选</b></h5><blockquote>
<p>在Pandas中可以对数据的任何一行或一列进行表达式的筛选。<br><b>例子：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">4</span>,<span class="number">3</span>),[<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;three&#x27;</span>,<span class="string">&#x27;four&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(df.loc[<span class="string">&#x27;one&#x27;</span>]&gt;<span class="number">0.5</span>)        <span class="comment"># 对第一行的数据进行筛选</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">             0         1         2</span><br><span class="line">one    0.085626  0.291507  0.621788</span><br><span class="line">two    0.273505  0.441954  0.061773</span><br><span class="line">three  0.638026  0.294578  0.819607</span><br><span class="line">four   0.257750  0.563129  0.833397</span><br><span class="line"></span><br><span class="line">0    False</span><br><span class="line">1    False</span><br><span class="line">2     True</span><br></pre></td></tr></table></figure>
<p><b>注意：</b>筛选只会对数据进行<code>False</code>和<code>True</code>的判断。</p>
</blockquote>
</blockquote>
<h5 id="删除行-列"><a href="#删除行-列" class="headerlink" title="删除行&#x2F;列"></a><b>删除行&#x2F;列</b></h5><blockquote>
<ul>
<li>Pandas中的删除操作主要用到<code>.drop()</code>函数。</li>
<li>要注意的是<code>.drop()</code>函数既可以删除行也可以删除列，默认为删除行，如果要删除列则需要对函数内<code>axis</code>这一变量改成1。<br><b>例子：</b><blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">4</span>,<span class="number">3</span>),[<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;three&#x27;</span>,<span class="string">&#x27;four&#x27;</span>],[<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(df.drop(<span class="string">&#x27;one&#x27;</span>))       <span class="comment"># 删除one这一行</span></span><br><span class="line"><span class="built_in">print</span>(df.drop(<span class="string">&#x27;1&#x27;</span>,axis=<span class="number">1</span>))  <span class="comment"># 删除1这一列</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">             1         2         3</span><br><span class="line">one    0.383043  0.690688  0.878634</span><br><span class="line">two    0.627987  0.863513  0.573880</span><br><span class="line">three  0.317966  0.795148  0.379909</span><br><span class="line">four   0.198166  0.202716  0.906900</span><br><span class="line"></span><br><span class="line">             1         2         3</span><br><span class="line">two    0.627987  0.863513  0.573880</span><br><span class="line">three  0.317966  0.795148  0.379909</span><br><span class="line">four   0.198166  0.202716  0.906900</span><br><span class="line"></span><br><span class="line">             2         3</span><br><span class="line">one    0.690688  0.878634</span><br><span class="line">two    0.863513  0.573880</span><br><span class="line">three  0.795148  0.379909</span><br><span class="line">four   0.202716  0.906900</span><br><span class="line"></span><br><span class="line">             1         2         3</span><br><span class="line">one    0.383043  0.690688  0.878634</span><br><span class="line">two    0.627987  0.863513  0.573880</span><br><span class="line">three  0.317966  0.795148  0.379909</span><br><span class="line">four   0.198166  0.202716  0.906900</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<p><b>注意：</b>单纯使用<code>.drop()</code>函数是无法对原来的DataFrame对象进行删除，如果要对原来的对象进行删除，则需要将函数内的<code>inplace</code>修改为<code>True</code><br><b>例子：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">4</span>,<span class="number">3</span>),[<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;three&#x27;</span>,<span class="string">&#x27;four&#x27;</span>],[<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line">df.drop(<span class="string">&#x27;one&#x27;</span>,inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">             1         2         3</span><br><span class="line">one    0.573584  0.608141  0.479227</span><br><span class="line">two    0.624102  0.986326  0.202363</span><br><span class="line">three  0.126534  0.401310  0.187309</span><br><span class="line">four   0.617479  0.313356  0.231538</span><br><span class="line"></span><br><span class="line">             1         2         3</span><br><span class="line">two    0.624102  0.986326  0.202363</span><br><span class="line">three  0.126534  0.401310  0.187309</span><br><span class="line">four   0.617479  0.313356  0.231538</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h5 id="重置索引"><a href="#重置索引" class="headerlink" title="重置索引"></a><b>重置索引</b></h5><blockquote>
<p>有时候需要方便的定位，需要重置索引（恢复成由0开始的整数索引），这是可以用<code>reset_index()</code>函数，与删除的同理，如果要在原数据的基础上重置索引，则需要加上<code>inplace=True</code>。<br><b>例子：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">4</span>,<span class="number">3</span>),[<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;three&#x27;</span>,<span class="string">&#x27;four&#x27;</span>],[<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line">df.reset_index(inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">             1         2         3</span><br><span class="line">one    0.681956  0.055052  0.723009</span><br><span class="line">two    0.167769  0.608805  0.750459</span><br><span class="line">three  0.907047  0.338093  0.828860</span><br><span class="line">four   0.265728  0.633751  0.435069</span><br><span class="line"></span><br><span class="line">  index         1         2         3</span><br><span class="line">0    one  0.681956  0.055052  0.723009</span><br><span class="line">1    two  0.167769  0.608805  0.750459</span><br><span class="line">2  three  0.907047  0.338093  0.828860</span><br><span class="line">3   four  0.265728  0.633751  0.435069</span><br></pre></td></tr></table></figure>
</blockquote>
<p>当然除了重置默认的索引，Pandas也可以重新设置索引：<br><b>例子：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">4</span>,<span class="number">3</span>),[<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;three&#x27;</span>,<span class="string">&#x27;four&#x27;</span>],[<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line">df[<span class="string">&#x27;new_index&#x27;</span>] = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>]</span><br><span class="line">df.set_index(<span class="string">&#x27;new_index&#x27;</span>,inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">             1         2         3</span><br><span class="line">one    0.904210  0.158044  0.699409</span><br><span class="line">two    0.108463  0.598657  0.747665</span><br><span class="line">three  0.777337  0.577440  0.738239</span><br><span class="line">four   0.562839  0.950309  0.274281</span><br><span class="line"></span><br><span class="line">                 1         2         3</span><br><span class="line">new_index                              </span><br><span class="line">A          0.904210  0.158044  0.699409</span><br><span class="line">B          0.108463  0.598657  0.747665</span><br><span class="line">C          0.777337  0.577440  0.738239</span><br><span class="line">D          0.562839  0.950309  0.274281</span><br></pre></td></tr></table></figure>
<p><b>补充：</b>与<code>reset_index()</code>一样，如果不加<code>inplace=True</code>就无法在原数据上修改</p>
</blockquote>
</blockquote>
<h5 id="填充和删除重复行"><a href="#填充和删除重复行" class="headerlink" title="填充和删除重复行"></a><b>填充和删除重复行</b></h5><blockquote>
<p>对于一个原始数据集，有时我们可能会遇到数值缺失的情况，因此我们需要<code>dropna()</code>和<code>fillna()</code>对其进行操作。<br><b>删除：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d1 = pd.Series([<span class="number">101</span>,<span class="number">102</span>,<span class="number">103</span>,<span class="number">104</span>])</span><br><span class="line">d2 = pd.Series([<span class="string">&#x27;Alex&#x27;</span>,<span class="string">&#x27;Peter&#x27;</span>,<span class="string">&#x27;Lisa&#x27;</span>])</span><br><span class="line">d3 = pd.Series([<span class="number">2000</span>,<span class="number">3000</span>])</span><br><span class="line">d4 = pd.Series([])</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;id&#x27;</span>:d1, <span class="string">&#x27;name&#x27;</span>:d2, <span class="string">&#x27;salary&#x27;</span>:d3, <span class="string">&#x27;age&#x27;</span>:d4&#125;)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.dropna())          <span class="comment"># 删除有空值的那一行</span></span><br><span class="line"><span class="built_in">print</span>(df.dropna(axis=<span class="number">1</span>))    <span class="comment"># 删除有空值的那一列</span></span><br><span class="line"><span class="built_in">print</span>(df.dropna(axis=<span class="number">1</span>, how=<span class="string">&#x27;all&#x27;</span>))     <span class="comment"># 删除全是空值的那一列</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   id   name  salary  age</span><br><span class="line">0  101   Alex  2000.0  NaN</span><br><span class="line">1  102  Peter  3000.0  NaN</span><br><span class="line">2  103   Lisa     NaN  NaN</span><br><span class="line">3  104    NaN     NaN  NaN</span><br><span class="line"></span><br><span class="line">Empty DataFrame</span><br><span class="line">Columns: [id, name, salary, age]</span><br><span class="line">Index: []</span><br><span class="line"></span><br><span class="line">   id</span><br><span class="line">0  101</span><br><span class="line">1  102</span><br><span class="line">2  103</span><br><span class="line">3  104</span><br><span class="line"></span><br><span class="line">   id   name  salary</span><br><span class="line">0  101   Alex  2000.0</span><br><span class="line">1  102  Peter  3000.0</span><br><span class="line">2  103   Lisa     NaN</span><br><span class="line">3  104    NaN     NaN</span><br></pre></td></tr></table></figure>
</blockquote>
<p><b>注释：</b></p>
<blockquote>
<ul>
<li>删除也和上面的操作类似，不加<code>inplace=True</code>就无法对元数据进行修改。</li>
<li>删除空值的函数默认为删除行，如果要删除列就需要在参数中加上<code>axis=1</code>。</li>
<li>在删除时，如果只想删除全部都是空值的行&#x2F;列，需要在参数中加上<code>how=&#39;all&#39;</code>。</li>
</ul>
</blockquote>
<p><b>填充：</b><br>在对空值进行处理时，除了删除操作，当然也包括填充操作<br><b>例子：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d1 = pd.Series([<span class="number">101</span>,<span class="number">102</span>,<span class="number">103</span>,<span class="number">104</span>])</span><br><span class="line">d2 = pd.Series([<span class="string">&#x27;Alex&#x27;</span>,<span class="string">&#x27;Peter&#x27;</span>,<span class="string">&#x27;Lisa&#x27;</span>])</span><br><span class="line">d3 = pd.Series([<span class="number">2000</span>,<span class="number">3000</span>])</span><br><span class="line">d4 = pd.Series([])</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;id&#x27;</span>:d1, <span class="string">&#x27;name&#x27;</span>:d2, <span class="string">&#x27;salary&#x27;</span>:d3, <span class="string">&#x27;age&#x27;</span>:d4&#125;)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.fillna(<span class="string">&#x27;missing&#x27;</span>))         <span class="comment"># 填充特定值</span></span><br><span class="line"><span class="built_in">print</span>(df.fillna(df.mean()))         <span class="comment"># 填充均值</span></span><br><span class="line"><span class="built_in">print</span>(df.fillna(method=<span class="string">&#x27;ffill&#x27;</span>,limit=<span class="number">1</span>))        <span class="comment"># method指定方式：向后填充且仅限一次</span></span><br><span class="line"><span class="built_in">print</span>(df.fillna(method=<span class="string">&#x27;pad&#x27;</span>))      <span class="comment"># 使用前一值填充，与上一方法类似</span></span><br><span class="line">df[<span class="string">&#x27;salary&#x27;</span>]=df[<span class="string">&#x27;salary&#x27;</span>].ffill()   <span class="comment"># 使用ffill()函数填充，类似method指定</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line">df1 = df.fillna(&#123;<span class="string">&#x27;age&#x27;</span>:<span class="number">0</span>&#125;)         <span class="comment"># 也可以直接指定某一列进行填充</span></span><br><span class="line"><span class="built_in">print</span>(df1)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   id   name  salary  age</span><br><span class="line">0  101   Alex  2000.0  NaN</span><br><span class="line">1  102  Peter  3000.0  NaN</span><br><span class="line">2  103   Lisa     NaN  NaN</span><br><span class="line">3  104    NaN     NaN  NaN</span><br><span class="line"></span><br><span class="line">   id     name   salary      age</span><br><span class="line">0  101     Alex     2000  missing</span><br><span class="line">1  102    Peter     3000  missing</span><br><span class="line">2  103     Lisa  missing  missing</span><br><span class="line">3  104  missing  missing  missing</span><br><span class="line"></span><br><span class="line">   id   name  salary  age</span><br><span class="line">0  101   Alex  2000.0  NaN</span><br><span class="line">1  102  Peter  3000.0  NaN</span><br><span class="line">2  103   Lisa  2500.0  NaN</span><br><span class="line">3  104    NaN  2500.0  NaN</span><br><span class="line"></span><br><span class="line">   id   name  salary  age</span><br><span class="line">0  101   Alex  2000.0  NaN</span><br><span class="line">1  102  Peter  3000.0  NaN</span><br><span class="line">2  103   Lisa  3000.0  NaN</span><br><span class="line">3  104   Lisa     NaN  NaN</span><br><span class="line"></span><br><span class="line">   id   name  salary  age</span><br><span class="line">0  101   Alex  2000.0  NaN</span><br><span class="line">1  102  Peter  3000.0  NaN</span><br><span class="line">2  103   Lisa  3000.0  NaN</span><br><span class="line">3  104   Lisa  3000.0  NaN</span><br><span class="line"></span><br><span class="line">   id   name  salary  age</span><br><span class="line">0  101   Alex  2000.0  NaN</span><br><span class="line">1  102  Peter  3000.0  NaN</span><br><span class="line">2  103   Lisa  3000.0  NaN</span><br><span class="line">3  104    NaN  3000.0  NaN</span><br><span class="line"></span><br><span class="line">   id   name  salary  age</span><br><span class="line">0  101   Alex  2000.0  0.0</span><br><span class="line">1  102  Peter  3000.0  0.0</span><br><span class="line">2  103   Lisa  3000.0  0.0</span><br><span class="line">3  104    NaN  3000.0  0.0</span><br></pre></td></tr></table></figure>
</blockquote>
<p><b>注释：</b></p>
<blockquote>
<ul>
<li>与上面的操作相同，填充操作除了<code>df[&#39;salary&#39;]=df[&#39;salary&#39;].ffill()</code>是直接对原数据进行修改，其他的如果要在原数据上修改，则需要在参数上加上<code>inplace=True</code>。</li>
<li><code>df.fillna(method=&#39;ffill&#39;,limit=1)</code>与<code>df.fillna(method=&#39;pad&#39;)</code>的执行效果是相同的，只是函数的参数不一样而已。</li>
<li>对于<code>df.fillna(method=&#39;ffill&#39;,limit=1)</code>中的<code>method</code>除了<code>ffill</code>以外，还有<code>bfill</code>是根据后面的值来填充。</li>
</ul>
</blockquote>
</blockquote>
<h5 id="运算及分组统计"><a href="#运算及分组统计" class="headerlink" title="运算及分组统计"></a><b>运算及分组统计</b></h5><blockquote>
<ul>
<li><p>在Pandas中非常容易做矩阵相关列表的运算<br><b>例子：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = pd.Series(np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))</span><br><span class="line">s2 = pd.Series(np.array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]))</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&quot;a&quot;</span>: s1, <span class="string">&quot;b&quot;</span>: s2&#125;)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(df.a.mean())          <span class="comment"># 求a列的均值</span></span><br><span class="line"><span class="built_in">print</span>(df.a.<span class="built_in">sum</span>())           <span class="comment"># 求a列之和</span></span><br><span class="line"><span class="built_in">print</span>(df.a.var())           <span class="comment"># 求a列的方差</span></span><br><span class="line"><span class="built_in">print</span>(df.a.std())           <span class="comment"># 求a列的标准差</span></span><br><span class="line"><span class="built_in">print</span>(df.a.<span class="built_in">max</span>())           <span class="comment"># 求a列的最大值</span></span><br><span class="line"><span class="built_in">print</span>(df.a.<span class="built_in">min</span>())           <span class="comment"># 求a列的最小值</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  a  b</span><br><span class="line">0  1  4</span><br><span class="line">1  2  5</span><br><span class="line">2  3  6</span><br><span class="line">3  4  7</span><br><span class="line">2.5</span><br><span class="line">10</span><br><span class="line">1.6666666666666667</span><br><span class="line">1.2909944487358056</span><br><span class="line">4</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>当然在Pandas中，还可以用<code>groupby()</code>函数对数据进行分组统计整理。<br><b>例子：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = pd.Series(np.array([<span class="string">&#x27;流浪星球&#x27;</span>,<span class="string">&#x27;新喜剧之王&#x27;</span>,<span class="string">&#x27;绿皮书&#x27;</span>,<span class="string">&#x27;流浪星球&#x27;</span>,<span class="string">&#x27;流浪星球&#x27;</span>,<span class="string">&#x27;新喜剧之王&#x27;</span>]))</span><br><span class="line">s2 = pd.Series(np.array([<span class="number">120000</span>, <span class="number">86000</span>,<span class="number">92000</span>,<span class="number">143000</span>,<span class="number">98000</span>,<span class="number">68000</span>]))</span><br><span class="line">s3 = pd.Series(pd.to_datetime([<span class="string">&#x27;20181203&#x27;</span>,<span class="string">&#x27;20181203&#x27;</span>,<span class="string">&#x27;20181205&#x27;</span>,<span class="string">&#x27;20181206&#x27;</span>,<span class="string">&#x27;20180207&#x27;</span>,<span class="string">&#x27;20181207&#x27;</span>]))</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;电影名&#x27;</span>:s1, <span class="string">&#x27;票房&#x27;</span>:s2, <span class="string">&#x27;日期&#x27;</span>:s3&#125;)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line">group = df.groupby(by=[<span class="string">&#x27;电影名&#x27;</span>])         <span class="comment"># 按名称进行分组</span></span><br><span class="line"><span class="built_in">print</span>(group.<span class="built_in">max</span>())          <span class="comment"># 按分组结果找出各组中最大的那个数据</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">电影名       票房    日期                     </span><br><span class="line">新喜剧之王   86000   2018-12-07</span><br><span class="line">流浪星球    143000  2018-12-06</span><br><span class="line">绿皮书      92000   2018-12-05</span><br></pre></td></tr></table></figure>
<p><b>补充：</b><code>df.groupby(by=[&#39;电影名&#39;])</code>可以将电影名相同的统计为一组，<code>group.max()</code>则是找出每组中的最大值。</p>
<ul>
<li><p>也可以在<code>groupby()</code>后直接加入运算函数进行各类统计，如以‘电影名’分组统计总票房。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.groupby([<span class="string">&#x27;电影名&#x27;</span>]).<span class="built_in">sum</span>())</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">电影名      票房</span><br><span class="line">新喜剧之王  154000</span><br><span class="line">流浪星球   361000</span><br><span class="line">绿皮书     92000</span><br></pre></td></tr></table></figure>
</li>
<li><p>在使用<code>groupby()</code>对数据集统计，可以在<code>groupby()</code>的参数内把对象罗列出来即可，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.groupby([<span class="string">&#x27;电影名&#x27;</span>,<span class="string">&#x27;日期&#x27;</span>]).median())</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">电影名     日期          票房     </span><br><span class="line">新喜剧之王 2018-12-03   86000</span><br><span class="line">        2018-12-07   68000</span><br><span class="line">流浪星球  2018-02-07   98000</span><br><span class="line">       2018-12-03   120000</span><br><span class="line">       2018-12-06   143000</span><br><span class="line">绿皮书   2018-12-05    92000</span><br></pre></td></tr></table></figure>
<p><b>补充：</b>上例是将数据按电影名和日期进行统计，从而将中位数排在中间。</p>
</li>
<li><p>如果相对数据集进行排序还可以用<code>sort_values()</code>或<code>sort_index()</code>函数对其进行排序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.sort_values(by=<span class="string">&#x27;票房&#x27;</span>, ascending=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    电影名      票房         日期</span><br><span class="line">5  新喜剧之王   68000 2018-12-07</span><br><span class="line">1  新喜剧之王   86000 2018-12-03</span><br><span class="line">2    绿皮书   92000 2018-12-05</span><br><span class="line">4   流浪星球   98000 2018-02-07</span><br><span class="line">0   流浪星球  120000 2018-12-03</span><br><span class="line">3   流浪星球  143000 2018-12-06</span><br></pre></td></tr></table></figure>
<p><b>补充：</b>其中，<code>by=</code>是指数据集按什么进行排序，<code>ascending=True</code>代表这个排序为由低到高，<code>False</code>为由高到低。</p>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h5 id="数据合并"><a href="#数据合并" class="headerlink" title="数据合并"></a><b>数据合并</b></h5><blockquote>
<p>对于将数据表内容连接起来的方法，Pandas提供了3个函数—<code>concat()</code>、<code>join()</code>和<code>merge()</code>。</p>
<ul>
<li><p><b>concat():</b></p>
<blockquote>
<p>基本语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.concat(objs, axis=<span class="number">0</span>, join=<span class="string">&#x27;outer&#x27;</span>, join_axes=<span class="literal">None</span>, ignore_index=<span class="literal">False</span>, keys=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>参数<code>objs</code>可以是‘series’、’DataFrame‘类型。</li>
<li>参数<code>axis</code>是指表合并轴的方向，默认值为0.0是指纵向的方式连接，1指横向的方式连接。</li>
<li>参数<code>join</code>是指连接的方式。默认值outer是指外连接，他得到的是两个表的并集，如果是inner则是内连接，得到的是两个表的交集。</li>
<li>参数<code>join_axes</code>是指根据指定的轴来连接数据（左连接或右连接）。<b>注意：</b>由于奇怪的原因，这个变量无法被识别。</li>
<li>参数<code>keys</code>是指根据指定的key值来标识数据源自那个表（类似多了一个index）<br><b>例子：</b><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1 = pd.DataFrame(np.full((<span class="number">3</span>, <span class="number">4</span>), <span class="number">2</span>), index=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>], columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df1)</span><br><span class="line">df2 = pd.DataFrame(np.full((<span class="number">3</span>, <span class="number">4</span>), <span class="number">6</span>), index=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;E&#x27;</span>], columns=[<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df2)</span><br><span class="line">df = pd.concat([df1, df2], sort=<span class="literal">False</span>)</span><br><span class="line">df3 = pd.concat([df1, df2],keys=[<span class="string">&#x27;df1&#x27;</span>,<span class="string">&#x27;df2&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(df3)</span><br></pre></td></tr></table></figure>
输出：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  a  b  c  d</span><br><span class="line">A  2  2  2  2</span><br><span class="line">B  2  2  2  2</span><br><span class="line">C  2  2  2  2</span><br><span class="line"></span><br><span class="line">  c  d  e  f</span><br><span class="line">A  6  6  6  6</span><br><span class="line">B  6  6  6  6</span><br><span class="line">E  6  6  6  6</span><br><span class="line"></span><br><span class="line">    a    b  c  d    e    f</span><br><span class="line">A  2.0  2.0  2  2  NaN  NaN</span><br><span class="line">B  2.0  2.0  2  2  NaN  NaN</span><br><span class="line">C  2.0  2.0  2  2  NaN  NaN</span><br><span class="line">A  NaN  NaN  6  6  6.0  6.0</span><br><span class="line">B  NaN  NaN  6  6  6.0  6.0</span><br><span class="line">E  NaN  NaN  6  6  6.0  6.0</span><br><span class="line"></span><br><span class="line">        a    b  c  d    e    f</span><br><span class="line">df1 A  2.0  2.0  2  2  NaN  NaN</span><br><span class="line">   B  2.0  2.0  2  2  NaN  NaN</span><br><span class="line">   C  2.0  2.0  2  2  NaN  NaN</span><br><span class="line">df2 A  NaN  NaN  6  6  6.0  6.0</span><br><span class="line">   B  NaN  NaN  6  6  6.0  6.0</span><br><span class="line">   E  NaN  NaN  6  6  6.0  6.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<b>注：</b><blockquote>
<ul>
<li>这里的<code>sort</code>是为了避免Pandas的一些奇怪的警告而添加的。</li>
<li><code>key</code>可以对来自不同的表进行建立新的索引。</li>
<li><code>axis</code>虽然在这里没写出来，但是直接在参数上加上就可以用了。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><b>merge():</b><br><code>merge()</code>函数的连接方式与<code>concat</code>不同，它是以类似数据合并的方式进行连接的，语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.merge(obj1, obj2, how=<span class="string">&#x27;inner&#x27;</span>, on=<span class="string">&#x27;key&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>obj1代表连接左侧的DataFrame;obj2代表连接右侧的DataFrame。</li>
<li>how代表连接方式，默认值为<code>innner</code>内连接（交集），可以设置为<code>outer</code>外连接（并集）；也可以设置为<code>left</code>,<code>right</code>分别为以左侧为轴连接（左连接），和右侧为轴连接（右连接）。</li>
<li>on&#x3D;’key’代表合并两者所在的列，表示以该列为基准进行合并<br><b>例子：</b><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_obj1 = pd.DataFrame(&#123;<span class="string">&#x27;y&#x27;</span>:[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;e&#x27;</span>], <span class="string">&#x27;data1&#x27;</span>:[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>]&#125;)</span><br><span class="line">df_obj2 = pd.DataFrame(&#123;<span class="string">&#x27;y&#x27;</span>:[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>], <span class="string">&#x27;data2&#x27;</span>:[<span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;10&#x27;</span>]&#125;)</span><br><span class="line"><span class="built_in">print</span>(pd.merge(df_obj1, df_obj2))       <span class="comment"># 默认参数</span></span><br><span class="line"><span class="built_in">print</span>(pd.merge(df_obj1, df_obj2, how=<span class="string">&#x27;outer&#x27;</span>, on=<span class="string">&#x27;y&#x27;</span>))</span><br></pre></td></tr></table></figure>
输出：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  y data1 data2</span><br><span class="line">0  b     1     9</span><br><span class="line">1  b     2     9</span><br><span class="line">2  a     3     8</span><br><span class="line">3  a     4     8</span><br><span class="line">4  d     5    10</span><br><span class="line"></span><br><span class="line">  y data1 data2</span><br><span class="line">0  b     1     9</span><br><span class="line">1  b     2     9</span><br><span class="line">2  a     3     8</span><br><span class="line">3  a     4     8</span><br><span class="line">4  d     5    10</span><br><span class="line">5  c     6   NaN</span><br><span class="line">6  e     7   NaN</span><br></pre></td></tr></table></figure>
<b>补充：</b></li>
<li>对于索引不同名的，可以在merge函数中添加<code>left_on</code>或<code>right_on</code>来对两个表进行左右连接。用法：<code>pd.merge(df_obj1, df_obj2, left_on=&#39;y&#39;, right_on=&#39;y1&#39;, how=&#39;outer&#39;)</code></li>
<li>对于没有共同列的两个表，可以用<code>join</code>进行连接。用法：<code>df_obj1.join(df_obj2, how=&#39;outer&#39;)</code></li>
</ul>
</blockquote>
</li>
<li><p><b>append():</b><br>在Pandas中<code>append()</code>可以连接多个DataFrame或者Series，但注意在来连接Series时，要加上<code>ignore_index=Ture</code>来避免奇怪的异常。<br><b>例子：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1 = pd.DataFrame(np.full((<span class="number">3</span>, <span class="number">4</span>), <span class="number">2</span>))</span><br><span class="line">df2 = pd.DataFrame(np.full((<span class="number">3</span>, <span class="number">4</span>), <span class="number">3</span>))</span><br><span class="line">df3 = pd.Series([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df1.append(df2))</span><br><span class="line"><span class="built_in">print</span>(df1.append(df3, ignore_index=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  0  1  2  3</span><br><span class="line">0  2  2  2  2</span><br><span class="line">1  2  2  2  2</span><br><span class="line">2  2  2  2  2</span><br><span class="line">0  3  3  3  3</span><br><span class="line">1  3  3  3  3</span><br><span class="line">2  3  3  3  3</span><br><span class="line"></span><br><span class="line">  0  1  2  3</span><br><span class="line">0  2  2  2  2</span><br><span class="line">1  2  2  2  2</span><br><span class="line">2  2  2  2  2</span><br><span class="line">3  a  b  c  d</span><br></pre></td></tr></table></figure>
<p><b>注：</b>如果不加<code>ignore_index=True</code>就会报错：<code>Can only append a Series if ignore_index=True or if the Series has a name</code></p>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="Pandas读取文件数据"><a href="#Pandas读取文件数据" class="headerlink" title="Pandas读取文件数据"></a><b>Pandas读取文件数据</b></h4><blockquote>
<p>Pandas除了可以对不同矩阵之间的操作，同时也可以从外部读取数据进行操作,如csv,execel,sql,json,html等文件。<br>以csv文件为例，</p>
<ul>
<li>如果要读取csv文件时，可以调用<code>read_csv(path)</code>函数，其中<code>path</code>为文件路径，其中还有一个参数<code>header=x</code>，这个参数表示：定义第x列为列名，默认值为0，可以设置为None。</li>
<li>如果要导出csv文件时，可以调用<code>to_csv(path)</code>函数，其中<code>path</code>为文件路径，如果想导出文件不包括索引可以加上<code>index = False</code>。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-函数</title>
    <url>/2021/08/31/Python-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h4 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a><b>函数的定义</b></h4><blockquote>
<p>在Python中函数的定义需要<code>def</code>关键字，并且函数名末尾需要跟一个冒号。<br><b>例子：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>():</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;这是一个函数&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   fun()</span><br></pre></td></tr></table></figure>
<p><b>结果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是一个函数</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h4 id="向函数传递信息"><a href="#向函数传递信息" class="headerlink" title="向函数传递信息"></a><b>向函数传递信息</b></h4><blockquote>
<p>对于一个函数，我们可以向函数传递一个信息作为参数。首先先说明两个名词的含义：<b>形参</b>、<b>实参</b></p>
<blockquote>
<ul>
<li><b>形参</b>：即形式参数，特指在定义函数时的参数，如<code>def fun(a):</code>中的a就是形式参数。</li>
<li><b>实参</b>：即实际参数，指在调用函数时传递的参数，如<code>fun(a)</code>中的a就是实际参数。</li>
</ul>
</blockquote>
<p>一般来说，实参会存储在形参中。<br>函数的参数传递非常广泛，实参可以时Python中的任何数据结构。<br><b>注意：</b>将列表传给函数后，函数对其的所有修改都是永久性的。（列表和字典都会永久性修改，其他的暂时不知道）当然可以通过将列表的副本传给函数来禁止函数修改列表。</p>
</blockquote>
<h5 id="位置实参"><a href="#位置实参" class="headerlink" title="位置实参"></a><b>位置实参</b></h5><blockquote>
<p>在调用函数时，在Python中必须将每个实参都关联到函数定义的一个形参中，简单来说就是实参的位置要与形参的位置对得上。</p>
</blockquote>
<h5 id="关键字实参"><a href="#关键字实参" class="headerlink" title="关键字实参"></a><b>关键字实参</b></h5><blockquote>
<p>关键字实参是传递给函数的名称—值对。你直接在实参中将名称和值关联起来了，因此向函数传递实参时不会混淆。关键字实参让你无需考虑函数调用中的实参顺序，还清楚地指出了函数调用中各个值的用途。<br><b>例如：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">a, b</span>):</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;这是一个函数：&#x27;</span>, a)</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;这是一个函数：&#x27;</span>,b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   fun(b=<span class="string">&#x27;A&#x27;</span>, a=<span class="string">&#x27;B&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><b>结果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是一个函数： B</span><br><span class="line">这是一个函数： A</span><br></pre></td></tr></table></figure>
</blockquote>
<p><b>默认参数：</b></p>
<blockquote>
<p>在定义函数时，可以对形参设置默认值。如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">a, b=<span class="string">&#x27;A&#x27;</span></span>):</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;这是一个函数：&#x27;</span>, a)</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;这是一个函数：&#x27;</span>,b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   fun(a=<span class="string">&#x27;B&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><b>结果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是一个函数： B</span><br><span class="line">这是一个函数： A</span><br></pre></td></tr></table></figure>
<p><b>补充：</b>就算函数中形参设置了默认值，在调用时也可以重新对有默认值的形参进行重新赋值。</p>
</blockquote>
</blockquote>
<h5 id="传递任意数量的实参"><a href="#传递任意数量的实参" class="headerlink" title="传递任意数量的实参"></a><b>传递任意数量的实参</b></h5><blockquote>
<p>有时候你并不知道函数需要接收多少个实参，在Python中你可以在形参前加一个<code>*</code>来接收任意数量的参数。如，</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">*a</span>):</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">       <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   fun(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><b>结果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
</blockquote>
<p><b>原理：</b>形参<code>*a</code>中星号让python创建了一个名为a的空元组，并将所有接收到的参数装到这个元组中。<br><b>注意：</b>如果要将任意数量的实参和位置实参和关键字实参混用时，要将任意数量的实参放在最后，因为Python先匹配位置实参和关键字实参，再将余下的实参都收集到最后一个形参中。<br><b>补充：</b>形如<code>**a</code>这样的形参，中间两个星号让python创建了一个名为a的空字典，其他用法与<code>*a</code>一样。</p>
</blockquote>
<h4 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a><b>函数的返回值</b></h4><blockquote>
<p>在python中，一个函数可以有返回值也可以没有返回值，如果要设置返回值，可以用<code>return</code>进行设置。如，</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>():</span><br><span class="line">   a = <span class="string">&#x27;函数的返回值&#x27;</span></span><br><span class="line">   <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   <span class="built_in">print</span>(fun())</span><br></pre></td></tr></table></figure>
<p><b>结果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数的返回值</span><br></pre></td></tr></table></figure>
</blockquote>
<p>函数的返回值可以是python中任何的数据结构。</p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言基础</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-数据类型(1)</title>
    <url>/2021/04/28/Python-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-1/</url>
    <content><![CDATA[<h4 id="数据类型概述"><a href="#数据类型概述" class="headerlink" title="数据类型概述"></a><b>数据类型概述</b></h4><blockquote>
<p>在Python$ \ $3.x的版本中，主要有7种数据类型：</p>
<blockquote>
<ul>
<li>数值型（整型int、浮点型float、复数complex、布尔型bool）</li>
<li>字符串（string）</li>
<li>字节（bytes）</li>
<li>列表（list）</li>
<li>元组（tuple）</li>
<li>集合（set）</li>
<li>字典（dict）</li>
</ul>
</blockquote>
<p>根据数据是否拥有哈希值，可以将上述的7种数据类型分成<b>可变数据类型</b>和<b>不可变数据类型</b>。</p>
<blockquote>
<ul>
<li><b>可变数据类型</b>：列表、字典、集合</li>
<li><b>不可变数据类型</b>：数值型、字符串、字节、元组<br><b>补充：</b>哈希值是一种有损压缩数据的格式，它可以把任意长度的数据通过通过散列压缩成固定长度的输出，这个输出值就是<b>哈希值</b>。</li>
</ul>
</blockquote>
</blockquote>
<h4 id="数值"><a href="#数值" class="headerlink" title="数值"></a><b>数值</b></h4><blockquote>
<p>在Python$ \ $3.x中数值型数据包括<b>整型int</b>、<b>浮点型float</b>、<b>复数complex</b>、<b>布尔型bool</b></p>
</blockquote>
<h5 id="整型"><a href="#整型" class="headerlink" title="整型"></a><b>整型</b></h5><blockquote>
<p>在Python中，可以定义处理任意大小的整数（无论多少位数，没错就算100位也行），包括负整数。其语法与书写的整数一致，如<code>a=100</code>、<code>b=-10000</code>等。同时，Python中也支持用十六进制来表示整数（注意要加0x的前缀），如<code>a = 0xff0</code>等。</p>
</blockquote>
<h5 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a><b>浮点型</b></h5><blockquote>
<p>在Python中，浮点型只有<code>float</code>一类，而且小数点之后最多可以显示15位。<br>浮点型的数既可以用通常的显示方法，如<code>a = 1.2345</code>，也可以用科学记数法，如<code>a = 1.6e3=1600.0</code>，其中<code>e</code>表示10.</p>
</blockquote>
<h5 id="复数"><a href="#复数" class="headerlink" title="复数"></a><b>复数</b></h5><blockquote>
<ul>
<li>复数是由实部与虚部组成，可以用$a+bj$来表示，也可以用complex(a,b)表示。其中a和b都是实数（浮点型）。</li>
<li><b>注意：</b>在Python中虚数不可能单独存在，并且在虚部中必须加上后缀<code>j</code>或<code>J</code>。</li>
<li>对于复数来说，可以通过<code>real()</code>和<code>imag()</code>来分别调用复数的实部和虚部。</li>
<li>对于复数，Python中可以用<code>conjugate()</code>返回复数的<b>共轭复数</b>。<br><b>例子：</b><blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span> + <span class="number">2j</span></span><br><span class="line"><span class="built_in">print</span>(a.real)              <span class="comment"># 求复数的实部</span></span><br><span class="line"><span class="built_in">print</span>(a.imag)              <span class="comment"># 求复数的虚部</span></span><br><span class="line"><span class="built_in">print</span>(a.conjugate())       <span class="comment"># 求共轭复数</span></span><br></pre></td></tr></table></figure>
<p><b>输出：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.0</span><br><span class="line">2.0</span><br><span class="line">(1-2j)</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</blockquote>
<h5 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a><b>布尔型</b></h5><blockquote>
<p>布尔型数据通常使用关键字<code>True</code>和<code>False</code>来表示（首字母是大写）。<br>布尔型常用于if语句的判断或者循环语句中的判断条件。</p>
</blockquote>
<h5 id="常用数值运算符"><a href="#常用数值运算符" class="headerlink" title="常用数值运算符"></a><b>常用数值运算符</b></h5><blockquote>
<p><b>算术运算</b></p>
<blockquote>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">表达式</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>+</code></td>
<td align="center">a + b</td>
<td align="center">a和b相加</td>
</tr>
<tr>
<td align="center"><code>-</code></td>
<td align="center">a - b</td>
<td align="center">a减去b</td>
</tr>
<tr>
<td align="center"><code>*</code></td>
<td align="center">a * b</td>
<td align="center">a与b相乘</td>
</tr>
<tr>
<td align="center"><code>/</code></td>
<td align="center">a &#x2F; b</td>
<td align="center">a除以b</td>
</tr>
<tr>
<td align="center"><code>%</code></td>
<td align="center">a % b</td>
<td align="center">a除以b的余数（取模）</td>
</tr>
<tr>
<td align="center"><code>**</code></td>
<td align="center">a ** b</td>
<td align="center">a的b次方</td>
</tr>
<tr>
<td align="center"><code>//</code></td>
<td align="center">a &#x2F;&#x2F; b</td>
<td align="center">a除以b（仅返回整数部分）</td>
</tr>
</tbody></table>
</blockquote>
<p><b>比较运算</b></p>
<blockquote>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">表达式</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>==</code></td>
<td align="center">a &#x3D;&#x3D; b</td>
<td align="center">a等于b（返回布尔值）</td>
</tr>
<tr>
<td align="center"><code>!=</code></td>
<td align="center">a !&#x3D; b</td>
<td align="center">a不等于b（返回布尔值）</td>
</tr>
<tr>
<td align="center"><code>&gt;</code></td>
<td align="center">a &gt; b</td>
<td align="center">a大于b（返回布尔值）</td>
</tr>
<tr>
<td align="center"><code>&lt;</code></td>
<td align="center">a &lt; b</td>
<td align="center">a小于b（返回布尔值）</td>
</tr>
<tr>
<td align="center"><code>&gt;=</code></td>
<td align="center">a &gt;&#x3D; b</td>
<td align="center">a大于等于b（返回布尔值）</td>
</tr>
<tr>
<td align="center"><code>&lt;=</code></td>
<td align="center">a &lt;&#x3D; b</td>
<td align="center">a小于等于b（返回布尔值）</td>
</tr>
</tbody></table>
</blockquote>
<p><b>身份运算</b></p>
<blockquote>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">表达式</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>is</code></td>
<td align="center">a is b</td>
<td align="center">判断a与b是否有相同的存储地址</td>
</tr>
<tr>
<td align="center"><code>is not</code></td>
<td align="center">a is not b</td>
<td align="center">判断a与b是否不同的存储地址</td>
</tr>
</tbody></table>
</blockquote>
<p><b>逻辑运算</b></p>
<blockquote>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">表达式</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>and</code></td>
<td align="center">a and b</td>
<td align="center">返回a与b的值</td>
</tr>
<tr>
<td align="center"><code>or</code></td>
<td align="center">a or b</td>
<td align="center">返回a或b的值</td>
</tr>
<tr>
<td align="center"><code>not</code></td>
<td align="center">not a</td>
<td align="center">返回非a的值</td>
</tr>
</tbody></table>
</blockquote>
<p><b>成员运算</b></p>
<blockquote>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">表达式</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>in</code></td>
<td align="center">a in b</td>
<td align="center">判断a元素是否在b元素中</td>
</tr>
<tr>
<td align="center"><code>not in</code></td>
<td align="center">a not in b</td>
<td align="center">判断a元素是否不在b元素中</td>
</tr>
</tbody></table>
</blockquote>
<p><b>补充：</b>除了上面的运算符，还有常用的运算函数如，</p>
<blockquote>
<p><code>max()``min()</code>，<code>sum()``len()</code>等。</p>
</blockquote>
</blockquote>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><b>字符串</b></h4><h5 id="字符串的定义"><a href="#字符串的定义" class="headerlink" title="字符串的定义"></a><b>字符串的定义</b></h5><blockquote>
<p>在Python中，<b>字符串</b>就是一系列字符，用引号括起来的都是字符串，其中引号可以是<b>双引号</b>也可以是<b>单引号</b>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;I hava a pen&#x27;</span></span><br><span class="line">b = <span class="string">&quot;I have a apple&quot;</span></span><br></pre></td></tr></table></figure>
<p><b>注：</b>单引号和双引号都没什么区别，两个所表达的效果都是一样的，好处是可以灵活在字符串中插入单引号或双引号。<br>还有一个神奇的定义方法，当句子太长，或者写一段文字时，可以使用三引号来定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;&#x27;&#x27;如果这句话太长了，</span></span><br><span class="line"><span class="string">我们可以用三个单引号或双引号！</span></span><br><span class="line"><span class="string">(虽然感觉没什么用~~)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a><b>字符串拼接</b></h5><blockquote>
<p>在处理字符串时可以直接使用<code>+</code>来对字符串进行拼接：</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;I hava a pen&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;a apple&#x27;</span></span><br><span class="line">c = a + <span class="string">&#x27; and &#x27;</span> + b</span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure>
<p><b>输出：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I hava a pen and a apple</span><br></pre></td></tr></table></figure>
</blockquote>
<p>当然在输出的时候也可以对字符串进行切片输出：</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&quot;卧槽，这是啥玩意？&quot;</span></span><br><span class="line">b = <span class="string">&quot;算了，我放弃治疗了~&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a, b, sep=<span class="string">&#x27;——&#x27;</span>)       <span class="comment"># sep可以定义两个字符串拼接处的连接符</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>:<span class="number">2</span>], b[-<span class="number">8</span>:])</span><br></pre></td></tr></table></figure>
<p><b>输出：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">卧槽，这是啥玩意？——算了，我放弃治疗了~</span><br><span class="line">卧槽 ，我放弃治疗了~</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h5 id="字符串的常用函数"><a href="#字符串的常用函数" class="headerlink" title="字符串的常用函数"></a><b>字符串的常用函数</b></h5><blockquote>
<ul>
<li><p>对字母大小写进行操作：</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;protection POLLOUTION&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;I hava a pen&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(b.title())        <span class="comment"># 每个单词首字母都变大写</span></span><br><span class="line"><span class="built_in">print</span>(a.upper())        <span class="comment"># 每个字母都变为小写</span></span><br><span class="line"><span class="built_in">print</span>(a.lower())        <span class="comment"># 每个字母都变为大写</span></span><br></pre></td></tr></table></figure>
<p><b>输出：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I Hava A Pen</span><br><span class="line">PROTECTION POLLOUTION</span><br><span class="line">protection polloution</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>对字符串的空格进行操作</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;  apple              &#x27;</span></span><br><span class="line">b = <span class="string">&#x27; pen&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a + b)</span><br><span class="line"><span class="built_in">print</span>(a.rstrip() + b)                  <span class="comment"># 去除末尾多余的空格</span></span><br><span class="line"><span class="built_in">print</span>(b.lstrip())                      <span class="comment"># 去除开头的空格</span></span><br><span class="line"><span class="built_in">print</span>(a.strip())                       <span class="comment"># 去除两头的空格</span></span><br></pre></td></tr></table></figure>
<p><b>输出：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> apple               pen</span><br><span class="line"> apple pen</span><br><span class="line">pen</span><br><span class="line">apple</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</blockquote>
<h5 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a><b>转义字符</b></h5><blockquote>
<p>在需要在字符中使用特殊字符时，python 用反斜杠<code>\</code>转义字符。<br>常用的就<code>\t</code><b>制表符</b>和<code>\n</code><b>换行符</b>。</p>
</blockquote>
<h4 id="bytes数据类型"><a href="#bytes数据类型" class="headerlink" title="bytes数据类型"></a><b>bytes数据类型</b></h4><blockquote>
<p>bytes主要是用于二进制的数据处理的数据类型，非常适合于socket编程。<br>bytes是byte的序列，而str是unicode的序列。<br>bytes数据类型主要分为bytes与bytearray两个不同的方式。</p>
</blockquote>
<h5 id="bytes"><a href="#bytes" class="headerlink" title="bytes"></a><b>bytes</b></h5><blockquote>
<p>bytes类型多用于网络的字符串传输<br>因为它可以将字符串转化为十六进制的字符<br><b>例子：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;你是条咸鱼&quot;</span></span><br><span class="line">byte = <span class="built_in">str</span>.encode()</span><br><span class="line"><span class="built_in">print</span>(byte)</span><br><span class="line">str1 = byte.decode()</span><br><span class="line"><span class="built_in">print</span>(str1)</span><br></pre></td></tr></table></figure>
<p><b>输出：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;\xe4\xbd\xa0\xe6\x98\xaf\xe6\x9d\xa1\xe5\x92\xb8\xe9\xb1\xbc&#x27;</span><br><span class="line">你是条咸鱼</span><br></pre></td></tr></table></figure>
</blockquote>
<p>bytes主要通过<code>encode()</code>编码以及<code>decode()</code>解码，进行不同数据之间的转化。<br><b>补充：</b>由于个人用的比较少<del>(而且懒)</del>，就不展开了</p>
</blockquote>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a><b>列表</b></h4><blockquote>
<ul>
<li>列表，个人用起来感觉像高级版的列表。</li>
<li>列表可以存放各类的数据，一般列表里的数据都是字符串型的.</li>
<li>列表的操作主要为增、删、改以及一些奇奇怪怪的操作。</li>
</ul>
</blockquote>
<h5 id="列表的创建："><a href="#列表的创建：" class="headerlink" title="列表的创建："></a><b>列表的创建：</b></h5><blockquote>
<p>列表创建非常直接明了：</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&#x27;I &#x27;</span>, <span class="string">&#x27;have &#x27;</span>, <span class="string">&#x27;a &#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p><b>输出：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;I &#x27;, &#x27;have &#x27;, &#x27;a &#x27;, &#x27;apple&#x27;]</span><br></pre></td></tr></table></figure>
<p><b>补充：</b>输出时带着个中括号是列表的重要标志之一。</p>
</blockquote>
</blockquote>
<h5 id="列表元素的添加"><a href="#列表元素的添加" class="headerlink" title="列表元素的添加"></a><b>列表元素的添加</b></h5><blockquote>
<p>列表元素的删除主要有两种方法：（我知道的）</p>
<ul>
<li><p><b>append():</b><br>用法：</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&#x27;I &#x27;</span>, <span class="string">&#x27;have &#x27;</span>, <span class="string">&#x27;a &#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a.append(<span class="string">&#x27;pen&#x27;</span>)     <span class="comment"># 增</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p><b>输出：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;I &#x27;, &#x27;have &#x27;, &#x27;a &#x27;, &#x27;apple&#x27;]</span><br><span class="line">[&#x27;I &#x27;, &#x27;have &#x27;, &#x27;a &#x27;, &#x27;apple&#x27;, &#x27;pen&#x27;]</span><br></pre></td></tr></table></figure>
<p><code>append()</code>只能在列表最后添加元素，不能在其他位置添加。</p>
</blockquote>
</li>
<li><p>insert():<br>用法：</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&#x27;I &#x27;</span>, <span class="string">&#x27;have &#x27;</span>, <span class="string">&#x27;a &#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a.insert(<span class="number">2</span>, <span class="string">&#x27;er~&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p><b>输出：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;I &#x27;, &#x27;have &#x27;, &#x27;a &#x27;, &#x27;apple&#x27;]</span><br><span class="line">[&#x27;I &#x27;, &#x27;have &#x27;, &#x27;er~&#x27;, &#x27;a &#x27;, &#x27;apple&#x27;]</span><br></pre></td></tr></table></figure>
<p><code>insert</code>需要两参数，第一个是要插入列表的位置（位置可以是正数也可以是负数），第二个是插入的元素。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h5 id="列表元素的删除"><a href="#列表元素的删除" class="headerlink" title="列表元素的删除"></a><b>列表元素的删除</b></h5><blockquote>
<p>列表元素的删除共有三种（我已知的）：</p>
<ul>
<li><p><b>del a[]</b>:</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&#x27;I &#x27;</span>, <span class="string">&#x27;have &#x27;</span>, <span class="string">&#x27;a &#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="keyword">del</span> a[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p><b>效果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;I &#x27;, &#x27;have &#x27;, &#x27;a &#x27;, &#x27;apple&#x27;]</span><br><span class="line">[&#x27;I &#x27;, &#x27;a &#x27;, &#x27;apple&#x27;]</span><br></pre></td></tr></table></figure>
<p><code>del</code>只能按索引来删除，所以使用条件是要知道要删除元素的位置。</p>
</blockquote>
</li>
<li><p><b>.pop()</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&#x27;I &#x27;</span>, <span class="string">&#x27;have &#x27;</span>, <span class="string">&#x27;a &#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a.pop()     </span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p><b>效果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;I &#x27;, &#x27;have &#x27;, &#x27;a &#x27;, &#x27;apple&#x27;]</span><br><span class="line">[&#x27;I &#x27;, &#x27;have &#x27;, &#x27;a &#x27;]</span><br></pre></td></tr></table></figure>
<p><code>.pop()</code>的操作类似于栈，不加参数默认弹出最后一个进列表的元素，<b>但是</b>也可以在括号中加入索引删除指定值。另外，<code>.pop()</code>的元素可以用其他变量來接。</p>
</blockquote>
</li>
<li><p><b>.remove()</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&#x27;I &#x27;</span>, <span class="string">&#x27;have &#x27;</span>, <span class="string">&#x27;a &#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a.append(<span class="string">&#x27;have&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a.remove(<span class="string">&#x27;have&#x27;</span>)   <span class="comment"># 定点删除，多个相同的话只删第一个</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p><b>效果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;I &#x27;, &#x27;have &#x27;, &#x27;a &#x27;, &#x27;apple&#x27;]</span><br><span class="line">[&#x27;I &#x27;, &#x27;have &#x27;, &#x27;a &#x27;, &#x27;apple&#x27;, &#x27;have&#x27;]</span><br><span class="line">[&#x27;I &#x27;, &#x27;have &#x27;, &#x27;a &#x27;, &#x27;apple&#x27;]</span><br></pre></td></tr></table></figure>
<p><code>.remove()</code>可以根据元素来进行查找删除，如果有多个重名的元素，则会删除索引值较小的那个。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h5 id="列表元素的修改"><a href="#列表元素的修改" class="headerlink" title="列表元素的修改"></a><b>列表元素的修改</b></h5><blockquote>
<p>列表元素的修改只有一种（其实我只会这一种）：<br>直接根据索引值进行修改：</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&#x27;I &#x27;</span>, <span class="string">&#x27;have &#x27;</span>, <span class="string">&#x27;a &#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a[<span class="number">0</span>] = <span class="string">&#x27;you&#x27;</span>     </span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p><b>效果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;I &#x27;, &#x27;have &#x27;, &#x27;a &#x27;, &#x27;apple&#x27;]</span><br><span class="line">[&#x27;you&#x27;, &#x27;have &#x27;, &#x27;a &#x27;, &#x27;apple&#x27;]</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h5 id="列表的一些其他操作"><a href="#列表的一些其他操作" class="headerlink" title="列表的一些其他操作"></a><b>列表的一些其他操作</b></h5><blockquote>
<ul>
<li><p><b>列表当作循环的标记：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&#x27;I &#x27;</span>, <span class="string">&#x27;have &#x27;</span>, <span class="string">&#x27;a &#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> a:                 <span class="comment"># 循环输出列表a中的元素</span></span><br><span class="line">   <span class="built_in">print</span>(m)</span><br></pre></td></tr></table></figure>
<p><b>效果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I </span><br><span class="line">have </span><br><span class="line">a </span><br><span class="line">apple</span><br></pre></td></tr></table></figure>
<p>这操作一般用于<code>for</code>循环上，列表当循环次数。</p>
</blockquote>
</li>
<li><p><b>将其他类型的数据转化为列表型数据</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100</span>) </span><br><span class="line">a = <span class="built_in">list</span>(a)                   <span class="comment"># 将序列转化成列表型</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">b = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">21</span>, <span class="number">2</span>))	<span class="comment"># 可以在结尾的数字后加个步长</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>
<p><b>效果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]</span><br><span class="line">[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>list</code>可以将其他的数据转化成列表类型的数据。</li>
<li>如果列表元素全是数字类型的话，还可以对其进行简单的统计，如<code>min()</code>,<code>max()</code>,<code>sum()</code>等。</li>
</ul>
</blockquote>
</li>
<li><p><b>列表的切片：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&#x27;I &#x27;</span>, <span class="string">&#x27;have &#x27;</span>, <span class="string">&#x27;a &#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>: <span class="number">3</span>])              <span class="comment"># 可以理解为是一个左开右闭的操作</span></span><br><span class="line"><span class="built_in">print</span>(a[: <span class="number">3</span>])               <span class="comment"># 左边不写的话默认为从第一个元素开始</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>: ])               <span class="comment"># 同理右边不写的话默认为到最后一个元素结束</span></span><br><span class="line"><span class="built_in">print</span>(a[-<span class="number">3</span>: ])              <span class="comment"># 当然也可以倒数来输出元素</span></span><br></pre></td></tr></table></figure>
<p><b>效果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;have &#x27;, &#x27;a &#x27;]</span><br><span class="line">[&#x27;I &#x27;, &#x27;have &#x27;, &#x27;a &#x27;]</span><br><span class="line">[&#x27;have &#x27;, &#x27;a &#x27;, &#x27;apple&#x27;]</span><br><span class="line">[&#x27;have &#x27;, &#x27;a &#x27;, &#x27;apple&#x27;]</span><br></pre></td></tr></table></figure>
<p>列表的切片可以十分灵活，中括号的参数样式也可以多种多样，其中的参数则遵循着<code>:</code>左边为开始点，<code>:</code>右边为结束点，没有的话则从头开始&#x2F;到尾结束。</p>
</blockquote>
</li>
<li><p><b>列表的复制</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = a                         <span class="comment"># 这种复制不会出现两个独立的个体</span></span><br><span class="line">b.append(<span class="string">&#x27;ur~&#x27;</span>)</span><br><span class="line">b = a[:]                       <span class="comment"># 这种复制则会出现两个独立的个体</span></span><br><span class="line">b.append(<span class="string">&#x27;applepen&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>
<p><b>效果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;I &#x27;, &#x27;have &#x27;, &#x27;a &#x27;, &#x27;apple&#x27;, &#x27;ur~&#x27;]</span><br><span class="line">[&#x27;I &#x27;, &#x27;have &#x27;, &#x27;a &#x27;, &#x27;apple&#x27;, &#x27;ur~&#x27;, &#x27;applepen&#x27;]</span><br></pre></td></tr></table></figure>
<ul>
<li>在列表中，直接用<code>=</code>并不能复制出两个独立的列表个体，反而变得有点像两个变量（指针）指向同一块内存里了。</li>
<li>用<code>b = a[:]</code>则可以复制出两个独立的列表个体。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言基础</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-变量</title>
    <url>/2021/03/26/Python-%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h4 id="Python的变量"><a href="#Python的变量" class="headerlink" title="Python的变量"></a><b>Python的变量</b></h4><blockquote>
<p>在Python中，变量没有特定的标识符，即定义变量时不需要用特定的标识符来修饰变量。</p>
</blockquote>
<blockquote>
<p><b>变量的使用规范</b>：</p>
<ul>
<li>变量名只能包含字母、数字和下划线。变量名可以用<b>下划线</b>和<b>字母</b>开头，但不能用<b>数字</b>开头。</li>
<li>变量名不能包括空格。</li>
<li>变量名不能与Python中的函数名与关键字重名。</li>
<li>变量名尽量为小写。</li>
</ul>
</blockquote>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><b>字符串</b></h5><blockquote>
<p>在Python中，字符串的定义可以用双引号<code>“</code>，也可以用单引号<code>‘</code>来定义，<br><b>例如：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&quot;This is a string&quot;</span></span><br><span class="line">b = <span class="string">&quot;This is also a string&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">pring(b)</span><br></pre></td></tr></table></figure>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/Python/%E5%AD%97%E7%AC%A6%E4%B8%B2.jpg" alt="字符串" title="字符串的定义"></p>
</blockquote>
<p><b>用函数修改字符串的大小写</b><br>对于全是小写的字符串</p>
<ul>
<li>使用<code>.title()</code>可以使字符串中每个单词的首字母变为大写。</li>
<li>使用<code>.upper()</code>可以使字符串中每个字母都变为大写。</li>
<li>使用<code>.lower()</code>可以使字符串中每个字母都变为小写。<br><b>例如：</b><blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&quot;a poor man&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a.title())</span><br><span class="line"><span class="built_in">print</span>(a.upper())</span><br><span class="line"><span class="built_in">print</span>(a.lower())</span><br></pre></td></tr></table></figure>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/Python/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%86%99.jpg" alt="字符串" title="字符串的大小写"></p>
</blockquote>
</li>
</ul>
<p><b>字符串的连接</b><br>在Python中你可以通过<code>+</code>来对两个字符串进行连接。<br><b>例如：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&quot;a&quot;</span></span><br><span class="line">b = <span class="string">&quot;dog&quot;</span></span><br><span class="line">c = a+<span class="string">&quot; &quot;</span>+b</span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/Python/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8B%BC%E6%8E%A5.jpg" alt="字符串" title="字符串的拼接"></p>
</blockquote>
</blockquote>
<h5 id="数字"><a href="#数字" class="headerlink" title="数字"></a><b>数字</b></h5><blockquote>
<ul>
<li><p><b>整数</b></p>
<blockquote>
<p>Pyton中的整数除了定义时与其他语言有所区别，其余都一样<br>Pyton中整数支持<b>加、减、乘、除</b>的运算。</p>
</blockquote>
</li>
<li><p><b>浮点数</b></p>
<blockquote>
<p>Python将带有小数点的数字称为<b>浮点数</b><br>对于浮点数来说，结果包含的小数位数可能是不确定的。<br><b>例如：</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/Python/%E6%B5%AE%E7%82%B9%E6%95%B0.jpg" alt="浮点数" title="浮点数"></p>
</blockquote>
</li>
</ul>
</blockquote>
<h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a><b>注释</b></h5><blockquote>
<p>在Python中，可以用<code>#</code>来进行注释，在<code>#</code>后面的内容都会被Python解释器忽略。<br><b>例如：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#这是一条注释</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;这不是注释&quot;</span>)</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h5 id="一些奇奇怪怪的错误"><a href="#一些奇奇怪怪的错误" class="headerlink" title="一些奇奇怪怪的错误"></a><b>一些奇奇怪怪的错误</b></h5><blockquote>
<ul>
<li>上面也说了，Python在定义变量时不需要标识符，字符串又可以用<code>+</code>来拼接，那么在拼接字符串时塞个数字进去会怎样？如<code>message = &quot;A&quot;+23+&quot;rd Years&quot;</code></li>
<li>答案是会报错，因为Python无法识别出这个拼接后的<code>message</code>是什么类型的数据。</li>
<li>这是可以用<code>str()</code>来避免这个错误，即<code>message = &quot;A&quot;+str(23)+&quot;rd Years&quot;</code></li>
</ul>
</blockquote>
<h5 id="一个彩蛋"><a href="#一个彩蛋" class="headerlink" title="一个彩蛋"></a><b>一个彩蛋</b></h5><blockquote>
<p>输入<code>import this</code>可以浏览，<br>这也是一个编程准则，其内容如下</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Beautiful is better than ugly.</span><br><span class="line"></span><br><span class="line">Explicit is better than implicit.</span><br><span class="line"></span><br><span class="line">Simple is better than complex.</span><br><span class="line"></span><br><span class="line">Complex is better than complicated.</span><br><span class="line"></span><br><span class="line">Flat is better than nested.</span><br><span class="line"></span><br><span class="line">Sparse is better than dense.</span><br><span class="line"></span><br><span class="line">Readability counts.</span><br><span class="line"></span><br><span class="line">Special cases aren&#x27;t special enough to break the rules.</span><br><span class="line"></span><br><span class="line">Although practicality beats purity.</span><br><span class="line"></span><br><span class="line">Errors should never pass silently.</span><br><span class="line"></span><br><span class="line">Unless explicitly silenced.</span><br><span class="line"></span><br><span class="line">In the face of ambiguity, refuse the temptation to guess.</span><br><span class="line"></span><br><span class="line">There should be one-- and preferably only one --obvious way to do it.</span><br><span class="line"></span><br><span class="line">Although that way may not be obvious at first unless you&#x27;re Dutch.</span><br><span class="line"></span><br><span class="line">Now is better than never.</span><br><span class="line"></span><br><span class="line">Although never is often better than *right* now.</span><br><span class="line"></span><br><span class="line">If the implementation is hard to explain, it&#x27;s a bad idea.</span><br><span class="line"></span><br><span class="line">If the implementation is easy to explain, it may be a good idea.</span><br><span class="line"></span><br><span class="line">Namespaces are one honking great idea -- let&#x27;s do more of those!</span><br></pre></td></tr></table></figure>
</blockquote>
<p>中文翻译：<del>(其实是机翻)</del></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">美丽胜于丑陋。</span><br><span class="line"></span><br><span class="line">显性比隐性好。</span><br><span class="line"></span><br><span class="line">简单胜于复杂。</span><br><span class="line"></span><br><span class="line">复杂总比复杂好。</span><br><span class="line"></span><br><span class="line">平的比嵌套的好。</span><br><span class="line"></span><br><span class="line">疏胜于密。</span><br><span class="line"></span><br><span class="line">可读性很重要。</span><br><span class="line"></span><br><span class="line">特殊情况不足以打破规则。</span><br><span class="line"></span><br><span class="line">尽管实用胜过纯洁。</span><br><span class="line"></span><br><span class="line">错误不应该悄悄地过去。</span><br><span class="line"></span><br><span class="line">除非明确沉默。</span><br><span class="line"></span><br><span class="line">面对模棱两可，拒绝猜测的诱惑。</span><br><span class="line"></span><br><span class="line">应该有一个——最好只有一个——显而易见的方法。</span><br><span class="line"></span><br><span class="line">尽管这种方式一开始可能并不明显，除非你是荷兰人。</span><br><span class="line"></span><br><span class="line">现在总比没有好。</span><br><span class="line"></span><br><span class="line">虽然从来没有比现在更好。</span><br><span class="line"></span><br><span class="line">如果实现很难解释，那就不是个好主意。</span><br><span class="line"></span><br><span class="line">如果实现很容易解释，那么这可能是一个好主意。</span><br><span class="line"></span><br><span class="line">名称空间是一个非常好的主意——让我们做更多的工作吧！</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言基础</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-文件处理</title>
    <url>/2021/09/02/Python-%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h4 id="从文件中读取数据"><a href="#从文件中读取数据" class="headerlink" title="从文件中读取数据"></a><b>从文件中读取数据</b></h4><blockquote>
<p>使用文本文件中的信息，首先需要将其读取到内存中，读取方式又包括<b>一次性读取所有文件</b>和<b>每次一行的方式</b>逐步读取。</p>
</blockquote>
<h5 id="读取整个文件"><a href="#读取整个文件" class="headerlink" title="读取整个文件"></a><b>读取整个文件</b></h5><blockquote>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.txt&#x27;</span>) <span class="keyword">as</span> file_data:</span><br><span class="line">   line = file_data.read()</span><br><span class="line"></span><br><span class="line">   <span class="built_in">print</span>(line)</span><br></pre></td></tr></table></figure>
<p><b>结果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.141592</span><br><span class="line">6535897</span><br><span class="line">9323846</span><br><span class="line">2643383</span><br><span class="line">279        </span><br></pre></td></tr></table></figure>
</blockquote>
<p>打开文件的操作有点类似于导入包，<code>with</code>是关键字，<code>open()</code>是函数，<code>file_data</code>是一个文件信息的对象，具体输出：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;_io.TextIOWrapper name=&#x27;data.txt&#x27; mode=&#x27;r&#x27; encoding=&#x27;cp936&#x27;&gt;</span><br></pre></td></tr></table></figure>
<p>第一个<b>大概</b>是文件地址，第二个是文件打开方式，r代表只读，第三个<b>大概</b>是编码方式。</p>
</blockquote>
</blockquote>
<blockquote>
<ul>
<li><p>关键字<code>with</code>在不需要访问文件后将其关闭，但是python非常贴心，它会自动选择合适的时机自动将其关闭。</p>
</li>
<li><p>另外，如果读取出来的的数据有空格，而你想去掉它，可以直接调用<code>strip()</code>函数来去除多余的空格，如</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.txt&#x27;</span>) <span class="keyword">as</span> file_data:</span><br><span class="line">   line = file_data.read()</span><br><span class="line"></span><br><span class="line">   <span class="built_in">print</span>(<span class="built_in">len</span>(line))</span><br><span class="line">   <span class="built_in">print</span>(<span class="built_in">len</span>(line.rstrip()))</span><br></pre></td></tr></table></figure>
<p><b>结果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">48</span><br><span class="line">40</span><br></pre></td></tr></table></figure>
<p><b>补充：</b>这个函数可以对任何字符串数据使用，并且<code>rstrip</code>或<code>lstrip</code>指的是删除右边的或左边的空格，<code>strip</code>则是两边空格都删掉。</p>
</blockquote>
</li>
<li><p>关于文件的路径（即上例中<code>open</code>的参数），路径分为<b>绝对路径</b>和<b>相对路径</b></p>
<blockquote>
<ul>
<li><b>相对路径：</b>从程序开始到文件位置的路径，一般开头没有<code>\</code>或<code>/</code></li>
<li><b>绝对路径：</b>从基本盘的位置开始到文件所在的位置，一般开头为<code>/</code>或’X:&#39;（X代表盘号）</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h5 id="逐行读取"><a href="#逐行读取" class="headerlink" title="逐行读取"></a><b>逐行读取</b></h5><blockquote>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.txt&#x27;</span>) <span class="keyword">as</span> file_data:</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> file_data:</span><br><span class="line">       <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<p><b>结果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.141592</span><br><span class="line"></span><br><span class="line">6535897</span><br><span class="line"></span><br><span class="line">9323846</span><br><span class="line"></span><br><span class="line">2643383</span><br><span class="line"></span><br><span class="line">279 </span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果想要消去多余的空行，可以使用<code>strip()</code>进行操作。</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;data.txt&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(a) <span class="keyword">as</span> file_data:</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> file_data:</span><br><span class="line">       <span class="built_in">print</span>(i.rstrip())</span><br></pre></td></tr></table></figure>
<p><b>结果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.141592</span><br><span class="line">6535897</span><br><span class="line">9323846</span><br><span class="line">2643383</span><br><span class="line">279</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h5 id="创建一个包括文件各行的列表"><a href="#创建一个包括文件各行的列表" class="headerlink" title="创建一个包括文件各行的列表"></a><b>创建一个包括文件各行的列表</b></h5><blockquote>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;data.txt&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(a) <span class="keyword">as</span> file_data:</span><br><span class="line">   lines = file_data.readlines()</span><br><span class="line">   <span class="built_in">print</span>(<span class="built_in">type</span>(lines))</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> lines:</span><br><span class="line">       <span class="built_in">print</span>(i.rstrip())</span><br></pre></td></tr></table></figure>
<p><b>结果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;class &#x27;list&#x27;&gt;</span><br><span class="line">3.141592</span><br><span class="line">6535897</span><br><span class="line">9323846</span><br><span class="line">2643383</span><br><span class="line">279</span><br></pre></td></tr></table></figure>
<p><b>补充：</b>直接读的数据是字符串型的数据。</p>
</blockquote>
</blockquote>
<h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a><b>写入文件</b></h4><blockquote>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;data.txt&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(a, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file_data:</span><br><span class="line">   a = <span class="string">&#x27;This is a data&#x27;</span></span><br><span class="line">   file_data.write(a)</span><br></pre></td></tr></table></figure>
<p><b>结果：</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/Python/%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6.png" alt="图片" title="写入文件！"></p>
</blockquote>
<ul>
<li><code>open</code>函数中的第二个参数可以指定打开文件的方式，其中默认为<code>r</code>读取文件，<code>w</code>为写入文件（覆盖地写入），<code>a</code>为附加模式（可以在原来的基础上继续追加数据），<code>r+</code>是同时允许读取和写入文件。<br><b>多行写入：</b><blockquote>
<p>多行写入只需多次调用<code>file_data.write(a)</code>即可。<br><b>注意：</b>多行写入也是覆盖式写入，而且需要换行的话要自行在每行末尾追加<code>\n</code></p>
</blockquote>
</li>
</ul>
<p><b>附加写入</b></p>
<blockquote>
<p>将<code>open()</code>中第二个参数改为<code>a</code>后，python不会在返回文件对象前清空文件。<br>你写入到文件的行都将追加到文件末尾。<br><b>注意：</b>如果文件不存在，python将为你创建一个空文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ad = <span class="string">&#x27;data.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(ad, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file_data:</span><br><span class="line">       a = <span class="string">&#x27;This is a data\n&#x27;</span></span><br><span class="line">       file_data.write(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">   <span class="keyword">with</span> <span class="built_in">open</span>(ad, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> file_data:</span><br><span class="line">       a = <span class="string">&#x27;wryyyyyyyyyyyyyyyyy\n&#x27;</span></span><br><span class="line">       file_data.write(a)</span><br></pre></td></tr></table></figure>
<p><b>结果：</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/Python/%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6_1.png" alt="图片" title="写入文件！"></p>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言基础</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-数据类型(2)</title>
    <url>/2021/08/30/Python-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-2/</url>
    <content><![CDATA[<h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a><b>元组</b></h4><blockquote>
<p>元组与列表定义方式相似，列表用<code>[]</code>而元组用<code>()</code>：</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (<span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p><b>效果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(100, 200)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>值得注意的是，元组不能修改，甚至想删除其中的元素也不行。<br>不过可以重新定义或者<code>del</code>直接整个元组删掉。</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[<span class="number">1</span>] = <span class="number">300</span>;</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> a</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p><b>效果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line"> File &quot;D:/学习用的/pyex/ML/ML/normal_ex.py&quot;, line 71, in &lt;module&gt;</span><br><span class="line">   a[1] = 300;</span><br><span class="line">TypeError: &#x27;tuple&#x27; object does not support item assignment</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line"> File &quot;D:/学习用的/pyex/ML/ML/normal_ex.py&quot;, line 74, in &lt;module&gt;</span><br><span class="line">   print(a)</span><br><span class="line">NameError: name &#x27;a&#x27; is not defined</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a><b>集合</b></h4><h5 id="集合的定义"><a href="#集合的定义" class="headerlink" title="集合的定义"></a><b>集合的定义</b></h5><blockquote>
<p>集合可以用<code>&#123;&#125;</code>和<code>set()</code>两种方法定义：</p>
<ul>
<li><p></b>直接使用大括号定义：<b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;have&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p><b>效果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;class &#x27;set&#x27;&gt;</span><br><span class="line">&#123;&#x27;have&#x27;, &#x27;a&#x27;, &#x27;I&#x27;, &#x27;apple&#x27;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><b>用set()函数来定义：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">set</span>(<span class="string">&#x27;apple&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p><b>效果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;class &#x27;set&#x27;&gt;</span><br><span class="line">&#123;&#x27;e&#x27;, &#x27;p&#x27;, &#x27;a&#x27;, &#x27;l&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，用<code>set</code>如果只放一对单引号的话只能定义出单子符的集合。<br>想要定义字符串集合可以：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">set</span>((<span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;have&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p><b>效果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;class &#x27;set&#x27;&gt;</span><br><span class="line">&#123;&#x27;have&#x27;, &#x27;I&#x27;, &#x27;a&#x27;, &#x27;apple&#x27;&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<p><b>补充：</b>集合与列表不同，集合中不会出现重复的元素，且集合的输出标记为<code>&#123;&#125;</code>。</p>
</blockquote>
<h5 id="集合的添加"><a href="#集合的添加" class="headerlink" title="集合的添加"></a><b>集合的添加</b></h5><blockquote>
<ul>
<li><b>.add()</b><blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">set</span>((<span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;have&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">a.add(<span class="string">&#x27;pen&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p><b>效果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;pen&#x27;, &#x27;have&#x27;, &#x27;I&#x27;, &#x27;apple&#x27;, &#x27;a&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>集合添加元素是使用集合内的函数来实现的，<b>值得注意的是</b>，如果元素已经存在，那么集合不会进行任何操作。</p>
</blockquote>
</li>
</ul>
<p><b>注意：</b>要创建空集合只能用<code>set()</code>，直接用大括号会创建出一个空字典。</p>
<ul>
<li><b>.update()</b><blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">set</span>((<span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;have&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">a.update([<span class="number">1</span>, <span class="number">3</span>],[<span class="number">2</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p><b>效果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1, 2, &#x27;have&#x27;, 3, 5, &#x27;a&#x27;, &#x27;I&#x27;, &#x27;apple&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p><code>update()</code>也是集合添加元素的一个函数，这个函数可以同时添加多个元素，且可以是其他类型的数据，如数组，元组等。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h5 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a><b>删除元素</b></h5><blockquote>
<ul>
<li><p><b>remove()</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">set</span>((<span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;have&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">a.remove(<span class="string">&#x27;I&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p><b>效果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;have&#x27;, &#x27;a&#x27;, &#x27;apple&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>删除时注意元素是否存在，不存在的话会发生错误。</p>
</blockquote>
</li>
<li><p><b>discard()</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">set</span>((<span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;have&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">a.discard(<span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">a.discard(<span class="string">&#x27;adsa&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p><b>效果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;apple&#x27;, &#x27;have&#x27;, &#x27;a&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>discard()</code>同样可以删除集合中的元素，且删除不存在的元素时不会报错。</p>
</blockquote>
</li>
<li><p><b>pop()</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">set</span>((<span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;have&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">a.pop()</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p><b>效果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;apple&#x27;, &#x27;I&#x27;, &#x27;have&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p><b>注意：</b>这个删除的随机删除的。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h5 id="清空集合"><a href="#清空集合" class="headerlink" title="清空集合"></a><b>清空集合</b></h5><blockquote>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">set</span>((<span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;have&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">a.clear()</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p><b>效果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set()</span><br></pre></td></tr></table></figure>
<p><code>clear()</code>这个函数可以将集合一键清空，留下一个空集合。</p>
</blockquote>
</blockquote>
<h5 id="判断元素是否存在于集合中"><a href="#判断元素是否存在于集合中" class="headerlink" title="判断元素是否存在于集合中"></a><b>判断元素是否存在于集合中</b></h5><blockquote>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">set</span>((<span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;have&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">test1 = <span class="string">&#x27;have&#x27;</span> <span class="keyword">in</span> a</span><br><span class="line">test2 = <span class="string">&#x27;pen&#x27;</span> <span class="keyword">in</span> a</span><br><span class="line"><span class="built_in">print</span>(test1)</span><br><span class="line"><span class="built_in">print</span>(test2)</span><br></pre></td></tr></table></figure>
<p><b>效果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a><b>字典</b></h4><h5 id="字典的定义"><a href="#字典的定义" class="headerlink" title="字典的定义"></a><b>字典的定义</b></h5><blockquote>
<p>python最后一种数据类型就是字典了，字典类型分为两部分：键 - 值</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;x1&#x27;</span>, <span class="string">&#x27;y&#x27;</span>: <span class="string">&#x27;123&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&#x27;x&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p><b>效果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;x&#x27;: &#x27;x1&#x27;, &#x27;y&#x27;: &#x27;123&#x27;&#125;</span><br><span class="line">x1</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>字典中每个<b>键值对</b>用<code>:</code>分割，每个对之间用<code>，</code>分割</li>
<li>字典中冒号<code>：</code>左边的称为键，右边称为值，其中键、值的数据类型可以不一致。</li>
<li>键的值必须是唯一的，但是值不需要。</li>
<li>直接用<code>a=&#123;&#125;</code>就可以创建一个空字典了<br>字典的一个特征是大括号、冒号。<br><b>补充：</b>字典的键只能是一个单词或数字或字母，值可以是任何的数据类型</li>
</ul>
</blockquote>
<h5 id="字典的访问"><a href="#字典的访问" class="headerlink" title="字典的访问"></a><b>字典的访问</b></h5><blockquote>
<ul>
<li><p>直接根据字典的变量名进行访问，即</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">message =&#123;&#125;</span><br><span class="line"></span><br><span class="line">name = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">keys = <span class="number">12</span></span><br><span class="line"></span><br><span class="line">message[<span class="string">&#x27;name&#x27;</span>] = name</span><br><span class="line">message[<span class="string">&#x27;age&#x27;</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">message[<span class="string">&#x27;orther&#x27;</span>] = [<span class="string">&#x27;None&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure>
<p><b>结果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;name&#x27;: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], &#x27;age&#x27;: [1, 2, 3, 4, 5], &#x27;orther&#x27;: [&#x27;None&#x27;]&#125;</span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><b>利用关键字进行访问</b></p>
<blockquote>
<p>访问字典主要有两个关键字，<code>keys</code>与<code>values</code>，以<code>keys</code>为例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">message =&#123;&#125;</span><br><span class="line">name = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">keys = <span class="number">12</span></span><br><span class="line">message[<span class="string">&#x27;name&#x27;</span>] = name</span><br><span class="line">message[<span class="string">&#x27;age&#x27;</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">message[<span class="string">&#x27;orther&#x27;</span>] = [<span class="string">&#x27;None&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(message)</span><br><span class="line"><span class="built_in">print</span>(message.keys())</span><br></pre></td></tr></table></figure>
<p><b>结果</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;name&#x27;: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], &#x27;age&#x27;: [1, 2, 3, 4, 5], &#x27;orther&#x27;: [&#x27;None&#x27;]&#125;</span><br><span class="line">dict_keys([&#x27;name&#x27;, &#x27;age&#x27;, &#x27;orther&#x27;])</span><br></pre></td></tr></table></figure>
<p><b>补充：</b>将数据放入字典后，数据类型也会变化，<code>keys</code>会变为dict_keys，<code>values</code>会变为dict_values。</p>
</blockquote>
</li>
<li><p><b>根据键值进行访问</b></p>
<blockquote>
<p>就像查字典一样，我们可以根据字典的键来查找对应的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">message =&#123;&#125;</span><br><span class="line">name = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">keys = <span class="number">12</span></span><br><span class="line">message[<span class="string">&#x27;name&#x27;</span>] = name</span><br><span class="line">message[<span class="string">&#x27;age&#x27;</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">message[<span class="string">&#x27;orther&#x27;</span>] = [<span class="string">&#x27;None&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(message[<span class="string">&#x27;name&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p><b>结果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</blockquote>
<h5 id="字典添加键-值对"><a href="#字典添加键-值对" class="headerlink" title="字典添加键-值对"></a><b>字典添加键-值对</b></h5><blockquote>
<p>字典是一种动态结构，可随时在其中添加键-值对。具体方法：字典名[‘键’] &#x3D; 值，如</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">message =&#123;&#125;</span><br><span class="line">name = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">message[<span class="string">&#x27;name&#x27;</span>] = name</span><br></pre></td></tr></table></figure>
<p><b>效果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;name&#x27;: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><b>补充：</b>当然键与值都可以是变量，<b>另外，字典中键不支持直接修改，而值的修改与定义类似，也是根据键来进行修改。</b></p>
</blockquote>
<h5 id="字典中键-值对的删除"><a href="#字典中键-值对的删除" class="headerlink" title="字典中键-值对的删除"></a><b>字典中键-值对的删除</b></h5><blockquote>
<p>对于字典中不再需要的信息，可使用del 语句将相应的键—值对彻底删除。使用<code>del</code>语句时，必须指定字典名和要删除的键。</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">message =&#123;&#125;</span><br><span class="line">name = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">key = <span class="string">&#x27;age&#x27;</span></span><br><span class="line">message[<span class="string">&#x27;name&#x27;</span>] = name</span><br><span class="line">message[key] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">message[<span class="string">&#x27;orther&#x27;</span>] = [<span class="string">&#x27;None&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(message)</span><br><span class="line"><span class="keyword">del</span> message[<span class="string">&#x27;orther&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure>
<p><b>结果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;name&#x27;: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], &#x27;age&#x27;: [1, 2, 3, 4, 5], &#x27;orther&#x27;: [&#x27;None&#x27;]&#125;</span><br><span class="line">&#123;&#x27;name&#x27;: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], &#x27;age&#x27;: [1, 2, 3, 4, 5]&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a><b>补充</b></h5><blockquote>
<ul>
<li><p>字典可以做出一个类似对象的东西，如</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;name&#x27;: &#x27;Alex&#x27;, &#x27;age&#x27;: 19, &#x27;skill&#x27;: [&#x27;python&#x27;, &#x27;ML&#x27;, &#x27;NLP&#x27;]&#125;</span><br></pre></td></tr></table></figure>
<p>上面就定义了一个人的对象。</p>
</blockquote>
</li>
<li><p>字典还可以通过嵌套生成一个树形结构。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;ltree&#x27;: &#123;&#x27;lnode&#x27;: 12, &#x27;rnode&#x27;: 22&#125;, &#x27;rtree&#x27;: 19&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>字典所有键-值对的同时遍历</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">message =&#123;&#125;</span><br><span class="line">message[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;Alex&#x27;</span></span><br><span class="line">message[<span class="string">&#x27;age&#x27;</span>] = <span class="number">19</span></span><br><span class="line">message[<span class="string">&#x27;skill&#x27;</span>] = [<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;ML&#x27;</span>, <span class="string">&#x27;NPL&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> message.items():</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;key:&#x27;</span>, key)</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;value:&#x27;</span>, value)</span><br></pre></td></tr></table></figure>
<p><b>结果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key: name</span><br><span class="line">value: Alex</span><br><span class="line">key: age</span><br><span class="line">value: 19</span><br><span class="line">key: skill</span><br><span class="line">value: [&#x27;python&#x27;, &#x27;ML&#x27;, &#x27;NPL&#x27;]</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言基础</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>SVM算法</title>
    <url>/2021/02/18/SVM%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h4 id="SVM的介绍"><a href="#SVM的介绍" class="headerlink" title="SVM的介绍"></a><b>SVM的介绍</b></h4><blockquote>
<ul>
<li>SVM全程为Support Vector Machine,中文名为支持向量机，是一种监督学习的算法。</li>
<li>在机器学习中，SVM算法说白了就是通过训练样本与算法划出一条线，用这条线进行分类。（其实绝大多数都是这样做的）</li>
<li>SVM算法的最大优点是可以应用在训练样本点较少的训练集上。<br><b>支持向量机的结构图：</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/SVM/SVM%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="SVM的结构" title="结构图"><br>SVM分为<b>线性SVM</b>和<b>非线性SVM</b></li>
</ul>
</blockquote>
<h4 id="线性SVM"><a href="#线性SVM" class="headerlink" title="线性SVM"></a><b>线性SVM</b></h4><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/SVM/%E7%BA%BF%E6%80%A7SVM.jpg" alt="线性SVM" title="线性SVM"></p>
<ul>
<li><b>注释：</b><blockquote>
<ul>
<li>SVM就是要找一条线（或平面、超平面）将样本点分开从而达到分类目的。</li>
<li>这条线（或平面、超平面）上下移动时，接触到的第一个样本点称为<b>支持向量</b>。</li>
<li>两个支持向量之间的距离称为<b>间距d</b>。</li>
<li>SVM的目的就是求d的最大值。</li>
</ul>
</blockquote>
</li>
<li><b>线性SVM的优化问题：</b><blockquote>
<p><b>最小化：</b>$\frac{1}{2}||\omega||^2$<br><b>限制条件：</b>$y_i[{\omega}^TX_i+b]&gt;&#x3D;1$(i&#x3D;1～N)</p>
</blockquote>
</li>
</ul>
</blockquote>
<p><b>以下是该优化问题的推导：</b></p>
<blockquote>
<p>首先是两个事实：</p>
<ul>
<li><b>事实1：</b><blockquote>
<p>设一平面为：${\omega}_1x+{\omega}_2y+b&#x3D;0$,一个点为：$(x_0,y_0)$<br>则点$(x_0,y_0)$到该平面的距离为：$d&#x3D;\frac{|{\omega}_1x+{\omega}_2y+b|}{\sqrt[]{\omega^2_1+\omega^2_2}}$</p>
</blockquote>
</li>
<li><b>事实2：</b><blockquote>
<p>$\omega^TX+b&#x3D;0$与$a\omega^TX+ab&#x3D;0$是同一个平面。（$a{\in}R^+$）<br>$({\omega},b)$满足公式：$y_i[{\omega}^TX_i+b]&gt;&#x3D;1$,那么$(a\omega,ab)$也满足该公式。<br>还有两个定义：<br><b>函数距离：</b><br>$$y_i(\omega^T X + b)$$<br><b>集合距离：</b><br>$$\frac{\omega^TX+b}{||\omega||}$$</p>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<p><b>推导:</b></p>
<blockquote>
<ul>
<li>由事实1可得到<b>向量$X_0$</b>到<b>超平面$\omega^TX+b&#x3D;0$</b>的距离为：(注：$X_0$为支持向量)<br>$d&#x3D;\frac{|\omega^TX_0+b|}{||\omega||}$(其中$||\omega||$为$\omega$的$L_2$范数)</li>
<li>然后，根据事实2，<b>用a来缩放</b>$(\omega,b)$,使得$(\omega,b)—&gt;(a\omega,ab)$<br>最终使在支持向量$X_0$上有：$|\omega^TX_0+b|&#x3D;1$<br>即，$d&#x3D;\frac{1}{||\omega||}$</li>
<li>要求$d&#x3D;\frac{1}{||\omega||}$的<b>最大值</b>，所以此时目标变为<b>求$||\omega||$的最小值</b>（带个$\frac{1}{2}$是为了以后好计算）</li>
<li>同样，限制条件$y_i[{\omega}^TX_i+b]&gt;&#x3D;1$(i&#x3D;1～N)中大于等于1的原因：<br>因为离线段最近的<b>支持向量</b>$X_0$的$|\omega^TX_0+b|&#x3D;1$,所以对于其他点来说，$\omega$不能变，那么只能$|\omega^TX_0+b|&gt;1$了<br>所以就有了限制条件$|\omega^TX_0+b|&gt;&#x3D;1$</li>
</ul>
</blockquote>
</blockquote>
<h4 id="非线性SVM"><a href="#非线性SVM" class="headerlink" title="非线性SVM"></a><b>非线性SVM</b></h4><blockquote>
<ul>
<li>对于一些简单的样本可以很明显地就用一条直线将样本分开两类，而一些用一条直线是无论如何都不可能划分的，如：<br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/SVM/%E9%9D%9E%E7%BA%BF%E6%80%A7SVM%E9%97%AE%E9%A2%98.png" alt="非线性SVM" title="非线性SVM"></li>
<li>对于非线性的SVM问题，如果还是用上面的线性模型来解，是求不出解的，所以要对其进行改造。<blockquote>
<p><b>最小化：</b>$\frac{1}{2}||\omega||^2+C\sum^N_{i&#x3D;1}\xi_i$<br><b>限制条件：</b></p>
<blockquote>
<ul>
<li>$y_i[\omega^TX_i+b]&gt;&#x3D;1-\xi_i$</li>
<li>$\xi_i&gt;&#x3D;0$</li>
</ul>
</blockquote>
</blockquote>
</li>
</ul>
<p><b>已知的量：</b>$X_i,y_i,C$<br><b>未知的量：</b>$\omega,b,\xi$</p>
<ul>
<li>其中，$\xi$称为<b>松弛变量</b>，C是<b>事先设好的参数</b>，C主要用于限制松弛变量。</li>
<li>$C\sum^N_{i&#x3D;1}\xi_i$称为<b>正则项</b>，正则项的作用主要是使目标函数规范化，使原本无解的函数有解。</li>
</ul>
</blockquote>
<h4 id="高维映射："><a href="#高维映射：" class="headerlink" title="高维映射："></a><b>高维映射：</b></h4><blockquote>
<ul>
<li>$X$(低维)$—&gt;\phi(x)$(高维)</li>
<li>当在SVM问题中划不出一条直线将样本分开时，可以将样本的特征维数升高，从而在高维处用超平面将样本分开。<br><b>例如：异或问题</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/SVM/SVM%E5%BC%82%E6%88%96%E9%97%AE%E9%A2%98.jpg" alt="异或问题" title="异或问题"><br>A&#x3D;$\begin{bmatrix}{0}\\{1}\end{bmatrix}$，B&#x3D;$\begin{bmatrix}{1}\\{1}\end{bmatrix}$，C&#x3D;$\begin{bmatrix}{0}\\{0}\end{bmatrix}$，D&#x3D;$\begin{bmatrix}{1}\\{0}\end{bmatrix}$<br><b>设一个高维映射</b>$X—&gt;\phi(x)$&#x3D;&gt;$\begin{bmatrix}{a}\\{b}\end{bmatrix}$—&gt;$\begin{bmatrix}{a^2}\\{b^2}\\{a}\\{b}\\{ab}\end{bmatrix}$<br>A&#x3D;$\begin{bmatrix}{0}\\{1}\end{bmatrix}$—&gt;$\phi(A)$&#x3D;$\begin{bmatrix}{0}\\{1}\\{0}\\{1}\\{0}\end{bmatrix}$，B&#x3D;$\begin{bmatrix}{1}\\{1}\end{bmatrix}$—&gt;$\phi(B)&#x3D;\begin{bmatrix}{1}\\{1}\\{1}\\{1}\\{1}\end{bmatrix}$<br>C&#x3D;$\begin{bmatrix}{0}\\{0}\end{bmatrix}$—&gt;$\phi(C)$&#x3D;$\begin{bmatrix}{0}\\{0}\\{0}\\{0}\\{0}\end{bmatrix}$，D&#x3D;$\begin{bmatrix}{1}\\{0}\end{bmatrix}$—&gt;$\phi(B)&#x3D;\begin{bmatrix}{1}\\{0}\\{1}\\{0}\\{0}\end{bmatrix}$<br><b>目的：</b>找出一个$\omega$和b来使$A,D$和$,C$分开。（此时的$\omega$的维度升高了，b依旧是一个常数）<br>使下式得以满足，$y_i[\omega^TX_i+b]&gt;&#x3D;1-\xi_i$—&gt;$y_i[\omega^T\phi(X_i)+b]&gt;&#x3D;1-\xi_i$<br>解出一个答案，$\omega&#x3D;\begin{bmatrix}{-1}\\{-1}\\{-1}\\{-1}\\{6}\end{bmatrix}$和$b&#x3D;1$</li>
<li>$\omega^T\phi(A)+b&#x3D;-1$</li>
<li>$\omega^T\phi(B)+b&#x3D;3$</li>
<li>$\omega^T\phi(C)+b&#x3D;1$</li>
<li>$\omega^T\phi(D)+b&#x3D;-1$<br>明显A，D是一类，而B，C又是另一类，所以在高维上就解出了这个分类问题。</li>
</ul>
<p><b>特点：</b>在高维映射中，维度越高，数据分开的概率就越高。</p>
<ul>
<li>因此如果我们将维度提升到<b>无限维</b>，那么数据分开的概率就会提升到1。</li>
<li>但是我们不可能写出这个向量，也不可能解出这个向量。</li>
<li>此时，我们只需要知道一个<b>核函数</b>，<br>$$K(X_1,X_2)&#x3D;\phi(X_1)^T\phi(X_2)$$<br>那么该优化式依然可解。</li>
<li>当然，要使该核函数成立需要以下条件：<blockquote>
<ul>
<li>$K(X_1,X_2)&#x3D;K(X_2,X_1)$</li>
<li>$\forall{C_i},{X_i}(i&#x3D;1～N)$有，$\sum_{i&#x3D;1}^{N}\sum_{j&#x3D;1}^{N}C_iC_jK(X_i,X_j)&gt;&#x3D;0$ (其中C为常数，X为向量)</li>
</ul>
</blockquote>
</li>
</ul>
<p><b>常用核函数：</b></p>
<blockquote>
<p><b>线性核：</b>$K(x_i,x_j)&#x3D;x^T_ix_j$</p>
<ul>
<li><b>多项式核:</b>$K(x_i,x_j)&#x3D;(x^T_ix_j)^d$（d&gt;&#x3D;1为多项式的次数）</li>
<li><b>高斯核：</b>$K(x_i,x_j)&#x3D;e^{-\frac{|x_i-x_j|^2}{2\sigma^2}}$ ($\sigma$&gt;0为高斯核的带宽)<br><b>拉普拉斯核：</b>$K(x_i,x_j)&#x3D;e^{-\frac{|x_i-x_j|}{\sigma}}$ ($\sigma$&gt;0)<br><b>Sigmoid:</b>$K(x_i,x_j)&#x3D;tanh(\beta{x_i}^Tx_j+\theta)$ (tanh为双曲正切函数，$\beta$&gt;0,$\theta$&lt;0)</li>
</ul>
</blockquote>
<p><b>其中带点的是最常用的核函数</b></p>
</blockquote>
<h4 id="SVM优化问题的解"><a href="#SVM优化问题的解" class="headerlink" title="SVM优化问题的解"></a><b>SVM优化问题的解</b></h4><blockquote>
<p>首先,现在<b>原问题</b>为：<br><b>最小化：</b>$\frac{1}{2}||\omega||^2+C\sum^N_{i&#x3D;1}\xi_i$<br><b>限制条件：</b></p>
<blockquote>
<ul>
<li>$y_i[\omega^T\phi(X_i)+b]&gt;&#x3D;1-\xi_i$</li>
<li>$\xi_i&gt;&#x3D;0$</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<p>对$\xi_i$进行改动，那么上面原问题的式子就会变为：<br><b>最小化：</b>$\frac{1}{2}||\omega||^2-C\sum^N_{i&#x3D;1}\xi_i$<br><b>限制条件：</b></p>
<blockquote>
<ul>
<li>$1+\xi_i-y_i[\omega^T\phi(X_i)+b]&lt;&#x3D;0$</li>
<li>$\xi_i&lt;&#x3D;0$</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<p>那么该原问题的<b>对偶问题</b>为：（原问题与对偶问题的关系详情见<a href="/blog/public/2021/02/19/%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA/index.html">这里</a>）<br><b>最大化：</b>$\theta(\alpha,\beta)&#x3D;inf[L(\omega,\xi_i,b)]$<br>而$L(\omega,\xi_i,b)&#x3D;\frac{1}{2}|\omega|^2-C\sum^N_{i&#x3D;1}\xi_i+\sum^N_{i&#x3D;1}\beta_i\xi_i+\sum^N_{i&#x3D;1}\alpha_i[1+\xi_i-y\omega^T\phi(X_i)-y_ib]$<br><b>限制条件：</b>$\alpha_i&gt;&#x3D;0$,$\beta_i&gt;&#x3D;0$(i&#x3D;1～N)</p>
<blockquote>
<p><b>标准公式与原问题进行比较：</b><br><b>标准公式：</b>$$L(\omega,\alpha,\beta)&#x3D;f(\omega)+\sum^K_{i&#x3D;1}{\alpha}{g_i(\omega)}+\sum^M_{i&#x3D;1}\beta_ih_i(\omega)$$</p>
<p><b>要解的公式：</b>$$L(\omega,\xi_i,b)&#x3D;\frac{1}{2}|\omega|^2-C\sum^N_{i&#x3D;1}\xi_i+\sum^N_{i&#x3D;1}\beta_i\xi_i+\sum^N_{i&#x3D;1}\alpha_i[1+\xi_i-y\omega^T\phi(X_i)-y_ib]$$</p>
<ul>
<li>因此，$\frac{1}{2}|\omega|^2-C\sum^N_{i&#x3D;1}\xi_i$，对应标准公式中的$f(\omega)$</li>
<li>$1+\xi_i-y\omega^T\phi(X_i)-y_ib$和$\xi_i$，对应标准公式中的$g_i(\omega)$</li>
<li>$\alpha_i,\beta_i$，对应标准公式中的$\alpha_i$</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<p>由上可知，现在<b>原问题</b>转变成了对应的<b>对偶问题</b>。<br>那么$inf[L(\omega,\xi_i,b)]$就是对$L(\omega,\xi_i,b)$求最小值，那么有，<br>$$\frac{\partial L}{\partial\omega}&#x3D;0 &#x3D;&gt; \omega&#x3D;\sum^N_{i&#x3D;1}\alpha_iy_i\phi(x_i)$$</p>
<p>$$\frac{\partial L}{\partial\xi_i}&#x3D;0 &#x3D;&gt; -C+\beta_i+\alpha_i&#x3D;0 &#x3D;&gt; \beta_i+\alpha_i&#x3D;C$$</p>
<p>$$\frac{\partial L}{\partial b}&#x3D;0 &#x3D;&gt; \sum^N_{i&#x3D;1}\alpha_iy_i&#x3D;0$$</p>
<p>接着将以上三项代回$L(\omega,\xi_i,b)$，化简可得：</p>
<blockquote>
<p>$$L(\omega,\xi_i,b)&#x3D;-\frac{1}{2}\sum^N_{i&#x3D;1}\sum^N_{j&#x3D;1}\alpha_i\alpha_jy_iy_jk(X_i,X_j)+\sum^N_{i&#x3D;1}\alpha_i$$</p>
</blockquote>
</blockquote>
<blockquote>
<p>此时，问题化为：（其中<b>已知变量</b>为$y_iy_j$以及$k(X_i,X_j)$，<b>未知变量</b>为所有$\alpha$）</p>
<blockquote>
<p><b>最大化：</b>$\theta(\alpha)&#x3D;\sum^N_{i&#x3D;1}\alpha_i-\frac{1}{2}\sum^N_{i&#x3D;1}\sum^N_{j&#x3D;1}\alpha_i\alpha_jy_iy_jk(X_i,X_j)$<br><b>限制条件：</b></p>
<blockquote>
<ul>
<li>$0&lt;&#x3D;\alpha_i&lt;&#x3D;C$ （这个由$\alpha_i&gt;&#x3D;0,\beta_i&gt;&#x3D;0,\beta_i+\alpha_i&#x3D;C$整合而来）</li>
<li>$\sum^N_{i&#x3D;1}\alpha_iy_i&#x3D;0$</li>
</ul>
</blockquote>
</blockquote>
<p>这个凸函数可以用<a href="/2021/03/03/SMO%E7%AE%97%E6%B3%95/index.html">SMO算法</a>求解出$\alpha$</p>
</blockquote>
<blockquote>
<p><b>求解$\omega$与$b$</b><br><b>求$\omega$</b></p>
<ul>
<li>对于分类问题，我们只需要求出$\omega^T\phi(X)+b$的值即可，所以求出$\omega^T\phi(X)$也是可以的，</li>
<li>其中$\omega&#x3D;\sum^N_{i&#x3D;1}\alpha_iy_i\phi(x_i)$，所以$\omega^T\phi(X)&#x3D;\sum^N_{i&#x3D;1}\alpha_iy_ik(X_i,X)$</li>
</ul>
<p><b>求$b$</b></p>
<ul>
<li>由KKT条件得，<blockquote>
<ul>
<li>要么$\beta_i&#x3D;0$，要么$\xi_i&#x3D;0$ </li>
<li>要么$\alpha_i&#x3D;0$，要么$1+\xi_i-y_i[\omega^T\phi(x_i)+b]&#x3D;0$<br>$b&#x3D;\frac{1-y_i\omega^T\phi(x_i)}{y_i}&#x3D;\frac{1-y_i\sum^N_{j&#x3D;1}\alpha_jy_ik(x_i,x_j)}{y_i}$</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>深渊巨坑</tag>
        <tag>机器学习</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-用户输入和循环语句</title>
    <url>/2021/08/30/Python-%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E5%92%8C%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h4 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a><b>用户输入</b></h4><blockquote>
<p>在Python中用户输入的功能是由<code>input()</code>函数提供的。<br>input函数可以让程序暂停运行，等待用户输入一些文本，获取的文本都会存储在变量中。</p>
<ul>
<li><b>input函数的形式</b><blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = <span class="built_in">input</span>(<span class="string">&#x27;name:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure>
<p><b>结果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name:Alex</span><br><span class="line">Alex</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<p><b>补充：</b></p>
<blockquote>
<ul>
<li>input()中的括号可以放字符串，放进去后的效果就是相当于多了一个不换行的print()函数</li>
<li>input()中的括号还可以放入变量，然后input()会默认输出变量后要求用户输入。</li>
<li>值得注意的是，<code>input()</code>输入的任何东西都是字符串类型的数据，如果要输入数字类型，需要进行数字类型的转换。</li>
</ul>
</blockquote>
</blockquote>
<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a><b>for循环</b></h4><blockquote>
<p>基本形式：<code>for i in x:</code></p>
<ul>
<li>其中x是一个一维的线性表(可以是列表、字典、集合等等)，如果是二维数据a[m][n]，x就会是一个a[m]的数组，其中每一个元素都是a中一行的数据。</li>
<li>i则是x中的一个个的元素，如果x是二维表，那么i就是x中一整行的数据。<br><b>例子：</b><blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;s&#x27;</span>],[<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;r&#x27;</span>]]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a :</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;x=&#x27;</span>,i)</span><br></pre></td></tr></table></figure>
<p><b>结果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x= [&#x27;a&#x27;, &#x27;1&#x27;, &#x27;s&#x27;]</span><br><span class="line">x= [&#x27;c&#x27;, &#x27;e&#x27;, &#x27;r&#x27;]</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<p><b>补充：</b><code>range(start,end,step)</code>函数在循环中用得很多,其中start为起始值，默认从0开始，end为结束值需要自己设置，step为步长，默认为1。这个函数可以生成一个[start,end)的数组。</p>
</blockquote>
<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a><b>while循环</b></h4><blockquote>
<p>基本形式：<code>while xxxxxx:</code><br>其中xxxxxx为循环结束的条件，只要它为真，循环就会一直持续下去，<br><b>例子：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line"><span class="keyword">while</span> a&gt;<span class="number">0</span>:</span><br><span class="line">   a -= <span class="number">1</span></span><br><span class="line">   <span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p><b>结果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>while</code>相较于<code>for</code>来说更容易陷入死循环，因此我们有时需要用到两个关键字:<code>break</code>和<code>continue</code></p>
<ul>
<li><p><b>break</b></p>
<blockquote>
<p><code>break</code>会强制退出当前的<b>一个</b>循环。</p>
</blockquote>
</li>
<li><p><b>continue</b></p>
<blockquote>
<p>用法与<code>break</code>相似，在每次循环中跳过<code>continue</code>后面的代码<b>一次</b></p>
</blockquote>
</li>
</ul>
<p><b>注意：</b><code>break</code>和<code>continue</code>同样使用与<code>while</code>和<code>for</code>循环中。</p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言基础</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-类</title>
    <url>/2021/09/01/Python-%E7%B1%BB/</url>
    <content><![CDATA[<h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a><b>类的定义</b></h4><blockquote>
<p>类在Python中与在C++一样，几乎可以模拟任何东西，同时也是用关键字<code>class</code>来定义：</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">       self.name = name</span><br><span class="line">       self.age = age</span><br><span class="line">       <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">pr</span>(<span class="params">self</span>):</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;name:&#x27;</span>, self.name.title())</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;age:&#x27;</span>, self.age)</span><br><span class="line">       <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   myDog = Dog(<span class="string">&#x27;hapi&#x27;</span>, <span class="number">10</span>)</span><br><span class="line">   myDog.pr()</span><br></pre></td></tr></table></figure>
<p><b>结果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name: Hapi</span><br><span class="line">age: 10</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h5 id="init-方法"><a href="#init-方法" class="headerlink" title="init()方法"></a><b><strong>init</strong>()方法</b></h5><blockquote>
<p>首先在python的类中定义的所有函数称为方法。<br><code>__init__()</code>类似于c++中的构造函数，在为一个类创建对象时会自动调用。<br>要注意的是，<code>__init()__</code>中必须要有<code>self</code>这个形参，并且它必须要在其它形参之前。它是一个指向示例本身的引用，从而让示例可以访问类中的属性与方法。<br><strong>init</strong>()方法可以为一个类设置默认值，修改默认值可以直接修改或者通过类的内置函数来修改。</p>
</blockquote>
<h5 id="类中属性与方法的调用"><a href="#类中属性与方法的调用" class="headerlink" title="类中属性与方法的调用"></a><b>类中属性与方法的调用</b></h5><blockquote>
<p>在python中类的属性与方法可以直接利用<code>.</code>进行调用，如</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">       self.name = name</span><br><span class="line">       self.age = age</span><br><span class="line">       <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">pr</span>(<span class="params">self</span>):</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;name:&#x27;</span>, self.name.title())</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;age:&#x27;</span>, self.age)</span><br><span class="line">       <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   myDog = Dog(<span class="string">&#x27;hapi&#x27;</span>, <span class="number">10</span>)</span><br><span class="line">   myDog.pr()</span><br></pre></td></tr></table></figure>
<p><b>结果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name: Hapi</span><br><span class="line">age: 10</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在类中可以用<code>self</code>来代替对象实例，在类之外可以用类名+<code>.</code>+属性或方法进行调用。</p>
</blockquote>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a><b>继承</b></h4><blockquote>
<p>继承机制可以让一些代码可以重用。<br>通过继承创建的新类称为子类或派生类，被继承的类称为基类、父类或超类。<br><b>继承语法：</b></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class 派生类名(基类名，基类名,...):</span><br></pre></td></tr></table></figure>
<p>继承可以让子类继承父类的所有属性与方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">       self.name = name</span><br><span class="line">       self.age = age</span><br><span class="line">       <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">pr</span>(<span class="params">self</span>):</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;name:&#x27;</span>, self.name.title())</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;age:&#x27;</span>, self.age)</span><br><span class="line">       <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EletricDog</span>(<span class="title class_ inherited__">Dog</span>):</span><br><span class="line">   Eletric = <span class="number">100</span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">changeName</span>(<span class="params">self</span>):</span><br><span class="line">       self.name = <span class="string">&#x27;EletricDog&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   myDog = EletricDog(<span class="string">&#x27;hapi&#x27;</span>, <span class="number">10</span>)</span><br><span class="line">   myDog.changeName()</span><br><span class="line">   myDog.pr()</span><br></pre></td></tr></table></figure>
<p><b>结果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name: Eletricdog</span><br><span class="line">age: 10</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如例子所示，子类中并没定义构造方法，也没定义<code>name</code>和<code>age</code>属性，但是通过继承可以获得父类的所有属性与方法。<br><b>注意：</b>当多继承时，如果不重写父类的构造方法，那么子类默认调用的是第一个父类的构造方法。</p>
</blockquote>
<h5 id="重写方法"><a href="#重写方法" class="headerlink" title="重写方法"></a><b>重写方法</b></h5><blockquote>
<ul>
<li><p><b>重写构造方法：</b></p>
<blockquote>
<ul>
<li><b>子类需要自动调用父类的方法：</b> 子类不重写__init__()方法，实例化子类后，会自动调用父类的__init__()的方法。</li>
<li><b>子类不需要自动调用父类的方法：</b>子类重写__init__()方法，实例化子类后，将不会自动调用父类的__init__()的方法。</li>
<li><b>子类重写__init__()方法又需要调用父类的方法：</b>使用super关键词：<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">super</span>(子类，self).__init__(参数<span class="number">1</span>，参数<span class="number">2</span>，....)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Father</span>):</span><br><span class="line"> <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):   </span><br><span class="line">   <span class="built_in">super</span>(Son, self).__init__(name)</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><b>重写父类的方法：</b></p>
<blockquote>
<p>在子类中直接重写一个与父类重名的函数即可，如</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">       self.name = <span class="string">&#x27;D&#x27;</span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">pr</span>(<span class="params">self</span>):</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;The father:&#x27;</span>, self.name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S</span>(<span class="title class_ inherited__">D</span>):</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">pr</span>(<span class="params">self</span>):</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;The son:&#x27;</span>, self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   a = S()</span><br><span class="line">   a.pr()</span><br></pre></td></tr></table></figure>
<p><b>结果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The son: D</span><br></pre></td></tr></table></figure></blockquote>
</blockquote>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言基础</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>中心极限定理</title>
    <url>/2021/03/14/%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h4 id="中心极限定理的客观背景："><a href="#中心极限定理的客观背景：" class="headerlink" title="中心极限定理的客观背景："></a><b>中心极限定理的客观背景：</b></h4><blockquote>
<p>在客观现实中有许多随机变量，它们都是由大量相互独立的<b>随机因素</b>的综合影响形成的，其中一些个别因素所起的作用都是微小的。这种随机变量往往服从<b>正态分布</b>。</p>
</blockquote>
<h4 id="独立同分布的中心极限定理："><a href="#独立同分布的中心极限定理：" class="headerlink" title="独立同分布的中心极限定理："></a><b>独立同分布的中心极限定理：</b></h4><blockquote>
<p>设随机变量$X_1,X_2,X_3,…,X_n$相互独立，服从同一分布，且具有数学期望和方差。<br>$E(X_k)&#x3D;\mu,D(X_k)&#x3D;\sigma^2$(k&#x3D;1,2,3,…)<br>则随机变量之和$\sum^n_{k&#x3D;1}X_k$的标准化变量：</p>
<p>$$Y_n&#x3D;\frac{\sum^n_{k&#x3D;1}X_k-E(\sum^n_{k&#x3D;1}X_k)}{\sqrt[]{D(\sum^n_{k&#x3D;1}X_k)}}&#x3D;\frac{\sum^n_{k&#x3D;1}X_k-n\mu}{\sqrt[]{n}\sigma}$$ </p>
<p>当n充分大时，近似地有<br>$$\frac{\sum^n_{k&#x3D;1}X_k-n\mu}{\sqrt[]{n}\sigma}～N(0,1)$$</p>
<p>或者说，当n充分大时，近似的有<br>$$\frac{\sum^n_{k&#x3D;1}X_k-n\mu}{\sqrt[]{n}\sigma}～N(n\mu,n\sigma^2)$$</p>
<p><b>结论：</b><br>由上式可得，无论随机变量$X_i$服从什么分布，且都具有有限的期望和方差，那么作为总和$\sum^n_{i&#x3D;1}X_i$这个随机变量，当n充分大时，那么可以近似看作正态分布。<br><b>例如：</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%A6%82%E7%8E%87%E8%AE%BA/%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86.png" alt="中心极限定理" title="中心极限定理"></p>
</blockquote>
]]></content>
      <categories>
        <category>数学基础</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title>传输层</title>
    <url>/2022/02/20/%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<h2 id="传输层提供的服务"><a href="#传输层提供的服务" class="headerlink" title="传输层提供的服务"></a>传输层提供的服务</h2><h3 id="传输层的功能"><a href="#传输层的功能" class="headerlink" title="传输层的功能"></a>传输层的功能</h3><blockquote>
<p>传输层向上面的应用层提供服务，它属于用户主机端才有的一个层次，也是用户主机中最低层。</p>
<p>传输层使用的传输单元：<strong>报文段</strong></p>
<p><strong>传输层的功能：</strong></p>
<blockquote>
<ul>
<li><p>传输层提供<strong>应用进程</strong>之间的逻辑通信（端到端的通信）；与网络层的区别是，网络层提供的是<strong>主机到主机</strong>之间的逻辑通信。（逻辑通信：传输层之间的通信好像是沿水平方向传送数据，但实际上这两个传输层之间并没有一条水平方向的物理连接。）</p>
</li>
<li><p><strong>复用和分用：</strong></p>
<blockquote>
<p>复用是指发送方<strong>不同的进程</strong>都可以<strong>使用同一个传输层协议</strong>传输数据；</p>
<p>分用是指接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的的应用进程。</p>
<p><strong>注意：</strong>网络层也有分用与复用，网络层的分用是指数据报在剥去首部后交给相应协议，复用是指不同协议的数据都可以封装成IP数据报发送出去。</p>
</blockquote>
</li>
<li><p>传输层还要对收到的报文进行差错检测（首部和<strong>数据部分</strong>）。网络层只能检验首部。</p>
</li>
<li><p>提供<strong>两种不同的传输协议</strong>，<strong>面向连接的TCP</strong>和<strong>无连接的UDP</strong>。网络层只能<strong>同时</strong>提供一种协议，要么只提供面向连接的服务（如虚电路），要么只提供无连接的服务（如数据报）</p>
</li>
</ul>
</blockquote>
</blockquote>
<h3 id="传输层的寻址和端口"><a href="#传输层的寻址和端口" class="headerlink" title="传输层的寻址和端口"></a>传输层的寻址和端口</h3><h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><blockquote>
<p>在一台主机上可以运行许多的进程。这里面又有相当多的进程会与其他主机上的进程进行通信，这时候就需要一个标识符进行区分不同的进程了。在传输层中，这个标识符就是端口号。</p>
<p><strong>注意：</strong>传输层使用的是<strong>软件端口</strong>，即应用层的各种协议进程与传输实体进行层间的一种地址（可以类比于网络层中的IP地址，数据链路层的MAC地址）；而路由器、交换机上的<strong>硬件端口</strong>与软件端口概念完全不一样。</p>
<p><strong>端口号：</strong></p>
<blockquote>
<p>端口号<strong>长度为16bit</strong>，能够表示<strong>65536</strong>个不同的端口号。</p>
<p>端口号只具有本地意义，即在不同主机上相同的端口号之间并无任何关系。</p>
</blockquote>
<p><strong>端口号的分类：</strong> </p>
<blockquote>
<ul>
<li><p><strong>服务器端使用的端口：</strong></p>
<blockquote>
<ul>
<li><strong>熟知端口号：</strong>数值为<strong>0~1023</strong>，是IANA（互联网地址指派机构）将这些端口号指派给TCP&#x2F;IP最重要的一些应用进程。</li>
<li><strong>登记端口号：</strong>数值为<strong>1024~49151</strong>，使用这类端口号必须在IANA登记，以防止重复。</li>
</ul>
<p><strong>一些常用的熟知端口号：</strong></p>
<table>
<thead>
<tr>
<th>应用程序</th>
<th>FTP</th>
<th>TELNET</th>
<th>SMTP</th>
<th>DNS</th>
<th>TFTP</th>
<th>HTTP</th>
<th>SNMP</th>
</tr>
</thead>
<tbody><tr>
<td>熟知端口号</td>
<td>21</td>
<td>23</td>
<td>25</td>
<td>53</td>
<td>69</td>
<td>80</td>
<td>161</td>
</tr>
</tbody></table>
</blockquote>
</li>
<li><p><strong>客户端使用的端口（短暂端口号&#x2F;临时端口号）：</strong>数值为<strong>49152~65535</strong>，这类端口号仅在客户进程运行时才<strong>动态分配</strong>，且在结束通信后，该端口号就会被回收等待分配。</p>
</li>
</ul>
</blockquote>
</blockquote>
<h4 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h4><blockquote>
<p>在网络中通过IP地址来标识和区别不同的主机，通过端口号来标识和区分一台主机上不同过的进程。因此将<strong>端口号拼接到IP地址上</strong>就可以构成<strong>套接字Socket</strong>，套接字实际上是一个通信端点，即<br>$$<br>套接字Socket &#x3D; (IP地址:端口号)<br>$$<br>套接字可以唯一标识网络中一台主机和其中的一个应用进程。</p>
</blockquote>
<h3 id="无连接服务与面向连接服务"><a href="#无连接服务与面向连接服务" class="headerlink" title="无连接服务与面向连接服务"></a>无连接服务与面向连接服务</h3><blockquote>
<p><strong>面向连接服务：</strong></p>
<blockquote>
<p>在通信双方进行通信之前，<strong>必须先建立连接</strong>，在通信过程中，整个连接的情况一直被<strong>实时地监控和管理</strong>，通信结束之后，主动<strong>释放这个连接</strong>。</p>
<p>面向连接的<strong>传输控制协议（TCP）</strong>是传输层向上提供的一条<strong>全双工的可靠逻辑信道</strong>。</p>
<p>TCP<strong>不提供广播或组播服务</strong>。</p>
<p>由于TCP提供面向连接的可靠传输服务，因此会增加许多的开销，如确认、流量控制、计时器及连接管理等。</p>
</blockquote>
<p><strong>无连接服务：</strong></p>
<blockquote>
<p>在两个实体之间的通信<strong>不需要先建立好连接</strong>，需要通信时直接将数据发送到“网络”中，让该信息尽可能地传输到目的地中。</p>
<p>无连接的<strong>用户数据报协议（UDP）</strong>是传输层向上提供的一条<strong>不可靠</strong>的逻辑信道。</p>
<p>它在IP之上仅提供两个附加服务：</p>
<blockquote>
<ul>
<li><strong>多路复用</strong></li>
<li><strong>对数据的差错检测</strong></li>
</ul>
</blockquote>
</blockquote>
<p><strong>补充：</strong></p>
<blockquote>
<p><strong>IP数据报和UDP数据报的区别：</strong></p>
<blockquote>
<ul>
<li>IP数据报在网络层需要经过路由器的存储转发；</li>
<li>UDP数据报是在传输层的端到端的逻辑信道中传输，封装成IP数据报在网络层传输时，UDP数据报对路由器来说是不可见的。</li>
</ul>
</blockquote>
<p><strong>TCP和网络层虚电路的区别：</strong></p>
<blockquote>
<ul>
<li>TCP报文段在传输层的逻辑信道中传输，对路由器是不可见的；虚电路所经过的交换节点都必须保存虚电路的状态信息。</li>
<li>在网络层如果采用了虚电路方式，就无法提供无连接服务；在传输层中TCP的使用并不影响网络层提供无连接服务。</li>
</ul>
</blockquote>
</blockquote>
</blockquote>
<h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><h3 id="UDP数据报"><a href="#UDP数据报" class="headerlink" title="UDP数据报"></a>UDP数据报</h3><blockquote>
<p><strong>UDP概述：</strong></p>
<blockquote>
<p>UDP仅在IP数据报服务之上增加了两个基本服务：<strong>分用复用</strong>和<strong>差错检测</strong>。使用UDP的话，应用程序几乎直接与IP打交道。</p>
<p><strong>UDP的优点：</strong></p>
<blockquote>
<ul>
<li><strong>无需建立连接：</strong>因此UDP不会引入建立连接的时延</li>
<li><strong>无连接状态：</strong>UDP无需维护连接状态，因此也无需跟踪一些参数，所以可以使得服务器支持更多的连接。</li>
<li><strong>分组首部开销小：</strong>TCP首部开销有20B，而UDP首部只有8B。</li>
<li><strong>应用层能更好地控制要发送的数据与发送时间：</strong>UDP没有拥塞控制，因此网络中的拥塞不会影响主机的发送效率。</li>
<li><strong>UDP支持一对一、一对多、多对多的交互通信</strong></li>
</ul>
</blockquote>
<p><strong>注意：</strong></p>
<blockquote>
<ul>
<li><strong>UDP虽然不提供可靠传输，但可以由应用层来完成数据传输的可靠性。</strong>（即由开发者在应用层来设计自己的可靠性机制）</li>
<li><strong>UDP是面向报文的：</strong>发送方UDP对应用层交付下来的报文，在添加首部后就直接下交给IP层，一次发送一个报文，<strong>既不合并，也不拆分，保留这些报文的边界；</strong>（报文的大小由应用层序来设计，应用程序会选择合适大小的报文）接收方UDP对IP层交上来的UDP数据报，在<strong>去除首部后原封不动地交给上层应用程序</strong>，因此在<strong>UDP中报文是不可分割</strong>的。</li>
</ul>
</blockquote>
</blockquote>
</blockquote>
<h3 id="UDP的首部格式"><a href="#UDP的首部格式" class="headerlink" title="UDP的首部格式"></a>UDP的首部格式</h3><blockquote>
<p>UDP数据报包含两部分：<strong>UDP首部</strong>和<strong>用户数据</strong>。UDP首部有<strong>8B</strong>，由4个字段组成，每个字段长度都是2B。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%BC%A0%E8%BE%93%E5%B1%82/UDP%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png" alt="UDP首部格式"></p>
<ul>
<li><strong>源端口号：</strong>在需要对方回复时选用，<strong>不需要时可以全0</strong>。</li>
<li><strong>目的端口号：</strong>在终点交付时必须使用到。</li>
<li><strong>长度：</strong>UDP数据报的长度（包括首部和数据部分），最小是8B（仅有首部）。</li>
<li><strong>校验和：</strong>检测UDP数据报在传输中是否出错，出错就丢弃。该字段<strong>可选</strong>，如果<strong>不需要的时候为全0</strong>。</li>
</ul>
<p><strong>UDP基于端口的分用：</strong></p>
<blockquote>
<ul>
<li>当传输层从IP层收到UDP数据报时，就根据首部中的目的端口，把UDP数据报通过相应的端口上交给应用进程。</li>
<li>如果发现报文中过的<strong>端口号不正确</strong>，那么就<strong>丢弃该报文，并由ICMP发送“端口不可达”的错误报文给发送方</strong></li>
</ul>
</blockquote>
</blockquote>
<h3 id="UDP校验"><a href="#UDP校验" class="headerlink" title="UDP校验"></a>UDP校验</h3><blockquote>
<p>在计算校验和的时候，需要在UDP数据报之前加入<strong>12B的伪首部</strong>，伪首部并不是UDP的真正首部，只是在计算校验和时，临时添加在UDP数据报前面。</p>
<p>UDP的校验和同时校验<strong>首部</strong>和<strong>数据部分</strong>。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%BC%A0%E8%BE%93%E5%B1%82/UDP%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E4%BC%AA%E9%A6%96%E9%83%A8.png" alt="UDP数据报的伪首部"></p>
<ul>
<li><strong>源IP地址：</strong>发送端的IP地址</li>
<li><strong>目的IP地址：</strong>接收端的IP地址</li>
<li><strong>0：</strong>8位的全0</li>
<li><strong>17：</strong>标识协议字段是17</li>
<li><strong>UDP长度：</strong>UDP首部加数据部分的长度（不包括伪首部）</li>
</ul>
<p><strong>例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%BC%A0%E8%BE%93%E5%B1%82/UDP%E6%A0%A1%E9%AA%8C%E5%92%8C%E8%AE%A1%E7%AE%97%E4%BE%8B%E5%AD%90.png" alt="UDP校验和计算例子"></p>
<p><strong>发送端：</strong></p>
<blockquote>
<ul>
<li>填上伪首部</li>
<li>校验和字段填充上全0</li>
<li>数据部分需要的话就补充0，使得整个UDP数据报是4字节的整数倍</li>
<li>伪首部+首部+数据部分求和</li>
<li>将求和结果取反码得到校验和</li>
</ul>
</blockquote>
<p><strong>接收端：</strong></p>
<blockquote>
<ul>
<li>填上伪首部</li>
<li>伪首部+首部+数据部分求和</li>
<li>将求和结果取反码得到校验结果</li>
<li><strong>如果全为1则无差错</strong>，否则<strong>丢弃</strong>或<strong>交给应用层并附上出错警告</strong></li>
</ul>
</blockquote>
</blockquote>
<p><strong>注意：</strong></p>
<blockquote>
<ul>
<li><strong>伪首部只是用于校验，并不会交给下层发送，也不会交给上层使用</strong></li>
<li>数据部分补充的0也只用于求校验和与校验结果，并不会交给下层发送，也不会交给上层使用</li>
<li>UDP的校验失败后有两种结果：<strong>丢弃、交给应用层并附上出错警告</strong></li>
<li>伪首部可以查到IP数据报的<strong>源IP地址</strong>与<strong>目的IP地址</strong></li>
</ul>
</blockquote>
</blockquote>
<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><h3 id="TCP协议的特点"><a href="#TCP协议的特点" class="headerlink" title="TCP协议的特点"></a>TCP协议的特点</h3><blockquote>
<ul>
<li><p>TCP是<strong>面向连接</strong>的传输层协议</p>
</li>
<li><p>每条TCP连接只能有两个端点，每条TCP连接只能是<strong>点对点</strong>的</p>
</li>
<li><p>TCP提供<strong>可靠的交付服务</strong>，保证传输的数据<strong>无差错、不丢失、不重复</strong>且<strong>有序</strong></p>
</li>
<li><p>TCP提供<strong>全双工通信</strong>，为此TCP连接两端设有<strong>发送缓存</strong>和<strong>接收缓存</strong></p>
<blockquote>
<ul>
<li><strong>发送缓存：</strong>应用程序发送给发送方TCP<strong>准备发送</strong>的数据、TCP<strong>已经发送但尚未收到确认</strong>的数据</li>
<li><strong>接收缓存：</strong> <strong>按序到达且未被接收</strong>程序读取的数据、<strong>不按序到达</strong>的数据</li>
</ul>
</blockquote>
</li>
<li><p>TCP是面向<strong>字节流</strong>的（即TCP传输时是逐个字节传送的）：TCP仅把应用程序交下来的数据仅看作一连串无结构的字节流</p>
</li>
</ul>
</blockquote>
<h3 id="TCP报文段"><a href="#TCP报文段" class="headerlink" title="TCP报文段"></a>TCP报文段</h3><blockquote>
<p>TCP传输的数据单元称为<strong>报文段</strong>。TCP报文段既可以用来运载数据，又可以用来<strong>建立连接、释放连接</strong>和<strong>应答</strong>。</p>
<p>整个TCP报文可以分成两个部分：<strong>首部</strong>、数据部分。其中首部中又有<strong>20B的固定部分</strong>，且<strong>首部的大小通常为4B的整数倍</strong>。</p>
<p><strong>TCP报文段：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP%E6%8A%A5%E6%96%87%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png" alt="TCP报文首部格式"></p>
<ul>
<li><strong>源端口：</strong>即源端口号，占2B</li>
<li><strong>目的端口：</strong>即目的端口号，占2B</li>
<li><strong>序号：</strong>占4B，范围是0~$2^{32}-1$。由于TCP是面向字节传输的，因此TCP传输过程中每个字节都需要给定一个序号。序号字段的<strong>含义</strong>是：<strong>本报文段所发送的数据的第一个字节的序号</strong>。如，一报文段序号字段为301，携带100B的数据，那么下一个报文的序号为401。</li>
<li><strong>确认号：</strong>占4B，用于<strong>确认报文</strong>的字段，是<strong>期望收到对方下一个报文段的第一个数据字节的序号</strong>，且<strong>确认号为N，那么意味着前N-1个字节都正确接收到了</strong>。如，B正确接收到了A发送的一个200B，序号字段为501的报文，那么B发送给A的确认号字段为701。</li>
<li><strong>数据偏移：</strong>占4位，指的是TCP报文<strong>数据起始处</strong>距离<strong>报文起始处</strong>有多远，实际上就是<strong>首部长度（包括长度可变的部分）</strong>，<strong>单位为4B</strong>，因此<strong>首部最长为60B</strong>。</li>
<li><strong>保留：</strong>占6位，保留为以后使用，目前全部置0</li>
<li><strong>URG（紧急位）：</strong>当URG&#x3D;1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，不需在缓存中排队，应尽快传输（相当于高优先级的数据）。URG需要和紧急指针配合使用，即数据从<strong>第一个字节到紧急指针所指的字节</strong>就是紧急数据。</li>
<li><strong>ACK（确认位）：</strong>仅当ACK&#x3D;1时确认号字段才有效，否则确认号字段无效。TCP规定，在建立连接后所有传送的报文段都必须把ACK置为1。</li>
<li><strong>PSH（推送位）：</strong>接收方TCP收到PSH&#x3D;1的报文段时，直接将该报文段交给进程，无需等到缓存满了再交</li>
<li><strong>RST（复位位）：</strong>RST&#x3D;1时，表明TCP连接中出现严重差错，必须释放连接，然后重新建立连接</li>
<li><strong>SYN（同步位）：</strong>SYN&#x3D;1表示这是一个<strong>连接请求</strong>或<strong>连接接受</strong>报文。当SYN&#x3D;1，ACK&#x3D;0的时候，表明这是一个连接请求报文，如果对方同意建立连接，则在响应报文中使用SYN&#x3D;1，ACK&#x3D;1</li>
<li><strong>FIN（终止位）：</strong>用来释放一个连接，当FIN&#x3D;1时，表明此报文段的发送方的数据已经发送完毕，并要求释放传输数据。</li>
<li><strong>窗口：</strong>占2B，范围是0~$2^{16}-1$。<strong>它表示现在允许对方发送的数据量</strong>。如，确认号是701，窗口字段为1000，这表明从701号开始，发送此报文段的发送方还有接收1000字节数据的接收缓存空间。</li>
<li><strong>校验和：</strong>占2B。<strong>校验和字段检验范围包括首部和数据两部分。</strong>在计算校验和时，和UDP的操作一致，也是要在TCP报文段前面加上12B的伪首部（唯一区别是伪首部的第4个字段的17改为6）.</li>
<li><strong>紧急指针：</strong>占2B。紧急指针只有在URG&#x3D;1时才有意义，它指出本报文段中紧急数据共有多少字节（紧急数据在报文段数据的最前面）</li>
<li><strong>选项：</strong>长度可变。最大报文段长度MSS（TCP报文段中的<strong>数据字段</strong>的最大长度）</li>
<li><strong>填充：</strong>为了使得首部长度是4B的整数倍。</li>
</ul>
</blockquote>
</blockquote>
<h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3><blockquote>
<p>TCP是面向连接的协议，因此每个TCP连接都有三个阶段：<strong>连接建立</strong>、<strong>数据传送</strong>和<strong>连接释放</strong>。</p>
<p>TCP连接管理就是是运输连接的建立和释放都能正常进行。</p>
<p>在TCP连接建立的过程中，都要解决以下问题：</p>
<blockquote>
<ul>
<li>要使每一方能够确知对方的存在</li>
<li>双方协商一些参数（如最大窗口数、是否使用窗口扩大选项、时间戳选项等）、</li>
<li>能够对运输实体资源（如缓存大小等）进行分配。</li>
</ul>
</blockquote>
<p>TCP连接的端口称为<strong>套接字</strong>或<strong>插口</strong>，每条TCP连接唯一地被通信的两个端点（套接字）确定。</p>
<p>TCP连接的建立采用<strong>客户&#x2F;服务器</strong>方式，主动发起连接建立的称为<strong>客户</strong>，等待被连接的称为<strong>服务器</strong>。</p>
<p><strong>TCP连接的建立：</strong></p>
<blockquote>
<p>TCP连接的建立过程又称为<strong>三次握手</strong>。</p>
<p><strong>过程图：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B.png" alt="TCP连接建立"></p>
<p><strong>三次握手：</strong></p>
<blockquote>
<ul>
<li><strong>第一步：</strong>客户机TCP首先向服务器TCP发送连接请求报文段。该报文段中同步位SYN设置为1，同时选择一个<strong>初始序号x</strong>（随机）。此时客户端进入<strong>SYN-SENT（同步已发送）状态</strong>。（本报文不携带应用层数据，但依旧需要消耗一个序号）</li>
<li><strong>第二步：</strong>服务器在收到连接请求报文后，如果同意建立连接，则向用户端<strong>发回确认</strong>，<strong>并为该TCP连接分配缓存和变量</strong>。在确认报文中，SYN和ACK都为1，<strong>确认号ack是x+1</strong>，同时也选择一个<strong>初始序号y</strong>（随机）。此时服务器进入<strong>SYN-RCVD（同步收到）状态</strong>。（本报文不携带应用层数据，但依旧需要消耗一个序号）。</li>
<li><strong>第三步：</strong>客户端收到确认报文后，还要向服务器端给出确认，并为该TCP连接分配缓存和变量。该报文中，ACK置为1，<strong>确认号ack置为y+1</strong>，<strong>序号为x+1</strong>。该报文可以携带应用层的数据，如果不携带则不消耗序号。此时客户端进入<strong>ESTABLISHED（已建立连接）状态</strong>。</li>
</ul>
</blockquote>
<p><strong>注意：</strong> <strong>服务器是在第二次握手时就分配连接资源，而客户端是在第三次握手才分配连接资源。</strong>因此可以通过多个客户端对服务器进行<strong>SYN洪泛攻击</strong>（即让服务器一直进行第二次握手，分配连接资源）。</p>
</blockquote>
</blockquote>
<p><strong>TCP连接的释放：</strong></p>
<blockquote>
<p>TCP连接释放又称<strong>四次握手</strong></p>
<p><strong>过程图：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP%E8%BF%9E%E6%8E%A5%E9%87%8A%E6%94%BE.png" alt="TCP连接释放"></p>
<ul>
<li><strong>第一步：</strong>客户机打算关闭连接时，停止发送数据并让其TCP发送连接释放报文段。该报文段的<strong>终止位FIN置1</strong>，<strong>序号为u</strong>。本报文段不携带数据，但也要占用一个序号。此时<strong>客户端进入FIN-WAIT-1（终止等待1）状态</strong>。（注意此时客户端不能再发送数据，但是<strong>对方依旧可以发送数据</strong>）</li>
<li><strong>第二步：</strong>服务器收到连接释放报文段后即发出确认，<strong>确认号为u+1</strong>，<strong>序号为v</strong>。然后<strong>服务器端进入CLOSE-WAIT（关闭等待）状态</strong>。此时<strong>从客户机到服务器这一条连接就断开了</strong>（即客户端无法向服务器发送数据），<strong>但服务器发送的数据客户端依旧要接收</strong>，TCP处于半关闭状态。</li>
<li><strong>第三步：</strong>服务器也发送完数据以后，就通知TCP释放连接，此时的报文段的<strong>FIN&#x3D;1</strong>，报文段的<strong>序号为w</strong>（这里假设第二步之后服务器依旧有数据发送），重复之前的<strong>确认号u+1</strong>。此时服务器进入<strong>LAST-ACK（最后确认）状态</strong>。</li>
<li><strong>第四步：</strong>客户端接收到连接释放报文后需要发送一个确认报文，该报文<strong>确认位ACK&#x3D;1</strong>，<strong>确认号为w+1</strong>，<strong>序号为u+1</strong>。此时TCP连接尚未释放，需要<strong>等待2MSL（最长报文段寿命）后，客户端进入CLOSED（连接关闭）状态</strong>。</li>
</ul>
</blockquote>
</blockquote>
<p><strong>总结：</strong></p>
<blockquote>
<ul>
<li><p><strong>连接建立（三次握手）：</strong></p>
<blockquote>
<ul>
<li><strong>SYN&#x3D;1，seq&#x3D;x</strong></li>
<li><strong>SYN&#x3D;1，ACK&#x3D;1，seq&#x3D;y，ack&#x3D;x+1</strong></li>
<li><strong>ACK&#x3D;1，seq&#x3D;x+1，ack&#x3D;y+1</strong></li>
</ul>
</blockquote>
</li>
<li><p><strong>释放连接（四次握手）：</strong> </p>
<blockquote>
<ul>
<li><strong>FIN&#x3D;1，seq&#x3D;u</strong></li>
<li><strong>ACK&#x3D;1，seq&#x3D;v，ack&#x3D;u+1</strong></li>
<li><strong>FIN&#x3D;1，ACK&#x3D;1，seq&#x3D;w，ack&#x3D;u+1</strong></li>
<li><strong>ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1</strong></li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<h3 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h3><blockquote>
<p>TCP的任务是在IP层的不可靠的基础上建立一种可靠的传输服务。</p>
<p>TCP的可靠传输：<strong>保证接收方接收到的数据与发送方发出的数据完全一致</strong>。</p>
<p>TCP使用<strong>检验、序号、确认</strong>和<strong>重传</strong>来确保可靠传输的实现，其中检验与UDP的校验一致。</p>
<p><strong>序号：</strong></p>
<blockquote>
<p>TCP首部的序号字段可以保证数据能够按序交给接收方的应用层，TCP是将数据看作一个无结构但有序的字节流，序号就是建立在字节流之上的。</p>
<p>TCP连接传输的字节流中<strong>一个字节就对应一个编号</strong>。<strong>序号字段对应的值是本报文段中第一个字节的序号</strong>。（即每一个报文段中可能有多个字节，那么就有多个序号，但是头部序号指的是报文中第一个字节的序号）。</p>
</blockquote>
<p><strong>确认：</strong></p>
<blockquote>
<p>TCP首部的<strong>确认号</strong>是期望收到<strong>对方的下一个报文段的数据的第一个字节的序号。</strong>例如，B收到序号为2的报文段，它期望下一个报文段的序号是3号，那么B给A发送的确认号就是3。</p>
<p>TCP默认使用累计确认，即<strong>TCP只确认数据流中第一个丢失字节的前一个字节</strong>。例如，B收到了A发送过的0<del>2及6</del>7的数据报，但丢失了3~5的数据报，那么B发回给A的确认号是3。</p>
</blockquote>
<p><strong>重传：</strong></p>
<blockquote>
<p> TCP出现重传主要是两个事件：<strong>超时</strong>和<strong>冗余ACK</strong></p>
<p><strong>超时：</strong>TCP每发送一个报文段都会为此设置一个计时器，当计时器归零以后仍未收到确认的时候，发送方就会重传这一报文。</p>
<p><strong>冗余ACK：</strong>指再次确认某个报文段的ACK，而发送方先前已经收到该报文段的确认。例如，发送方A向B发送数据报1，2，3，4，5，其中2号数据报丢失了。此时接收方B在接收完1号数据报后期待收到2号数据报，但实际上收到的是3，4，5号数据报，那么它就会向A连续发送<strong>3个1号数据报的冗余ACK</strong>，A在收到三个冗余ACK后就知道2号数据报丢失了，立即进行重传。这种技术也称为<strong>快速重传技术</strong>。</p>
</blockquote>
</blockquote>
<h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><blockquote>
<p>TCP流量控制是一个速度匹配服务，它用于消除发送方发送速率过快而导致接收方缓存区溢出的问题。</p>
<p><strong>过程：</strong></p>
<blockquote>
<p><strong>接收窗口(rwnd)：</strong>接收方根据自己接收缓存大小，动态地调整发送方的窗口，即<strong>TCP首部中的“窗口”字段</strong>。</p>
<p><strong>拥塞窗口(cwnd)：</strong>发送方根据当前网络拥塞程度的估计而确定的窗口值，其大小与网络中的<strong>带宽</strong>和<strong>时延</strong>相关。<br>$$<br>发送窗口上限&#x3D;min[rwnd,cwnd]<br>$$</p>
</blockquote>
<p><strong>例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.png" alt="TCP流量控制"></p>
</blockquote>
<p><strong>注意：</strong></p>
<blockquote>
<p>传输层和数据链路层都存在流量控制，<strong>传输层的流量控制</strong>是<strong>端到端</strong>之间的流量控制，<strong>数据链路层的流量控制</strong>是<strong>两个相邻结点</strong>（路由器等）之间的流量控制。<strong>数据链路层</strong>的<strong>滑动窗口大小不能改变</strong>，而<strong>传输层</strong>的滑动窗口是<strong>动态变化</strong>的。</p>
</blockquote>
</blockquote>
<h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><blockquote>
<p>拥塞控制是指防止过多的数据进入网络，保证网络中的路由器或链路不过载。</p>
<p>对通信连接来说，拥塞往往表现为<strong>通信时延的增加</strong>。</p>
<p><strong>拥塞控制与流量控制的区别：</strong></p>
<blockquote>
<ul>
<li>拥塞控制是一个<strong>全局性</strong>的过程，设计所有主机、所有的路由器。</li>
<li>流量控制是指<strong>点对点</strong>的通信量的控制，是端到端的问题。</li>
</ul>
<p>例如，某链路的传输带宽是10Gb&#x2F;s，A主机以1Gb&#x2F;s的速度向B主机发送，对于这样不需要拥塞控制，但接收方接收能力不足的话就需要<strong>流量控制</strong>；在相同的链路上有100万台主机以1Mb&#x2F;s的速度进行通信，那么就会出现拥塞，就需要<strong>拥塞控制</strong>。</p>
</blockquote>
<p><strong>拥塞控制的常用算法：</strong> <strong>慢开始</strong>、<strong>拥塞避免</strong>、<strong>快重传</strong>和<strong>快恢复</strong>。</p>
<p><strong>注意：</strong>以下讨论的情况都是一方发送数据，另一方仅发送确认；假设接收方的接收窗口足够大，发送方仅考虑cwnd。</p>
<p><strong>慢开始与拥塞避免：</strong></p>
<blockquote>
<p><strong>注意：</strong>拥塞控制中的单位是<strong>最大报文段（MSS）</strong>，而不是字节。</p>
<p><strong>图例：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%BC%A0%E8%BE%93%E5%B1%82/%E6%85%A2%E5%BC%80%E5%A7%8B%E5%92%8C%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D.png" alt="慢开始和拥塞避免"></p>
<p><strong>慢开始：</strong></p>
<blockquote>
<ul>
<li>发送方先将<strong>拥塞窗口cwnd</strong>设为1</li>
<li>发送方在接收到确认的时候将cwnd乘2</li>
<li>当cwnd超过<strong>开始门限ssthresh</strong>的时候就改成拥塞避免算法</li>
</ul>
</blockquote>
<p><strong>拥塞避免：</strong></p>
<blockquote>
<ul>
<li>每经过一个往返时延RTT就把发送方的拥塞窗口cwnd加1（加法增大）</li>
</ul>
</blockquote>
<p><strong>遇到拥塞的情况：</strong></p>
<blockquote>
<ul>
<li>当遇到拥塞的时候，cwnd重新置为1</li>
<li>开始门限ssthresh设置为<strong>网络拥塞时cwnd的一半</strong></li>
<li>重新使用慢开始算法</li>
</ul>
</blockquote>
<p><strong>补充：</strong>慢开始和拥塞控制两种算法一般都是混合使用的。</p>
</blockquote>
</blockquote>
<p><strong>快重传和快恢复：</strong></p>
<blockquote>
<p>快重传和快恢复算法是对慢开始和拥塞避免的改进。</p>
<p><strong>快重传：</strong></p>
<blockquote>
<p>与流量控制中的冗余ACK的快速重传一致，<strong>当发送方连续收到三个重复的ACK时，直接重传对方未收到的报文段，无需等待那个报文段的重传计时器超过</strong>。</p>
</blockquote>
<p><strong>快恢复：</strong></p>
<blockquote>
<ul>
<li>当发送方连续收到三个冗余ACK时，执行“乘法减小”算法，即把慢开始门限ssthresh设置为此时发送方cwnd的一半</li>
<li><strong>cwnd的值设置为ssthresh的值</strong></li>
<li>使用拥塞避免算法使cwnd缓慢地线性增大</li>
</ul>
</blockquote>
<p><strong>图例：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E4%BC%A0%E8%BE%93%E5%B1%82/%E5%BF%AB%E6%81%A2%E5%A4%8D%E5%9B%BE%E4%BE%8B.png" alt="快恢复图例"></p>
</blockquote>
<p><strong>与慢开始和拥塞避免的区别：</strong></p>
<blockquote>
<ul>
<li>使用快重传机制检测拥塞的发生</li>
<li>检测出现拥塞后，cwnd减小至原来的一半</li>
<li>除了一开始会使用慢开始以外，往后都不会出现慢开始算法</li>
</ul>
</blockquote>
</blockquote>
<p><strong>注意：</strong></p>
<blockquote>
<p>接收方的缓存空间是有限的，实际发送方窗口的实际大小是由<strong>流量控制</strong>和<strong>拥塞控制</strong>共同决定的。当同时出现<strong>接收窗口rwnd</strong>和<strong>拥塞窗口cwnd</strong>时，发送方的发送窗口大小取这两者之间的最小值。</p>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>基础学科</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理</title>
    <url>/2022/08/10/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="一、内存管理概念"><a href="#一、内存管理概念" class="headerlink" title="一、内存管理概念"></a>一、内存管理概念</h2><h3 id="1、内存管理的基本原理和要求"><a href="#1、内存管理的基本原理和要求" class="headerlink" title="1、内存管理的基本原理和要求"></a>1、内存管理的基本原理和要求</h3><blockquote>
<p><strong>内存管理：</strong>指操作系统对内存空间进行合理的划分和有计划的动态分配与回收。</p>
<p><strong>内存管理的功能：</strong></p>
<blockquote>
<ul>
<li><strong>内存空间的分配和回收</strong></li>
<li><strong>内存空间的扩充</strong></li>
<li><strong>地址转换</strong></li>
<li><strong>存储保护</strong></li>
</ul>
</blockquote>
</blockquote>
<h4 id="1-1、程序装入和链接"><a href="#1-1、程序装入和链接" class="headerlink" title="1.1、程序装入和链接"></a>1.1、程序装入和链接</h4><blockquote>
<p>​        创建进程的前提是要先将程序和数据装入内存。而将用户源程序转变为在内存中的可执行程序，需要以下步骤：</p>
<ul>
<li><strong>编译</strong>：由编译程序将用户源代码编译成若干目标模块</li>
<li><strong>链接：</strong>由链接程序将编译后的一组目标模块与所需要的库函数链接在一起，形成一个完整的装入模块</li>
<li><strong>装入：</strong>由装入程序将模块装入内存</li>
</ul>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E7%A8%8B%E5%BA%8F%E8%A3%85%E5%85%A5.png" alt="程序装入"></p>
<p>对于程序的<strong>链接</strong>，也有以下三种方法：</p>
<blockquote>
<ul>
<li><strong>静态链接：</strong>在程序运行前就将各目标模块及它们所需的库函数链接成一个完成的可执行文件，以后不再拆开（逻辑地址固定）</li>
<li><strong>装入时动态链接：</strong>在需要装入内存时，才使用边装入边链接的方式。</li>
<li><strong>运行时动态链接：</strong>对于目标模块的链接，只有在执行中需要用到该模块时才进行链接。</li>
</ul>
</blockquote>
<p>对于程序的<strong>装入</strong>，同样有以下三种方法：</p>
<blockquote>
<ul>
<li><p><strong>绝对装入</strong></p>
<blockquote>
<p>​        指在<strong>编译时</strong>就将程序中的的逻辑地址写成内存中的物理地址。即在绝对装入的程序中，逻辑地址就是运行时的物理地址。绝对装入由于灵活性差，只能用在单道程序环境中。</p>
</blockquote>
</li>
<li><p><strong>可重定位装入</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E9%9D%99%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D.png" alt="静态重定位"></p>
<p>​        又称<strong>静态重定位</strong>，指目标模块的初始地址都是从0开始的逻辑地址。在装入内存时，获得其物理起始地址后，再将其逻辑地址直接加上物理的起始地址。要求程序必须一次性装入内存，而且作业的存放地址是连续的。而且程序在装入内存后不可再移动，也不可再请求分配空间。</p>
</blockquote>
</li>
<li><p><strong>动态运行时装入</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D.png" alt="动态重定位"></p>
<p>​        也称<strong>动态重定位</strong>，目标模块的初始地址也都是从0开始的逻辑地址。在装入时，将其逻辑地址与<strong>重定位寄存器</strong>的值相加从而得到其真实的物理地址。这样一来程序的物理地址就由逻辑地址和重定位寄存器的值所决定，从而装入内存时的灵活性就大大地提高了。</p>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<h4 id="1-2、逻辑地址空间与物理地址空间"><a href="#1-2、逻辑地址空间与物理地址空间" class="headerlink" title="1.2、逻辑地址空间与物理地址空间"></a>1.2、逻辑地址空间与物理地址空间</h4><blockquote>
<ul>
<li><strong>逻辑地址空间：</strong>指在编译后，每个目标模块都是从0开始编址的，这些地址称为该目标模块的<strong>相对地址（逻辑地址）</strong>。当连接程序将各个模块链接成一个完整的可执行目标程序时，这时的可执行程序就构成了一个从0号单元开始编址的<strong>逻辑地址空间</strong></li>
<li><strong>物理地址空间：</strong>指内存中物理单元的集合，它是地址转换的最终地址，进程在运行时执行指令和访问数据时的地址。当装入程序通过地址转换<strong>将逻辑地址转换成物理地址</strong>，这个过程称为<strong>地址重定位</strong>。（其中程序员只能指定程序的逻辑地址，逻辑地址向物理地址的转换是操作系统完成的工作，对所有用户都是透明的）</li>
</ul>
</blockquote>
<h4 id="1-3、内存保护"><a href="#1-3、内存保护" class="headerlink" title="1.3、内存保护"></a>1.3、内存保护</h4><blockquote>
<p>​        指在分配内存前，需要保护操作系统不受用户进程影响，同时保护用户进程不会相互影响。内存保护可采取两种方式：</p>
<ul>
<li><p><strong>在CPU中设置一对上、下限寄存器：</strong>存放用户程序在内存中的上限地址和下限地址，当CPU在执行该程序需要访问一个地址时，分别于这两个寄存器的值进行比较，判断有无越界。（越界则抛出一个<strong>越界中断</strong>）</p>
</li>
<li><p><strong>采用重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）</strong>：重定位寄存器存放该程序的最小地址；而界地址寄存器存放的是该程序逻辑地址的最大值。当CPU在执行该程序需要访问一个地址时，判断该地址是否小于界地址寄存器的值，然后再加上重定位寄存器的值，最后再用该地址访问内存，即</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4.png" alt="重定位和内存保护"></p>
</li>
</ul>
</blockquote>
<h3 id="2、覆盖与交换"><a href="#2、覆盖与交换" class="headerlink" title="2、覆盖与交换"></a>2、覆盖与交换</h3><blockquote>
<p><strong>覆盖技术：</strong></p>
<blockquote>
<p><strong>基本思想：</strong></p>
<blockquote>
<p>​        由于程序运行时并非任何时候都要访问程序集数据的各个部分，因此可把用户空间分成一个<strong>固定区</strong>和若干<strong>覆盖区</strong>。将最经常活跃的那部分放在固定区，其余部分<strong>按调用关系分段</strong>，需要使用时再放入覆盖区。</p>
</blockquote>
<p><strong>例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF.png" alt="覆盖技术"></p>
</blockquote>
<p><strong>特点：</strong></p>
<blockquote>
<p>必须由程序员确定覆盖结构，操作系统自动覆盖</p>
<p>对用户不透明，增加编程负担</p>
<p>覆盖技术只用于早期的操作系统</p>
</blockquote>
</blockquote>
<p><strong>交换技术</strong></p>
<blockquote>
<p><strong>基本思想：</strong></p>
<blockquote>
<p>​        将处于等待状态的程序从内存转移到辅存中，从而把内存空间腾出来，这一过程称为<strong>换出</strong>；把准备好竞争CPU运行的程序从辅存转移到内存中，这一过程称为<strong>换入</strong>（即上一章的<strong>中级调度</strong>）。</p>
</blockquote>
<p><strong>注意的问题</strong></p>
<blockquote>
<ul>
<li>在磁盘中，通常会有一部分区域用作交换，被称为交换区，采用连续分配的方式；其余的称为文件区，是存放一般文件的区域，采用离散分配的方式，从而提高空间的利用率。</li>
<li>程序换出的依据可以是优先级、调入内存的时间等。</li>
</ul>
</blockquote>
</blockquote>
</blockquote>
<h3 id="3、连续分配管理方式"><a href="#3、连续分配管理方式" class="headerlink" title="3、连续分配管理方式"></a>3、连续分配管理方式</h3><blockquote>
<p>​        连续分配方式是指为一个用户程序分配一个<strong>连续</strong>的内存空间，其中连续分配方式主要包括：<strong>单一连续分配</strong>、<strong>固定分区分配</strong>和<strong>动态分区分配</strong>。</p>
<ul>
<li><p><strong>单一连续分配</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D.png" alt="单一连续分配"></p>
<p>​        内存再此方式下分为<strong>系统区</strong>和<strong>用户区</strong>。系统区仅供操作系统使用，通常在低地址部分；用户区是为用户提供的内存空间。在这种内存中永远<strong>只有一道程序</strong>，因此不会出现访问越界等现象。</p>
<p><strong>优点：</strong>简单、无外部碎片，可采用覆盖技术。</p>
<p><strong>缺点：</strong>只能用于单用户、单任务的操作系统中，有内部碎片，存储器利用率低。</p>
</blockquote>
</li>
<li><p><strong>固定分区分配</strong></p>
<blockquote>
<img src="/picture/学习/操作系统上的图/内存管理/固定分区分配.png" alt="固定分区分配" style="zoom: 67%;" />

<p>​        它将用户内存空间划分为若干固定大小的区域，每个分区只装入一个作业。根据分区划分方法的不同，可以分为以下两种：</p>
<blockquote>
<ul>
<li><p><strong>分区大小相等</strong>：用于利用一台计算机去控制多个相同对象的场合，灵活性差，容易产生区内碎片</p>
</li>
<li><p><strong>分区大小不等：</strong>划分为多个较小的分区、适量的中等分区和少量大分区</p>
<p>为便于内存分配，通常将分区按大小排队，为其建立一张<strong>分区说明表</strong>，其中包括表项每个分区的初始地址、大小及状态（是否已分配），如图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%88%86%E5%8C%BA%E8%AF%B4%E6%98%8E%E8%A1%A8.png" alt="分区说明表"></p>
</li>
</ul>
</blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<ul>
<li>程序可能太大而放不进任何一个分区，此时就需要用到覆盖技术了</li>
<li>贮存利用率低，当程序小于固定分区大小时，也要占用一个分区，那么此时就会产生内部碎片</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>动态分区分配</strong></p>
<blockquote>
<p>​        动态分区分配又称<strong>可变分区分配</strong>，指不预先划分内存，而是在程序装入内存时，根据程序大小动态地建立分区，并使得分区的大小正好合适内存。如图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%88%86%E5%8C%BA.png" alt="动态分配分区"></p>
<p>​        动态分区刚开始分配时很好，但是逐渐往后就会使得内存出现许多小的内存块。如果随着事件进一步推移，那么就会产生更多的碎片空间，从而导致内存的利用率下降。一种解决办法是使用<strong>紧凑技术</strong>（即操作系统不时地对进程进行移动和整理，使得碎片可以相互合并，从而形成较大的可用空间）；另一种办法是在动态分配时使用相应算法：</p>
<blockquote>
<ul>
<li><p><strong>首次适应（First Fit）算法</strong></p>
<blockquote>
<p><strong>算法思路：</strong>每次从低地址开始查找，找到第一个能满足大小的空闲分区</p>
<p><strong>实现方法：</strong> <strong>空闲分区以地址递增的次序排列</strong>，每次分配内存时按顺序查找空闲分区链（空闲分区表），找到大小能满足要求的第一个空闲分区。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95.png" alt="首次适应算法"></p>
<p><strong>优点：</strong>综合性能最好，算法开销小，回收分区后一般不需要对空闲分区队列重新排列</p>
</blockquote>
</li>
<li><p><strong>最佳适应（Best Fit）算法</strong></p>
<blockquote>
<p><strong>算法思路：</strong>为了保证大进程可以有连续唔冻大片空间，因此<strong>优先使用更小的空闲区</strong></p>
<p><strong>实现方法：</strong>空闲分区<strong>按容量递增次序链接</strong>。每次分配内存时<strong>顺序查找空闲分区</strong>链（空闲分区表），<strong>找到大小能满足要求的第一个空闲分区</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95.png" alt="最佳适应算法"></p>
<p><strong>优点：</strong>会有更多的大分区被保留下来，能够满足大进程的需求</p>
<p><strong>缺点：</strong>会产生很多难以利用的碎片；<strong>算法开销大</strong>（因为每次都需要对空闲分区链重新排序）</p>
</blockquote>
</li>
<li><p><strong>最坏适应（Worst Fit）算法</strong></p>
<blockquote>
<p><strong>算法思路：</strong>为了解决最佳适应算法的问题，在每次分配时<strong>优先利用最大的连续分区</strong>，这样分配后的剩余空闲区就不会太小，方便使用</p>
<p><strong>实现方法：</strong>空闲分区<strong>按容量递减次序链接</strong>。每次分配内存时顺序查找空闲分区链（空闲分区表），找到大小能满足要求的第一个空闲分区</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E6%9C%80%E5%9D%8F%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95.png" alt="最坏适应算法"></p>
<p><strong>优点：</strong>可以减少难以利用的内存碎片</p>
<p><strong>缺点：</strong>大分区容易被使用完，不利于大进程；<strong>算法开销也大</strong></p>
</blockquote>
</li>
<li><p><strong>邻近适应（Next Fit）算法</strong></p>
<blockquote>
<p><strong>算法思路：</strong>每次都从上次查找结束的位置开始检索空间。</p>
<p><strong>实现方法：</strong>空闲分区以地址递增的顺序排列（<strong>排成一个循环链表</strong>）。每次分配内存时<strong>从上次查找结束的位置开始查找</strong>空闲分区链（空闲分区表），找到大小能满足要求的第一个空闲分区</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E9%82%BB%E8%BF%91%E6%9C%80%E4%BD%B3%E7%AE%97%E6%B3%95.png" alt="邻近最佳算法"></p>
<p><strong>优点：</strong>不用每次都从低地址的小分区开始检索。算法开销小</p>
<p><strong>缺点：</strong>会时高地址的大分区也被用完。</p>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="4、非连续分配管理方式"><a href="#4、非连续分配管理方式" class="headerlink" title="4、非连续分配管理方式"></a>4、非连续分配管理方式</h3><blockquote>
<p>​        非连续分配允许一个程序分散地装入不同的内存分区。在连续分配管理中，如果内存中没有足够大的连续空间，那么程序则无法装入内存中；在非连续分配管理中，只要内存足够大，那么就可以将程序分成许多个小部分放入内存中。</p>
<p>​        因此根据不同的分法，非连续分配管理可以分为：<strong>分页式存储</strong>和<strong>分段式存储</strong></p>
</blockquote>
<h4 id="4-1、分页式存储"><a href="#4-1、分页式存储" class="headerlink" title="4.1、分页式存储"></a>4.1、分页式存储</h4><blockquote>
<p><strong>分页存储的概念：</strong></p>
<blockquote>
<ul>
<li><strong>页：</strong>指进程中的块</li>
<li><strong>页号：</strong>指进程中块的序号（在操作系统中一般都是隐藏的）</li>
<li><strong>页表：</strong>用于记录每个进程的页面和内存中页框之间的映射关系。通常<strong>存放在进程的PCB中</strong></li>
<li><strong>页表项：</strong>指页表中每一行数据，一般由页号和内存块号组成</li>
<li><strong>页框：</strong>也称为<strong>页帧</strong>，指内存中的块</li>
<li><strong>页框号（页帧号）：</strong>指内存中的块的序号。甚至可以叫作<strong>内存块号</strong>，简称<strong>块号</strong>（外存也可以这样划分，也叫块号）</li>
</ul>
<p><strong>其中的关系：</strong></p>
<blockquote>
<p> <img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E9%A1%B5%E8%A1%A8.png" alt="页表"></p>
</blockquote>
</blockquote>
<p><strong>分页存储的管理方式</strong></p>
<blockquote>
<p>​        由于固定分区会产生内部碎片，而动态分区又会产生外部碎片，从而导致内存利用率变低。因此我们引入了一种新的划分方法：分页划分。即<strong>把内存划分为大小相同且固定的块，其中块的大小相对较小，作为内存的基本单元。</strong>每个进程以块为划分，在执行时，以块为单位逐个向内存申请。</p>
<p>​        <strong>分页存储与固定分区技术的区别：</strong>①、分页技术的块很小，一般只有KB级别的大小，因此即使造成内部碎片，其损失也是可以接受的；②、程序在使用分页技术的块时，无需连续申请，每一个块可以离散地分布在内存中各个地方。</p>
</blockquote>
<p><strong>基本地址变换机构</strong></p>
<blockquote>
<p>地址变换机构的任务是将逻辑地址转换为内存中的物理地址，其过程如下图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B.png" alt="地址转换过程"></p>
<p><strong>一些概念：</strong></p>
<blockquote>
<ul>
<li><strong>页表起始地址：</strong>指该页表在内存中的起始地址（因为页表是连续存在的，因此在根据页号查页表时，需要知道页表的起始地址）</li>
<li><strong>页表长度：</strong>指该进程分了多少个页块</li>
<li><strong>页表项长度：</strong>指一个页地址占多大存储空间（如4GB内存中，一个页面大小为4KB的话，则需要20位来表示所有的页块，那么这些页块地址就需要3个字节的长度来表示，这3字节就是页表项长度）</li>
<li><strong>页面大小：</strong>指一个页块能表是多大的内存空间（程序中的大小与内存中的大小一致）</li>
<li><strong>页表寄存器：</strong>存放页表在内存的起始地址F和页表长度M的寄存器</li>
<li><strong>页内偏移量：</strong>指该地址在该页内的位置</li>
<li><strong>越界中断：</strong>指该页大于页表长度，属于不存在的页号，因此会向系统发出一个<strong>内中断</strong></li>
</ul>
</blockquote>
<p><strong>变换过程：</strong></p>
<blockquote>
<ul>
<li><strong>计算页号P：</strong>$P&#x3D;\frac{逻辑地址A}{页面大小L}$</li>
<li><strong>计算页内偏移量W：</strong>$W&#x3D;逻辑地址A%页面大小L$</li>
<li><strong>比较页号P和页表长度M</strong>，若$P\ge M$，则产生一个越界中断；否则继续执行</li>
<li><strong>根据页号获得相应的页表项地址，</strong>即$页表项地址&#x3D;页表初始地址F+页号P \times 页表项长度$</li>
<li><strong>根据页表项地址取得相应的内存块号b</strong></li>
<li><strong>计算物理地址E，</strong>$E&#x3D;内存块号b \times 页面大小L+页内偏移量W$</li>
</ul>
<p><strong>例如：</strong></p>
<blockquote>
<p>页面大小L为1KB，页面2对应的物理块为b&#x3D;8，计算逻辑地址A&#x3D;2600的物理地址转换：</p>
<ul>
<li>计算页号：$P&#x3D;\frac{2600}{1KB}&#x3D;2$</li>
<li>计算页内偏移量：$W&#x3D;2600%1KB(1024B)&#x3D;552$</li>
<li>根据题目可知，页号2对应了物理块号8</li>
<li>计算物理地址：$E&#x3D;8 \times 1KB+552&#x3D;8744$</li>
</ul>
<p>因此只要给出页面大小，那么逻辑地址就可以转化为物理地址了</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>快表：</strong></p>
<blockquote>
<p>​         为了提高页块的查询速度，一般会在地址变换机构中增设一个<strong>高速缓冲寄存器——快表</strong>。快表又称<strong>相联存储器</strong>，用于存放少数常用的页表项，从而达到加速地址转换的效果。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png" alt="具有快表的地址转换"></p>
<p><strong>查询过程：</strong></p>
<blockquote>
<ul>
<li><strong>计算页号P：</strong>$P&#x3D;\frac{逻辑地址A}{页面大小L}$</li>
<li><strong>计算页内偏移量W：</strong>$W&#x3D;逻辑地址A%页面大小L$</li>
<li><strong>比较页号P和页表长度M</strong>，若$P\ge M$，则产生一个越界中断；否则继续执行</li>
<li><strong>根据页号查询快表中是否命中</strong>，如果命中则根据快表中的记录访问内存；如果不命中则去内存中查询页表</li>
</ul>
</blockquote>
<p><strong>两种不同的方式：</strong></p>
<blockquote>
<ul>
<li><strong>先查询快表，再查询页表</strong></li>
<li><strong>快表和页表同时查询</strong></li>
</ul>
</blockquote>
<p><strong>注意：</strong></p>
<blockquote>
<ul>
<li>高速缓冲寄存器的速度是远快于内存的</li>
<li>高速缓冲寄存器中存放的是内存中的副本</li>
<li>快表能实现的基础是：<strong>局部性原理</strong>（即系统更可能会连续地访问程序的某部分，而不是先访问这再访问那的离散型访问）</li>
</ul>
</blockquote>
</blockquote>
<p><strong>多级页表</strong></p>
<blockquote>
<p><strong>以下用两级页表作为讨论对象</strong></p>
<p><strong>数据结构：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8.png" alt="两级页表"></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt="两级页表结构"></p>
<p><strong>注意：</strong>一级页号所对应的页表也被称为，<strong>页目录表（常用）</strong>、<strong>顶级页表</strong>或<strong>外层页表</strong></p>
</blockquote>
<p>​        使用二级页表后，可以根据一级页号查找到一个二级子页表，然后再根据二级页号来找到相应的内存块。因此一个二级页表的访问次数一般为3次。</p>
<p>​        而且使用二级页表后，可以按需地将二级页表放入内存中，即需要的那一部分就放入内存中，不需要的部分暂时放在外存中，这样一来就节约了空间。（实现这个功能可以在页表中加入一个状态字段来表示该页表是否在内存中）</p>
<p><strong>注意</strong></p>
<blockquote>
<ul>
<li><p>使用分级页表的话，<strong>各级页表的大小不能超过一个页面</strong>，如</p>
<blockquote>
<p>某系统按字节编址，采用28位来表示页号，页面大小为4KB，页表项大小为4B，需要分3级页表来存储</p>
<ul>
<li>页面大小为$4KB&#x3D;2^{12}B$，即一个页面可以存$2^{12}$个字节的东西</li>
<li>页表项为$4B$，即一个页表项长度为4个字节</li>
<li>现在拿一个页面存页表项，即可以存$\frac{2^{12}}{4}&#x3D;2^{10}$个页表项（超出这个数，那么一个页表就存不下那么多个子页表项了）</li>
<li>因此28位页号需要分成8, 10, 10 三级页号来表示。</li>
</ul>
</blockquote>
</li>
<li><p>两级页表的<strong>访存次数</strong>（没有快表）：需要三次访存才能找到内存单元。</p>
</li>
</ul>
</blockquote>
<p><strong>与单机页表的比较：</strong></p>
<blockquote>
<p>​        解决了页表过大时，占用空间的问题。但是两级页表的访存次数比单机页表多了一次，因此在访问速度上要慢于单级页表。（时间换空间策略）</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="4-2、分段式存储"><a href="#4-2、分段式存储" class="headerlink" title="4.2、分段式存储"></a>4.2、分段式存储</h4><blockquote>
<p>​        进程的地址空间：按照程序本身的逻辑关系划分为若干个段，每一段从0开始编址。</p>
<p>​        内存分配原则：以段位单位进行分配，<strong>每个段中占据连续的内存空间</strong>，但<strong>各段之间可以不相邻</strong>，如下图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%88%86%E6%AE%B5.png" alt="分段"></p>
<p><strong>数据结构：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E6%AE%B5%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="段的数据结构"></p>
<ul>
<li><strong>段号：</strong>决定了每个进程最多可以分几段</li>
<li><strong>段内地址：</strong>决定了每个段的最大长度</li>
</ul>
</blockquote>
<p><strong>段表</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E6%AE%B5%E8%A1%A8.png" alt="段表"></p>
<ul>
<li>每个段对应一个段表项，其中记录了该段在<strong>内存的初始位置</strong>和<strong>段的长度</strong></li>
<li>相较于页表，段表还多出了一个段长</li>
<li>每个<strong>段表项的长度</strong>是相同的</li>
<li>段号是可以隐藏的</li>
</ul>
</blockquote>
<p><strong>地址转换：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E6%AE%B5%E7%9A%84%E5%8F%98%E5%9D%80%E6%9C%BA%E6%9E%84.png" alt="段的变址机构"></p>
<ul>
<li>根据逻辑地址得到段号和段内地址</li>
<li>利用段表寄存器中的段表长度来<strong>判断段号是否越界</strong>，如果越界，则产生越界中断，否则继续进行（<strong>注意：</strong>段表长度至少为1，而段号最小为0）</li>
<li><strong>查询段表</strong>，找到对应的段表项</li>
<li><strong>检查段内地址是否越界</strong>，如果越界，则产生越界中断（根据偏移量和段长的比较进行判断）</li>
<li>计算物理地址</li>
</ul>
</blockquote>
<p><strong>分段的共享实现：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%88%86%E6%AE%B5%E7%9A%84%E5%85%B1%E4%BA%AB%E5%AE%9E%E7%8E%B0.png" alt="分段的共享实现"></p>
<p>进程使用分段可以更好地实现共享存储，<strong>只需要让双方都指向共享区域即可</strong>。</p>
<p><strong>分页无法实现共享的原因：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%88%86%E9%A1%B5%E7%9A%84%E5%85%B1%E4%BA%AB.png" alt="分页的共享"></p>
<p>由于分页方式中，页面大小无法由用户控制，因此进程共享部分容易被分到不同页面中，从而导致难以与其它进程共享。</p>
</blockquote>
</blockquote>
<p><strong>分页和分段的区别：</strong></p>
<blockquote>
<ul>
<li>页是信息的<strong>物理单位</strong>，其目的是为了提高内存利用率，且分页由系统决定，对于用户来说是透明的；段是信息的<strong>逻辑单位</strong>，其目的是为了满足用户需求，分段可以由用户决定，对用户是可见的。</li>
<li><strong>页面大小由系统决定，段的大小由程序员决定</strong></li>
<li>分页的用户进程逻辑地址是一维的，即只需知道地址即可；分段中的用户进程逻辑地址是二维的，需要知道段号和段内地址。</li>
<li>分段更容易实现信息的共享和保护</li>
<li>分段也可以引入快表机制</li>
</ul>
</blockquote>
</blockquote>
<h4 id="4-3、段页式存储"><a href="#4-3、段页式存储" class="headerlink" title="4.3、段页式存储"></a>4.3、段页式存储</h4><blockquote>
<p>​        段页式管理方式就是对程序即进行分段管理，又进行分页管理。即<strong>对程序先分段，然后在每个段中再分页</strong>，因此程序的逻辑地址会分为三部分：段号、页号和页内偏移量。如图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F.png" alt="段页式管理方式"></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80.png" alt="段页式逻辑地址"></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E6%AE%B5%E8%A1%A8.png" alt="段页式段表"></p>
<p><strong>注意：</strong></p>
<blockquote>
<p> 再段页式管理中的段表与纯段式管理中的段表有些许不同。</p>
<ul>
<li>段页式中的段表记录的是页表长度和页表存放块</li>
<li>段式中过的段表记录的是段长和基址</li>
</ul>
</blockquote>
<p><strong>地址转换过程：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E8%AE%BF%E5%AD%98%E8%BF%87%E7%A8%8B.png" alt="段页式访存过程"></p>
<ul>
<li>根据逻辑地址得到段号、页号和页内偏移量</li>
<li>判断段号是否越界</li>
<li>根据段号查询段表，根据查询结果得到页表存放块号并根据页表长度判断是否越界</li>
<li>根据页表存放块号找到相应的页表，再根据页号找到相应的页表项</li>
<li>根据页表项从而得到内存块号</li>
<li>将内存块号和页内偏移量相结合，从而得到<strong>物理地址</strong></li>
</ul>
<p><strong>注意：</strong></p>
<blockquote>
<ul>
<li>段页式一共进行了三次访存，访问段表、访问页表、访问目标内存单元</li>
<li>段页式管理也可以引入快表进行查询</li>
</ul>
</blockquote>
</blockquote>
</blockquote>
<h2 id="二、虚拟内存管理"><a href="#二、虚拟内存管理" class="headerlink" title="二、虚拟内存管理"></a>二、虚拟内存管理</h2><h3 id="1、虚拟内存的基本概念"><a href="#1、虚拟内存的基本概念" class="headerlink" title="1、虚拟内存的基本概念"></a>1、虚拟内存的基本概念</h3><blockquote>
<p><strong>传统存储管理方式的特征：</strong></p>
<blockquote>
<ul>
<li><strong>一次性：</strong>作业必须一次性全部装入内存后，才能开始运行</li>
<li><strong>驻留性：</strong>作业被装入内存后，就一直驻留在内存中，即使某部分不起作用也不会换出，直到作业运行结束</li>
</ul>
<p>因此可知，传统的存储管理方式对内存空间的利用率仍可以继续提高。</p>
</blockquote>
<p><strong>局部性原理：</strong></p>
<blockquote>
<ul>
<li><strong>时间局部性：</strong>程序中某条指令一旦被执行，不久后该指令可能会再次执行。（因为程序中可能存在循环操作）</li>
<li><strong>空间局部性：</strong>一旦程序访问了某个存储单元，在不久后，其附近的存储单元也将被访问，即程序在一段时间内访问的地址，可能是在一定的范围之内的。（由于数据以数组形式存放）</li>
</ul>
</blockquote>
<p><strong>虚拟存储器的定义和特征：</strong></p>
<blockquote>
<p>​        基于局部性原理，在程序装入时，将程序的一部分装入内存，而将其它部分留在外存，就可以启动程序执行。因此操作系统在执行程序的过程中，将所需要的部分调入内存中，将暂时用不上的部分换出到外存上，从而腾出空间存放将要调入内存的信息。这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为<strong>虚拟存储器</strong>。</p>
<p><strong>虚拟存储器的特点：</strong></p>
<blockquote>
<ul>
<li><strong>多次性：</strong>指程序允许被分为多次调入内存中运行</li>
<li><strong>对换性：</strong>指整个程序无需在运行时一直保留在内存中，允许在运行时进行换出或换进</li>
<li><strong>虚拟性：</strong>指从逻辑上扩充内存的容量，使得用户所看到的内存容量远大于实际的内存容量</li>
</ul>
</blockquote>
</blockquote>
<p><strong>虚拟内存技术的实现：</strong></p>
<blockquote>
<p><strong>虚拟内存的实现需要建立在离散分配的内存管理方式的基础之上</strong></p>
<p>虚拟内存的实现方式：</p>
<blockquote>
<ul>
<li>请求分页存储管理</li>
<li>请求分段存储管理</li>
<li>请求段页式存储管理</li>
</ul>
</blockquote>
<p>需要的硬件支持：</p>
<blockquote>
<ul>
<li>一定容量的内存和外存</li>
<li>页表机制</li>
<li>中断机制</li>
<li>地址转换机制</li>
</ul>
</blockquote>
</blockquote>
</blockquote>
<h3 id="2、请求分页管理方式"><a href="#2、请求分页管理方式" class="headerlink" title="2、请求分页管理方式"></a>2、请求分页管理方式</h3><blockquote>
<p>​        <strong>请求分页系统</strong>建立在<strong>基本分页系统</strong>基础之上，为了支持虚拟存储器功能而增加了<strong>请求调页</strong>和<strong>页面置换</strong>两大功能。请求分页系统是目前最常用的一种实现虚拟存储器的方法。</p>
<p><strong>页表机制：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E9%A1%B5%E8%A1%A8.png" alt="请求分页页表"></p>
<p><strong>新增的字段：</strong></p>
<ul>
<li><strong>状态位：</strong>用于指示该页是否调入内存</li>
<li><strong>访问字段：</strong>记录本页在一段时间内被访问的次数，或记录本页最近多长时间未被访问</li>
<li><strong>修改位：</strong>标识该页调入内存后是否被修改过</li>
<li><strong>外存地址：</strong>指出该页在外存上的地址，通常位物理块号</li>
</ul>
</blockquote>
<p><strong>缺页中断机制：</strong></p>
<blockquote>
<p>​        在请求分页系统中，每当要访问的页面不再内存中是，就会产生一个<strong>缺页中断</strong>，请求操作系统将所缺的页调入内存。此时应<strong>将缺页的进程阻塞</strong>，直到调页完成后再唤醒。</p>
<p><strong>注意：</strong></p>
<blockquote>
<ul>
<li>缺页中断是在一条指令执行期间产生和处理的中断信号，因此属于<strong>内部中断</strong></li>
<li>一条指令在执行期间，可能产生多次缺页中断</li>
</ul>
</blockquote>
</blockquote>
<p><strong>地址变换机制：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png" alt="请求分页中的地址转换"></p>
<p>注意，与基本分页系统相比，请求分页系统多了<strong>检查页是否在内存中</strong>和<strong>将页换进内存</strong>的操作</p>
</blockquote>
<p><strong>补充：</strong></p>
<blockquote>
<ul>
<li>在将某一页数据置换出外存时，需要检查其是否进行过修改，如果发生过修改，则写回外存；如果没有，则直接覆盖</li>
<li>如果请求分页系统中也存在快表，那么如果置换的页也存在于快表中，此时也要对快表进行更换</li>
<li>一个页面的置换，需要使用到外存和CPU，因此需要一定的系统开销</li>
</ul>
</blockquote>
</blockquote>
<h3 id="3、页面置换算法"><a href="#3、页面置换算法" class="headerlink" title="3、页面置换算法"></a>3、页面置换算法</h3><h4 id="3-1、最佳置换算法（OPT）"><a href="#3-1、最佳置换算法（OPT）" class="headerlink" title="3.1、最佳置换算法（OPT）"></a>3.1、最佳置换算法（OPT）</h4><blockquote>
<p><strong>算法思路：</strong>选择以后永不使用或很久以后才使用的页面，以保证获得最低的缺页率</p>
<p><strong>例子：</strong></p>
<blockquote>
<p>假定系统为某进程分配了三个物理块，并且页面号引入串为：7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.png" alt="最佳置换算法"></p>
<p>例如四个页面时，由于7号页面是倒数第三个页面才用到，因此首先让它先置换出去。</p>
</blockquote>
<p><strong>优点：</strong>缺页率最低，效果最好</p>
<p><strong>缺点：</strong>使用该算法需要先知道后续要调用的页面号（而这个一般都是不可知的），因此只能是理论上的算法，实际上难以实现</p>
</blockquote>
<h4 id="3-2、先进先出置换算法（FIFO）"><a href="#3-2、先进先出置换算法（FIFO）" class="headerlink" title="3.2、先进先出置换算法（FIFO）"></a>3.2、先进先出置换算法（FIFO）</h4><blockquote>
<p><strong>算法思路：</strong>优先淘汰最早进入内存的页面，即优先淘汰在内存中驻留时间最久的页面</p>
<p><strong>例子：</strong></p>
<blockquote>
<p>假定系统为某进程分配了三个物理块，并且页面号引入串为：3，2，1，0，3，2，4，3，2，1，0，4</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.png" alt="先进先出置换算法"></p>
<p>该算法将内存中的页面串成一个队列，每次置换时将队尾的页面置换出去。</p>
<p><strong>注意：</strong>FIFO算法还会产生一个<strong>Belady异常</strong>：即<strong>随着分配的物理块数增大，缺页率反而增加</strong>的异常现象，如下图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Belady%E5%BC%82%E5%B8%B8.png" alt="Belady异常"></p>
<p>在多加了一个内存块4以后，缺页次数反而从原来的9次，提高到了10次。</p>
</blockquote>
<p><strong>特点：</strong>实现简单，但效果并不理想。</p>
</blockquote>
<h4 id="3-3、最近最久未使用置换算法（LRU）"><a href="#3-3、最近最久未使用置换算法（LRU）" class="headerlink" title="3.3、最近最久未使用置换算法（LRU）"></a>3.3、最近最久未使用置换算法（LRU）</h4><blockquote>
<p><strong>算法思路：</strong>选择最近最长时间未访问过的页面给予淘汰。（即使用页表项中的<strong>访问字段记录最近访问情况</strong>）</p>
<p><strong>例子：</strong></p>
<blockquote>
<p>假定系统为某进程分配了四个物理块，并且页面号引入串为：1, 8, 1, 7, 8, 2, 7, 2, 1, 8, 3, 8, 2, 1, 3, 1, 7, 1, 3, 7</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.png" alt="最近最久未使用置换算法"></p>
<p>该算法是根据以前的情况来推测以后哪些页面可能会被访问，使用到了局部性原理，因此是最接近LRU的算法</p>
</blockquote>
<p><strong>特点：</strong>算法性能好，但需要寄存器和栈的硬件支持。</p>
</blockquote>
<h4 id="3-4、时钟置换算法（CLOCK）"><a href="#3-4、时钟置换算法（CLOCK）" class="headerlink" title="3.4、时钟置换算法（CLOCK）"></a>3.4、时钟置换算法（CLOCK）</h4><blockquote>
<p>时钟置换算法是一种性能和开销都较为均衡的算法，又称<strong>最近未使用算法（NRU）</strong></p>
<p><strong>算法思路：</strong>将内存中的页面连成一个循环链表，每次扫描哪个是最近未访问过的页面，找到以后将其置换。</p>
<p><strong>页表项结构：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E9%A1%B5%E8%A1%A8%E9%A1%B9.png" alt="时钟置换算法页表项"></p>
<p>仅使用访问位来表示最近是否被访问过。</p>
</blockquote>
<p><strong>例子：</strong></p>
<blockquote>
<p>假定系统为某进程分配了五个物理块，并且页面号引入串为：1, 3, 4, 2, 5, 6, 3, 4, 7</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.png" alt="时钟置换算法"></p>
<ul>
<li>当某页被访问时，其访问位置为1</li>
<li>当要淘汰一个页面时，只需检查页的访问位，如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面</li>
<li>若第一轮扫描中所有页面都是1，则将这些页面的访问位全部置为0后，再进行第二轮扫描（在一个简单CLOCK算法中，<strong>最多只会经过两轮扫描</strong>）</li>
</ul>
</blockquote>
</blockquote>
<h4 id="3-5、改进型的时钟置换算法"><a href="#3-5、改进型的时钟置换算法" class="headerlink" title="3.5、改进型的时钟置换算法"></a>3.5、改进型的时钟置换算法</h4><blockquote>
<p><strong>算法思路：</strong>在时钟置换算法的基础上，加上了”只有被淘汰的页面被修改是，才需要写回外存“</p>
<p><strong>页表项结构：</strong>在时钟置换算法的基础上，用<strong>（访问位，修改位）</strong>的形式来表示各页面的状态，如（1，1）表示一个页面近期被访问过且修改过</p>
<p><strong>算法规则：</strong></p>
<blockquote>
<ul>
<li>将所有可能被置换的页面排成一个循环队列</li>
<li><strong>第一轮：</strong>从当前位置开始扫描到第一个（0，0）的页面用于替换。<strong>本轮扫描不修改任何标志位</strong>（即<strong>最近没访问，且没修改的页面</strong>）</li>
<li><strong>第二轮：</strong>若第一轮扫描失败（未能找到要求的页面），则重新扫描，查找第一个（0，1）的页面用于替换。本轮扫描过后将所有访问过的页面中的<strong>访问位设为0</strong>.（即<strong>最近未访问，但经过修改的页面</strong>）</li>
<li><strong>第三轮：</strong>若第二轮扫描失败，则重新扫描，查找第一个（0，0）的页面用于替换。<strong>本轮扫描不修改任何标志位</strong>（即<strong>最近访问过，但未修改过的页面</strong>）</li>
<li><strong>第四轮：</strong>若第三轮扫描失败，则重新扫描，找到第一个（0，1）的页面用于替换。（即<strong>最近访问过，且修改过的页面</strong>）</li>
</ul>
</blockquote>
</blockquote>
<h4 id="3-6、五类算法的比较"><a href="#3-6、五类算法的比较" class="headerlink" title="3.6、五类算法的比较"></a>3.6、五类算法的比较</h4><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.png" alt="置换算法"></p>
</blockquote>
<h3 id="4、页面分配策略"><a href="#4、页面分配策略" class="headerlink" title="4、页面分配策略"></a>4、页面分配策略</h3><blockquote>
<p><strong>驻留集大小</strong></p>
<blockquote>
<p>由于操作系统不可能将一个进程完全地放入内存中，因此只能在进程中选择适当的页数放入内存中，而这个页数的集合被称为<strong>驻留集</strong>。</p>
<p><strong>驻留集：</strong>给一个进程分配的物理页框的集合就是这个进程的驻留集（即在内存中给进程分配的页数）</p>
<p>驻留集分配得大了，会导致系统整体的并发性下降（系统可并发执行的程序减少了）<br>驻留集分配得小了，会导致进程频繁缺页（可用的页数下降，导致经常换页）</p>
<p><strong>固定分配：</strong>操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即<strong>驻留集大小不变</strong>。<br><strong>可变分配：</strong>先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即<strong>驻留集大小可变</strong>。</p>
<p><strong>局部置换：</strong>指发生缺页时<strong>只能选进程自己的物理块</strong>进行置换（进程自身的内存）<br><strong>全局置换：</strong>可以将操作系统保留的空间物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。（整个系统的内存）</p>
<p>根据不同组合，操作系统常用以下三种策略：</p>
<blockquote>
<ul>
<li><p><strong>固定分配局部置换</strong></p>
<blockquote>
<p><strong>操作过程：</strong></p>
<ul>
<li><p>为每个进程分配一定数量的物理块，在整个运行期间都不改变。</p>
</li>
<li><p>若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后调入所需的页面</p>
</li>
</ul>
<p><strong>缺点：</strong>难以确定每个进程应该分配多少内存块。</p>
</blockquote>
</li>
<li><p><strong>可变分配全局置换</strong></p>
<blockquote>
<p><strong>操作过程：</strong></p>
<ul>
<li>为系统中每个进程分配一定数目的物理块，操作系统自身也保持一个空闲物理块队列</li>
<li>当某进程发生缺页时，系统从空闲物理块队列中取出一个物理块分配给该进程</li>
<li>并将调入的页装入其中</li>
</ul>
<p><strong>优点：</strong>可以动态增加进程的物理块，使得分配更加灵活</p>
<p><strong>缺点：</strong>可能会盲目地给进程增加物理块，使得系统并发性下降</p>
</blockquote>
</li>
<li><p><strong>可变分配局部置换</strong></p>
<blockquote>
<p><strong>操作过程：</strong></p>
<ul>
<li>为每个进程分配一定数目的物理块</li>
<li>当某进程发生缺页时，只从该进程在内存中的页面选出一页换出</li>
<li>如果某进程频繁发生缺页，则系统就再为该进程分配物理块，直到该进程缺页率趋于适当值</li>
<li>如果某进程缺页率特别低，则适当减少分配给该进程的物理块</li>
</ul>
<p><strong>优点：</strong>可以动态增加进程物理块的数量，也能动态减少进程物理块的数量，同时也保证了系统的并发性。</p>
<p><strong>缺点：</strong>实现复杂且系统开销大（需要对物理块动态地分配）</p>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<p><strong>调入页面的时机：</strong></p>
<blockquote>
<ul>
<li><strong>预调页策略：</strong>根据局部性原理，一次调入若干相邻的页。（常用于进程的首次调入中，由程序员指出应先调入哪些页）</li>
<li><strong>请求调页策略：</strong>进程在运行中需要访问的页面不在内存而提出请求，由系统将所需要页面调入内存。（即常见的每次只调入所缺的页面）</li>
</ul>
</blockquote>
<p><strong>从何处调入页面：</strong></p>
<blockquote>
<p>​        请求分页系统中的外存分为两部分：用于存放文件的<strong>文件区</strong>，用于存放对换页面的<strong>对换区</strong>。其中文件区采用离散分配的方式，对换区则采用连续分配的方式。因此对换区的读写速度会快于文件区。从何处调入页面就存在三种情况：</p>
<ul>
<li><p><strong>系统拥有足够的对换区空间：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E8%B6%B3%E5%A4%9F%E7%9A%84%E5%AF%B9%E6%8D%A2%E5%8C%BA.png" alt="足够的对换区"></p>
<p>系统中文件的交换全部由对换区和内存进行。因此在程序执行前，需要将副本放入对换区中，然后才能进入内存。</p>
</blockquote>
</li>
<li><p><strong>系统缺少足够的对换区空间：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E7%BC%BA%E5%B0%91%E5%AF%B9%E6%8D%A2%E5%8C%BA.png" alt="缺少对换区"></p>
<ul>
<li>不会被修改的数据（即只读数据）可以直接从文件区中读入内存中</li>
<li>修改的数据则需要经过对换区后才能写回文件区，而且对于修改过的数据可以从对换区直接读入。</li>
</ul>
</blockquote>
</li>
<li><p><strong>UNIX方式</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/UNIX%E6%96%B9%E5%BC%8F.png" alt="UNIX方式"></p>
<ul>
<li>程序第一次调入时可以直接从文件区中调入</li>
<li>后续的调出和调入都需要经过对换区了</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<h3 id="5、抖动"><a href="#5、抖动" class="headerlink" title="5、抖动"></a>5、抖动</h3><blockquote>
<p>​        指在页面置换过程中，<strong>刚刚换出的页面马上又要换入内存中，刚刚换入的页面又要换出内存中</strong>，这种频繁的页面调度就称为<strong>抖动</strong>或<strong>颠簸</strong>。</p>
<p>​        <strong>抖动发生的原因：</strong>某个进程<strong>频繁访问的页面数</strong>高于<strong>可用的物理页面数</strong>。</p>
</blockquote>
<h3 id="6、工作集"><a href="#6、工作集" class="headerlink" title="6、工作集"></a>6、工作集</h3><blockquote>
<p><strong>工作集：</strong>指某段时间间隔里，进程时机访问页面的集合。</p>
<p><strong>驻留集：</strong>指请求分页存储管理中给进程分配的物理块的集合</p>
<p><strong>例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%B7%A5%E4%BD%9C%E9%9B%86%E4%BE%8B%E5%AD%90.png" alt="工作集例子"></p>
<p>​        根据局部性原理，工作集大小是可能小于窗口尺寸的。一般来说驻留集的大小不能小于工作集的大小，否则会导致进程运行过程中频繁缺页。</p>
</blockquote>
</blockquote>
<h2 id="三、内存映射文件"><a href="#三、内存映射文件" class="headerlink" title="三、内存映射文件"></a>三、内存映射文件</h2><blockquote>
<p><strong>内存映射文件：</strong>操作系统向上层程序员提供的功能（系统调用）</p>
<p><strong>作用：</strong></p>
<blockquote>
<ul>
<li>能更方便地使用文件</li>
<li>能更好地共享文件</li>
</ul>
</blockquote>
<p><strong>传统的文件访问方式</strong></p>
<blockquote>
<ul>
<li>open 系统调用——打开文件</li>
<li>seek 系统调用——将读写指针移到某要读取文件的位置</li>
<li>read 系统调用——从读写指针所指位置读入若干数据（从磁盘读入内存）</li>
<li>write 系统调用——将内存中的指定数据，写回磁盘（根据读写指针来确定要写回的位置）</li>
</ul>
</blockquote>
<p><strong>内存映射文件的访问方式</strong></p>
<blockquote>
<ul>
<li>open 系统调用——打开文件</li>
<li>mmap 系统调用——<strong>将文件映射到进程的虚拟地址空间</strong></li>
<li>以访问内存的方式访问文件数据（即查看是否缺页）</li>
<li>文件数据的读入、写出都由操作系统自动完成</li>
<li>进程关闭文件时，操作系统自动将文件被修改的数据写回磁盘</li>
</ul>
</blockquote>
<p><strong>内存映射文件的共享：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E8%99%9A%E6%8B%9F%E7%A9%BA%E9%97%B4%E5%85%B1%E4%BA%AB.png" alt="虚拟空间共享"></p>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>基础学科</tag>
      </tags>
  </entry>
  <entry>
    <title>决策树</title>
    <url>/2021/08/17/%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    <content><![CDATA[<h4 id="决策树模型"><a href="#决策树模型" class="headerlink" title="决策树模型"></a><b>决策树模型</b></h4><blockquote>
<ul>
<li><b>决策树</b>是一种常见的机器学习方法，有<b>回归</b>和<b>分类</b>这两种方法。</li>
<li>决策树模型呈树形结构，可以认为是if-then规则的集合。<br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%86%B3%E7%AD%96%E6%A0%91/%E5%86%B3%E7%AD%96%E6%A0%91%E6%A8%A1%E5%9E%8B.png" alt="决策树模型" title="决策树模型"></li>
<li>决策树模型由<b>结点(node)</b>和<b>有向边(directed edge)</b>组成。结点有可以分为<b>内部结点</b>和<b>叶结点</b>。其中内部结点表示一个特征或属性，叶结点则代表一类数据。</li>
<li>决策树学习本质上是从训练数据集中归纳出一组分类规则。</li>
<li>与训练集不矛盾的决策树可以有很多个（当然也有可能一个也没有），我们需要通过一些参数来找到一个与训练集矛盾最小的树，同时还要保证拥有一定的泛化能力。</li>
<li>决策树学习算法包括：<b>特征选择、决策树的生成</b>和<b>决策树的剪枝</b>。</li>
</ul>
</blockquote>
<h4 id="决策树的特征选择"><a href="#决策树的特征选择" class="headerlink" title="决策树的特征选择"></a><b>决策树的特征选择</b></h4><blockquote>
<p>特征选择指的是：在训练数据中选取有利于划分数据集的特征。通常特征选择的标准参数是<b>信息增益</b>和<b>信息增益比</b>。<br>这有个案例：</p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%86%B3%E7%AD%96%E6%A0%91/%E6%A0%B7%E4%BE%8B.png" alt="样例图" title="样例"><br>上面的<b>年龄</b>、<b>有工作</b>、<b>有自己的房子</b>和<b>信贷情况</b>都是特征。<br>假如选择了年龄为划分数据集的特征后，那么数据集会被划分为<b>青年</b>、<b>中年</b>和<b>老年</b>三部分，然后在对每个子数据判断是否要继续划分，要则继续，不用则产生叶子结点。</p>
</blockquote>
<p>当然，在没有任何要求条件下，这颗决策树是有多种划分方法的，如</p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%86%B3%E7%AD%96%E6%A0%91/%E6%A0%B7%E4%BE%8B2.png" alt="样例图" title="不同划分"><br>对此，我们需要引入一些参数来作为我们划分的标准。</p>
</blockquote>
<ul>
<li><p><b>信息增益</b></p>
<blockquote>
<p>为了说明信息增益，先要给出<b>香农熵</b>的定义：<br>熵是表示随机变量不确定性的度量，设X是一个取有限个值得离散型随机变量，其概率分布为：<br>$$P(X&#x3D;x_i)&#x3D;p_i \quad (i&#x3D;1,2,3,…,n)$$<br>则随机变量X得熵定义为：<br>$$H(X) &#x3D; -\sum_{i&#x3D;1}^n{p_ilog \ p_i}$$<br>可以证明得，<br>$$0 \le H(p) \le log \ n$$<br>其中熵越大，随机变量得不确定性就越大<br><b>注意：</b>当出现0概率时，令$0log0&#x3D;0$<br><b>经验条件熵：</b><br>条件经验熵$H(Y|X)$表示在已知随机变量X得条件下随机变量Y得不确定性，定义为：<br>$$H(Y|X)&#x3D;\sum_{i&#x3D;1}^n p_i H(Y|X&#x3D;x_i)$$<br>其中$p_i&#x3D;P(X&#x3D;x_i) \quad i&#x3D;1,2,…,n$<br><b>信息增益：</b>表示得知特征X得信息而使类Y得信息不确定度减少的程度。定义为，<br>集合D的经验熵H(D)与特征A给定条件下D的经验条件熵H(D|A)之差，即<br>$$g(D,A)&#x3D;H(D)-H(D|A)$$<br>信息增益表示信息不确定度减少的程度，所以固定的数据集D<b>信息增益越大的特征就越好</b>。</p>
</blockquote>
</li>
<li><p><b>信息增益算法</b><br>输入：训练数据集D与特征A；<br>输出：特征A对训练数据集D的信息增益g(D,A)</p>
<blockquote>
<ul>
<li>计算数据集D的经验熵H(D)<br>$$H(D)&#x3D;-\sum_{k&#x3D;1}^k \frac{|C_k|}{|D|} log_2 \frac{|C_k|}{|D|}$$</li>
<li>计算特征A对数据集D的经验条件熵H(D|A)<br>$$H(D|A)&#x3D;\sum_{i&#x3D;1}^n H(D_i)$$</li>
<li>计算信息增益<br>$$g(D,A)&#x3D;H(D)-H(D|A)$$</li>
</ul>
</blockquote>
</li>
</ul>
<p>其中D：数据集，|D|：样本容量，$C_k$：第k个类，$|C_k|$：第k个类的样本数<br>$D_i$：特征A将D划分开的各个数据子集，$|D_i|$：$D_i$的样本数</p>
<ul>
<li><b>信息增益比</b><br>在信息增益中，对于可取值数目较多的属性会有所偏好，即可取值数目较多的属性的信息增益会较大<br>为了避免这种情况，又增加了信息增益比这一概念，即特征A对训练数据集D的信息增益比为：<br>$$g_R(D,A)&#x3D;\frac{g(D,A)}{H(D)}$$</li>
</ul>
<p><b>注意：</b>信息增益比与信息增益的特性刚好相反，即可取值数目较少的属性的信息增益比会较大</p>
</blockquote>
<h4 id="决策树的生成"><a href="#决策树的生成" class="headerlink" title="决策树的生成"></a><b>决策树的生成</b></h4><h5 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a><b>ID3算法</b></h5><blockquote>
<p>ID3算法的核心在与决策树上的每个结点都是用信息增益作为标准来选择特征。<br>具体步骤大致为：从根结点开始，对结点计算所有可能特征的信息增益，选择信息增益最大的特征作为结点特征，根据该特征的划分建立子结点，再对子结点递归调用以上方法，直到没有特征可选择或者所有信息增益都很小为止。<br><b>算法描述：</b></p>
<blockquote>
<p>输入：训练数据集D，特征集A，（阈值$\epsilon$）<br>输出：决策树T</p>
<ul>
<li>若D中所有实例属于同一类$C_k$，则T为单结点树，并将类$C_k$作为该结点的类标记，返回T</li>
<li>若A为空集，则T为单结点树，并将D中实例数最多的类$C_k$作为该结点的类标记，返回T</li>
<li>否则，计算A中各特征对D的信息增益，选择信息增益最大的特征$A_g$</li>
<li>如果$A_g$的信息增益小于阈值$\epsilon$，则置T为单结点树，并将D中实例数最多的类$C_k$作为该结点的类标记，返回T</li>
<li>否则，对$A_g$的每一个可能值$a_i$，按照$A_g&#x3D;a_i$将D分割为若干非空子集$D_i$，将$D_i$中实例数最多的类作为标记，构建子结点，由结点及其子结点构建树T，返回T</li>
<li>对第i个子结点，以$D_i$为训练集，以$A-A_g$为特征集，递归调用上述步骤，得到子树$T_i$，最终返回T</li>
</ul>
</blockquote>
</blockquote>
<h5 id="C4-5算法"><a href="#C4-5算法" class="headerlink" title="C4.5算法"></a><b>C4.5算法</b></h5><blockquote>
<p>C4.5算法与ID3算法相类似，C4.5算法在生成过程中，用的是信息增益比作为特征选择的标准。其他与ID3算法一致<br><b>算法描述：</b></p>
<blockquote>
<p>输入：训练数据集D，特征集A，（阈值$\epsilon$）<br>输出：决策树T</p>
<ul>
<li>若D中所有实例属于同一类$C_k$，则T为单结点树，并将类$C_k$作为该结点的类标记，返回T</li>
<li>若A为空集，则T为单结点树，并将D中实例数最多的类$C_k$作为该结点的类标记，返回T</li>
<li>否则，计算A中各特征对D的信息增益比，选择信息增益比最大的特征$A_g$</li>
<li>如果$A_g$的信息增益比小于阈值$\epsilon$，则置T为单结点树，并将D中实例数最多的类$C_k$作为该结点的类标记，返回T</li>
<li>否则，对$A_g$的每一个可能值$a_i$，按照$A_g&#x3D;a_i$将D分割为若干非空子集$D_i$，将$D_i$中实例数最多的类作为标记，构建子结点，由结点及其子结点构建树T，返回T</li>
<li>对第i个子结点，以$D_i$为训练集，以$A-A_g$为特征集，递归调用上述步骤，得到子树$T_i$，最终返回T</li>
</ul>
</blockquote>
</blockquote>
<h4 id="决策树的剪枝"><a href="#决策树的剪枝" class="headerlink" title="决策树的剪枝"></a><b>决策树的剪枝</b></h4><blockquote>
<p>$\quad$决策树是递归产生决策树的，这样的方法往往会出现过拟合的现象。出现这个问题往往是因为决策树的复杂度太高了，因此需要对决策树进行简化。<br>$\quad$剪枝就是简化决策树的方法。具体地，剪枝就是在已经生成的树上剪掉一些子树或者叶结点，并将其根结点或父结点作为新的叶结点。<br>$\quad$决策树的剪枝算法有很多种，但是主要分为两大类：<b>预剪枝</b>、<b>后剪枝</b></p>
<ul>
<li><p><b>预剪枝：</b></p>
<blockquote>
<p>预剪枝的思想就是在生成决策树的过程中就进行剪枝，例如在生成划分结点时，计算划分前与划分后的验证集精度，然后比较它们，如果划分后的验证集精度小于划分前的验证集精度，那么就剪枝，否则就不剪枝。<br>需要注意的是，这种方法是采用一种贪心策略，仅仅寻找局部的最优解，容易产生欠拟合的现象。</p>
</blockquote>
</li>
<li><p><b>后剪枝：</b></p>
<blockquote>
<p>与预剪枝类似，在决策树生成完成后，进行剪枝时，计算剪枝前与剪枝后的验证集精度，然后比较它们，如果剪枝后的验证集精度高于剪枝前的，那么就剪枝，否则不剪。</p>
</blockquote>
</li>
</ul>
<p>对于剪枝，这里只写一下思路，实际上有许许多多的算法可以对决策树进行剪枝（可以自己百度）。</p>
</blockquote>
<h4 id="CART算法"><a href="#CART算法" class="headerlink" title="CART算法"></a><b>CART算法</b></h4><blockquote>
<p>$\quad$分类与回归树（CART）模型与1984年被提出，CART同样由<b>特征选择</b>、<b>树的生成</b>和<b>树的剪枝</b>三部分组成<br>$\quad$CART假定决策树为二叉树，并且内部结点特征取值只有<b>是</b>和<b>否</b>，并且左分支为“是”，右分支为“否”。<br>$\quad$决策树的生成就是递归构建二叉决策树的过程，对<b>回归树</b>用平方误差最小化准则，对<b>分类树</b>用基尼指数最小化准则进行特征选择。</p>
</blockquote>
<h5 id="回归树"><a href="#回归树" class="headerlink" title="回归树"></a><b>回归树</b></h5><blockquote>
<p>$\quad$回归树就是通过训练集划分区间，而每个区间都会有一个取值，当输入变量x时开始寻找这个点所在的区间，然后将对应区间的取值输出。<br>$\quad$回归树的生成主要考虑两个问题：<b>怎么划分</b>和<b>输出值怎么确定</b><br>$\quad$首先回答比较简单的<b>输出值怎么确定</b></p>
<blockquote>
<p>当划分好区间后，将区间内所有取值的<b>平均值</b>作为输出，即<br>$$c&#x3D;ave(y_i|x_i \in R_1(j,s))$$</p>
</blockquote>
<p><b>怎么划分</b>： </p>
<blockquote>
<p>回归树利用<b>平方误差最小化</b>作为划分准则，即<br>采用启发式的方法，选择第j个变量$x^{(j)}$与它的取值s，作为切分变量和切分点，从而得到两个区域<br>$$R_1(j,s)&#x3D;(x|x^{(j)} \le s ) \quad \quad \quad R_2(j,s)&#x3D;(x|x^{(j)} &gt; s )$$<br>然后在所有的切分点中寻找最优的切分点，即<br>$$min_{j,s}[min_{c_1}\sum_{x_i \in R_1(j,s)}(y_i-c_1)^2+min_{c_2}\sum_{x_i \in R_2(j,s)}(y_i-c_2)^2]$$<br>其中，$c_1&#x3D;ave(y_i|x_i \in R_1(j,s)) \quad \quad \quad c_1&#x3D;ave(y_i|x_i \in R_1(j,s))$<br>遍历所有输入变量，找到最优的切分变量j，构成一对(j,s)。根据这个点将空间划分两个区域，接着对每个区域重复上述划分过程，直到满足条件为止。</p>
</blockquote>
<p><b>具体算法如下：</b></p>
<blockquote>
<p><b>输入：</b>训练数据集D<br><b>输出：</b>回归树f(x)<br>(1) 选择一个切分变量j与切分点s，求解<br>$$min_{j,s}[min_{c_1}\sum_{x_i \in R_1(j,s)}(y_i-c_1)^2+min_{c_2}\sum_{x_i \in R_2(j,s)}(y_i-c_2)^2]$$<br>遍历变量j，对固定的切分变量j扫描切分点s，找到令上式达到最小值的(j,s)<br>(2) 用选定的(j,s)划分区域并决定相应的输出值：<br>$$R_1(j,s)&#x3D;(x|x^{(j)} \le s ) \quad \quad \quad R_2(j,s)&#x3D;(x|x^{(j)} &gt; s )$$<br>$$c_m&#x3D;ave(y_i|x_i \in R_m(j,s))$$<br>(3) 继续对两个子区域调用步骤(1),(2)，直到满足条件为止<br>(4) 将输入空间划分为M个区域$R_1,R_2,…,R_M$，生成决策树f(x)</p>
</blockquote>
</blockquote>
<h5 id="分类树"><a href="#分类树" class="headerlink" title="分类树"></a><b>分类树</b></h5><blockquote>
<p>分类树的算法与前面的ID3和C4.5算法大致类似。都是根据某一个特征选择的标准参数来进行特征选择，然后构造决策树。CART中的分类树则是根据<b>基尼指数</b>进行选择。</p>
<ul>
<li><b>基尼指数</b>：<blockquote>
<p>基尼指数指的是样本集合中一个随机选中的样本被分错的概率，即基尼指数越小那么样本中被分错的概率就越小。<br>基尼指数（基尼不纯度）&#x3D;样本被选中的概率 * 样本被分错的概率<br><b>定义：</b></p>
<ul>
<li>设有K个类，样本点属于第k类的概率为$p_k$，则概率分布的基尼指数定义为：<br>$$Gini(p)&#x3D;\sum_{k&#x3D;1}^K p_k(1-p_k)&#x3D;1- \sum_{k&#x3D;1}^K p_k ^2$$</li>
<li>如果是二分类问题设第一类的概率为p，那么其基尼指数为：<br>$$Gini(p)&#x3D;2p(1-p)$$</li>
<li>对于指定的样本集合D，其基尼指数为(其中$C_k$是D中属于第k类的样本子集，K是类的个数)：<br>$$Gini(D)&#x3D;1-\sum_{k&#x3D;1}^K(\frac{|C_k|}{|D|})^2$$</li>
<li>在特征A的条件下，集合D的基尼指数定义为：<br>$$Gini(D,A)&#x3D;\frac{|D_1|}{|D|}Gini(D_1)+\frac{|D_2|}{|D|}Gini(D_2)$$</li>
</ul>
</blockquote>
</li>
</ul>
<p> <b>算法描述：</b></p>
<blockquote>
<p><b>输入：</b>训练数据集D，停止计算的条件<br><b>输出：</b>CART决策树<br>(1) 设结点的训练数据集为D，计算现有特征对该数据集的基尼指数。此时，对每一个特征A，对其可能取的每一个值a，根据样本点对A&#x3D;a的测试为“是”或“否”将D分为$D_1$和$D_2$两部分，并计算A&#x3D;a的基尼指数。<br>(2) 在所有可能的特征A及其它们所有可能的切分点a中，<b>选择基尼指数最小的特征</b>及其对应的切分点作为最优特征与最优切分点，根据这个从现结点生成两个子结点，并将训练数据集依照特征分配到两个子结点中去。<br>(3) 对两个子结点递归调用(1),(2)，直到满足条件为止。<br>(4) 生成CART决策树<br><b>补充：</b>停止条件一般为结点中样本个数小于预定的阈值，或样本中的基尼指数小于阈值，或者没有更多特征了。</p>
</blockquote>
</blockquote>
<h5 id="CART剪枝"><a href="#CART剪枝" class="headerlink" title="CART剪枝"></a><b>CART剪枝</b></h5><blockquote>
<p>在CART中决策树的剪枝遵循着一个算法，但是我…<br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%A1%A8%E6%83%85%E5%8C%85/%E6%88%91%E6%91%B8%E5%88%B0%E4%BA%86.jpg" alt="摸鱼" title="摸鱼"></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>深渊巨坑</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>串</title>
    <url>/2021/10/13/%E4%B8%B2/</url>
    <content><![CDATA[<h4 id="串的介绍"><a href="#串的介绍" class="headerlink" title="串的介绍"></a><b>串的介绍</b></h4><blockquote>
<ul>
<li><p><b>串</b>是由零个或多个字符组成的有限序列，一般记为：</p>
<blockquote>
<p>$$S&#x3D;”a_1a_2…a_n”$$</p>
<ul>
<li>其中S称为串名，引号内的字符序列称为串的内容；</li>
<li>a可以是数字、字母、文字甚至其他字符；</li>
<li>串中的个数n代表了串的长度，称为串长，当n&#x3D;0时的串称为<b>空串</b>。<br><b>注意：</b>空格串指的是串里全是空格字符的串，这与空串不相等。</li>
</ul>
</blockquote>
</li>
<li><p>串中任意多个<b>连续的字符</b>组成的子序列称为S的子串，空串是任何串的<b>子串</b>（可以类比与子集）。相对的，包含任何子串的就称为<b>主串</b>。</p>
</li>
<li><p><b>子串的位置：</b>特指子串在主串中第一个字符的位置。</p>
</li>
<li><p><b>串与线性表的区别：</b></p>
<blockquote>
<ul>
<li>串的数据对象仅限于字符集。</li>
<li>线性表的操作对象称为元素，<b>串的操作对象为子串。</b>（这是串和全是字符的线性表的最大区别）</li>
</ul>
</blockquote>
</li>
<li><p><b>Ascii编码表：</b></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%B2/ascii%E8%A1%A8.jpg" alt="ascii表" title="ascii表"></p>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a><b>串的存储结构</b></h4><h5 id="定长顺序存储结构"><a href="#定长顺序存储结构" class="headerlink" title="定长顺序存储结构"></a><b>定长顺序存储结构</b></h5><blockquote>
<p>类似与线性表的顺序存储结构，用了一组连续的存储单元存储串值得字符序列。在串中每个串变量分配一个固定长度得存储区，即定长数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SString</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> ch[MAXLEN];</span><br><span class="line">   <span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于串长的记录有两种方法：</p>
<blockquote>
<ul>
<li>第一种就是像上面那样用一个<code>length</code>来记录串长</li>
<li>第二种则是在每个串后面加入一个不计入串长的结束标记字符<code>&#39;\0&#39;</code>,此时串长是一个隐含值。</li>
</ul>
</blockquote>
</blockquote>
<h5 id="堆分配存储表示"><a href="#堆分配存储表示" class="headerlink" title="堆分配存储表示"></a><b>堆分配存储表示</b></h5><blockquote>
<p>堆分配存储表示仍然以一组地址连续的存储单元存放串值得字符序列，但是他么得存储空间在程序执行过程中动态分配得到的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HString</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> *ch;</span><br><span class="line">   <span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在C语言中，存在一个称之为“堆”的自由存储区，用<code>malloc()</code>和<code>free()</code>函数来完成动态存储管理。在使用结束后需要使用<code>free()</code>来释放内存空间。</p>
</blockquote>
<h5 id="块链存储表示"><a href="#块链存储表示" class="headerlink" title="块链存储表示"></a><b>块链存储表示</b></h5><blockquote>
<p>类似与线性表中的链式存储结构，也可以采用链表方式存储串值。<br>由于串的特殊性（每一个位置只能存串的一个字符），而在32位系统中指针占4个字节。因此如果每个结点只放一个字符的话会导致存储密度较低。<br>所以可以在一个结点中多放多个字符，每个结点称为<b>块</b>。<br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%B2/%E5%9D%97%E9%93%BE%E5%AD%98%E5%82%A8%E8%A1%A8%E7%A4%BA.png" alt="块链" title="块链"><br>当然如果一个块填不满的时候可以用<code>#</code>来填充。</p>
</blockquote>
<h4 id="串的基本操作"><a href="#串的基本操作" class="headerlink" title="串的基本操作"></a><b>串的基本操作</b></h4><blockquote>
<p><b>注：</b>这里的串都为定长顺序存储结构。</p>
<ul>
<li><p><b>串的初始化：</b></p>
<blockquote>
<p>创建一个字符串数组，并且将字符串的长度置为0。<br><b>代码示例：</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">SString <span class="title">InitStr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   SString s;</span><br><span class="line">   s.length=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><b>串的赋值操作</b></p>
<blockquote>
<p>将串T（开始或许为非空）赋值为chars。<br><b>代码示例：</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StrAssign</span><span class="params">(SString &amp;T, SString chars)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">ClearString</span>(T);</span><br><span class="line">   <span class="keyword">if</span>(!<span class="built_in">StrEmpty</span>(chars))</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=chars.length;i++)</span><br><span class="line">               T.ch[i] = chars.ch[i];</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><b>判断串是否为空</b></p>
<blockquote>
<p>判串是否为空。<br><b>代码示例：</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StrEmpty</span><span class="params">(SString S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(S.length==<span class="number">0</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><b>清空串：</b></p>
<blockquote>
<p>清空串，将串初始化。<br><b>代码示例：</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ClearString</span><span class="params">(SString &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">StrEmpty</span>(S))</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           S=<span class="built_in">InitStr</span>();</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><b>复制操作</b></p>
<blockquote>
<p>将串S复制得到T。<br><b>代码示例：</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StrCopy</span><span class="params">(SString &amp;T,SString S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">StrEmpty</span>(S))</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=S.length;i++)</span><br><span class="line">       T.ch[i] = S.ch[i];</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><b>比较操作</b></p>
<blockquote>
<p>按字典的顺序比较串S和串T的大小，当S&gt;T返回1，S&#x3D;T返回0，S&lt;T返回-1。<br><b>代码示例：</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">StrCompare</span><span class="params">(SString S, SString T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> len = S.length;</span><br><span class="line">   <span class="type">int</span> flag =<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span>(len&lt;T.length)</span><br><span class="line">       &#123;</span><br><span class="line">           len=T.length;</span><br><span class="line">           flag=<span class="number">-1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(len==T.length)</span><br><span class="line">       flag=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(S.ch[i]==T.ch[i])</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       <span class="keyword">if</span>(S.ch[i]&lt;T.ch[i])</span><br><span class="line">           <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(S.ch[i]&gt;T.ch[i])</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(flag==<span class="number">-1</span>)   <span class="comment">//在两者字符比较完都没分出大小时，较长的串排在后面。</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><b>求子串</b></p>
<blockquote>
<p>用Sub返回串S的第pos个字符起长度为len的子串。<br><b>代码示例：</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SubString</span><span class="params">(SString &amp;Sub, SString S, <span class="type">int</span> pos, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">StrEmpty</span>(S))</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="built_in">ClearString</span>(Sub);</span><br><span class="line">   Sub.length=len;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">       Sub.ch[i]=S.ch[pos+i<span class="number">-1</span>];</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><b>串的拼接</b></p>
<blockquote>
<p>将串S1和串S2拼接起来存到T中。<br><b>代码示例：</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Concat</span><span class="params">(SString &amp;T,SString S1,SString S2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(S1.length+S2.length &gt; MAXLEN)</span><br><span class="line">       cout&lt;&lt;<span class="string">&quot;长度溢出，会导致拼接后丢失一部分字符。&quot;</span>&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=S1.length+S2.length,j&lt;=S2.length;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(i&lt;=S1.length)</span><br><span class="line">           T.ch[i]=S1.ch[i];</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               T.ch[i]=S2.ch[j];</span><br><span class="line">               j++;</span><br><span class="line">           &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   T.length = S1.length+S2.length;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><b>定位子串（暴力串的匹配）</b></p>
<blockquote>
<p>返回子串T第一次出现在主串S的位置。<br><b>代码示例：</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index</span><span class="params">(SString S,SString T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T.length&gt;S.length)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   SString sub;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=S.length-T.length+<span class="number">1</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       sub.length=T.length;</span><br><span class="line">       <span class="built_in">SubString</span>(sub,S,i,T.length);</span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">StrCompare</span>(sub,T)==<span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</blockquote>
<h4 id="串的匹配算法"><a href="#串的匹配算法" class="headerlink" title="串的匹配算法"></a><b>串的匹配算法</b></h4><blockquote>
<p>子串的定位操作称为串的<b>模式匹配</b>，它是求子串<b>（也称模式串）</b>在主串的位置。<br>模式串的匹配较多出现在搜索的案例中，例如网络搜索引擎，关键字搜索引擎。<br>比较常见的为<b>BF算法（暴力法）</b>和<b>KMP算法</b>。</p>
</blockquote>
<h5 id="暴力匹配法"><a href="#暴力匹配法" class="headerlink" title="暴力匹配法"></a><b>暴力匹配法</b></h5><blockquote>
<p>顾名思义，暴力法就是简单的将模式串一直和主串进行对比。<br><b>例子：</b></p>
<blockquote>
<ul>
<li>首先，模式串与主串对其，然后一一比较。<br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%B2/BF1.png" alt="BF算法" title="BF算法"></li>
<li>由于模式串中第三个字符与主串的比配失败了，所以模式串A向后移一步，继续与主串匹配。<br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%B2/BF2.png" alt="BF算法" title="BF算法"></li>
<li>模式串一开始就匹配失败了，所以模式串继续向后移一步，继续和主串匹配。<br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%B2/BF3.png" alt="BF算法" title="BF算法"></li>
<li>模式串的最后一个字符匹配失败，此时模式串依旧向后移一步，继续和主串匹配。<br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%B2/BF4.png" alt="BF算法" title="BF算法"></li>
<li>最终模式串与主串完全匹配，输出主串中的i作为模式串的位置。</li>
</ul>
</blockquote>
<p><b>代码：</b></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定位子串，返回子串T第一次出现在主串S的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BF</span><span class="params">(SString S,SString T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T.length&gt;S.length)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   SString sub;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=S.length-T.length+<span class="number">1</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       sub.length=T.length;</span><br><span class="line">       <span class="built_in">SubString</span>(sub,S,i,T.length);</span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">StrCompare</span>(sub,T)==<span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><b>总结：</b></p>
<blockquote>
<ul>
<li>BF算法的最大优势是原理简单，实现也简单。</li>
<li>但缺点是时间复杂度太高。<blockquote>
<ul>
<li>假设有一个长度为n的主串B，一个长度为m的模式串A。</li>
<li>在最好的情况下（即模式串在主串的开头），此时的时间复杂度为$o(m)$</li>
<li>最坏的情况是模式串在匹配时，总是在最后一个字符中匹配失败，那么主串中的指针i就要一直回退，而且对于主串B中的每一个字符都要重复匹配m次，这使得时间复杂度标为$o(m*n)$</li>
</ul>
</blockquote>
</li>
</ul>
<p>所以为了解决这一个问题，我们可以使用一种方法来让主串的指针i不回退，从而降低时间复杂度，这就是KMP算法要解决的问题了。</p>
</blockquote>
</blockquote>
<h5 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a><b>KMP算法</b></h5><blockquote>
<p>在介绍KMP算法之前先补充两个概念：</p>
<blockquote>
<ul>
<li><b>前缀：</b>指除最后一个字符以外，字符串的所有头部字串。如，”hello”中的前缀为：”h,he,hel,hell”</li>
<li><b>后缀：</b>指除第一个字符以外，字符串的所有尾部字串。如，”hello”中的后缀为：”o,lo,llo,ello”</li>
<li><b>部分匹配值：</b>字符串前缀和后缀的最长相等前后缀长度。如，”ababa”的前缀和后缀的最长相等前后缀长为”aba”，所以部分匹配值为3。</li>
</ul>
</blockquote>
<ul>
<li><p>假设现在有主串A&#x3D;”ababcababa”，模式串B&#x3D;”ababa”</p>
</li>
<li><p>在第一次匹配时模式串会在’c’上匹配失败，前面的’abab’是匹配得上的。如果按照暴力法那么主串的i要回退到第一个’b’上，j也要回退到第一个’a’上。</p>
</li>
<li><p>如果是KMP算法，因为是在’c’上匹配失败，那么前面的’ab’是匹配得上的，那么模式串的第一个’ab’可以跳过匹配，j直接指向第二个’a’上，而主串的i保持不变。<br><b>KMP算法示意图：</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%B2/KMP.gif" alt="KMP算法" title="KMP算法"></p>
</li>
<li><p><b>next数组表：</b></p>
<blockquote>
<p>KMP算法中，对于j值的回溯可以时先算出一个next数组表，那么每次进行匹配时可以直接参照next数组表的值进行j的回溯。</p>
<ul>
<li>next数组表其实就是模式串中每一个字符的部分匹配值。</li>
<li>要注意的是，next数组第一个数规定为0(或-1)，第二个为1。<br><b>特性：</b>next数组的增加是循序渐进的即，1，2，3，4……这样的，不可能出现1，3，4……这种断层情况。<br><b>代码实现</b><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_next</span><span class="params">(SString T, <span class="type">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;</span><br><span class="line">   next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(i&lt;T.length)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(j==<span class="number">0</span>||T.ch[i]==T.ch[j])</span><br><span class="line">       &#123;</span><br><span class="line">           ++i; ++j;</span><br><span class="line">           next[i]=j;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           j=next[j];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
<p>在计算完next数组后，我们就可以固定遍历主串的i一直不回退得寻找子串位置了。<br><b>代码：</b></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">KMP</span><span class="params">(SString T,SString t,<span class="type">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(i&lt;=T.length &amp;&amp; j&lt;=t.length)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(T.ch[i] == t.ch[j]||j==<span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           i++;j++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           j=next[j];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(j&gt;t.length)</span><br><span class="line">       <span class="keyword">return</span> i-t.length;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><b>补充：</b></p>
<ul>
<li>上诉代码体现了指向主串的i不回退，每次只回退指向模式串的j。</li>
<li>值得注意的是，在模式串有规律的情况下（即next不是全为1），KMP算法才相较于暴力算法有优势，否则（next全为1）这两个算法时间复杂度相近。</li>
</ul>
</blockquote>
<h5 id="KMP算法的改进"><a href="#KMP算法的改进" class="headerlink" title="KMP算法的改进"></a><b>KMP算法的改进</b></h5><blockquote>
<p>对于KMP算法来说，上面的next仍然有一些不足。<br><b>例如：</b></p>
<blockquote>
<ul>
<li>假定一个模式串为：”aaaab”</li>
<li>如果用上述的算法求出来的next数组为：01234</li>
<li>但实际在匹配的时候，如果在模式串中的第四个字符’a’匹配失败时，<b>此时明知主串中这个位置的字符不是’a’了，但根据上面的next数组，j还是会返回到模式串的第三个字符’a’</b>，然后照样匹配失败，然后到模式串中第二个字符’a’，直到j&#x3D;0为止。</li>
</ul>
</blockquote>
<ul>
<li>如果出现上面的情况，那么就会白白多做了3次无用匹配。</li>
<li>为了防止这种现象，我们将上面的next进行改造：nextval&#x3D;00004</li>
<li>即当我在匹配模式串中字符’a’失败时，j直接置为0，跳过无用的回溯。<br><b>代码：</b><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_nextval</span><span class="params">(SString T, <span class="type">int</span> nextval[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;</span><br><span class="line">   nextval[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(i&lt;T.length)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(j==<span class="number">0</span>||T.ch[i]==T.ch[j])</span><br><span class="line">       &#123;</span><br><span class="line">           ++i; ++j;</span><br><span class="line">           <span class="keyword">if</span>(T.ch[i]!=T.ch[j])</span><br><span class="line">               nextval[i]=j;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               nextval[i]=nextval[j];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           j=nextval[j];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>基础学科</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>决策树实例代码</title>
    <url>/2021/08/21/%E5%86%B3%E7%AD%96%E6%A0%91%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h4 id="基本算法："><a href="#基本算法：" class="headerlink" title="基本算法："></a><b>基本算法：</b></h4><blockquote>
<p><b>输入：</b>训练数据集D<br><b>输出：</b>回归树f(x)<br>(1) 选择一个切分变量j与切分点s，求解<br>$$min_{j,s}[min_{c_1}\sum_{x_i \in R_1(j,s)}(y_i-c_1)^2+min_{c_2}\sum_{x_i \in R_2(j,s)}(y_i-c_2)^2]$$<br>遍历变量j，对固定的切分变量j扫描切分点s，找到令上式达到最小值的(j,s)<br>(2) 用选定的(j,s)划分区域并决定相应的输出值：<br>$$R_1(j,s)&#x3D;(x|x^{(j)} \le s ) \quad \quad \quad R_2(j,s)&#x3D;(x|x^{(j)} &gt; s )$$<br>$$c_m&#x3D;ave(y_i|x_i \in R_m(j,s))$$<br>(3) 继续对两个子区域调用步骤(1),(2)，直到满足条件为止<br>(4) 将输入空间划分为M个区域$R_1,R_2,…,R_M$，生成决策树f(x)</p>
</blockquote>
<h4 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a><b>具体代码</b></h4><blockquote>
<ul>
<li><p><b>导入的包：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">import</span> pickle</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><b>创建数据集：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">createDataSet</span>():</span><br><span class="line">   dataSet = [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;no&#x27;</span>],  <span class="comment"># 数据集</span></span><br><span class="line">              [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">              [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">              [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">              [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">              [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">              [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">              [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">              [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">              [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">              [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">              [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">              [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">              [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">              [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;no&#x27;</span>]]</span><br><span class="line">   labels = [<span class="string">&#x27;年龄&#x27;</span>, <span class="string">&#x27;有工作&#x27;</span>, <span class="string">&#x27;有自己的房子&#x27;</span>, <span class="string">&#x27;信贷情况&#x27;</span>]  <span class="comment"># 分类属性</span></span><br><span class="line">   <span class="keyword">return</span> dataSet, labels  <span class="comment"># 返回数据集和分类属性</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<p><b>数据集的样貌：</b><br> <img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%86%B3%E7%AD%96%E6%A0%91/%E6%A0%B7%E4%BE%8B.png" alt="样例图" title="样例"></p>
<ul>
<li><p><b>计算香农熵：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calcShannonEnt</span>(<span class="params">dataSet</span>):</span><br><span class="line">   numEntries = <span class="built_in">len</span>(dataSet)  <span class="comment"># 数据集的行数</span></span><br><span class="line">   labelsCounts = &#123;&#125;  <span class="comment"># 每个标签(yes和no)出现次数的字典</span></span><br><span class="line">   <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">       currentLabel = featVec[-<span class="number">1</span>]</span><br><span class="line">       <span class="keyword">if</span> currentLabel <span class="keyword">not</span> <span class="keyword">in</span> labelsCounts.keys():</span><br><span class="line">           labelsCounts[currentLabel] = <span class="number">0</span></span><br><span class="line">       labelsCounts[currentLabel] += <span class="number">1</span></span><br><span class="line">   shannonEnt = <span class="number">0.0</span>  <span class="comment"># 经验熵</span></span><br><span class="line">   <span class="keyword">for</span> key <span class="keyword">in</span> labelsCounts:  <span class="comment"># 开始计算经验熵</span></span><br><span class="line">       prob = <span class="built_in">float</span>(labelsCounts[key]) / numEntries  <span class="comment"># 计算该标签（yes或no）的概率</span></span><br><span class="line">       shannonEnt -= prob * log(prob, <span class="number">2</span>)  <span class="comment"># 根据定义计算</span></span><br><span class="line">   <span class="keyword">return</span> shannonEnt</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><b>根据某个特征进行划分数据集：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">data要切分的为数据集</span></span><br><span class="line"><span class="string">axis为要切分的特征索引（如年龄，有工作，有自己的房子，信贷情况）</span></span><br><span class="line"><span class="string">value为特征的具体值(如年龄中的青年、中年、老年)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 将数据集按照某个特征划分</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">splitDataSet</span>(<span class="params">dataSet, axis, value</span>):</span><br><span class="line">   retDataSet = []</span><br><span class="line">   <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">       <span class="keyword">if</span> featVec[axis] == value:  <span class="comment"># 分类的地方</span></span><br><span class="line">           reducedFeatVec = featVec[:axis]  <span class="comment"># 在axis前的所有数据，如axis为&quot;有工作&quot;的索引时，featVec[:axis]就代表“年龄”这一列数据</span></span><br><span class="line">           reducedFeatVec.extend(</span><br><span class="line">               featVec[axis + <span class="number">1</span>:])  <span class="comment"># 在axis后的所有数据，如axis为&quot;有工作&quot;的索引时。featVec[axis+1:]代表“有自己的房子”和“信贷情况”的数据</span></span><br><span class="line">           retDataSet.append(reducedFeatVec)</span><br><span class="line">   <span class="keyword">return</span> retDataSet  <span class="comment"># 仅返回索引值为axis的特征中，值为value的数据</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><b>计算信息增益，并且返回最优特征</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算信息增益，并返回信息增益最大的特征索引值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chooseBestFeatureToSplit</span>(<span class="params">dataSet</span>):</span><br><span class="line">   numFeatures = <span class="built_in">len</span>(dataSet[<span class="number">0</span>]) - <span class="number">1</span>  <span class="comment"># 数据集特征数</span></span><br><span class="line">   baseEntropy = calcShannonEnt(dataSet)  <span class="comment"># 计算数据几的信息熵</span></span><br><span class="line">   bestInfoGain = <span class="number">0.0</span>  <span class="comment"># 信息增益</span></span><br><span class="line">   bestFeature = -<span class="number">1</span>  <span class="comment"># 最优特征的索引值</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numFeatures):</span><br><span class="line">       featList = [example[i] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]  <span class="comment"># 我看不懂，但我大为震撼</span></span><br><span class="line">       uniqueVals = <span class="built_in">set</span>(featList)  <span class="comment"># 各特征值</span></span><br><span class="line">       newEntropy = <span class="number">0.0</span>  <span class="comment"># 经验条件熵</span></span><br><span class="line">       <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:  <span class="comment"># 计算信息增益</span></span><br><span class="line">           <span class="comment"># print(&quot;value=&quot;, value, &quot;i=&quot;, i)</span></span><br><span class="line">           subDataSet = splitDataSet(dataSet, i, value)</span><br><span class="line">           prob = <span class="built_in">len</span>(subDataSet) / <span class="built_in">float</span>(<span class="built_in">len</span>(dataSet))</span><br><span class="line">           newEntropy += prob * calcShannonEnt(subDataSet)  <span class="comment"># 计算经验条件熵</span></span><br><span class="line">       infoGain = baseEntropy - newEntropy  <span class="comment"># 计算信息增益</span></span><br><span class="line">       <span class="comment"># print(&quot;第&quot;, i, &quot;个特征的增益为&quot;, infoGain)</span></span><br><span class="line">       <span class="keyword">if</span> infoGain &gt; bestInfoGain:</span><br><span class="line">           bestInfoGain = infoGain</span><br><span class="line">           bestFeature = i</span><br><span class="line">   <span class="keyword">return</span> bestFeature</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><b>在数据集中找到出现最多的元素：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找classList中出现最多的元素</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">majorityCount</span>(<span class="params">classList</span>):</span><br><span class="line">   classCount = &#123;&#125;</span><br><span class="line">   <span class="keyword">for</span> vote <span class="keyword">in</span> classList:</span><br><span class="line">       <span class="keyword">if</span> vote <span class="keyword">not</span> <span class="keyword">in</span> classCount.keys(): classCount[vote] = <span class="number">0</span></span><br><span class="line">       classCount[vote] += <span class="number">1</span></span><br><span class="line">   sortedClassCount = <span class="built_in">sorted</span>(classCount.items(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="literal">True</span>)</span><br><span class="line">   <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><b>创建决策树：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">createTree</span>(<span class="params">dataSet, labels, featLabels</span>):</span><br><span class="line">   classList = [example[-<span class="number">1</span>] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]  <span class="comment"># 去分类标签“yes”或“no”</span></span><br><span class="line">   <span class="keyword">if</span> classList.count(classList[<span class="number">0</span>]) == <span class="built_in">len</span>(classList):  <span class="comment"># 如果类别完全相同则停止划分</span></span><br><span class="line">       <span class="keyword">return</span> classList[<span class="number">0</span>]</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(dataSet[<span class="number">0</span>]) == <span class="number">1</span>:  <span class="comment"># 如果全部特征都划分完后，选择出现最多的元素进行返回</span></span><br><span class="line">       <span class="keyword">return</span> majorityCount(classList)</span><br><span class="line">   bestFeat = chooseBestFeatureToSplit(dataSet)  <span class="comment"># 选择最优特征的索引</span></span><br><span class="line">   bestFeatLabel = labels[bestFeat]</span><br><span class="line">   featLabels.append(bestFeatLabel)  <span class="comment"># 存储最优特征的标签</span></span><br><span class="line">   myTree = &#123;bestFeatLabel: &#123;&#125;&#125;  <span class="comment"># 根据最优特征的标签生成树</span></span><br><span class="line">   <span class="keyword">del</span> (labels[bestFeat])  <span class="comment"># 删除已经使用的特征标签</span></span><br><span class="line">   featValues = [example[bestFeat] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]  <span class="comment"># 得到训练集中所有最优特征的属性值</span></span><br><span class="line">   uniqueVal = <span class="built_in">set</span>(featValues)</span><br><span class="line">   <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVal:</span><br><span class="line">       <span class="comment"># 递归生成树</span></span><br><span class="line">       myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet, bestFeat, value), labels, featLabels)</span><br><span class="line">   <span class="keyword">return</span> myTree</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><b>根据决策树进行分类</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据决策树对点进行分类</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">classify</span>(<span class="params">inputTree, featLabels, testVec</span>):</span><br><span class="line">   firstStr = <span class="built_in">next</span>(<span class="built_in">iter</span>(inputTree))  <span class="comment"># 获取根节点</span></span><br><span class="line">   secondDict = inputTree[firstStr]  <span class="comment"># 获取根节点下的两颗树</span></span><br><span class="line">   featIndex = featLabels.index(firstStr)</span><br><span class="line">   <span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">       <span class="keyword">if</span> testVec[featIndex] == key:</span><br><span class="line">           <span class="keyword">if</span> <span class="built_in">type</span>(secondDict[key]).__name__ == <span class="string">&#x27;dict&#x27;</span>:  <span class="comment"># 如果子节点是一棵树，那么递归调用分类器</span></span><br><span class="line">               classLabel = classify(secondDict[key], featLabels, testVec)</span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               classLabel = secondDict[key]  <span class="comment"># 如果子节点是一个叶子节点，那么直接返回</span></span><br><span class="line">   <span class="keyword">return</span> classLabel</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><b>主函数：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   dataSet, labels = createDataSet()</span><br><span class="line">   featLabels = []</span><br><span class="line">   myTree = createTree(dataSet, labels, featLabels)</span><br><span class="line">   <span class="built_in">print</span>(myTree)</span><br><span class="line">   testVec = [<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">   result = classify(myTree, featLabels, testVec)</span><br><span class="line">   <span class="keyword">if</span> result == <span class="string">&#x27;yes&#x27;</span>:</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;放贷&#x27;</span>)</span><br><span class="line">   <span class="keyword">if</span> result == <span class="string">&#x27;no&#x27;</span>:</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;不放贷&#x27;</span>)</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><b>DLC（拓展）</b>：将决策树转为二进制形式存储起来，以及读取二进制形式的决策树</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 存储决策树</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">storeTree</span>(<span class="params">inputTree, filename</span>):</span><br><span class="line">   <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fw:</span><br><span class="line">       pickle.dump(inputTree, fw)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取决策树</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">grabTree</span>(<span class="params">filename</span>):</span><br><span class="line">   fr = <span class="built_in">open</span>(filename, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">   <span class="keyword">return</span> pickle.load(fr)</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</blockquote>
<hr>
<blockquote>
<ul>
<li><p><b>完整代码：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createDataSet</span>():</span><br><span class="line">   dataSet = [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;no&#x27;</span>],  <span class="comment"># 数据集</span></span><br><span class="line">              [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">              [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">              [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">              [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">              [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">              [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">              [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">              [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">              [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">              [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">              [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">              [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">              [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">              [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;no&#x27;</span>]]</span><br><span class="line">   labels = [<span class="string">&#x27;年龄&#x27;</span>, <span class="string">&#x27;有工作&#x27;</span>, <span class="string">&#x27;有自己的房子&#x27;</span>, <span class="string">&#x27;信贷情况&#x27;</span>]  <span class="comment"># 分类属性</span></span><br><span class="line">   <span class="keyword">return</span> dataSet, labels  <span class="comment"># 返回数据集和分类属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calcShannonEnt</span>(<span class="params">dataSet</span>):</span><br><span class="line">   numEntries = <span class="built_in">len</span>(dataSet)  <span class="comment"># 数据集的行数</span></span><br><span class="line">   labelsCounts = &#123;&#125;  <span class="comment"># 每个标签(yes和no)出现次数的字典</span></span><br><span class="line">   <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">       currentLabel = featVec[-<span class="number">1</span>]</span><br><span class="line">       <span class="keyword">if</span> currentLabel <span class="keyword">not</span> <span class="keyword">in</span> labelsCounts.keys():</span><br><span class="line">           labelsCounts[currentLabel] = <span class="number">0</span></span><br><span class="line">       labelsCounts[currentLabel] += <span class="number">1</span></span><br><span class="line">   shannonEnt = <span class="number">0.0</span>  <span class="comment"># 经验熵</span></span><br><span class="line">   <span class="keyword">for</span> key <span class="keyword">in</span> labelsCounts:  <span class="comment"># 开始计算经验熵</span></span><br><span class="line">       prob = <span class="built_in">float</span>(labelsCounts[key]) / numEntries  <span class="comment"># 计算该标签（yes或no）的概率</span></span><br><span class="line">       shannonEnt -= prob * log(prob, <span class="number">2</span>)  <span class="comment"># 根据定义计算</span></span><br><span class="line">   <span class="keyword">return</span> shannonEnt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">data要切分的为数据集</span></span><br><span class="line"><span class="string">axis为要切分的特征索引（如年龄，有工作，有自己的房子，信贷情况）</span></span><br><span class="line"><span class="string">value为特征的具体值(如年龄中的青年、中年、老年)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 将数据集按照某个特征划分</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">splitDataSet</span>(<span class="params">dataSet, axis, value</span>):</span><br><span class="line">   retDataSet = []</span><br><span class="line">   <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">       <span class="keyword">if</span> featVec[axis] == value:  <span class="comment"># 分类的地方</span></span><br><span class="line">           reducedFeatVec = featVec[:axis]  <span class="comment"># 在axis前的所有数据，如axis为&quot;有工作&quot;的索引时，featVec[:axis]就代表“年龄”这一列数据</span></span><br><span class="line">           reducedFeatVec.extend(</span><br><span class="line">               featVec[axis + <span class="number">1</span>:])  <span class="comment"># 在axis后的所有数据，如axis为&quot;有工作&quot;的索引时。featVec[axis+1:]代表“有自己的房子”和“信贷情况”的数据</span></span><br><span class="line">           retDataSet.append(reducedFeatVec)</span><br><span class="line">   <span class="keyword">return</span> retDataSet  <span class="comment"># 仅返回索引值为axis的特征中，值为value的数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算信息增益，并返回信息增益最大的特征索引值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chooseBestFeatureToSplit</span>(<span class="params">dataSet</span>):</span><br><span class="line">   numFeatures = <span class="built_in">len</span>(dataSet[<span class="number">0</span>]) - <span class="number">1</span>  <span class="comment"># 数据集特征数</span></span><br><span class="line">   baseEntropy = calcShannonEnt(dataSet)  <span class="comment"># 计算数据几的信息熵</span></span><br><span class="line">   bestInfoGain = <span class="number">0.0</span>  <span class="comment"># 信息增益</span></span><br><span class="line">   bestFeature = -<span class="number">1</span>  <span class="comment"># 最优特征的索引值</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numFeatures):</span><br><span class="line">       featList = [example[i] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]  <span class="comment"># 我看不懂，但我大为惊叹</span></span><br><span class="line">       uniqueVals = <span class="built_in">set</span>(featList)  <span class="comment"># 各特征值</span></span><br><span class="line">       newEntropy = <span class="number">0.0</span>  <span class="comment"># 经验条件熵</span></span><br><span class="line">       <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:  <span class="comment"># 计算信息增益</span></span><br><span class="line">           <span class="comment"># print(&quot;value=&quot;, value, &quot;i=&quot;, i)</span></span><br><span class="line">           subDataSet = splitDataSet(dataSet, i, value)</span><br><span class="line">           prob = <span class="built_in">len</span>(subDataSet) / <span class="built_in">float</span>(<span class="built_in">len</span>(dataSet))</span><br><span class="line">           newEntropy += prob * calcShannonEnt(subDataSet)  <span class="comment"># 计算经验条件熵</span></span><br><span class="line">       infoGain = baseEntropy - newEntropy  <span class="comment"># 计算信息增益</span></span><br><span class="line">       <span class="comment"># print(&quot;第&quot;, i, &quot;个特征的增益为&quot;, infoGain)</span></span><br><span class="line">       <span class="keyword">if</span> infoGain &gt; bestInfoGain:</span><br><span class="line">           bestInfoGain = infoGain</span><br><span class="line">           bestFeature = i</span><br><span class="line">   <span class="keyword">return</span> bestFeature</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 找classList中出现最多的元素</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">majorityCount</span>(<span class="params">classList</span>):</span><br><span class="line">   classCount = &#123;&#125;</span><br><span class="line">   <span class="keyword">for</span> vote <span class="keyword">in</span> classList:</span><br><span class="line">       <span class="keyword">if</span> vote <span class="keyword">not</span> <span class="keyword">in</span> classCount.keys(): classCount[vote] = <span class="number">0</span></span><br><span class="line">       classCount[vote] += <span class="number">1</span></span><br><span class="line">   sortedClassCount = <span class="built_in">sorted</span>(classCount.items(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="literal">True</span>)</span><br><span class="line">   <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createTree</span>(<span class="params">dataSet, labels, featLabels</span>):</span><br><span class="line">   classList = [example[-<span class="number">1</span>] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]  <span class="comment"># 去分类标签“yes”或“no”</span></span><br><span class="line">   <span class="keyword">if</span> classList.count(classList[<span class="number">0</span>]) == <span class="built_in">len</span>(classList):  <span class="comment"># 如果类别完全相同则停止划分</span></span><br><span class="line">       <span class="keyword">return</span> classList[<span class="number">0</span>]</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(dataSet[<span class="number">0</span>]) == <span class="number">1</span>:  <span class="comment"># 如果全部特征都划分完后，选择出现最多的元素进行返回</span></span><br><span class="line">       <span class="keyword">return</span> majorityCount(classList)</span><br><span class="line">   bestFeat = chooseBestFeatureToSplit(dataSet)  <span class="comment"># 选择最优特征的索引</span></span><br><span class="line">   bestFeatLabel = labels[bestFeat]</span><br><span class="line">   featLabels.append(bestFeatLabel)  <span class="comment"># 存储最优特征的标签</span></span><br><span class="line">   myTree = &#123;bestFeatLabel: &#123;&#125;&#125;  <span class="comment"># 根据最优特征的标签生成树</span></span><br><span class="line">   <span class="keyword">del</span> (labels[bestFeat])  <span class="comment"># 删除已经使用的特征标签</span></span><br><span class="line">   featValues = [example[bestFeat] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]  <span class="comment"># 得到训练集中所有最优特征的属性值</span></span><br><span class="line">   uniqueVal = <span class="built_in">set</span>(featValues)</span><br><span class="line">   <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVal:</span><br><span class="line">       <span class="comment"># 递归生成树</span></span><br><span class="line">       myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet, bestFeat, value), labels, featLabels)</span><br><span class="line">   <span class="keyword">return</span> myTree</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据决策树对点进行分类</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">classify</span>(<span class="params">inputTree, featLabels, testVec</span>):</span><br><span class="line">   firstStr = <span class="built_in">next</span>(<span class="built_in">iter</span>(inputTree))  <span class="comment"># 获取根节点</span></span><br><span class="line">   secondDict = inputTree[firstStr]  <span class="comment"># 获取根节点下的两颗树</span></span><br><span class="line">   featIndex = featLabels.index(firstStr)</span><br><span class="line">   <span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">       <span class="keyword">if</span> testVec[featIndex] == key:</span><br><span class="line">           <span class="keyword">if</span> <span class="built_in">type</span>(secondDict[key]).__name__ == <span class="string">&#x27;dict&#x27;</span>:  <span class="comment"># 如果子节点是一棵树，那么递归调用分类器</span></span><br><span class="line">               classLabel = classify(secondDict[key], featLabels, testVec)</span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               classLabel = secondDict[key]  <span class="comment"># 如果子节点是一个叶子节点，那么直接返回</span></span><br><span class="line">   <span class="keyword">return</span> classLabel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 存储决策树</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">storeTree</span>(<span class="params">inputTree, filename</span>):</span><br><span class="line">   <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fw:</span><br><span class="line">       pickle.dump(inputTree, fw)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取决策树</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">grabTree</span>(<span class="params">filename</span>):</span><br><span class="line">   fr = <span class="built_in">open</span>(filename, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">   <span class="keyword">return</span> pickle.load(fr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   dataSet, labels = createDataSet()</span><br><span class="line">   featLabels = []</span><br><span class="line">   myTree = createTree(dataSet, labels, featLabels)</span><br><span class="line"></span><br><span class="line">   <span class="built_in">print</span>(myTree)</span><br><span class="line">   testVec = [<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">   result = classify(myTree, featLabels, testVec)</span><br><span class="line">   <span class="keyword">if</span> result == <span class="string">&#x27;yes&#x27;</span>:</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;放贷&#x27;</span>)</span><br><span class="line">   <span class="keyword">if</span> result == <span class="string">&#x27;no&#x27;</span>:</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;不放贷&#x27;</span>)</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><b>运行结果：</b></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;有自己的房子&#x27;: &#123;0: &#123;&#x27;有工作&#x27;: &#123;0: &#x27;no&#x27;, 1: &#x27;yes&#x27;&#125;&#125;, 1: &#x27;yes&#x27;&#125;&#125;</span><br><span class="line">放贷</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<p>上面第一行为生成的决策树，第二行是一个测试例子解预测结果。</p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>深渊巨坑</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>判断链表是否有环</title>
    <url>/2023/06/06/%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/</url>
    <content><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><blockquote>
<p>有一个单向链表，链表中可能出现“环”，如何通过程序判断这个链表是否有一个环</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/%E6%9C%89%E7%8E%AF%E9%93%BE%E8%A1%A8.jpg" alt="有环链表"></p>
</blockquote>
<h4 id="方法一：穷举遍历"><a href="#方法一：穷举遍历" class="headerlink" title="方法一：穷举遍历"></a>方法一：穷举遍历</h4><blockquote>
<p><strong>思路：</strong>首先从头节点开始，依次遍历该链表的每一个节点。每遍历到一个新节点时，就从头节点重新遍历之前的所有节点，用新节点<strong>唯一ID</strong>与之前所有节点ID进行比较。如果重复则证明有环；否则为无环。（不是唯一ID可能分不清是否有环）</p>
<p><strong>例子：</strong>遍历上面图2，</p>
<blockquote>
<ul>
<li><strong>第一趟遍历：</strong>不进行遍历</li>
<li><strong>第二趟遍历：</strong>1，检查遍历队列中是否有2</li>
<li><strong>第三趟遍历：</strong>1、2，检查遍历队列中是否有3</li>
<li><strong>第四趟遍历：</strong>1、2、3，检查遍历队列中是否有4</li>
<li><strong>第五趟遍历：</strong>1、2、3、4，检查遍历队列中是否有5</li>
<li><strong>第六趟遍历：</strong>1、2、3、4、5，检查遍历队列中是否有6</li>
<li><strong>第七趟遍历：</strong>1、2、3、4、5、6，检查遍历队列中是否有7</li>
<li><strong>第八趟遍历：</strong>1、2、3、4、5、6、7，检查遍历队列中是否有3</li>
<li>发现遍历队列中出现3，判断该链表有环</li>
</ul>
</blockquote>
<p><strong>复杂度：</strong></p>
<blockquote>
<ul>
<li><strong>时间复杂度：</strong>$O(n^n)$</li>
<li><strong>空间复杂度：</strong>$O(1)$</li>
</ul>
</blockquote>
</blockquote>
<h4 id="方法二：哈希表缓存"><a href="#方法二：哈希表缓存" class="headerlink" title="方法二：哈希表缓存"></a>方法二：哈希表缓存</h4><blockquote>
<p><strong>思路：</strong>创建一个以<strong>唯一节点ID</strong>为键的哈希表，每遍历一个节点就将该节点存入哈希表中，如果发现哈希表中已存在该ID，则判断该链表有环。</p>
<p><strong>例子：</strong>以上面图2为例，</p>
<blockquote>
<ul>
<li><strong>第一趟遍历后的哈希表：</strong>1</li>
<li><strong>第二趟遍历后的哈希表：</strong>1、2</li>
<li><strong>第三趟遍历后的哈希表：</strong>1、2、3</li>
<li><strong>第四趟遍历后的哈希表：</strong>1、2、3、4</li>
<li><strong>第五趟遍历后的哈希表：</strong>1、2、3、4、5</li>
<li><strong>第六趟遍历后的哈希表：</strong>1、2、3、4、5、6</li>
<li><strong>第七趟遍历后的哈希表：</strong>1、2、3、4、5、6、7</li>
<li><strong>第八趟遍历后的哈希表：</strong>1、2、3、4、5、6、7（发现3已经存在于哈希表中）</li>
<li>判断该链表有环</li>
</ul>
</blockquote>
<p><strong>复杂度：</strong></p>
<blockquote>
<ul>
<li><strong>时间复杂度：</strong>$O(n)$</li>
<li><strong>空间复杂度：</strong>$O(n)$</li>
</ul>
</blockquote>
</blockquote>
<h4 id="方法三：快慢指针"><a href="#方法三：快慢指针" class="headerlink" title="方法三：快慢指针"></a>方法三：快慢指针</h4><blockquote>
<p><strong>思路：</strong>创建两个指针p1和p2，p1每次沿着链表移动一步、p2每次沿着链表移动两步。一直持续下去，如果p1和p2相遇，则证明该链表有环。</p>
<p><strong>例子：</strong>以上面图2为例，</p>
<blockquote>
<ul>
<li><strong>第一趟指针的情况：</strong>1(p1,p2)$\to$2$\to$3$\to$4$\to$5$\to$6（$\to$3）</li>
<li><strong>第二趟指针的情况：</strong>1$\to$2(p1)$\to$3(p2)$\to$4$\to$5$\to$6（$\to$3）</li>
<li><strong>第三趟指针的情况：</strong>1$\to$2$\to$3(p1)$\to$4$\to$5(p2)$\to$6（$\to$3）</li>
<li><strong>第四趟指针的情况：</strong>1$\to$2$\to$3(p2)$\to$4(p1)$\to$5$\to$6（$\to$3）</li>
<li><strong>第五趟指针的情况：</strong>1$\to$2$\to$3$\to$4$\to$5(p1,p2)$\to$6（$\to$3）</li>
<li>p1和p2相遇，代表链表中有环</li>
</ul>
</blockquote>
<p><strong>复杂度：</strong></p>
<blockquote>
<ul>
<li><strong>时间复杂度：</strong>$O(n)$</li>
<li><strong>空间复杂度：</strong>$O(1)$</li>
</ul>
</blockquote>
</blockquote>
<h4 id="方法四：Set集合大小变化"><a href="#方法四：Set集合大小变化" class="headerlink" title="方法四：Set集合大小变化"></a>方法四：Set集合大小变化</h4><blockquote>
<p><strong>思路：</strong>用Set遍历链表，将节点放入Set中，如果Set长度+1则继续遍历。当Set的长度不再变化则证明链表中有环。</p>
<p><strong>复杂度：</strong></p>
<blockquote>
<ul>
<li><strong>时间复杂度：</strong>$O(n)$</li>
<li><strong>空间复杂度：</strong>$O(n)$</li>
</ul>
</blockquote>
</blockquote>
<h4 id="问题拓展1：如何找到入环点"><a href="#问题拓展1：如何找到入环点" class="headerlink" title="问题拓展1：如何找到入环点"></a>问题拓展1：如何找到入环点</h4><blockquote>
<p>如上图2中，入环点为3，如何使用程序快速找到该点为入环点？</p>
<p><strong>思路：</strong>当快慢指针中p1和p1相遇时（判断有环），记录下慢指针p1的位置，另取一个指针p指向链表头节点，然后指针p和慢指针p2同时移动（步距为1），当p和p1相遇时，该节点就是环点。</p>
<p><strong>例子：</strong>以上面图2为例，</p>
<blockquote>
<p>已知1$\to$2$\to$3$\to$4$\to$5(p1,p2)$\to$6（$\to$3），即p1和p2在节点5处相遇</p>
<ul>
<li>此时设置一个指针p指向链表头节点，1(p)$\to$2$\to$3$\to$4$\to$5(p1,p2)$\to$6（$\to$3）</li>
<li>指针p和慢指针p2同时移动:<ul>
<li>1$\to$2(p)$\to$3$\to$4$\to$5$\to$6(p1)（$\to$3）</li>
<li>1$\to$2$\to$3(p,p1)$\to$4$\to$5$\to$6（$\to$3）</li>
</ul>
</li>
<li>入环点为节点3</li>
</ul>
</blockquote>
</blockquote>
<h4 id="问题拓展2：如何判断两个单链表是否相交"><a href="#问题拓展2：如何判断两个单链表是否相交" class="headerlink" title="问题拓展2：如何判断两个单链表是否相交"></a>问题拓展2：如何判断两个单链表是否相交</h4><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/%E7%9B%B8%E4%BA%A4%E5%8D%95%E9%93%BE%E8%A1%A8.jpg" alt="相交单链表"></p>
<ul>
<li><strong>暴力求解：</strong>直接判断第一个链表中每个节点是否在第二个链表中找到，时间复杂度为$O(L1*L2)$</li>
<li><strong>哈希计数：</strong>设置一个哈希表，用于存放节点，各自遍历两个链表，如果是新节点就放入哈希表中，如果哈希表中已经存在该节点，则证明两个单链表相交。时间复杂度为$O(max(L1,L2))$，空间复杂度为$O(L1+L2)$</li>
<li><strong>检测最后一个节点：</strong>可以分别找到两个链表中最后一个节点，比较它们是否相同，如果相同则证明两个链表相交。时间复杂度为$O(L1+L2)$</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>基础学科</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣的愉快之旅-Day1</title>
    <url>/2021/08/23/%E5%8A%9B%E6%89%A3%E7%9A%84%E6%84%89%E5%BF%AB%E4%B9%8B%E6%97%85-Day1/</url>
    <content><![CDATA[<h4 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a><b>前情提要</b></h4><blockquote>
<p> 本篇主要记录我每天肝算法题的进度，有时可能会一天一道，可能几天一道，也可能一天几道。<br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%A1%A8%E6%83%85%E5%8C%85/%E8%90%8C%E6%96%B0.jpg" alt="萌新" title="老萌新了"></p>
</blockquote>
<h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><b>题目描述：</b></h4><blockquote>
<p>给定一个整数数组nums和一个整数目标值 target，请你在该数组中找出 和为目标值target的那两个整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br>你可以按任意顺序返回答案。<br><b>示例：</b></p>
<blockquote>
<p> <img src="/picture/%E5%AD%A6%E4%B9%A0/%E5%8A%9B%E6%89%A3/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%E7%9A%84%E7%A4%BA%E4%BE%8B.png" alt="示例" title="示例"></p>
</blockquote>
<p><b>提示：</b></p>
<blockquote>
<ul>
<li>2 &lt;&#x3D; nums.length &lt;&#x3D; 104</li>
<li>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</li>
<li>-109 &lt;&#x3D; target &lt;&#x3D; 109</li>
<li>只会存在一个有效答案<br><b>进阶：</b>你可以想出一个时间复杂度小于$ O(n^2)$ 的算法吗？</li>
</ul>
</blockquote>
</blockquote>
<h4 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a><b>解题代码</b></h4><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> index[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">	a = nums[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++)</span><br><span class="line">	&#123;</span><br><span class="line">		b = nums[j];</span><br><span class="line">		<span class="keyword">if</span> (a + b == target)</span><br><span class="line">		&#123;</span><br><span class="line">			index[<span class="number">0</span>] = i;</span><br><span class="line">			index[<span class="number">1</span>] = j;</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">idx</span><span class="params">(index, index + <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>简单说明：</b><br>没什么好说的，不在乎时间复杂度暴力循环就完事了<del>(其实我的也没n^2的复杂度啊)</del>，在乎时间复杂度就用hash表来解。<del>(如果有空再填)</del><br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%A1%A8%E6%83%85%E5%8C%85/%E6%88%91%E5%A5%BD%E8%8F%9C.jpg" alt="我好菜" title="我好菜"></p>
</blockquote>
<hr>
<blockquote>
<p>原题的具体<a href="https://leetcode-cn.com/problems/two-sum/">链接</a></p>
</blockquote>
]]></content>
      <categories>
        <category>力扣例题</category>
      </categories>
      <tags>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣的愉快之旅-Day2</title>
    <url>/2021/08/24/%E5%8A%9B%E6%89%A3%E7%9A%84%E6%84%89%E5%BF%AB%E4%B9%8B%E6%97%85-Day2/</url>
    <content><![CDATA[<h4 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a><b>前情提要</b></h4><blockquote>
<p> 本篇主要记录我每天肝算法题的进度，有时可能会一天一道，可能几天一道，也可能一天几道。<br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%A1%A8%E6%83%85%E5%8C%85/%E8%90%8C%E6%96%B0.jpg" alt="萌新" title="老萌新了"></p>
</blockquote>
<h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><b>题目描述：</b></h4><blockquote>
<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。<br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。<br><b>示例：</b></p>
<blockquote>
<p> <img src="/picture/%E5%AD%A6%E4%B9%A0/%E5%8A%9B%E6%89%A3/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%EF%BC%88%E9%93%BE%E8%A1%A8%E7%89%88%EF%BC%89%E7%9A%84%E7%A4%BA%E4%BE%8B.png" alt="示例" title="示例"></p>
</blockquote>
<p><b>提示：</b></p>
<blockquote>
<ul>
<li>每个链表中的节点数在范围 [1, 100] 内</li>
<li>0 &lt;&#x3D; Node.val &lt;&#x3D; 9</li>
<li>题目数据保证列表表示的数字不含前导零</li>
</ul>
</blockquote>
</blockquote>
<h4 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a><b>解题代码</b></h4><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">* struct ListNode &#123;</span></span><br><span class="line"><span class="comment">*     int val;</span></span><br><span class="line"><span class="comment">*     ListNode *next;</span></span><br><span class="line"><span class="comment">*     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment">*     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment">*     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">   <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">ListNode* result = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">ListNode* head = result;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (l1 != <span class="literal">nullptr</span> || l2 != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (l1 != <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			result-&gt;val += l1-&gt;val; </span><br><span class="line">			l1 = l1-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (l2 != <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			result-&gt;val += l2-&gt;val;</span><br><span class="line">			l2 = l2-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (result-&gt;val &gt; <span class="number">9</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			result-&gt;val -= <span class="number">10</span>;</span><br><span class="line">			result-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">			result = result-&gt;next;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (l1 == <span class="literal">nullptr</span> &amp;&amp; l2 == <span class="literal">nullptr</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			result-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">			result = result-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure>

<p><b>简单说明：</b><br>简单的链表加减法，但我居然花了一个小时<del>（更生艹的是我甚至指针都忘了怎么用了）</del>？？？<br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%A1%A8%E6%83%85%E5%8C%85/%E6%88%91%E5%A5%BD%E8%8F%9C.jpg" alt="我好菜" title="我好菜"><br>不过感觉还是比较简单的（可能是因为之前做过链表的超长加减运算）</p>
</blockquote>
<hr>
<blockquote>
<p>原题的具体<a href="https://leetcode-cn.com/problems/add-two-numbers/">链接</a></p>
</blockquote>
]]></content>
      <categories>
        <category>力扣例题</category>
      </categories>
      <tags>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣的愉快之旅-Day3</title>
    <url>/2021/09/08/%E5%8A%9B%E6%89%A3%E7%9A%84%E6%84%89%E5%BF%AB%E4%B9%8B%E6%97%85-Day3/</url>
    <content><![CDATA[<h4 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a><b>前情提要</b></h4><blockquote>
<p> 本篇主要记录我每天肝算法题的进度，有时可能会一天一道，可能几天一道，也可能一天几道。<br>一个不小心就摸了两个星期了，不过今天也肝了两道使用贪心策略的题。<br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%A1%A8%E6%83%85%E5%8C%85/%E8%90%8C%E6%96%B0.jpg" alt="萌新" title="老萌新了"></p>
</blockquote>
<h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><b>题目描述：</b></h4><h5 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a><b>分发饼干</b></h5><blockquote>
<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。<br>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;&#x3D; g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p><b>示例：</b></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E5%8A%9B%E6%89%A3/%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2%E7%9A%84%E7%A4%BA%E4%BE%8B.png" alt="示例" title="示例"></p>
</blockquote>
<p><b>提示：</b></p>
<blockquote>
<ul>
<li>1&lt;&#x3D;g.length&lt;&#x3D;3*10^4</li>
<li>0&lt;&#x3D;s.length&lt;&#x3D;3*10^4</li>
<li>1&lt;&#x3D;g[i],s[i]&lt;&#x3D;2^31-1</li>
</ul>
</blockquote>
<p><b>思路：</b></p>
<blockquote>
<p>利用贪心策略，首先将g和s两个数组按从小到大排序，然后每次优先尝试满足胃口值最小的孩子，由于事先排好了序，所以如果不满足的饼干那它对后面的孩子就更不可能满足了。</p>
</blockquote>
<p><b>代码：</b></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cookie = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> g_size = g.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> s_size = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span>(g_size &gt; num &amp;&amp; s_size &gt; cookie)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[num] &lt;= s[cookie])</span><br><span class="line">                num++;</span><br><span class="line">            cookie++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><b>补充：</b>在这题中，比较容易忽略的一点是，将两个数组排好序以后，不满足前面胃口的饼干那它对后面的孩子就更不可能满足。</p>
</blockquote>
<h5 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a><b>分发糖果</b></h5><blockquote>
<p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。<br>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p>
<blockquote>
<ul>
<li>每个孩子至少分配到 1 个糖果。</li>
<li>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。</li>
<li>那么这样下来，老师至少需要准备多少颗糖果呢？</li>
</ul>
</blockquote>
<p><b>示例：</b></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E5%8A%9B%E6%89%A3/%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C%E7%9A%84%E7%A4%BA%E4%BE%8B.png" alt="示例" title="示例"></p>
</blockquote>
<p><b>思路：</b></p>
<blockquote>
<p>额外创建一个存放糖果的数组，将数组全部置一，然后从左往右比较两个孩子的分数，如果右边的比左边的高，那右边孩子的糖果设为左边孩子糖果数加1，接着再从右往左比较一次，这次是左边的孩子分数高<b>且左边孩子糖果数小于等右边孩子的糖果数时</b>才将其设为右边孩子糖果数加1。<br><b>我觉得本题的难点：</b></p>
<ul>
<li>在设置糖果数时应该设为旁边孩子的糖果数加1，而不是直接加1，因为这样会出现数据的滞后性。</li>
<li>注意上面黑体加粗的地方，题目要求至少要准备的糖果，没有上面加粗的条件的话，会使最终分发的糖果数过多。</li>
</ul>
</blockquote>
<p><b>代码：</b></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cd = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> c_size = ratings.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> candy_r[c_size];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;c_size;i++)</span><br><span class="line">        candy_r[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;c_size<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ratings[i]&lt;ratings[i+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                candy_r[i+<span class="number">1</span>] = candy_r[i] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=c_size<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ratings[i]&lt;ratings[i<span class="number">-1</span>]&amp;&amp;candy_r[i<span class="number">-1</span>]&lt;=candy_r[i])</span><br><span class="line">        &#123;    </span><br><span class="line">            candy_r[i<span class="number">-1</span>] = candy_r[i] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;c_size;i++)</span><br><span class="line">        cd += candy_r[i]; </span><br><span class="line">    <span class="keyword">return</span> cd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<hr>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%A1%A8%E6%83%85%E5%8C%85/%E6%88%91%E5%A5%BD%E8%8F%9C.jpg" alt="我好菜" title="I&#39;m so vegetable"><br>原题链接：<a href="https://leetcode-cn.com/problems/assign-cookies/">分发饼干</a><br>原题链接：<a href="https://leetcode-cn.com/problems/candy/">分发糖果</a></p>
</blockquote>
]]></content>
      <categories>
        <category>力扣例题</category>
      </categories>
      <tags>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈</title>
    <url>/2023/05/31/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    <content><![CDATA[<h4 id="单调栈定义"><a href="#单调栈定义" class="headerlink" title="单调栈定义"></a>单调栈定义</h4><blockquote>
<p>在栈的基础上，要求栈中存放的数据是有序的。即单调栈可以分为<strong>单调递增栈</strong>和<strong>单调递减栈</strong></p>
<ul>
<li>单调递增栈：单调递增栈就是从栈底到栈顶数据是从大到小</li>
<li>单调递减栈：单调递减栈就是从栈底到栈顶数据是从小到大</li>
</ul>
</blockquote>
<h4 id="单调栈例子"><a href="#单调栈例子" class="headerlink" title="单调栈例子"></a>单调栈例子</h4><blockquote>
<p>现有一个数组[10, 13, 2, 4, 1, 3]，从左到右依次入栈（单调递增的单调栈，栈底大而栈顶小），如果<strong>栈为空</strong>或<strong>入栈元素小于栈顶元素</strong>，则可以入栈；否则需要将比入栈元素小的所有元素出栈。</p>
<ul>
<li>10入栈时，栈为空，入栈，栈内元素为[10]</li>
<li>13入栈时，比栈顶元素10大，10出栈，此时为空栈，入栈，栈内元素为[13]</li>
<li>2入栈时，比栈顶元素13小，直接入栈，栈内元素为[13,2]</li>
<li>4入栈时，比栈顶元素2大，栈顶元素出栈，再次比较栈顶元素13，比栈顶元素13小，直接入栈，栈内元素为[13,4]</li>
<li>1入栈时，比栈顶元素4小，入栈，栈内元素为[13,4,1]</li>
<li>3入栈时，比栈顶元素大，栈顶元素出栈，再次比较栈顶元素4，比栈顶元素3，直接入栈，栈内元素为[13, 4, 3]</li>
</ul>
</blockquote>
<h4 id="单调栈的伪代码"><a href="#单调栈的伪代码" class="headerlink" title="单调栈的伪代码"></a>单调栈的伪代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="comment">//此处一般需要给数组最后添加结束标志符</span></span><br><span class="line"><span class="keyword">for</span> (遍历这个数组)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (栈空 || 栈顶元素大于等于当前比较元素)</span><br><span class="line">	&#123;</span><br><span class="line">		入栈;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (栈不为空 &amp;&amp; 栈顶元素小于当前元素)</span><br><span class="line">		&#123;</span><br><span class="line">			栈顶元素出栈;</span><br><span class="line">			更新结果;</span><br><span class="line">		&#125;</span><br><span class="line">		当前数据入栈;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>基础学科</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>感知机</title>
    <url>/2021/04/10/%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
    <content><![CDATA[<h4 id="感知机的介绍"><a href="#感知机的介绍" class="headerlink" title="感知机的介绍"></a><b>感知机的介绍</b></h4><blockquote>
<ul>
<li>感知机是二分类的<b>线性分类模型</b>，其输入为实例的<b>特征向量</b>，输出为<b>实例的类别，取+1和-1二值</b>。</li>
<li>感知机对应于输入空间中将实例划分为<b>正负两类的分离超平面</b>，属于<b>判别模型</b>（即直接求出模型函数的模型）</li>
<li>感知机模型可以通过梯度下降法对模型的损失函数进行极小化来求得。</li>
<li>感知机是神经网络与支持向量机的基础。</li>
</ul>
</blockquote>
<h4 id="感知机模型"><a href="#感知机模型" class="headerlink" title="感知机模型"></a><b>感知机模型</b></h4><blockquote>
<p><b>定义：</b>假设输入空间（特征空间）是$\ {\chi}{\in}R^n$，输出空间是$\gamma&#x3D;(+1,-1)$.输入$x{\in}{\chi}$表示实例的特征向量，对于输入空间（特征空间）的点;输出$y{\in}{\gamma}$表示实例的类别。由输入空间到输出空间的如下函数<br>$$f(x)&#x3D;sign({\omega}{\cdot}x+b)$$<br>称为感知机。其中，$\omega$和$b$为感知机模型参数，$\omega{\in}R^n$叫作<b>权值</b>或<b>权值向量</b>,$b{\in}R$叫作<b>偏置</b>，$\omega{\cdot}x$表示$\omega$和$x$的内积。sign是符号函数，即<br>$$sign(x)&#x3D;\begin{cases}<br>+1 \quad x\ge0 \\<br>-1 \quad x\lt0<br>\end{cases}$$</p>
<p>其实感知机模型主要部分为：<br>$$\omega{\cdot}x+b&#x3D;0$$</p>
<p>该模型是对应于特征空间$R^n$中的一个超平面S（其维度n&#x3D;特征数量-1），其中$\omega$是超平面的法向量，b是超平面的截距。这个超平面将特征空间划分为两个部分，因此超平面S称为分离超平面，如<br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%84%9F%E7%9F%A5%E6%9C%BA/%E6%84%9F%E7%9F%A5%E6%9C%BA%E6%A8%A1%E5%9E%8B.jpg" alt="感知机模型" title="感知机模型"><br>对于感知机的学习其实就是通过训练数据集，求出模型参数$\omega,b$即可。</p>
</blockquote>
<h4 id="感知机学习策略"><a href="#感知机学习策略" class="headerlink" title="感知机学习策略"></a><b>感知机学习策略</b></h4><blockquote>
<p><b>前提条件：</b>感知机的训练数据集是<b>线性可分</b>的.</p>
<ul>
<li>感知机学习的目标是求得一个可以<b>将数据训练集正实例点和负实例点完全分开</b>的分离超平面，为了找出这样的超平面，就需要确定感知机模型参数$\omega,b$，为了确定这两个参数那就需要定义一个学习策略，即定义损失函数并将损失函数最小化。</li>
<li>损失函数的一个自然选择是<b>误分类点</b>的总数，但是这样的损失函数不是参数$\omega,b$的连续可导函数，不易优化。因此损失函数的另一个选择就是<b>误分类点到超平面S的总距离</b>。</li>
<li>首先，输入空间$R^n$中任一点$x_0$到超平面S的距离为：<br>$$\frac{1}{\lVert{\omega}\rVert}|\omega{\cdot}x_0+b|\quad$$（其中$\lVert{\omega}\rVert$是$\omega$的$L_2$范数）</li>
</ul>
<blockquote>
<p><b>解释上面公式的由来：</b><br>设有一个点$a(x_0,y_0)$，一条直线$\omega_1x+\omega_2y+b&#x3D;0$，那么点到直线的距离为：<br>$$d&#x3D;\frac{|\omega_1x_0+\omega_2y_0+b|}{\sqrt[]{\omega_1^2+\omega_2^2}}$$</p>
<p>上面的公式中的$\lVert{\omega}\rVert$就等于$\sqrt[]{\omega_1^2+\omega_2^2}$，$\omega{\cdot}x_0$就等于$\omega_1x_0+\omega_2y_0$.</p>
</blockquote>
<ul>
<li>其次，对于误分类点$(x_i,y_i)$来说，恒有<br>$$-y_i(\omega{\cdot}x_i+b)&gt;0$$</li>
</ul>
<blockquote>
<p><b>证明：</b>既然是误分类点，那么$y_i$(实际值)与$\omega{\cdot}x_i+b$(预测值)一定是异号的，那再加一个负号就迫使上式一定大于0.</p>
</blockquote>
<ul>
<li><p>因此误分类点$x_i$到超平面S的距离为：<br>$$-\frac{1}{\lVert{\omega}\rVert}y_i(\omega{\cdot}x_i+b)$$</p>
</li>
<li><p>所以所有误分类点到超平面S的总距离为：<br>$$-\frac{1}{\lVert{\omega}\rVert}\sum_{x_i{\in}M}y_i(\omega{\cdot}x_i+b)$$</p>
</li>
<li><p>不考虑$\frac{1}{\lVert{\omega}\rVert}$，就可以得到感知机学习的损失函数：<br>$$L(\omega,b)&#x3D;-\sum_{x_i{\in}M}y_i(\omega{\cdot}x_i+b)$$<br>其中$M$为误分类点的集合</p>
</li>
<li><p>感知机学习的策略就是在假想空间中选取使损失函数最小的模型参数$\omega,b$作为感知机模型。</p>
</li>
</ul>
</blockquote>
<h4 id="感知机学习算法"><a href="#感知机学习算法" class="headerlink" title="感知机学习算法"></a><b>感知机学习算法</b></h4><h5 id="感知机学习算法的原始形式"><a href="#感知机学习算法的原始形式" class="headerlink" title="感知机学习算法的原始形式"></a><b>感知机学习算法的原始形式</b></h5><blockquote>
<p>感知机学习算法是对以下最优化问题的算法，给定一个数据集<br>$$T&#x3D;[(x_1,y_1),(x_2,y_2),…,(x_N,y_N)]$$<br>其中，$x_i{\in}{\chi}&#x3D;R^n,y_i{\in}{\gamma}&#x3D;(-1,1),i&#x3D;1,2,…,N$，求参数$\omega,b$，使其为以下损失函数极小化问题的解<br>$$min_{\omega,b} \ L(\omega,b)&#x3D;-\sum_{x_i{\in}M}y_i(\omega{\cdot}x_i+b) \quad\quad (1)$$<br>其中M为误分类点的集合。</p>
<ul>
<li>感知机优化算法具体采用的是<b>随机梯度下降法</b>。<blockquote>
<ul>
<li>首先任意设定一个超平面，其参数为$\omega_0,b_0$</li>
<li>然后使用梯度下降法不断地极小化目标函数（1）</li>
<li>极小化过程为一次随机选取一个误分类点使其梯度下降。<br>如果误分类点集合M是固定的，那么损失函数$L(\omega,b)$的梯度为：<br>$$\nabla_{\omega}L(\omega,b)&#x3D;\frac{L(\omega,b)}{\partial{\omega}}&#x3D;-\sum_{x_i{\in}M}y_ix_i$$</li>
</ul>
<p>$$\nabla_bL(\omega,b)&#x3D;\frac{L(\omega,b)}{\partial{b}}&#x3D;-\sum_{x_i{\in}M}y_i$$</p>
<p>给出，任意选取一个误分类点$(x_i,y_i)$,对$\omega,b$进行更新：<br>$$\omega+{\eta}y_ix_i{\to}\omega$$</p>
<p>$$b+{\eta}y_i{\to}b$$<br>其中$\eta(0&lt;{\eta}\le1)$是<b>步长</b>，也称为<b>学习率</b>。这样通过不断迭代，可以使损失函数$L(\omega,b)$不断减小。</p>
</blockquote>
</li>
</ul>
<p><b>算法描述：</b></p>
<blockquote>
<ul>
<li><b>输入：</b>训练数据集$T&#x3D;[(x_1,y_1),(x_2,y_2),…,(x_N,y_N)]$,其中$x_i{\in}{\chi}&#x3D;R^n,y_i{\in}{\gamma}&#x3D;(-1,1),i&#x3D;1,2,…,N$;学习率$\eta(0&lt;{\eta}\le1)$</li>
<li><b>输出：</b>$\omega,b$;感知机模型$f(x)&#x3D;sign(\omega{\cdot}x+b)$<br>(1) 选取初值$\omega_0,b_0$<br>(2) 在训练集中选取数据$(x_i,y_i)$<br>(3) 如果$y_i(\omega{\cdot}x+b)\le0$<br>$$\omega+{\eta}y_ix_i{\to}\omega$$</li>
</ul>
<p>$$b+{\eta}y_i{\to}b$$<br>(4) 返回第(2)步，直到训练集中没有误分类点<br><b>图示效果：</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%84%9F%E7%9F%A5%E6%9C%BA/%E6%84%9F%E7%9F%A5%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96.jpg" alt="感知机算法" title="感知机算法"></p>
</blockquote>
</blockquote>
<h5 id="算法的收敛性"><a href="#算法的收敛性" class="headerlink" title="算法的收敛性"></a><b>算法的收敛性</b></h5><blockquote>
<p>设训练数据集$T&#x3D;[(x_1,y_1),(x_2,y_2),…,(x_N,y_N)]$是线性可分的，其中$x_i{\in}{\chi}&#x3D;R^n,y_i{\in}{\gamma}&#x3D;(-1,1),i&#x3D;1,2,…,N$，则</p>
<ul>
<li><p>存在满足条件$\lVert \omega_{opt} \rVert&#x3D;1$的超平面$\omega_{opt}{\cdot}x+b_{opt}&#x3D;0$将训练集完全正确分开;且存在$\gamma&gt;0$,对所有$i&#x3D;1,2,…,N$<br>$$y_i(\omega_{opt}{\cdot}x_i)&#x3D;y_i(\omega){\cdot}x_i+b_{opt}\ge{\gamma}$$</p>
</li>
<li><p>令$R&#x3D;max_{(1 \le i \le N)}\lVert x_i \rVert$,则感知机算法在训练数据集上的误分类次数k满足不等式<br>$$k \le {\frac{R}{\gamma}}^2$$</p>
</li>
</ul>
<p>(<b>补充：</b>如果想知道证明过程，建议看李航老师的《统计学习方法》中的31页到33页)<del>(这没写其实是因为我自己没看懂)</del></p>
<ul>
<li><b>总结：</b>上述定理表明，误分类的次数k是有上界的，在经过有限次搜索可以找到将训练数据完全正确分开的分离超平面（<b>但前提是训练数据集是线性可分的</b>）。换句话说，感知机学习算法的原始形式迭代是收敛的。但是感知机学习算法存在许多的解，这依赖于<b>参数起始值的选择</b>和迭代过程中<b>误分类点的选择</b>。如果想要得到唯一的超平面，就需要对分离超平面添加约束条件（这就是SVM的想法了）。当然如果训练数据集线性不可分，感知机学习算法就不会收敛，迭代结果会发生震荡，即永远都会有误分类点，永远都在进行迭代。</li>
</ul>
</blockquote>
<h5 id="感知机学习算法的对偶形式"><a href="#感知机学习算法的对偶形式" class="headerlink" title="感知机学习算法的对偶形式"></a><b>感知机学习算法的对偶形式</b></h5><blockquote>
<ul>
<li>对偶形式的基本想法是，将$\omega$和b表示为实例$x_i$和标记$y_i$的线性组合的形式，通过求解其系数而求得$\omega$和b，</li>
<li>在原始形式中，$\omega$和b的梯度下降为：<br>$$\omega+{\eta}y_ix_i{\to}\omega$$</li>
</ul>
<p>$$b+{\eta}y_i{\to}b$$<br>即逐步修改$\omega,b$，现在设修改n次，则$\omega,b$关于$(x_i,y_i)$的增量分别为$\alpha_iy_ix_i$和$\alpha_iy_i$，这里$\alpha_i&#x3D;n_i\eta$,这样可得最后学习到的$\omega,b$可以分别表示为：<br>$$\omega&#x3D;\sum^N_{i&#x3D;1}\alpha_iy_ix_i$$</p>
<p>$$b&#x3D;\sum^N_{i&#x3D;1}\alpha_iy_i$$</p>
<ul>
<li>这里，$\alpha\ge0,i&#x3D;1,2,…,N$，当$\eta&#x3D;1$时，则$\alpha_i$表示第i个实例点由于误分类而进行更新的次数，换句话说，实例点更新次数越多，即它离超平面越近，也就越难正确分类，对学习结果影响越大。</li>
</ul>
<p><b>算法描述：</b></p>
<blockquote>
<ul>
<li><b>输入：</b>训练数据集$T&#x3D;[(x_1,y_1),(x_2,y_2),…,(x_N,y_N)]$,其中$x_i{\in}&#x3D;R^n,y_i{\in}(-1,1),i&#x3D;1,2,…,N$;学习率$\eta(0&lt;{\eta}\le1)$</li>
<li><b>输出：</b>$\alpha,b$;感知机模型$f(x)&#x3D;sign(\sum^N_{j&#x3D;1}\alpha_jy_jx_j{\cdot}x+b)$<br>其中$\alpha&#x3D;(\alpha_1,\alpha_2,…,\alpha_N)^T$<br>(1) $\alpha\to0,b\to0$<br>(2) 在训练集中选取数据$(x_i,y_i)$<br>(3) 如果$y_i(\sum^N_{j&#x3D;1}\alpha_jy_jx_j{\cdot}x+b)\le0$<br>$$\omega+{\eta}y_ix_i{\to}\omega$$</li>
</ul>
<p>$$b+{\eta}y_i{\to}b$$<br>(4) 转至第(2)步直到没有误分类点数据。</p>
</blockquote>
</blockquote>
<hr>
<blockquote>
<p><b>写在后面的话：</b>这篇东西与其说是博客，更多的是读书笔记。这里面的内容绝大多数都出自<b>李航老师的《统计学习方法》</b>。<br><b>代码实现：</b><a href="/2021/08/16/%E6%84%9F%E7%9F%A5%E6%9C%BA%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">戳这里</a><br><b>下一个坑：</b><a href="/2021/04/12/k%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/">k近邻法</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>深渊巨坑</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>感知机代码实现</title>
    <url>/2021/08/16/%E6%84%9F%E7%9F%A5%E6%9C%BA%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="算法描述："><a href="#算法描述：" class="headerlink" title="算法描述："></a><b>算法描述：</b></h4><blockquote>
<blockquote>
<ul>
<li><b>输入：</b>训练数据集$T&#x3D;[(x_1,y_1),(x_2,y_2),…,(x_N,y_N)]$,其中$x_i{\in}&#x3D;R^n,y_i{\in}(-1,1),i&#x3D;1,2,…,N$;学习率$\eta(0&lt;{\eta}\le1)$</li>
<li><b>输出：</b>$\alpha,b$;感知机模型$f(x)&#x3D;sign(\sum^N_{j&#x3D;1}\alpha_jy_jx_j{\cdot}x+b)$<br>其中$\alpha&#x3D;(\alpha_1,\alpha_2,…,\alpha_N)^T$<br>(1) $\alpha\to0,b\to0$<br>(2) 在训练集中选取数据$(x_i,y_i)$<br>(3) 如果$y_i(\sum^N_{j&#x3D;1}\alpha_jy_jx_j{\cdot}x+b)\le0$<br>$$\omega+{\eta}y_ix_i{\to}\omega$$</li>
</ul>
<p>$$b+{\eta}y_i{\to}b$$<br>(4) 转至第(2)步直到没有误分类点数据（或者达到最大的循环次数）。</p>
</blockquote>
</blockquote>
<h4 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a><b>代码区</b></h4><blockquote>
<p><b>导入的包：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.lines <span class="keyword">import</span> Line2D</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br></pre></td></tr></table></figure>
</blockquote>
<p><b>导入数据的函数：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">createIrisDataSet</span>():</span><br><span class="line">   data = load_iris()</span><br><span class="line">   tt = data.data</span><br><span class="line">   dt = pd.DataFrame(data=data.data, columns=data.feature_names)</span><br><span class="line">   dt[<span class="string">&#x27;species&#x27;</span>] = data.target</span><br><span class="line">   data = dt</span><br><span class="line">   data.rename(columns=&#123;<span class="string">&#x27;sepal length (cm)&#x27;</span>: <span class="string">&quot;萼片长&quot;</span>, <span class="string">&#x27;sepal width (cm)&#x27;</span>: <span class="string">&quot;萼片宽&quot;</span>,</span><br><span class="line">                        <span class="string">&#x27;petal length (cm)&#x27;</span>: <span class="string">&quot;花瓣长&quot;</span>, <span class="string">&#x27;petal width (cm)&#x27;</span>: <span class="string">&quot;花瓣宽&quot;</span>,</span><br><span class="line">                        <span class="string">&#x27;species&#x27;</span>: <span class="string">&quot;种类&quot;</span>&#125;, inplace=<span class="literal">True</span>)</span><br><span class="line">  <span class="comment"># kind_dict = &#123;0: &quot;山鸢尾&quot;, 1: &quot;杂色鸢尾&quot;, 2: &quot;维吉尼亚鸢尾&quot;&#125;</span></span><br><span class="line">  <span class="comment"># data[&quot;种类&quot;] = data[&quot;种类&quot;].map(kind_dict)</span></span><br><span class="line">   <span class="keyword">return</span> data, tt  <span class="comment"># 返回一个带标签的数据集和一个不带标签的数据集</span></span><br></pre></td></tr></table></figure>
<p><b>画图函数：</b></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">plot</span>(<span class="params">data, slope, intercept</span>):</span><br><span class="line">   <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   @description: 画出点和超平面（直线）</span></span><br><span class="line"><span class="string">   @param data: 点的坐标</span></span><br><span class="line"><span class="string">   @param label: 点的标签</span></span><br><span class="line"><span class="string">   @param slope: 直线的斜率</span></span><br><span class="line"><span class="string">   @param intercept: 直线的纵截距</span></span><br><span class="line"><span class="string">   &quot;&quot;&quot;</span></span><br><span class="line">   plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>] <span class="comment"># 设置字体</span></span><br><span class="line">   plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line">   plt.xlabel(<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">   plt.ylabel(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">   area = np.pi * <span class="number">2</span> ** <span class="number">2</span> <span class="comment"># 点的面积</span></span><br><span class="line"></span><br><span class="line">   data_mat = np.array(data)</span><br><span class="line">   X = data_mat[:, <span class="number">0</span>]</span><br><span class="line">   Y = data_mat[:, <span class="number">1</span>]</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(data_mat.shape[<span class="number">0</span>]):</span><br><span class="line">       <span class="keyword">if</span> data_mat[i][<span class="number">2</span>] &gt; <span class="number">0</span>:</span><br><span class="line">           plt.scatter(X[i].tolist(), Y[i].tolist(), s=area, color=<span class="string">&#x27;red&#x27;</span>)  <span class="comment"># 画点</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           plt.scatter(X[i].tolist(), Y[i].tolist(), s=area, color=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">   <span class="comment"># 根据斜率和截距画出直线</span></span><br><span class="line">   axes = plt.gca()</span><br><span class="line">   x_vals = np.array(axes.get_xlim())</span><br><span class="line">   y_vals = intercept + slope * x_vals</span><br><span class="line">   plt.plot(x_vals, y_vals)</span><br><span class="line">   plt.show()</span><br></pre></td></tr></table></figure>
</blockquote>
<p><b>感知机原始形式的核心代码：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 原始形式</span></span><br><span class="line"><span class="comment"># dataSet为数据集，loop_max为循环最大次数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">perceptron</span>(<span class="params">dataSet, loop_max</span>):</span><br><span class="line">   eta = <span class="number">1</span>   <span class="comment"># 学习率</span></span><br><span class="line">   features = dataSet.shape[<span class="number">1</span>] - <span class="number">1</span>     <span class="comment"># x特征数量</span></span><br><span class="line">   w = np.array([x*<span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,features)])</span><br><span class="line">   b = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> times <span class="keyword">in</span> <span class="built_in">range</span>(loop_max):</span><br><span class="line">       <span class="keyword">for</span> d <span class="keyword">in</span> dataSet:</span><br><span class="line">           x = d[:-<span class="number">1</span>]</span><br><span class="line">           y = d[-<span class="number">1</span>]</span><br><span class="line">           <span class="keyword">if</span> y*(w@x+b) &lt;= <span class="number">0</span>:    <span class="comment"># 判断这是否是一个误分类点,@为矩阵之间的点乘</span></span><br><span class="line">               w = w + eta*y*x</span><br><span class="line">               b = b + eta*y</span><br><span class="line">   <span class="keyword">return</span> w, b</span><br></pre></td></tr></table></figure>
</blockquote>
<p><b>整体代码：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.lines <span class="keyword">import</span> Line2D</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createIrisDataSet</span>():</span><br><span class="line">   data = load_iris()</span><br><span class="line">   tt = data.data</span><br><span class="line">   dt = pd.DataFrame(data=data.data, columns=data.feature_names)</span><br><span class="line">   dt[<span class="string">&#x27;species&#x27;</span>] = data.target</span><br><span class="line">   data = dt</span><br><span class="line">   data.rename(columns=&#123;<span class="string">&#x27;sepal length (cm)&#x27;</span>: <span class="string">&quot;萼片长&quot;</span>, <span class="string">&#x27;sepal width (cm)&#x27;</span>: <span class="string">&quot;萼片宽&quot;</span>,</span><br><span class="line">                        <span class="string">&#x27;petal length (cm)&#x27;</span>: <span class="string">&quot;花瓣长&quot;</span>, <span class="string">&#x27;petal width (cm)&#x27;</span>: <span class="string">&quot;花瓣宽&quot;</span>,</span><br><span class="line">                        <span class="string">&#x27;species&#x27;</span>: <span class="string">&quot;种类&quot;</span>&#125;, inplace=<span class="literal">True</span>)</span><br><span class="line">  <span class="comment"># kind_dict = &#123;0: &quot;山鸢尾&quot;, 1: &quot;杂色鸢尾&quot;, 2: &quot;维吉尼亚鸢尾&quot;&#125;</span></span><br><span class="line">  <span class="comment"># data[&quot;种类&quot;] = data[&quot;种类&quot;].map(kind_dict)</span></span><br><span class="line">   <span class="keyword">return</span> data, tt  <span class="comment"># 返回一个带标签的数据集和一个不带标签的数据集</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 原始形式</span></span><br><span class="line"><span class="comment"># dataSet为数据集，loop_max为循环最大次数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">perceptron</span>(<span class="params">dataSet, loop_max</span>):</span><br><span class="line">   eta = <span class="number">1</span>   <span class="comment"># 学习率</span></span><br><span class="line">   features = dataSet.shape[<span class="number">1</span>] - <span class="number">1</span>     <span class="comment"># x特征数量</span></span><br><span class="line">   w = np.array([x*<span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,features)])</span><br><span class="line">   b = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> times <span class="keyword">in</span> <span class="built_in">range</span>(loop_max):</span><br><span class="line">       <span class="keyword">for</span> d <span class="keyword">in</span> dataSet:</span><br><span class="line">           x = d[:-<span class="number">1</span>]</span><br><span class="line">           y = d[-<span class="number">1</span>]</span><br><span class="line">           <span class="keyword">if</span> y*(w@x+b) &lt;= <span class="number">0</span>:    <span class="comment"># 判断这是否是一个误分类点,@为矩阵之间的点乘</span></span><br><span class="line">               w = w + eta*y*x</span><br><span class="line">               b = b + eta*y</span><br><span class="line">   <span class="keyword">return</span> w, b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot</span>(<span class="params">data, slope, intercept</span>):</span><br><span class="line">   <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   @description: 画出点和超平面（直线）</span></span><br><span class="line"><span class="string">   @param data: 点的坐标</span></span><br><span class="line"><span class="string">   @param label: 点的标签</span></span><br><span class="line"><span class="string">   @param slope: 直线的斜率</span></span><br><span class="line"><span class="string">   @param intercept: 直线的纵截距</span></span><br><span class="line"><span class="string">   &quot;&quot;&quot;</span></span><br><span class="line">   plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>] <span class="comment"># 设置字体</span></span><br><span class="line">   plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line">   plt.xlabel(<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">   plt.ylabel(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">   area = np.pi * <span class="number">2</span> ** <span class="number">2</span> <span class="comment"># 点的面积</span></span><br><span class="line"></span><br><span class="line">   data_mat = np.array(data)</span><br><span class="line">   X = data_mat[:, <span class="number">0</span>]</span><br><span class="line">   Y = data_mat[:, <span class="number">1</span>]</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(data_mat.shape[<span class="number">0</span>]):</span><br><span class="line">       <span class="keyword">if</span> data_mat[i][<span class="number">2</span>] &gt; <span class="number">0</span>:</span><br><span class="line">           plt.scatter(X[i].tolist(), Y[i].tolist(), s=area, color=<span class="string">&#x27;red&#x27;</span>)  <span class="comment"># 画点</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           plt.scatter(X[i].tolist(), Y[i].tolist(), s=area, color=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">   <span class="comment"># 根据斜率和截距画出直线</span></span><br><span class="line">   axes = plt.gca()</span><br><span class="line">   x_vals = np.array(axes.get_xlim())</span><br><span class="line">   y_vals = intercept + slope * x_vals</span><br><span class="line">   plt.plot(x_vals, y_vals)</span><br><span class="line">   plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   dataSet, tt = createIrisDataSet()</span><br><span class="line">   dataSet = dataSet[<span class="number">0</span>:<span class="number">100</span>]</span><br><span class="line">   dataSet = dataSet.drop([<span class="string">&#x27;花瓣长&#x27;</span>, <span class="string">&#x27;萼片宽&#x27;</span>], axis=<span class="number">1</span>)</span><br><span class="line">   dataSet = np.array(dataSet)</span><br><span class="line">   <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(dataSet.shape[<span class="number">0</span>]):</span><br><span class="line">       <span class="keyword">if</span> dataSet[a][<span class="number">2</span>] == <span class="number">0</span>:</span><br><span class="line">           dataSet[a][<span class="number">2</span>] = -<span class="number">1</span></span><br><span class="line">   loop_max = <span class="number">1000</span></span><br><span class="line">   w,b=perceptron(dataSet,loop_max)</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;感知机学习算法的原始形态，计算结果如下：&#x27;</span>)</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;w:&#x27;</span>,w,<span class="string">&#x27;b:&#x27;</span>,b)</span><br><span class="line">   <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">   slope = -w[<span class="number">0</span>] / w[<span class="number">1</span>]  <span class="comment"># 斜率</span></span><br><span class="line">   intercept = -b / w[<span class="number">1</span>]  <span class="comment"># 截距</span></span><br><span class="line"></span><br><span class="line">   plot(dataSet, slope, intercept)</span><br></pre></td></tr></table></figure>
</blockquote>
<p><b>结果：</b></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">感知机学习算法的原始形态，计算结果如下：</span><br><span class="line">w: [-0.5  5.6] b: -2.0</span><br></pre></td></tr></table></figure>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%84%9F%E7%9F%A5%E6%9C%BA/%E6%84%9F%E7%9F%A5%E6%9C%BA%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%9C.png" alt="感知机代码结果"></p>
</blockquote>
</blockquote>
<h4 id="感知机的优缺点："><a href="#感知机的优缺点：" class="headerlink" title="感知机的优缺点："></a><b>感知机的优缺点：</b></h4><blockquote>
<p><b>优点：</b></p>
<blockquote>
<ul>
<li>理论简单，实现方便</li>
<li>无论数据集大小如何都可以训练出一个较可靠的模型</li>
</ul>
</blockquote>
<p><b>缺点：</b></p>
<blockquote>
<ul>
<li>要求训练集必须是线性可分的，否则模型难以收敛</li>
<li>训练出来的模型只是解集中的可行解，不一定是最优解</li>
</ul>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>深渊巨坑</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>应用层</title>
    <url>/2022/03/16/%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<h2 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h2><h3 id="客户-服务器模型"><a href="#客户-服务器模型" class="headerlink" title="客户&#x2F;服务器模型"></a>客户&#x2F;服务器模型</h3><blockquote>
<p>客户&#x2F;服务器模型（Client&#x2F;Server，C&#x2F;S）模型中，有一个总是打开的主机称为<strong>服务器</strong>，它服务于许多来自其他称为<strong>客户机</strong>的主机请求。</p>
<p><strong>图例：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%BA%94%E7%94%A8%E5%B1%82/CS%E6%A8%A1%E5%9E%8B.png" alt="CS模型"></p>
<p><strong>服务器：</strong></p>
<blockquote>
<ul>
<li>永久提供服务</li>
<li>永久性访问地址&#x2F;域名</li>
</ul>
</blockquote>
<p><strong>客户机：</strong></p>
<blockquote>
<ul>
<li>与服务器通信，使用服务器提供的服务</li>
<li>间歇性接入网络</li>
<li>可能使用动态IP地址</li>
</ul>
</blockquote>
</blockquote>
<p><strong>工作流程：</strong></p>
<blockquote>
<ul>
<li>服务器处于接收请求的状态</li>
<li>客户机发出服务请求，并等待接收结果</li>
<li>服务器收到请求后，分析请求，进行必要的处理，并将得到的结果发回给客户机</li>
</ul>
</blockquote>
<p><strong>常见的CS模型应用：</strong> <strong>Web应用</strong>、<strong>文件传输协议（FTP）</strong>、<strong>远程登录</strong>和<strong>电子邮件</strong></p>
<p><strong>主要特点：</strong></p>
<blockquote>
<ul>
<li>网络中各计算机的地位不平等，服务器可以通过对客户机设置用户权限来达到管理目的。</li>
<li>整个网络由少数服务器进行管理</li>
<li>客户机之间不能之间通信，只能通过服务器进行间接通信</li>
<li>受服务器硬件和网络的影响，服务器支持的客户机数量有限</li>
</ul>
</blockquote>
</blockquote>
<h3 id="P2P模型"><a href="#P2P模型" class="headerlink" title="P2P模型"></a>P2P模型</h3><blockquote>
<p>在P2P模型中，各计算机没有固定的客户和服务器划分，任意的一台主机之间都是对等的。</p>
<p><strong>图例：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%BA%94%E7%94%A8%E5%B1%82/P2P%E6%A8%A1%E5%9E%8B.png" alt="P2P模型"></p>
</blockquote>
<p><strong>特点：</strong></p>
<blockquote>
<ul>
<li>不存在服务器</li>
<li>其中每一台主机<strong>既可以提供服务</strong>，<strong>也可以请求服务</strong></li>
<li>任意两台主机之间可以<strong>直接通信</strong></li>
<li>结点可能会间歇性接入网络</li>
<li>结点可能改变ip地址</li>
<li>可拓展性好，即该模型可以大量添加主机，无需担心带宽和硬件性能的影响</li>
</ul>
</blockquote>
<p><strong>缺点：</strong>P2P模型在获得服务的同时，也需要给其他结点提供服务，因此会占用较多的内存。</p>
</blockquote>
<h2 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h2><blockquote>
<p><strong>域名系统</strong>是因特网使用的命名系统，用来<strong>把便于记忆的主机名</strong>转换成<strong>IP地址</strong>。</p>
<p>DNS系统采用<strong>客户&#x2F;服务器模型</strong>，其协议运行在<strong>UDP</strong>之上，<strong>使用53号端口</strong>。</p>
<p>DNS可以分成三部分：<strong>层次域名空间</strong>、<strong>域名服务器</strong>和<strong>解析器</strong></p>
</blockquote>
<h3 id="层次域名空间"><a href="#层次域名空间" class="headerlink" title="层次域名空间"></a>层次域名空间</h3><blockquote>
<p>因特网采用层次树状结构的命名方式，即一个域名由多部分组成如：<a href="http://www.baidu.com,这就是一个域名,它由三部分组成,www称为三级域名,baidu称为二级域名,com称为顶级域名.各级之间又由.分隔./">www.baidu.com，这就是一个域名，它由三部分组成，www称为三级域名，baidu称为二级域名，com称为顶级域名。各级之间又由.分隔。</a></p>
<p><strong>域名树状图：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%BA%94%E7%94%A8%E5%B1%82/%E5%9F%9F%E5%90%8D%E6%A0%91.png" alt="域名树"></p>
<p><strong>顶级域名：</strong></p>
<blockquote>
<ul>
<li>国家级顶级域名：.cn，.us，.uk等</li>
<li>通用顶级域名：.com（公司），.net（网络服务机构），.gov（国家或政府部门）</li>
<li>基础结构域名：arpa，用于<strong>反向域名解析</strong>，即将IP地址传化成域名</li>
</ul>
</blockquote>
<p><strong>注意：</strong></p>
<ul>
<li><strong>域名中可以出现英文字母与数字</strong></li>
<li><strong>域名中的英文不区分大小写</strong></li>
<li><strong>域名中只能使用符号（-），其他都为非法符号</strong></li>
<li><strong>每一级域名不超过63个字符，完整的域名不超过255个字符</strong></li>
<li><strong>级别最低的域名写在最左边，级别最高的域名写在最右边</strong></li>
<li><strong>相同的域名可能出现在不同的等级中，如com</strong></li>
</ul>
</blockquote>
</blockquote>
<h3 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h3><blockquote>
<p>因特网的域名系统被设计为一个<strong>联机分布式</strong>的数据库系统，并采用<strong>客户&#x2F;服务器</strong>模型。</p>
<p>DNS采用了大量的域名服务器，它们使用的是层次方式组织</p>
<p><strong>根域名服务器：</strong></p>
<blockquote>
<p>根域名服务器是最高级的域名服务器，<strong>所有的根域名服务器都知道所有顶级域名服务器的IP地址</strong>。</p>
<p>根域名服务器负责管理顶级域（如.com）</p>
<p>根域名服务器通常不直接将待查询的域名转化成IP地址，而是告诉<strong>本地域名服务器</strong>下一步应当找哪个顶级域名服务器进行查询。</p>
</blockquote>
<p><strong>顶级域名服务器：</strong></p>
<blockquote>
<p>这些域名服务器负责管理<strong>在该顶级域名服务器注册的所有二级域名</strong>。</p>
<p>收到DNS查询请求时，要么给出结果（IP地址），要么下一步应当查找的域名服务器的IP地址</p>
</blockquote>
<p><strong>授权域名服务器（权限域名服务器）：</strong></p>
<blockquote>
<p>DNS层次结构的最底层，总是可以将所管辖的主机名转换成该主机的IP地址。</p>
<p>许多授权域名服务器同时充当<strong>本地域名服务器</strong>和<strong>授权域名服务器</strong>。</p>
</blockquote>
<p><strong>本地域名服务器：</strong></p>
<blockquote>
<p><strong>不属于域名服务器的层次结构</strong></p>
<p>主机发出DNS查询请求时，该报文就发给该主机的本地域名服务器代其查询。</p>
</blockquote>
<p><strong>DNS的层次结构图：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%BA%94%E7%94%A8%E5%B1%82/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="域名服务器"></p>
</blockquote>
</blockquote>
<h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3><blockquote>
<p>域名解析是指把<strong>域名映射为IP地址</strong>或<strong>把IP地址映射为域名</strong>的过程。前者称为<strong>正向解析</strong>，后者称为<strong>反向解析</strong>。</p>
<p>当客户端需要解析域名时，主机会通过本机的DNS客户端构造一个DNS请求报文，以UDP的方式发往本地域名服务器。</p>
<p>域名解析的两种方式：<strong>递归查询</strong>和<strong>递归与迭代相结合的查询</strong></p>
<p><strong>递归查询：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%BA%94%E7%94%A8%E5%B1%82/%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2.png" alt="递归查询"></p>
<p>类似于递归调用，让高级的服务器为主机查询，找到以后又层层上交，直到交给主机。</p>
<p>缺点很明显，对根服务器的负荷要求过大，如果过多的主机查询域名，那么就会使根服务器负荷过大。</p>
</blockquote>
<p><strong>递归与迭代相结合的查询：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%BA%94%E7%94%A8%E5%B1%82/%E9%80%92%E5%BD%92%E4%B8%8E%E8%BF%AD%E4%BB%A3%E6%9F%A5%E8%AF%A2%E7%9B%B8%E7%BB%93%E5%90%88.png" alt="递归与迭代查询相结合"></p>
<p><strong>过程：</strong></p>
<blockquote>
<ul>
<li>客户机向本地服务器发出DNS请求报文</li>
<li>本地服务器接收到报文以后，查询本地缓存，如果没找到，则以DNS客户的身份向根域名服务器发出请求报文</li>
<li>根域名服务器收到请求报文后，判断该域名中顶级域的所属，并将对于所属的顶级域名服务器的IP地址发送回本地域名服务器</li>
<li>本地域名服务器又向得到的顶级域名服务器进行DNS查询请求</li>
<li>顶级域名服务器收到请求报文后，判断该域名中域的所属，并将对于所属的授权域名服务器的IP地址发送回本地域名服务器</li>
<li>本地域名服务器收到以后又向该授权域名服务器发送DNS请求报文</li>
<li>授权域名服务器收到请求报文后进行查询，并返回结果给本地域名服务器</li>
<li>本地域名服务器收到结果后又将结果交给主机</li>
</ul>
</blockquote>
</blockquote>
<p><strong>注意：</strong>每个DNS服务器中都会存在高速缓存，以此降低DNS查询请求的数量。但是该高速缓存在一定事件内也会被清除。</p>
</blockquote>
<h2 id="文件传输协议-FTP"><a href="#文件传输协议-FTP" class="headerlink" title="文件传输协议(FTP)"></a>文件传输协议(FTP)</h2><blockquote>
<p>文件传输协议（FTP）是因特网上使用得最广泛得文件传输协议。它适合于<strong>异构网络中任意两台计算机之间传输文件</strong>。</p>
<p>FTP采用<strong>客户&#x2F;服务器（CS）</strong>的工作方式，使用<strong>TCP可靠传输</strong>，一个FTP服务器进程可以为多个客户进程提供服务。</p>
<p><strong>功能：</strong></p>
<blockquote>
<ul>
<li>提供不同种类主机系统之间得文件传输能力</li>
<li>以用户权限管理得方式对远程FTP服务器上得文件进行管理（如新建，删除，重命名等）</li>
<li>以<strong>匿名FTP方式</strong>提供公用文件共享能力。</li>
</ul>
</blockquote>
<p><strong>匿名登录：</strong></p>
<blockquote>
<p>即“匿名（Anonymous）”FTP服务器，这类服务器向公众提供文件拷贝服务，无需用户事先进行<strong>登记注册</strong>，也不需要取得FTP服务器的授权。</p>
<p><strong>用户使用特殊的用户名“anonymous”登录FTP服务器</strong>，就可以访问远程主机上的公开文件。</p>
</blockquote>
<p>FTP的服务器进程由两部分组成：<strong>一个主进程</strong>和<strong>若干个从属进程</strong></p>
<blockquote>
<p>主进程负责接收新的请求，从属进程负责处理单个请求</p>
<p><strong>FTP进程的执行步骤：</strong></p>
<blockquote>
<ul>
<li>打开熟知端口21，使客户进程连接上</li>
<li>等待客户进程发送连接请求</li>
<li>启动从属进程来处理用户进程发来的请求。主进程和从属进程并发执行，从属进程对用户进程的请求处理完成后即终止。</li>
<li>回到等待状态，继续接收其他客户进程的请求</li>
</ul>
</blockquote>
</blockquote>
<p><strong>控制连接和数据连接：</strong></p>
<blockquote>
<p>FTP在工作时使用两个并行的TCP连接：<strong>控制连接（端口号21）</strong>，<strong>数据连接（端口号20）</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%BA%94%E7%94%A8%E5%B1%82/%E6%8E%A7%E5%88%B6%E8%BF%9E%E6%8E%A5%E5%92%8C%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5.png" alt="控制连接和数据连接"></p>
<p><strong>控制连接：</strong></p>
<blockquote>
<p><strong>控制连接占用21号端口</strong>，用来传输<strong>7位ASCII格式</strong>的传输控制信息（如连接请求、发送请求等）</p>
<p>控制连接不进行传输文件，仅用于控制连接状态</p>
<p><strong>控制连接在整个会话期一直保持打开状态</strong>，直到连接断开。</p>
</blockquote>
<p><strong>数据连接：</strong></p>
<blockquote>
<p>在服务器端的控制进程接收到FTP客户发来的文件传输请求后，就创建<strong>“数据传送进程”</strong>和<strong>“数据连接”</strong>。数据传送进程实际完成文件的传送，在文件传送完毕后关闭“数据传送连接”并结束运行。</p>
<p>数据连接的两种传输模式：<strong>主动模式（PORT）</strong>和<strong>被动模式（PASV）</strong></p>
<p><strong>主动模式（PORT）：</strong></p>
<blockquote>
<p>在客户端成功登录后要读取数据时，<strong>客户端随机开放一个端口（&gt;1024）</strong>，并告知服务器，服务器收到PORT命令和端口后，通过20端口与客户端开放的端口进行连接。（客户端随机，服务器20）</p>
</blockquote>
<p><strong>被动模式（PASV）：</strong></p>
<blockquote>
<p>客户端要读取数据时，发送PASV命令到服务器，<strong>服务器在本地随机开放一个端口（&gt;1024）</strong>，并告知客户端，客户端再得到端口号后利用20端口与服务端开放的端口进行连接。（客户端20，服务器随机）</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>FTP传输模式：</strong></p>
<blockquote>
<ul>
<li><strong>文本模式：</strong>ASCII模式，以文本序列传输数据</li>
<li><strong>二进制模式：</strong>Binary模式，以二进制序列传输数据</li>
</ul>
</blockquote>
</blockquote>
<h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><h3 id="电子邮件系统的组成"><a href="#电子邮件系统的组成" class="headerlink" title="电子邮件系统的组成"></a>电子邮件系统的组成</h3><blockquote>
<p>电子邮件是一种<strong>异步通信</strong>方式，即通信时不需要双方同时在场。电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可以随时上网到自己使用的邮件服务器进行读取。</p>
<p>一个电子邮件服务器主要由三部分组成：<strong>用户代理、邮件服务器</strong>和<strong>电子邮件使用的协议</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%BA%94%E7%94%A8%E5%B1%82/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F.png" alt="电子邮件系统"></p>
<ul>
<li><strong>用户代理（User Agent）：</strong>用户与电子邮件的接口。用户代理实际上就是一个应用程序，具备<strong>撰写、显示</strong>和<strong>邮件处理</strong>的功能。</li>
<li><strong>邮件服务器：</strong>功能是<strong>发送</strong>和<strong>接收邮件</strong>，同时还要向发信人报告邮件传送情况（已交付、被拒绝、丢失等）。邮件服务器采用<strong>客户&#x2F;服务器</strong>方式工作，但它能同时充当客户和服务器。</li>
<li><strong>邮件发送协议和读取协议：</strong>邮件<strong>发送协议</strong>用于<strong>用户代理向邮件服务器递交邮件</strong>或在<strong>邮件服务器之间发送邮件</strong>，如SMTP；邮件<strong>读取协议</strong>用于<strong>用户代理在邮件服务器中读取邮件</strong>，如POP3。</li>
</ul>
<p><strong>电子邮件格式：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%BA%94%E7%94%A8%E5%B1%82/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E6%A0%BC%E5%BC%8F.png" alt="电子邮件格式"></p>
<ul>
<li><strong>信封：</strong>电子邮件会自动将信封所需的信息提取到信封上。</li>
<li><strong>首部：</strong>最基本的是To字段（收信人地址）和Subject字段（主题），当然也可能有From字段（发送人地址）和Date字段（时间）等等</li>
<li><strong>主体：</strong>邮件的主要内容，由发送方自己编写。</li>
</ul>
</blockquote>
<p><strong>电子邮件收发过程：</strong></p>
<blockquote>
<ul>
<li>发信人调用<strong>用户代理</strong>来撰写要发送的邮件。<strong>用户代理使用SMTP把邮件递交给发送端邮件服务器</strong></li>
<li>发送端邮件服务器将邮件放入邮件缓存队列中，等待发送</li>
<li>发送端邮件服务器发现缓存中有待发送的邮件，就向待接收的服务器<strong>发起TCP建立请求</strong></li>
<li>TCP连接建立完成后，<strong>SMTP客户进程就向SMTP服务器进程发送邮件</strong>。当所有邮件发送完毕以后，SMTP关闭TCP连接。</li>
<li>接收端的SMTP服务器进程将接收到的邮件放入收信人的用户邮箱，等待收信人在方便时进行读取。</li>
<li>收信人打算收信时，调用用户代理，<strong>使用POP3或IMAP协议</strong>将邮件从接收端邮件服务器的用户邮箱中取回。</li>
</ul>
</blockquote>
</blockquote>
<h3 id="SMTP和POP3"><a href="#SMTP和POP3" class="headerlink" title="SMTP和POP3"></a>SMTP和POP3</h3><blockquote>
<p><strong>SMTP：</strong></p>
<blockquote>
<p><strong>简单邮件传输协议（SMTP）</strong>是一种提供<strong>可靠</strong>且有效的电子邮件传输协议，它控制两个相互通信的SMTP进程交换信息。</p>
<p>SMTP使用<strong>TCP连接</strong>，<strong>端口号为25</strong>。SMTP通信有三个阶段：<strong>连接建立</strong>、<strong>邮件传送</strong>和<strong>连接释放</strong>。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%BA%94%E7%94%A8%E5%B1%82/SMTP%E4%BC%A0%E9%80%81.png" alt="SMTP传送"></p>
<p><strong>MIME：</strong></p>
<blockquote>
<p>传统的<strong>SMTP只能传送一定长度的ASCII码邮件</strong>，无法传送其他国家的文字以及图像、音频等。</p>
<p>因此提出了<strong>多用途网络邮件扩充（MIME）</strong></p>
<p>MIME并没有改变电子邮件系统的构造，只是在此基础上添加了一部分内容。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%BA%94%E7%94%A8%E5%B1%82/SMTP%E4%B8%8EMIME%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="SMTP与MIME的关系"></p>
<p>即在用户与SMTP进程之间加入了MIME，使得ASCII码以外的编码都可以转化为ASCII码，然后通过SMTP进程发送。</p>
</blockquote>
</blockquote>
<p><strong>POP3：</strong></p>
<blockquote>
<p>POP也使用<strong>客户&#x2F;服务器</strong>的工作方式，在传输层<strong>使用TCP</strong>，<strong>端口号为110</strong>。</p>
<p>POP有两种工作方式：<strong>下载并保留</strong>、<strong>下载并删除</strong></p>
<ul>
<li><strong>下载并保留：</strong>用户从邮件服务器上读取邮件后，邮件依旧会保留在服务器上，用户可以再次从服务器上读取邮件。</li>
<li><strong>下载并删除：</strong>用户从邮件服务器上读取邮件后，服务器就会删除该邮件。</li>
</ul>
<p><strong>IMAP：</strong>功能比POP3更多更复杂。如允许用户只读取邮件的一部分，允许用户在有条件的情况下才下载邮件中的附件，可以直接读取文本内容。</p>
</blockquote>
</blockquote>
<h3 id="基于万维网的电子邮件"><a href="#基于万维网的电子邮件" class="headerlink" title="基于万维网的电子邮件"></a>基于万维网的电子邮件</h3><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%BA%94%E7%94%A8%E5%B1%82/%E5%9F%BA%E4%BA%8E%E4%B8%87%E7%BB%B4%E7%BD%91%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6.png" alt="基于万维网的电子邮件"></p>
<p><strong>与传统电子邮件系统的区别：</strong>用户代理部分不再使用SMTP或POP协议，而是转而使用HTTP协议。</p>
</blockquote>
<h2 id="万维网与HTTP协议"><a href="#万维网与HTTP协议" class="headerlink" title="万维网与HTTP协议"></a>万维网与HTTP协议</h2><h3 id="万维网"><a href="#万维网" class="headerlink" title="万维网"></a>万维网</h3><blockquote>
<p><strong>定义：</strong>万维网是一个<strong>分布式</strong>、<strong>联机式</strong>的信息存储空间。</p>
<p>在万维网中每一样有用的事物称为一样”资源“，并由一个全域“<strong>统一资源定位符（URL）</strong>”标识。这些资源通过<strong>超文本协议（HTTP）</strong>传输给使用者，后者通过单击链接来获取资源。</p>
<p>万维网是以<strong>客户&#x2F;服务器方式</strong>工作的。</p>
<p><strong>万维网内核的三个标准：</strong></p>
<blockquote>
<ul>
<li><strong>统一资源定位符（URL）：</strong>负责标识万维网上的各种文档，并使每个文档在万维网中都有唯一的标识符。</li>
<li><strong>超文本传输协议（HTTP）：</strong>一个应用层协议，它使用<strong>TCP连接</strong>进行可靠传输，是<strong>万维网应用程序（如浏览器）</strong>和<strong>服务程序</strong>之间交互的协议。</li>
<li><strong>超文本标记语言（HTML）：</strong>一种文档结构的标记语言。</li>
</ul>
</blockquote>
<p><strong>URL的一般形式：</strong></p>
<blockquote>
<p>$$<br>&lt;协议&gt;:&#x2F;&#x2F;&lt;主机名&gt;:&lt;端口&gt;&#x2F;&lt;路径&gt;<br>$$</p>
<ul>
<li><strong>协议：</strong>指用什么协议来获取万维网文档</li>
<li><strong>主机名：</strong>是存放资源的主机在因特网中的<strong>域名</strong>或<strong>IP地址</strong></li>
<li><strong>端口&amp;路径：</strong>有时可以省略</li>
</ul>
<p><strong>注意：</strong>URL中不区分大小写。</p>
</blockquote>
<p><strong>万维网应用程序（浏览器）工作流程：</strong></p>
<blockquote>
<ul>
<li>用户使用浏览器与Web服务器建立连接，并发送浏览请求</li>
<li>Web服务器把URL转换成文件路径，并返回信息给浏览器</li>
<li>通信完成，关闭连接</li>
</ul>
</blockquote>
</blockquote>
<h3 id="超文本传输协议（HTTP）"><a href="#超文本传输协议（HTTP）" class="headerlink" title="超文本传输协议（HTTP）"></a>超文本传输协议（HTTP）</h3><blockquote>
<p>HTTP定义了浏览器怎么向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器，即规定了浏览器和服务器之间的请求和响应的格式和规则。</p>
<p>HTTP报文格式：<strong>请求报文</strong>（浏览器向服务发送请求服务的报文），<strong>响应报文</strong>（服务器对浏览器请求的回应）</p>
<p><strong>例子：</strong></p>
<blockquote>
<p>用户点击网站链接后所发生的事件：</p>
<ul>
<li>浏览器分析链接指向页面的URL</li>
<li>浏览器向DNS请求解析URL中域名的IP地址</li>
<li>DNS向浏览器返回解析出来的IP地址</li>
<li>浏览器和该IP地址的服务器建立TCP连接（默认端口为80）</li>
<li>浏览器发出HTTP请求：GET&#x2F;…&#x2F;index.htm</li>
<li>服务器通过HTTP响应把文件index.htm发送给服务器</li>
<li>释放TCP连接</li>
<li>浏览器解析文件index.htm，并显示给用户看</li>
</ul>
</blockquote>
<p><strong>HTTP的特点：</strong></p>
<blockquote>
<ul>
<li><p><strong>无状态</strong></p>
<blockquote>
<p>即同一客户第二次访问同一个服务器上的页面时，服务器的响应时间是一样的。服务器并不记得该客户是否曾经访问过，访问过几次。对此就出现了Cookie技术，即将用户的浏览记录<strong>存储在服务器的一个数据库中，并标识上一个唯一的标识码</strong>，同时用户的主机中也会存储这个标识码，当用户再次访问服务器的时候，服务器可以根据该标识码来找到用户的浏览记录。</p>
</blockquote>
</li>
<li><p><strong>HTTP本身是无连接的</strong></p>
<blockquote>
<p>即通信双方在交换HTTP报文之前都不需要先建立HTTP连接。</p>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>HTTP连接：</strong></p>
<blockquote>
<ul>
<li><p><strong>非持久连接：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%BA%94%E7%94%A8%E5%B1%82/%E9%9D%9E%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5.png" alt="非持久连接"></p>
<p>即每一次HTTP请求都需要建立一次TCP连接，这种连接方式浪费时间过大，效率较低。</p>
</blockquote>
</li>
<li><p><strong>持久连接：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%BA%94%E7%94%A8%E5%B1%82/%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5.png" alt="持久连接"></p>
<p>当传送完一个请求后，TCP连接不会立即断开，可以等待一段时间看是否有更多的请求。在此基础上还引申出了流水线的持久连接，即客户端可以连续发送请求，服务器也连续回应请求。</p>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>HTTP报文结构：</strong></p>
<blockquote>
<ul>
<li><p><strong>请求报文：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%BA%94%E7%94%A8%E5%B1%82/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png" alt="请求报文"></p>
<ul>
<li><strong>请求行：</strong>即开始行，用于区分是请求报文还是响应报文。方法：GET（请求读取URL的信息）、HEAD（请求读取URL信息的首部）、POST（给服务器添加信息）、CONNECT（用于代理服务器）</li>
<li><strong>首部行：</strong>用于说明浏览器、服务器或报文主体的一些信息。</li>
<li><strong>实体主体：</strong>请求报文一般不用</li>
</ul>
</blockquote>
</li>
<li><p><strong>响应报文：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%BA%94%E7%94%A8%E5%B1%82/%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.png" alt="响应报文"></p>
<ul>
<li><strong>状态行：</strong>即开始行，用于区分是请求报文还是响应报文。版本：HTTP的版本号。</li>
<li><strong>状态码：</strong>1xx：表示通知信息的，如请求收到了或正在处理；2xx：表示成功，如接受或知道了；3xx：表示重定向，如要完成请求还是采取进一步的行动；4xx：表示客户的差错，如请求中的错误语法或不能完成；5xx：表示服务器的差错，如服务器失效无法完成请求。</li>
<li><strong>首部行：</strong>用于说明浏览器、服务器或报文主体的一些信息。</li>
<li><strong>实体主体：</strong>响应报文中可能没有该字段。</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E5%BA%94%E7%94%A8%E5%B1%82/%E4%BE%8B%E5%AD%90.png" alt="例子"></p>
<ul>
<li>这是一个请求报文，要获取一个页面</li>
<li>该页面的是index.html</li>
<li>HTTP使用的版本号为1.1</li>
<li>服务器地址是：www. test.edu.cn</li>
<li>使用的是非持续连接</li>
<li>Cookie标识码为123456（可以看出之前曾经访问过该网站）</li>
</ul>
</blockquote>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>基础学科</tag>
      </tags>
  </entry>
  <entry>
    <title>拉格朗日乘子法</title>
    <url>/2021/10/21/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E5%AD%90%E6%B3%95/</url>
    <content><![CDATA[<h4 id="拉格朗日对偶性介绍"><a href="#拉格朗日对偶性介绍" class="headerlink" title="拉格朗日对偶性介绍"></a><b>拉格朗日对偶性介绍</b></h4><blockquote>
<p>在求解有约束的最优化问题时，经常使用的方法是：利用拉格朗日对偶性将原始问题转化为对偶问题，通过求解对偶问题从而得到原始问题的解。</p>
</blockquote>
<h4 id="原始问题"><a href="#原始问题" class="headerlink" title="原始问题"></a><b>原始问题</b></h4><blockquote>
<p><b>定义：</b></p>
<blockquote>
<p>假设$f(x),c_i(x),h_j(x)$是定义在$R^n$上的连续可微函数，约束最优化问题为：<br>$$min_{x \in R^n} \ \ f(x)$$</p>
<p>$$s.t. \quad c_i(x) \le 0, \quad i&#x3D;1,2,…,k$$</p>
<p>$$\quad h_j(x)&#x3D;0,\quad j&#x3D;1,2,…,l$$</p>
</blockquote>
<ul>
<li><p>首先，我们引入<b>拉格朗日函数</b>：</p>
<blockquote>
<p>$$L(x,\alpha,\beta)&#x3D;f(x)+\sum^K_{i&#x3D;1}{\alpha_i}{c_i(x)}+{\sum}^M_{j&#x3D;1}\beta_jh_j(x)$$</p>
<p>其中，$x&#x3D;(x^{(1)},x^{(2)},…,x^{(n)})^T \in R^n$，$\alpha_i,\beta_j$是拉格朗日乘子，$\alpha_i \ge 0$。考虑x的函数：<br>$$\theta_P(x)&#x3D;max_{\alpha,\beta;\alpha_i \ge 0} \ \ L(x,\alpha,\beta)$$<br>这里，$\theta_P(x)$表示原始问题$f(x)$+约束条件。</p>
</blockquote>
</li>
<li><p>引入拉格朗日函数的作用：</p>
<blockquote>
<p>我们知道，要求解带约束的优化问题，梯度下降，牛顿法这类方法都是不能解决的，因此我们可以通过拉格朗日函数，将约束条件融入到问题上，即将约束条件塞到$f(x)$里，构成一条式子。<br>当x不满足约束条件时，即某个i使得$c_i(w) &gt; 0$或者是某个j使得$h_j(w) \neq 0$,那么就有<br>$$\theta_P(x)&#x3D;max_{\alpha,\beta;\alpha_i \ge 0} \ \ [f(x)+\sum^K_{i&#x3D;1}{\alpha_i}{c_i(x)}+{\sum}^M_{j&#x3D;1}\beta_jh_j(x)]&#x3D;+\infty$$<br><b>原因：</b></p>
<blockquote>
<ul>
<li>当$c_i(w) &gt; 0$时，函数的目的是取到最大值，那么我们可以直接令这个i对应的$\alpha_i &#x3D; +\infty$，这里取最大值的结果会变成$+\infty$。</li>
<li>同理，如果$h_j(w) \neq 0$，函数的目的是取到最大值，那么j对应的$\beta_j&#x3D; +\infty$，这里取最大值的结果会变成$+\infty$。</li>
</ul>
<p>因为这里的目的是取最大值，而且$c_i(w) \le 0,\alpha_i \ge 0$（负数乘一个正数，结果还是负数）且$h_j(w) &#x3D; 0$，那么$\theta_P(x)$的最大值就等于$f(x)$，所以可得，<br>$$\theta_P(x)&#x3D;\begin{cases}f(x) \quad \quad x满足约束 \\+\infty \quad \quad 其他 \\\end{cases}$$</p>
<p><b>因此原问题的定义域就扩展到了整个实数域，不过只有满足约束条件的才等于$f(x)$，不满足的那一部分都等于正无穷。</b></p>
</blockquote>
<p>如果考虑求原问题的最小化，那么可以得到：<br>$$min_x \ \theta_P(x)&#x3D;min_x \ max_{\alpha,\beta;\alpha_i \ge 0} \ \ L(x,\alpha,\beta)$$<br>到此，我们已经将原问题的形式，从<br>$$min_{x \in R^n} \ \ f(x)$$</p>
<p>$$s.t. \quad c_i(x) \le 0, \quad i&#x3D;1,2,…,k$$</p>
<p>$$\quad h_j(x)&#x3D;0,\quad j&#x3D;1,2,…,l$$<br>变成了<br>$$min_x \ \theta_P(x)&#x3D;min_x \ max_{\alpha,\beta;\alpha_i \ge 0} \ \ L(x,\alpha,\beta)$$</p>
<ul>
<li>这样一来，求出$min_x \ \theta_P(x)$的解就等于求出了$min_{x \in R^n} \ \ f(x)$的解。<br>设原始问题的最优值为：$p^*&#x3D;min_x \ \theta_P(x)$</li>
</ul>
<p><b>补充：</b></p>
<ul>
<li>后面一直在提的原始问题也是$min_x \ \theta_P(x)$这个形式。</li>
<li>这个问题又称为广义拉格朗日函数的极小极大问题。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="对偶问题"><a href="#对偶问题" class="headerlink" title="对偶问题"></a><b>对偶问题</b></h4><blockquote>
<p><b>定义：</b></p>
<blockquote>
<p>$$\theta_D(\alpha,\beta)&#x3D;min_x \ \ L(x,\alpha,\beta)$$</p>
<ul>
<li>再考虑极大化$\theta_D(\alpha,\beta)&#x3D;min_x \ \ L(x,\alpha,\beta)$，即</li>
</ul>
<p>$$max_{\alpha,\beta:\alpha_i \ge 0} \ \ min_x \ L(x,\alpha,\beta)$$</p>
<ul>
<li>该问题又称为广义拉格朗日函数的极大极小问题。</li>
</ul>
</blockquote>
<p>此时我们可以将广义拉格朗日函数的极大极小问题表示为约束最优化问题：</p>
<blockquote>
<p>$$max_{\alpha,\beta} \ \ min_x \ L(x,\alpha,\beta)$$<br>$$s.t. \quad \alpha_i \ge 0, \quad i&#x3D;1,2,…,k$$</p>
</blockquote>
<p>同时我们也可以将其称为原始问题的对偶问题，定义对偶问题的最优值：</p>
<blockquote>
<p>$$d^*&#x3D;max_{\alpha,\beta:\alpha_i \ge 0} \ \ \theta_D(\alpha,\beta)$$</p>
</blockquote>
</blockquote>
<h4 id="原始问题与对偶问题的关系"><a href="#原始问题与对偶问题的关系" class="headerlink" title="原始问题与对偶问题的关系"></a><b>原始问题与对偶问题的关系</b></h4><blockquote>
<p><b>定理：</b><br>如果原问题和对偶问题都有最优解$p^*$和$d^*$。<br>那么它们满足：</p>
<blockquote>
<p>$$d^* &#x3D; max_{\alpha,\beta:\alpha_i \ge 0} \ \ \theta_D(\alpha,\beta) \le min_x \ \theta_P(x)&#x3D;p^*$$<br><b>证明：</b></p>
<blockquote>
<ul>
<li>因为$\theta_D(\alpha,\beta)&#x3D;min_x \ L(x,\alpha,\beta)$而$\theta_P(x)&#x3D;max_{\alpha,\beta:\alpha_i \ge 0} \ L(x,\alpha,\beta)$</li>
<li>所以对于任意变量恒有，$\theta_D(\alpha,\beta) \le theta_P(x)$</li>
<li>那么容易得到，$max_{\alpha,\beta:\alpha_i \ge 0} \ \theta_D(x,\alpha,\beta) \le min_x \ theta_P(x,\alpha,\beta)$</li>
<li>(对于任何x，恒有$f(x) \ge g(x)$，那么在$g(x)$中取得的最大值也会小于等于$f(x)$中取得的最小值)，这就是<b>极大值中的极小值</b>恒大于<b>极小值中的极大值</b>。</li>
<li>所以有$d^* \le p^*$</li>
</ul>
</blockquote>
</blockquote>
<p>设$x^*,\alpha^*,\beta^*$分别是对偶问题$\theta_D$和原始问题$\theta_P$的可行解，且$d^* &#x3D; p^*$，那么$x^*,\alpha^*,\beta^*$就是原始问题与对偶问题的最优解。<br>在某些条件下，原始问题与对偶问题的解是相等的，即$d^* &#x3D; p^*$。那么就可以利用对偶问题的解来代替原始问题的解了。</p>
<ul>
<li><p><b>定理一：</b>、</p>
<blockquote>
<p>若$f(x)$和$c_i(x)$是凸函数，$h_j(x)$是仿射函数，$c_i(x)$是严格可行的，即存在x对于所有i都有$c_i(x)&lt;0$,那么存在$x^*,\alpha^*,\beta^*$，$x^*$是原始问题的解，$\alpha^*,\beta^*$是对偶问题的解，并且<br>$$p^*&#x3D;d^*&#x3D;L(x^*,\alpha^*,\beta^*)$$</p>
</blockquote>
</li>
<li><p><b>定理二（KKT条件）：</b><br>在满足定理一的基础上，$x^*,\alpha^*,\beta^*$，$x^*$分别是原始问题和对偶问题的解的充分必要条件是，$x^*,\alpha^*,\beta^*$，$x^*$满足以下条件：</p>
<blockquote>
<ul>
<li>$\nabla_x L(x^*,\alpha^*,\beta^*)&#x3D;0$</li>
<li>$a_i^* c_i(x^*)&#x3D;0, \quad \quad i&#x3D;1,2,…,k$</li>
<li>$c_i(x^*) \le 0, \quad \quad i&#x3D;1,2,…,k$</li>
<li>$a_i^* \ge 0, \quad \quad i&#x3D;1,2,…,k$</li>
<li>$h_j(x^*)&#x3D;0  \quad \quad j&#x3D;1,2,…,l$</li>
</ul>
<p>其中根据$a_i^* c_i(x^*)&#x3D;0, \quad \quad i&#x3D;1,2,…,k$（称为KKT互补条件）可以得到：若$a_i^* &gt; 0$，则$c_i(x^*) &#x3D; 0$。</p>
</blockquote>
</li>
</ul>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2020/12/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><blockquote>
<ul>
<li><p><strong>思想：</strong>算法从左往右遍历，左边为排好序的子序列，右边为待排序的子序列，按顺序遍历右边的元素，按顺序插入到左边的子序列中。（时间消耗在寻找左边插入位置上）</p>
</li>
<li><p><strong>演示图：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" alt="插入排序"></p>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 升序排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert_sorted</span><span class="params">(<span class="type">int</span> array[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> tmp;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">    <span class="comment">// 顺序遍历右边的数</span></span><br><span class="line">    tmp=array[i];</span><br><span class="line">    <span class="comment">// 寻找应该插入到左边字序的哪个位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">      <span class="comment">// 向后判断，如果右边的数小于左边的数，则进行交换，直到处于正确的位置上</span></span><br><span class="line">      <span class="keyword">if</span>(tmp&lt;array[j])&#123;</span><br><span class="line">        <span class="comment">// 相邻的进行交换</span></span><br><span class="line">        <span class="built_in">swap</span>(array[j],array[j+<span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：实际上直接插入排序更适合用于链表数组的排序，用作顺序表中，则会变成冒泡排序。</p>
<p>另外，在寻找插入位置上可以引入折半查找插入位置，从而得到一定程度地优化。</p>
</li>
<li><p><strong>稳定性：</strong>属于稳定算法</p>
</li>
<li><p><strong>复杂度：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>$O(n^2)$，如果序列本身有序，时间复杂度为$O(n)$</li>
<li><strong>空间复杂度：</strong>$O(1)$</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><blockquote>
<ul>
<li><strong>思想：</strong>先将序列按步长为d来分割成若干个子序列，对各子序列进行直接插入排序；缩小步长d；重复上述步骤，直到d&#x3D;1.</li>
<li><strong>注意：</strong>步长d&#x3D;1的希尔排序就是直接插入排序；希尔排序本质就是逐渐构建一个相对有序的序列，最终使用一次直接插入排序；希尔排序仅适用于顺序表的排序。</li>
<li><strong>稳定性：</strong>属于不稳定算法</li>
<li><strong>复杂度：</strong><ul>
<li><strong>时间复杂度：</strong>位于$O(n^{1.3})$~$O(n^2)$之间</li>
<li><strong>空间复杂度：</strong>$O(1)$</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><blockquote>
<ul>
<li><p><strong>思想：</strong>通过遍历让两个相邻的数进行比较，如果为逆序，则进行交换；每一趟遍历都将最大的数交换到最底部（升序排序）</p>
</li>
<li><p><strong>演示图：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" alt="冒泡排序"></p>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 升序排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sorted</span><span class="params">(<span class="type">int</span> array[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;len-i;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(array[j]&gt;array[j+<span class="number">1</span>])</span><br><span class="line">        <span class="built_in">swap</span>(array[j],array[j+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>冒泡排序更适合用于顺序表中的排序，链表中需要一个额外的指针进行交换</p>
</li>
<li><p><strong>稳定性：</strong>属于稳定算法</p>
</li>
<li><p><strong>复杂度：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>$O(n^2)$</li>
<li><strong>空间复杂度：</strong>$O(1)$</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><blockquote>
<ul>
<li><p><strong>思想：</strong>将数组分为两部分，左边的为排好序的子序，右边为待排序的子序。每次从右边的子序选择最小值，将其放到左边子序中。（时间主要使用在右边寻找最小值上）</p>
</li>
<li><p><strong>演示图：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" alt="选择排序"></p>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 升序排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">select_sort</span><span class="params">(<span class="type">int</span> array[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> min_idx;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">    min_idx=i;</span><br><span class="line">    <span class="comment">// 寻找右边最小值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;len;j++)&#123;</span><br><span class="line">      <span class="comment">// 如果比当前值要小，那么就将下标记录下</span></span><br><span class="line">      <span class="keyword">if</span>(array[j]&lt;array[min_idx])</span><br><span class="line">        min_idx=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(array[i],array[min_idx]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>稳定性：</strong>属于不稳定算法</p>
</li>
<li><p><strong>复杂度：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>$O(n^2)$</li>
<li><strong>空间复杂度：</strong>$O(1)$</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><blockquote>
<ul>
<li><p><strong>思想：</strong>从序列中选择一个元素作为“基准”（一般为序列第一个元素）；遍历序列中的所有元素，小于基准的放到左边，大于基准的放到右边；得到两个子序列，子序列继续重复上述操作，直到子序列长度为1.</p>
</li>
<li><p><strong>演示图：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" alt="快速排序"></p>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//升序排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> array[],<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 防止越界</span></span><br><span class="line">  <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">    <span class="comment">// 设置基准</span></span><br><span class="line">    <span class="type">int</span> base=array[left];</span><br><span class="line">    <span class="type">int</span> i=left, j=right;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">      <span class="comment">// 在右边寻找第一个小于基准的数</span></span><br><span class="line">      <span class="keyword">while</span>(i&lt;j &amp;&amp; base&lt;=array[j])&#123;</span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 在不越界的情况下找到第一个小于基准的数</span></span><br><span class="line">      <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">        array[i]=array[j];</span><br><span class="line">        <span class="comment">// 此时空位在j上，开始查找左边第一个大于基准的数</span></span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在左边寻找第一个大于基准的数 </span></span><br><span class="line">      <span class="keyword">while</span>(i&lt;j &amp;&amp; base&gt;array[i])&#123;</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 在不越界的情况下找到第一个大于基准的数</span></span><br><span class="line">      <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">        array[j]=array[i];</span><br><span class="line">        <span class="comment">// 此时空位在i上，开始查找又边第一个小于基准的数</span></span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将基准放到中间，此时左边的所有元素都小于基准，右边的所有元素都大于基准</span></span><br><span class="line">    array[i]=base;</span><br><span class="line">    <span class="comment">//递归调用</span></span><br><span class="line">    <span class="comment">// 左边的子序列</span></span><br><span class="line">    <span class="built_in">quick_sort</span>(array,left,i<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 右边的子序列</span></span><br><span class="line">    <span class="built_in">quick_sort</span>(array,i+<span class="number">1</span>,right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>快速排序主要使用了一个分治思想，将序列分成两部分，每部分再各自处理；快速排序每一次循环都会将一个基准放到正确的位置；对于排列均匀的数组，快速排序可以达到最优的速度；快速排序的第n次遍历就会产生n个已排好的数。</p>
</li>
<li><p><strong>稳定性：</strong>属于不稳定算法</p>
</li>
<li><p><strong>复杂度：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>$O(n\log n)$，在原本有序的情况下最差，变为$O(n^2)$</li>
<li><strong>空间复杂度：</strong>$O(递归次数)$<ul>
<li><strong>最好的情况：</strong>基准一直对半分，此时为$O(\log n)$</li>
<li><strong>最坏的情况：</strong>基准将数据分成一边倒，此时为$O(n)$</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>注意：</strong>快速排序的递归顺序是先大后小（先处理大序列，再分割为小序列逐一处理）</p>
</li>
</ul>
</blockquote>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><blockquote>
<ul>
<li><p><strong>思想：</strong>将待排序列的元素分成两个大小一样的子序，对两个子序进行排序，将排好序的子序再进行合并，从而最终得到有序序列。</p>
</li>
<li><p><strong>演示图：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" alt="归并排序"></p>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 升序排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> array[],<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> temp[])</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">    <span class="comment">// 二分</span></span><br><span class="line">    <span class="type">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 对左边进行排序</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(array, left, mid, temp);</span><br><span class="line">    <span class="comment">// 对右边进行排序</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(array, mid+<span class="number">1</span>, right, temp);</span><br><span class="line">    <span class="comment">// 进行归并排序</span></span><br><span class="line">    <span class="type">int</span> i=left, j=mid+<span class="number">1</span>, k=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// i为左边子序的下标，j为右边子序的下标，k作为temp的下标</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">      <span class="comment">// 如果左边的数组小于右边的数组</span></span><br><span class="line">      <span class="keyword">if</span>(array[i]&lt;=array[j])</span><br><span class="line">        temp[k++]=array[i++];</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        temp[k++]=array[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左边数组有剩余的数</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">      temp[k++]=array[i++];</span><br><span class="line">    <span class="comment">// 如果右边数组有剩余的数</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;=right)</span><br><span class="line">      temp[k++]=array[j++];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将临时数组的值放回原数组</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">      array[left+i]=temp[i];</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>稳定性：</strong>属于稳定算法</p>
</li>
<li><p><strong>复杂度：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>$O(n\log n)$，一共需要$\log n$轮归并，每轮耗时$n$</li>
<li><strong>空间复杂度：</strong>$O(n)$</li>
</ul>
</li>
<li><p><strong>注意：</strong>与快速排序的递归不同，归并排序的递归是先小后大（先处理小序列最后再处理大序列）</p>
</li>
</ul>
</blockquote>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><blockquote>
<ul>
<li><p><strong>前情知识：</strong>堆实际上是一个完全二叉树，其中子结点和父结点满足以下关系</p>
<ul>
<li>父$\to$子：父为$i$，左孩子为$2i+1$，右孩子为$2i+2$</li>
<li>子$\to$父：子为i，父为$\frac{i-1}{2}$</li>
</ul>
</li>
<li><p><strong>思路：</strong>构建一个堆（这里为大根堆），将堆顶的元素与数组尾的元素进行交换，然后再将剩下部分调整为堆。</p>
</li>
<li><p><strong>演示图：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%A0%86%E6%8E%92%E5%BA%8F.gif" alt="堆排序"></p>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 升序排序</span></span><br><span class="line"><span class="comment">// 堆调整（大根堆）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_adjust</span><span class="params">(<span class="type">int</span> array[],<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 获取头节点</span></span><br><span class="line">  <span class="type">int</span> temp = array[start];</span><br><span class="line">  <span class="comment">// 开始调整，2*start+1为头节点的左孩子</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>*start+<span class="number">1</span>;i&lt;=end;i=i*<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 有右孩子且左孩子小于右孩子</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;end&amp;&amp;array[i]&lt;array[i+<span class="number">1</span>])&#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果子结点大于父结点</span></span><br><span class="line">    <span class="keyword">if</span>(array[i]&gt;temp)&#123;</span><br><span class="line">      <span class="comment">// 将子结点放到父结点上</span></span><br><span class="line">      array[start]=array[i];</span><br><span class="line">      <span class="comment">// 继续判断该结点的子结点</span></span><br><span class="line">      start=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将一开始的父结点放到合适的地方</span></span><br><span class="line">  array[start] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_sort</span><span class="params">(<span class="type">int</span> array[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 第一次建立大根堆，从后往前依次调整</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=(len<span class="number">-2</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="built_in">heap_adjust</span>(array,i,len<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 每次将根和堆尾进行交换，然后进行调整</span></span><br><span class="line">  <span class="type">int</span> tmp;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line">    tmp=array[<span class="number">0</span>];</span><br><span class="line">    array[<span class="number">0</span>]=array[len<span class="number">-1</span>-i];</span><br><span class="line">    array[len<span class="number">-1</span>-i]=tmp;</span><br><span class="line">    <span class="comment">// len-1-i-1分为两部分：(len-1)-i-1,(len-1)是为了防止越界</span></span><br><span class="line">    <span class="built_in">heap_adjust</span>(array,<span class="number">0</span>,len<span class="number">-1</span>-i<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>稳定性：</strong>属于不稳定算法</p>
</li>
<li><p><strong>复杂度：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>$O(n\log n)$，其中建堆时间复杂度为$O(\log n)$，排序时间为$O(n)$</li>
<li><strong>空间复杂度：</strong>$O(1)$</li>
</ul>
</li>
<li><p><strong>使用实例：</strong>快速在1亿个数中找到前100个最大值，即先取前100个数构成一个小根堆，然后用剩下的数与堆顶进行比较，若大于堆顶则交换，并且重新调整堆。总的时间复杂度为$O(n\log n)$</p>
</li>
</ul>
</blockquote>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><blockquote>
<ul>
<li><p><strong>思路：</strong>将关键字拆分为d位，按照各个关键字权值递增的次序（即个位、十位、百位），做d趟“分配”与”收集“。分配：根据当前关键字，将n个元素分配到相应的队列上，耗时为$O(n)$；收集：把各队列中的结点，依次出队并相互连接，形成一个完整的序列，耗时为$O(r)$</p>
</li>
<li><p><strong>演示图：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="基数排序"></p>
</li>
<li><p><strong>稳定性：</strong>属于稳定算法</p>
</li>
<li><p><strong>复杂度：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>$O(d*(n+r))$</li>
<li><strong>空间复杂度：</strong>$O(n)$</li>
</ul>
</li>
<li><p><strong>适用场景：</strong></p>
<ul>
<li>关键字可以分为d组</li>
<li>每组关键字取值范围不大</li>
<li>属于个数远大于分组数d</li>
<li>数据全为正整数或全为负整数</li>
</ul>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>基础学科</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据链路层层</title>
    <url>/2022/01/26/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<h1 id="数据链路层的功能："><a href="#数据链路层的功能：" class="headerlink" title="数据链路层的功能："></a>数据链路层的功能：</h1><blockquote>
<p>数据链路层在<strong>物理层</strong>提供服务的基础上向<strong>网络层</strong>提供服务，主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造为<strong>逻辑上无差错的数据链路</strong>。</p>
<p>所以我们可以近似认为：<strong>数据链路层接收的帧均无差错</strong>。</p>
<p>数据链路层的传输单元为<strong>数据帧</strong>。</p>
</blockquote>
<h2 id="为网络层提供服务"><a href="#为网络层提供服务" class="headerlink" title="为网络层提供服务"></a>为网络层提供服务</h2><blockquote>
<p>对于网络层来说，数据链路层的基本任务是将原机器中的网络层数据传输到目标机器的网络层之中。因此数据链路层为网络层提供以下服务：</p>
<ul>
<li><strong>无确定的无连接服务：</strong>源机器发送数据帧时<strong>不需要建立链路连接</strong>，目的机器在收到数据后也<strong>不用发送确认信息</strong>。常用于实时通信或质量较好的信道通信。</li>
<li><strong>有确认的无连接服务：</strong>源机器发送数据帧时<strong>不需要建立链路连接</strong>，但目的机器在收到数据后<strong>需要发送确认信息</strong>。源机器在规定时间内没收到确认消息就重传数据。</li>
<li><strong>有确认的有链接服务：</strong>帧传输过程分为三个阶段：<strong>建立数据链路、传输帧、释放数据链路</strong>。且目的机器对收到的每一个帧都要给出确认，源机器收到后才发送下一个帧。</li>
</ul>
</blockquote>
<h2 id="链路管理"><a href="#链路管理" class="headerlink" title="链路管理"></a>链路管理</h2><blockquote>
<p><strong>定义：</strong>数据链路层连接的<strong>建立、维持和释放</strong>过程。</p>
<p><strong>主要内容：</strong>它主要用于面向连接的服务。链路两端的结点要进行有链接的通信，必须首先确认对方已经处于就绪状态，并交换一些必要的信息以对帧序号的初始化，然后才开始建立连接。在传输过程中则要能维持连接，在传输完毕后要释放连接。</p>
</blockquote>
<h2 id="数据链路层的基本问题"><a href="#数据链路层的基本问题" class="headerlink" title="数据链路层的基本问题"></a>数据链路层的基本问题</h2><h3 id="封（组）装成帧"><a href="#封（组）装成帧" class="headerlink" title="封（组）装成帧"></a>封（组）装成帧</h3><blockquote>
<p><strong>帧的结构：</strong>将一段数据的前后分别添加首部和尾部，就构成了帧。其中帧的首部和尾部包含许多控制信息，其中一个重要的作用就是确定<strong>帧的界限</strong>，也称为<strong>帧定界</strong>。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%B8%A7%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="帧的结构"></p>
<p><strong>帧同步：</strong>指接收方能从接收到的二进制比特流中区分出帧的起始与终止。</p>
<p><strong>最大传送单元（MTU）：</strong>每种数据链路层协议所规定<strong>帧的数据部分长度上限</strong>。</p>
<p><strong>帧的四种组成方法：</strong>1、字符计数法；2、字符（节）填充法；3、零比特填充法；4、违规编码法</p>
<ul>
<li><p><strong>字符计数法：</strong>在帧首部使用一个计数字段（第一个字节，八位）来标明帧内字符数。</p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%AD%97%E7%AC%A6%E8%AE%A1%E6%95%B0%E6%B3%95.png" alt="字符计数法"></p>
<p><strong>缺点：</strong>如果某一个计数字段出现差错，那么后面所有帧都会出现错误。</p>
</blockquote>
</li>
<li><p><strong>字符（节）填充法：</strong>使用两个定界字符作为首部与尾部。</p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%AD%97%E7%AC%A6%E5%A1%AB%E5%85%85%E6%B3%95.png" alt="字符填充法"></p>
<p>当传输数据的编码为ASCII码时，无论数据部分输入的是什么，都可以进行透明传输。</p>
<p>同样<strong>字符（节）填充法</strong>也会出现控制信息在数据部分出现的问题，所以可以对出现在数据部分的控制信息位加上转义字符。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%AD%97%E7%AC%A6%E5%A1%AB%E5%85%85%E6%B3%95%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.png" alt="字符填充法解决方法"></p>
<p>这样一来，只需要在接收方刻意去除数据部分中的转移字符即可。</p>
</blockquote>
</li>
<li><p><strong>零比特填充法：</strong></p>
<blockquote>
<p>用<strong>01111110</strong>作为头部与尾部的标识符。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E9%9B%B6%E6%AF%94%E7%89%B9%E5%A1%AB%E5%85%85%E6%B3%95.png" alt="零比特填充法"></p>
<p><strong>操作：</strong></p>
<p>在发送端，扫描整个信息字段，子要出现连续5个1，就立即填入1个0。</p>
<p>在接收端收到一个帧时，先找到字段确定边界，再对数据部分的比特流进行扫描，发现5个1时，将后面的0删除。</p>
</blockquote>
</li>
<li><p><strong>违规编码法：</strong></p>
<blockquote>
<p>在编码的时候利用不可能出现的编码作为帧边界。如曼彻斯特编码，</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E8%BF%9D%E8%A7%84%E7%BC%96%E7%A0%81%E6%B3%95.png" alt="违规编码法"></p>
</blockquote>
</li>
</ul>
<p><strong>补充：</strong>比较普遍使用的帧同步法是<strong>零比特填充</strong>和<strong>违规编码法</strong>。</p>
</blockquote>
<h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><blockquote>
<p><strong>定义：</strong>指不管所传输的数据是什么样的比特组合，都应当能在链路上传送。</p>
<p><strong>要求：</strong>当所传数据中的比特组合与某一段控制信息完全一样是，应当采取适当的措施，使得接收方不会将该数据误认为是某种控制信息。</p>
</blockquote>
<h3 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h3><blockquote>
<p>概括来说，传输的差错是由于噪声引起的，</p>
<p><strong>全局性的噪声：</strong>由于线路本身电气特性所产生的<strong>随机噪声</strong>，这是信道固有的，且随机存在的。<strong>解决方法：</strong>提高信噪比或避免干扰。</p>
<p><strong>局部性的噪声：</strong>外界特定的短暂原因造成的<strong>冲击噪声</strong>，是产生差错的主要原因。</p>
<p><strong>差错的类型：</strong></p>
<ul>
<li><strong>位错：</strong>比特位出错，1变成0，0变成1（差错检测主要解决的问题）。</li>
<li><strong>帧错：</strong>又分为<strong>帧丢失、帧重复</strong>和<strong>帧失序</strong>。</li>
</ul>
</blockquote>
<h4 id="检错编码"><a href="#检错编码" class="headerlink" title="检错编码"></a>检错编码</h4><blockquote>
<p>只能检查出帧是否出错，无法定位和纠正错误。</p>
<p>检错编码又分为：<strong>奇偶检验码</strong>和<strong>循环冗余码</strong>。</p>
<ul>
<li><p><strong>奇偶检验码</strong></p>
<blockquote>
<p>可以分为<strong>奇校验码</strong>和<strong>偶校验码</strong>。在n-1位的信息元之前加入0或1，来保证整体1的个数为<strong>奇数</strong>或<strong>偶数</strong>。因此发送时有n-1位的信息元以及1位的校验元。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%A5%87%E5%81%B6%E6%A3%80%E9%AA%8C%E7%A0%81.png" alt="奇偶检验码"><br>在接收端，根据接收到的数据，一位位地统计其中1的个数。在奇校验码中，如果1的个数为奇数，那么判定为无差错；如果为偶数，则丢弃。</p>
<p><strong>注意：</strong>奇偶检验码的检错成功率只有50%，如奇校验码，如果出错的位恰好导致1的个数依旧是奇数，那么奇校验码就无法检出差错。</p>
</blockquote>
</li>
<li><p><strong>循环冗余码</strong></p>
<blockquote>
<p><strong>步骤：</strong></p>
<ul>
<li><strong>加0：</strong>设生成多项式G(x)的阶为r，则在待发送数据后面加r个0.</li>
<li><strong>模2除法：</strong>数据加0后除以多项式（直接除，不需要考虑进位），余数为**冗余码(FCS)**。</li>
</ul>
<p><strong>补充：</strong>多项式的一种表示方法：</p>
<blockquote>
<p>10011表示为多项式为：<br>$$<br>X^4+X^1+X^0<br>$$</p>
</blockquote>
<p><strong>例子：</strong>要发送的数据是1101 0110 11，采用CRC校验，生成多项式是10011，那么最终发送数据为？</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E7%A0%81.png" alt="循环冗余码"></p>
<p>最终结果将一开始加上的0全部换为除得的余数。（除得的商没有任何作用！）</p>
<p><strong>检错：</strong></p>
<blockquote>
<p>把收到的每一个帧都除以同样的除数，然后检查得到的余数R。</p>
<ul>
<li>余数为0，判定这个帧没有差错，接收。</li>
<li>余数不为0，判定这个帧有差错，丢弃。</li>
</ul>
</blockquote>
<p><strong>补充：</strong>FCS的生成以及CRC检测都是由硬件实现的。</p>
<p>链路层使用CRC检验能实现无比特差错，但这并不属于可靠传输。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="纠错编码"><a href="#纠错编码" class="headerlink" title="纠错编码"></a>纠错编码</h4><blockquote>
<p><strong>海明码：</strong></p>
<p><strong>特点：</strong>发现双比特错，纠正单比特错。</p>
<p><strong>过程：</strong></p>
<ul>
<li><p><strong>确定校验码位数r</strong></p>
<blockquote>
<p>满足海明不等式：<br>$$<br>2^r \ge k+r+1<br>$$<br>其中r为冗余码的位数，k为信息数据的位数。</p>
</blockquote>
</li>
<li><p><strong>确定校验码和数据的位置</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%A1%AE%E5%AE%9A%E6%A0%A1%E9%AA%8C%E7%A0%81%E4%BD%8D%E7%BD%AE.png" alt="确定校验码位置"></p>
</blockquote>
</li>
<li><p><strong>求校验码的值</strong></p>
<blockquote>
<p><strong>令所有要校验的位与校验码异或&#x3D;0</strong>，从而求出该位的校验码。</p>
<p>如上图的第一位校验码的求法：</p>
<blockquote>
<ul>
<li><p>首先确定$P_1$要校验的位数是1、3、5、7、9（这些的共同点是位数化为二进制后第一位的值相同都是1）</p>
</li>
<li><p>根据定义求：$P_1$ xor $D_1$ xor $D_3$ xor $D_5$ xor $D_7$ xor $D_9$ &#x3D;$P_1$ xor 1 xor 0  xor 1  xor 0 &#x3D; 0，求得P1等于0</p>
</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>检错并纠错</strong></p>
<blockquote>
<p><strong>令所有要校验的位与校验码异或</strong>，检查最后结果，如果结果全为0，那么帧无差错。如果结果出现1，那帧出错。</p>
<p>将所有<strong>校验的位与校验码异或</strong>的结果合起来就可以得到出错位的位号。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="流量控制与可靠传输机制"><a href="#流量控制与可靠传输机制" class="headerlink" title="流量控制与可靠传输机制"></a>流量控制与可靠传输机制</h2><blockquote>
<p><strong>前请补充：</strong></p>
<blockquote>
<ul>
<li>数据链路层中的<strong>流量控制</strong>与后面传输层中的<strong>流量控制</strong>会有一定的交叉。 </li>
<li><strong>现在数据链路层已经不再负责数据的流量控制与可靠传输</strong>了，但在计算机网络早期线路并不可靠的时候，数据链路层就需要承担起这两样职责。</li>
<li>现在数据链路层主要负责<strong>差错检验</strong>（即发现出错的帧就丢掉）。</li>
</ul>
</blockquote>
<p><strong>可靠传输：</strong>发送端发送什么，接收端就接收什么（帧的内容，帧的数量，帧组的序列等）。</p>
<p><strong>流量控制：</strong>控制发送方的发送速率，使得接收方有足够的能力接收发送的每一个帧。</p>
</blockquote>
<h3 id="可靠传输机制"><a href="#可靠传输机制" class="headerlink" title="可靠传输机制"></a>可靠传输机制</h3><blockquote>
<p>数据链路层使用<strong>确认</strong>和<strong>超时重传</strong>这两种机制来完成可靠传输。</p>
<p>确认是一种<strong>无数据的控制帧</strong>，它可以让发送方知道哪些帧被正确接收；有时确认还会捎带在一个回复帧里面，成为<strong>捎带确认</strong>。</p>
<p><strong>超时重传</strong>指在发送方中每发送完一个帧都会启用一个计时器，在计时器计时结束后仍未收到接收方的确认帧，那么就自动将数据再次重传。</p>
<p>在数据链路层中，可靠传输与流量控制有一定程度的相交。</p>
</blockquote>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><blockquote>
<p>当发送方的发送速率大于接收方的接受速率时就会出现传输出错，因此就需要流量控制进行调整。</p>
<p>流量控制的基本手段是：<strong>由接收方控制发送方的发送速率</strong>。</p>
<p><strong>数据链路层流量控制与传输层流量控制的区别</strong>：</p>
<blockquote>
<ul>
<li><strong>数据链路层的流量控制</strong>是<strong>点到点</strong>的（即本传输结点到下一个传输结点），而<strong>传输层的流量控制</strong>是<strong>端到端</strong>的（即本主机到目的主机之间，当然中间包含了许多的路由器等设备）</li>
<li><strong>数据链路层流量控制手段</strong>：接收方收不下就不回复确认；<strong>传输层流量控制手段</strong>：接收端给发送端一个窗口公告（缓冲区剩余量）。</li>
<li><strong>数据链路层</strong>中的<strong>发送窗口与接收窗口</strong>都是<strong>固定的</strong>，<strong>传输层</strong>中的<strong>发送窗口与接收窗口</strong>都是<strong>变化的</strong></li>
</ul>
</blockquote>
<p><strong>流量控制的方法：</strong></p>
<blockquote>
<ul>
<li><p><strong>停止-等待协议</strong>：每发送完一个帧就停止发送，等待对方的确认，在收到确认帧后再发送下一个帧。</p>
</li>
<li><p><strong>滑动窗口协议</strong>：反退N帧协议(GBN)、选择重传协议(SR)</p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png" alt="滑动窗口"></p>
</blockquote>
</li>
</ul>
<p><strong>窗口数量：</strong></p>
<blockquote>
<ul>
<li><strong>停止-等待协议：</strong>发送窗口大小&#x3D;1，接收窗口大小&#x3D;1；</li>
<li><strong>反退N帧协议(GBN)：</strong>发送窗口大小&gt;1，接收窗口大小&#x3D;1；</li>
<li><strong>选择重传协议(SR)：</strong>发送窗口大小&gt;1，接收窗口大小&gt;1；</li>
</ul>
</blockquote>
</blockquote>
</blockquote>
<h4 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h4><blockquote>
<p><strong>工作原理：</strong>发送端每发送完一个分组就停止发送，等待接收方确认，只有在收到确认后才发送下一个分组。</p>
<p><strong>无差错的情况：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%81%9C%E6%AD%A2-%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE%E6%97%A0%E5%B7%AE%E9%94%99.png" alt="停止-等待协议无差错"></p>
<p><strong>补充：</strong>由于每次只发送一个数据帧，因此用1bit来编号即可。</p>
</blockquote>
<p><strong>有差错的情况：</strong></p>
<blockquote>
<ul>
<li><p><strong>数据帧丢失或检测出错：</strong></p>
<blockquote>
<img src="/picture/学习/计算机网络上的图/数据链路层/停止-等待协议超时.png" alt="停止-等待协议超时" style="zoom: 67%;" />

<p><strong>过程：</strong>发送方有一个<strong>超时计时器</strong>，每发送一个帧就启动一个计时器，当计时器归零的时候还未收到确认，那就将刚刚的数据帧重新发送。</p>
<p><strong>注意：</strong>超时计时器设置的重传时间需要比帧的传输的平均RTT更长一些；发送完一个帧后，必须保留它的副本；数据帧和确认帧必须编号。</p>
</blockquote>
</li>
<li><p><strong>ACK丢失</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%81%9C%E6%AD%A2-%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AEACK%E4%B8%A2%E5%A4%B1.png" alt="停止-等待协议ACK丢失"></p>
<p><strong>过程：</strong>如果出现确认帧丢失，在超时后发送方仍未收到确认帧，那么就会重新发送数据帧；此时接收方收到重复的帧后，<strong>丢弃然后发送确认帧</strong>。</p>
</blockquote>
</li>
<li><p><strong>ACK迟到</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%81%9C%E6%AD%A2-%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AEACK%E8%BF%9F%E5%88%B0.png" alt="停止-等待协议ACK迟到"></p>
<p><strong>过程：</strong>ACK由于某种原因在超过重传计时器的范围后仍未到达，发送端进行超时重传，第二次ACK到达了，然后发送下一个数据帧，此时如果收到已经收到的确认帧，那么就直接丢弃不做处理。</p>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>停止-等待协议性能：</strong>优点是简单，缺点是信道利用率低。</p>
<p><strong>信道利用率：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87.png" alt="信道利用率"><br>$$<br>信道利用率U&#x3D;\frac{T_D}{T_D+RTT+T_A}<br>$$<br>即一个发送周期中，发送数据所需时间的占比。<br>$$<br>信道利用率&#x3D;(L&#x2F;C)&#x2F;T \quad(L为发送的比特长度，C发送方数据传输率，T发送周期)<br>$$</p>
<p>$$<br>信道吞吐率&#x3D;信道利用率*发送方的发送速率<br>$$</p>
<p> <strong>例题：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E4%BE%8B%E9%A2%98.png" alt="例题"></p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="反退N帧协议-GBN"><a href="#反退N帧协议-GBN" class="headerlink" title="反退N帧协议(GBN)"></a>反退N帧协议(GBN)</h4><blockquote>
<p>与停止-等待协议不同，反退N帧协议的发送方有n个发送窗口，因此相较于停止-等待协议，反退N帧协议的信道利用率更高。</p>
<p><strong>协议运行过程：</strong></p>
<blockquote>
<ul>
<li>发送方发送一连串有序的数据帧</li>
<li>接收方逐个接收数据帧，并发回<strong>一个确认帧</strong></li>
<li>发送方根据接受到的确认帧，继续发送确认帧后一位的数据帧</li>
<li>重复上诉步骤</li>
</ul>
</blockquote>
<p><strong>细节：</strong></p>
<blockquote>
<ul>
<li><p><strong>发送方：</strong></p>
<blockquote>
<ul>
<li><strong>上层的调用：</strong>上层要发送数据时，发送方会检测发送窗口是否已满，如果<strong>未满</strong>，则产生一个帧将其发送；如果<strong>窗口已满</strong>，发送方将数据返回给上层，提示上层窗口已满。（实际上发送方可以用缓冲区先缓存这些数据）</li>
<li><strong>收到一个ACK：</strong>在GBN协议中，对n号帧采用<strong>累积确认</strong>的方式，即n号帧的确认帧就可以表明了接收方接收到了n号帧和它之前的所有帧。</li>
<li><strong>超时事件：</strong>对于丢失或者出错的帧，发送方会重传所有已发送但未被确认的帧。</li>
</ul>
</blockquote>
</li>
<li><p><strong>接收方：</strong></p>
<blockquote>
<ul>
<li>如果正确收到n个帧，并且都按序，那么接收方发送一个n号的确认帧，并将数据交付给上层。</li>
<li>接收方中有一个变量expectedseqnum，专门用于存储下一个按序接收的帧的序号；当接收方收到一串失序的帧，那么它会将失序部分丢弃。如，接收方接收到0，1，2，3，5，6，7的帧，那么expectedseqnum就会等于4，并且接收方会丢弃5，6，7号的帧，直到收到4号帧为止。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>GBN协议运作流程例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/GBN%E5%8D%8F%E8%AE%AE%E8%BF%90%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="GBN协议运作流程">、</p>
</blockquote>
<p><strong>GBN协议重点总结：</strong></p>
<blockquote>
<ul>
<li><strong>累计确认</strong></li>
<li><strong>接收方只按顺序接收帧，无序部分将会丢弃</strong></li>
<li><strong>接收方确认序列号最大、且按序到达的帧</strong></li>
<li><strong>发送窗口最大为</strong>$2^n-1$，<strong>接收窗口大小为1</strong>（n为发送端为发送数据进行编码的位数，只要n一确定，那么后面将不会跟着改变）</li>
</ul>
</blockquote>
<p><strong>GBN协议的性能：</strong></p>
<blockquote>
<ul>
<li>提高了信道利用率</li>
<li>在重传时将一部分已经正确传送的帧重传，使得传送效率降低，也浪费了一部分的网络资源。</li>
</ul>
</blockquote>
</blockquote>
<h4 id="选择重传协议-SR"><a href="#选择重传协议-SR" class="headerlink" title="选择重传协议(SR)"></a>选择重传协议(SR)</h4><blockquote>
<p>GBN协议虽然解决了信道利用率较低的问题，但是它会出现过多的重传帧，因此会造成网络传输资源的浪费，为了解决这个问题，后来又提出了选择重传协议。</p>
<p><strong>协议运行过程：</strong></p>
<blockquote>
<ul>
<li>发送方连续发送窗口内的数据帧。</li>
<li>接收方<strong>仅接收属于滑动窗口内的数据帧</strong>。</li>
<li>发送方只有在滑动窗口的下界帧收到了确定后才移动滑动窗口。</li>
<li>接收方只有收到滑动窗口的下届的帧后才移动滑动窗口。</li>
<li>重复以上步骤。</li>
</ul>
</blockquote>
<p><strong>细节部分：</strong></p>
<blockquote>
<ul>
<li><p><strong>发送方：</strong></p>
<blockquote>
<ul>
<li><strong>上层的调用：</strong>从上层接收到待发送的数据后，SR检查滑动窗口是否已满，如果未满，则封装成帧然后发送；否则将数据缓存或者返回给上层。</li>
<li><strong>收到一个ACK</strong>：如果ACK对应帧的序号在窗口内，则将该帧标记为以确认帧，如果该帧时窗口的下界（最左边第一个窗口对应的序号），则窗口向前移动到具有最小序号的未确认帧处（移到窗口的下界是未确认帧处）。</li>
<li><strong>超时事件：</strong> <strong>每一个帧都有属于自己的定时器</strong>，当一个出现一个超时事件后就重传该帧。</li>
</ul>
</blockquote>
</li>
<li><p><strong>接收方：</strong></p>
<blockquote>
<ul>
<li><strong>对于窗口内的帧都来者不拒：</strong>接收方对于一个<strong>正确的帧（不过是否失序）</strong>都进行缓存（所以接收方也有一个缓存），并且接收哪个帧就发回哪个帧的确认帧，直到窗口内所有帧都被接收为止。只有<strong>窗口下界的帧被接收到</strong>了，<strong>窗口才会向后移动</strong>。</li>
<li>如果收到窗口序号外（小于窗口下界）的帧，就丢弃该帧并返回一个ACK。</li>
<li>其他情况就丢弃该帧。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>SR协议运作流程例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/SR%E5%8D%8F%E8%AE%AE%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="SR协议运行流程"></p>
<p>在本例中最终结果是发送端等待2号帧的确认，当收到确认以后，发送方的窗口会往前滑动。</p>
</blockquote>
<h6 id="滑动窗口长度："><a href="#滑动窗口长度：" class="headerlink" title="滑动窗口长度："></a><strong>滑动窗口长度：</strong></h6><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/SR%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%95%BF%E5%BA%A6.png" alt="SR滑动窗口长度"></p>
<p>当滑动窗口大于$2^{n-1}$（n为帧序号的编码位）时，就会出现上面的问题。</p>
<p>所以<strong>滑动窗口最大值不能大于</strong>$2^{n-1}$。</p>
</blockquote>
<p><strong>SR协议的重点总结：</strong></p>
<blockquote>
<ul>
<li><strong>对数据帧逐一确认，接收一个就确认一个</strong>（仅限于滑动窗口内）。</li>
<li><strong>只重传出错的帧</strong>。</li>
<li><strong>滑动窗口最大值不能大于</strong>$2^{n-1}$。</li>
</ul>
</blockquote>
</blockquote>
<h2 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h2><blockquote>
<p><strong>介质访问控制的任务：</strong>为使用介质的每一个结点隔离来自同一信道上其他结点的信号，已协调活动结点的传输，同时又增强数据的传输效率。</p>
<p><strong>分类：</strong></p>
<blockquote>
<ul>
<li><strong>静态划分信道：</strong>信道划分介质访问控制</li>
<li><strong>动态划分信道：</strong>随机访问介质访问控制、轮询访问介质访问控制</li>
</ul>
</blockquote>
<p><strong>各特点：</strong></p>
<blockquote>
<ul>
<li><p><strong>信道划分介质访问控制：</strong>基于<strong>多路复用</strong>技术，不会产生冲突。</p>
<blockquote>
<ul>
<li><strong>网络负载重：</strong>共享信道效率高，且公平</li>
<li><strong>网络负载轻：</strong>共享信道效率低</li>
</ul>
</blockquote>
</li>
<li><p><strong>随机划分介质访问控制：</strong>用户根据意愿<strong>随机</strong>发送信息，发送信息时可以独占信道带宽。</p>
<blockquote>
<ul>
<li><strong>网络负载重：</strong>产生冲突开销，信道效率下降</li>
<li><strong>网络负载轻：</strong>共享信道效率高，单个结点可以利用信道全部的带宽</li>
</ul>
</blockquote>
</li>
<li><p><strong>轮询访问介质访问控制</strong> </p>
<blockquote>
<p>既<strong>不产生冲突</strong>，又可以发送时<strong>占用全部带宽</strong>。</p>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<h3 id="信道划分介质访问控制"><a href="#信道划分介质访问控制" class="headerlink" title="信道划分介质访问控制"></a>信道划分介质访问控制</h3><blockquote>
<p><strong>定义：</strong>将使用介质的每个设备与在同一介质上的其他设备隔离开，把<strong>时域</strong>和<strong>频域</strong>合理地分配给网络上的设备。</p>
<p><strong>分类：</strong> **时分复用(TDM)、频分复用(FDM)、波分复用(WDM)、码分复用(CDM)**。</p>
<p><strong>多路复用：</strong>把多个信号组合在一条物理信道上进行传输，使得多个设备能够<strong>共享信道资源</strong>，提高信道利用率。</p>
</blockquote>
<h4 id="频分多路复用"><a href="#频分多路复用" class="headerlink" title="频分多路复用"></a>频分多路复用</h4><blockquote>
<p><strong>描述：</strong>在物理信道的可用带宽（可用频率）的范围里将物理信道的总带宽划分为若干个子信道的频带。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E9%A2%91%E5%88%86%E5%A4%8D%E7%94%A8.png" alt="频分复用"></p>
<p><strong>注意：</strong>在实际应用中还会在每个子信道之中加入“<strong>保护频带</strong>”，防止各信道之间产生干扰。</p>
<p><strong>优点：</strong>充分利用了传输介质的带宽；系统传输效率较高；技术比较成熟，容易实现。</p>
</blockquote>
<h4 id="时分多路复用"><a href="#时分多路复用" class="headerlink" title="时分多路复用"></a>时分多路复用</h4><blockquote>
<ul>
<li><p><strong>时分多路复用：</strong></p>
<blockquote>
<p> <strong>描述：</strong>将一条物理信道<strong>按时间分成若干时间片</strong>，轮流分配给多个信号使用。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8.png" alt="时分复用"></p>
<p>如果一个介质的传输速率有8Mb&#x2F;s，那么利用时分复用可以使得A、B、C、D每一个用户分到2Mb&#x2F;s的速度。</p>
<p><strong>注意：</strong>这里的帧<strong>并非数据链路层里的帧</strong>，而是物理层里的<strong>比特串</strong>。</p>
</blockquote>
</li>
<li><p><strong>统计时分多路复用：</strong></p>
<blockquote>
<p>不难看出如果B、C、D的传输数据量很低的话，采用固定的时分复用会导致介质传输的效率低下。为此又提出了<strong>统计时分多路复用。</strong></p>
<p><strong>区别：</strong>统计时分多路复用的帧改成按需的<strong>动态分配</strong>。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BB%9F%E8%AE%A1%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8.png" alt="统计时分复用"></p>
<p><strong>每个STDM帧中的时隙数小于连接在集中器上的用户数</strong>。各用户要发送数据时就将数据发往集中器中的<strong>输入缓存</strong>，集中器按顺序依次将数据扫描输入缓存，然后再把缓存的数据放入STDM帧中，当一个STDM帧满了就发出。</p>
<p>因此在统计时分多路复用中，如果介质的传输速率为8Mb&#x2F;s，每一个用户的传输速率<strong>范围变为0Mb&#x2F;s - 8Mb&#x2F;s</strong>。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="波分多路复用"><a href="#波分多路复用" class="headerlink" title="波分多路复用"></a>波分多路复用</h4><blockquote>
<p><strong>定义：</strong>波分多路复用就是光的频分多路复用，指的是在<strong>光纤中传输多种不同波长的光信号</strong>，从而使得各路光信号互不干扰。</p>
</blockquote>
<h4 id="码分多路复用"><a href="#码分多路复用" class="headerlink" title="码分多路复用"></a>码分多路复用</h4><blockquote>
<p> <strong>定义：</strong>码分多路复用是<strong>采用不同编码</strong>来区分各路原始信号的一种复用方式。它<strong>既共享时间，又共享频率</strong>。</p>
<p> <strong>原理：</strong>每个比特时间再划分成m个短的时间槽，称为<strong>码片</strong>，通常m的值为64或128。（下面的例子只是方便起见）</p>
<p> <strong>例子：</strong></p>
<blockquote>
<p>有A、B两个设备共享一条介质信道，A‘、B’分别是这两个设备的接收设备。</p>
<p>现在设A的码片序列为：(-1,-1,-1,+1,+1,-1,+1,+1)为1，(+1,+1,+1,-1,-1,+1,-1,-1)为0；</p>
<p>B的码片序列为：(-1,-1,+1,-1,+1,+1,+1,-1)为1，(+1,+1,-1,+1,-1,-1,-1,+1)为0。</p>
<p>当A发送1，B发送0时，两个向量就到公共信道上叠加，叠加方式是<strong>线性相加</strong>，即<br>$$<br>(-1,-1,-1,+1,+1,-1,+1,+1)+(+1,+1,-1,+1,-1,-1,-1,+1)&#x3D;(0,0,-2,2,0,-2,0,2)<br>$$<br>到达目的地址后，需要进行数据分离，此时只需要将得到的数据与对应接收方的码片进行内积再取平均即可，如A’收到后：<br>$$<br>[(0,0,-2,2,0,-2,0,2)*(-1,-1,-1,+1,+1,-1,+1,+1)]&#x2F;8&#x3D;1<br>$$<br>那么A‘就判定A发送的是1。</p>
</blockquote>
<p> <strong>注意点：</strong></p>
<blockquote>
<ul>
<li>码分复用的本质是利用互不相交的两个码片来代替不同信道上的0，1信号。</li>
<li>虽然码片序列中存在-1和+1，实际上传输的依旧是0，1信号。</li>
<li>码片序列0和1互为<strong>反码</strong>。</li>
<li>码片互不相交的体现：<strong>规格化内积为0</strong>（又称相互正交）。即如同$[(-1,-1,-1,+1,+1,-1,+1,+1)*(-1,-1,+1,-1,+1,+1,+1,-1)]&#x2F;8&#x3D;0$</li>
<li>在接收方分离信号的时候，得出的结果实际意义是：<strong>该信号是否与解码用的码片相同</strong>。如在上例中，A’如果用的是(+1,+1,+1,-1,-1,+1,-1,-1)来解码，那么得到的结果就为-1，就表示收到的信号不是0。</li>
<li>如果分离出的结果不是+1，也不是-1，那么代表叠加信号中没有要本设备接收的信号。</li>
</ul>
</blockquote>
</blockquote>
<h3 id="随机访问介质访问控制"><a href="#随机访问介质访问控制" class="headerlink" title="随机访问介质访问控制"></a>随机访问介质访问控制</h3><blockquote>
<p><strong>定义：</strong>不采用集中控制方式解决发送信息的次序问题，所有用户根据自身情况随机发送信息，占用介质的全部速率。</p>
<p><strong>实现特点：</strong>当两个或多个用户发生碰撞时，每个用户按照一定<strong>规则（协议）</strong>来重复重传帧，直到帧无碰撞通过。</p>
<p><strong>常用协议：</strong>ALOHA协议、CSMA协议、CSMA&#x2F;CD协议、CSMA&#x2F;CA协议</p>
</blockquote>
<h4 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h4><blockquote>
<p><strong>基本思想：</strong>不监听信道，各用户随时发送信息。</p>
<p>ALOHA协议又分<strong>纯ALOHA协议</strong>与<strong>时隙ALOHA协议</strong>。</p>
<ul>
<li><p><strong>纯ALOHA协议</strong>：</p>
<blockquote>
<p><strong>协议步骤：</strong></p>
<ul>
<li><p>每个用户需要发送数据时直接发送，然后等待接收方的确认帧。</p>
</li>
<li><p>当发生碰撞的时候不做处理，接收方收到发生碰撞的帧<strong>自动丢弃</strong>。</p>
</li>
<li><p>发送方计时器超时后<strong>随机找一个时间重发数据</strong>。</p>
</li>
</ul>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/ALOHA%E5%8D%8F%E8%AE%AE.png" alt="ALOHA协议"></p>
</blockquote>
</li>
<li><p><strong>时隙ALOHA协议：</strong></p>
<blockquote>
<p>由于纯ALOHA协议的随意性，会导致信道多处发生碰撞，使得信息传输效率下降。</p>
<p><strong>特点：</strong>时隙ALOHA协议的特点是<strong>将时间划分为一段段等长的时隙，规定只有在每一个时隙开始时才能发送一个帧。</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%97%B6%E9%9A%99ALOHA%E5%8D%8F%E8%AE%AE.png" alt="时隙ALOHA协议"></p>
<p>时隙ALOHA协议相较于纯ALOHA协议来说随机性更低了，因此使得信息传输效率更高了。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="CSMA协议"><a href="#CSMA协议" class="headerlink" title="CSMA协议"></a>CSMA协议</h4><blockquote>
<p>CSMA协议全称为<strong>载波监听多路访问协议</strong>。</p>
<p><strong>基本思想：</strong>每个站点在发送数据前都先监听一下共用信道，发现信道为空之后再发送数据。</p>
<p>根据监听方式和监听到信道繁忙后的处理方式不同可以将CSMA协议分成三类：<strong>1-坚持CSMA、非坚持CSMA</strong>和<strong>p-坚持CSMA</strong>。</p>
<p><strong>监听方式：</strong>检测信道上的电信号是否超过阈值。</p>
<ul>
<li><p><strong>1-坚持CSMA</strong></p>
<blockquote>
<p><strong>思想：</strong></p>
<blockquote>
<ul>
<li>一个结点要发送数据时，首先监听信道；</li>
<li>如果信道空闲，则立即发送数据；</li>
<li>如果信道繁忙，则<strong>继续</strong>监听信道，直到信道空闲；</li>
<li>如果发生冲突，那么<strong>随机等待一段时间后再重新开始监听信道</strong>，重复上诉步骤。</li>
</ul>
</blockquote>
<p><strong>1-坚持的意义：</strong>在信道繁忙的时候坚持监听信道。</p>
<p><strong>缺点：</strong>如果有两个结点都想发送数据的时候，它们一定会发生碰撞。</p>
</blockquote>
</li>
<li><p><strong>非坚持CSMA</strong></p>
<blockquote>
<p><strong>思想：</strong></p>
<blockquote>
<ul>
<li>一个结点要发送数据时，首先监听信道；</li>
<li>如果信道空闲，则立即发送数据；</li>
<li>如果信道繁忙，则<strong>放弃监听</strong>，等待一个随机的时间再重复上诉步骤。</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>p-坚持CSMA</strong></p>
<blockquote>
<p><strong>思想：</strong></p>
<blockquote>
<ul>
<li>一个结点要发送数据时，首先监听信道；</li>
<li>如果信道空闲，则以p的概率发送数据，以1-p的概率推迟到下一个时隙；</li>
<li>如果信道繁忙，则<strong>继续</strong>监听信道，直到信道空闲；</li>
</ul>
</blockquote>
</blockquote>
</li>
</ul>
<p><strong>三种CSMA协议的对比：</strong></p>
<blockquote>
<table>
<thead>
<tr>
<th>信道状态</th>
<th>1-坚持</th>
<th>非坚持</th>
<th>p-坚持</th>
</tr>
</thead>
<tbody><tr>
<td>空闲</td>
<td>立即发送数据</td>
<td>立即发送数据</td>
<td>以p概率发送数据，以1-p的概率推迟到下一时隙</td>
</tr>
<tr>
<td>繁忙</td>
<td>继续坚持监听</td>
<td>放弃监听，等待一个随机时间再监听</td>
<td>继续监听</td>
</tr>
</tbody></table>
</blockquote>
</blockquote>
<h4 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA&#x2F;CD协议"></a>CSMA&#x2F;CD协议</h4><blockquote>
<p><strong>全称：载波监听多点接入&#x2F;碰撞检测协议</strong>，其中各部分为：</p>
<blockquote>
<ul>
<li><strong>CS：</strong>载波监听，即每一个站<strong>在发数据之前</strong>以及<strong>发数据时</strong>都检测一下总线上是否有其他计算机在发送数据。</li>
<li><strong>MA：</strong>多点接入，表示许多计算机以多点接入的方式连接在一根总线上。（总线型网络）</li>
<li><strong>CD：</strong>碰撞检测（冲突检测），“<strong>边发送边监听</strong>”，适配器边发送数据变检测信道上信号电压的变化情况。（半双工网络）</li>
</ul>
</blockquote>
<p><strong>基本思想：</strong>在发送前先监听，如果信道有信号则停止不发送，等到信道空闲以后再发送。在发送的时候继续监听，一检测到碰撞就停止发送。总结就是：<strong>先听后发，边听边发，冲突停止，随机重发</strong>。</p>
<p><strong>只先监听后发送也会发生碰撞的原因（CSMA的缺点）：</strong></p>
<blockquote>
<p>由于传输信道会有传播时延，所以有可能出现A发出信息还没到B端，B端监听发现没有信号，所以B端也发送信息，这时就会出现碰撞。</p>
</blockquote>
<p> <strong>传播时延对载波监听的影响：</strong></p>
<blockquote>
<img src="/picture/学习/计算机网络上的图/数据链路层/碰撞分析.png" alt="碰撞分析"  />

<p>通过图可知，这个传播信道中最长需要<strong>两倍端到端传播时延</strong>（$2\tau$）的时间才知道是否发生碰撞。（也称冲突窗口&#x2F;碰撞窗口&#x2F;争用期）</p>
<p>因此可得，<strong>当两倍端到端传播时延后没检测到碰撞，那么就知道没有发生碰撞</strong>。</p>
</blockquote>
<p><strong>确定重传时机：</strong></p>
<blockquote>
<p>利用<strong>截断二进制指数规避算法</strong>来确定：</p>
<blockquote>
<ul>
<li>确定基本退避（推迟）时间争用期$2\tau$</li>
<li>确定参数k（<strong>重传次数</strong>），但k不超过10，当重传次数不超过10时，k等于重传次数；当k超过10时就一直等于10。</li>
<li>从离散的整数集合$[0,1,…,2^k-1]$中随机取出一个数r，重传所需的退避时间就是<strong>r倍的基本退避时间，</strong>即$2r\tau$</li>
<li>当重传达到<strong>16次</strong>仍不成功，那说明网络太拥挤，抛弃此帧并向高层报告出错。</li>
</ul>
</blockquote>
</blockquote>
<p><strong>最小帧长问题：</strong></p>
<blockquote>
<p>A发送一个帧，如果在发生碰撞时，这个帧太小，就直接发送出去了。为了解决这个问题就需要定义最小帧长。</p>
<p>为此帧的<strong>传输时延</strong>至少要大于两倍的传播时延（$2\tau$），即$\frac{帧长（bit）}{数据传输速率} \ge 2\tau$，所以有，</p>
<p><strong>最小帧长</strong>&#x3D;<strong>总线传输时延</strong> * <strong>数据传输速率</strong> * 2</p>
</blockquote>
</blockquote>
<h4 id="CSMA-CA协议"><a href="#CSMA-CA协议" class="headerlink" title="CSMA&#x2F;CA协议"></a>CSMA&#x2F;CA协议</h4><blockquote>
<p>CSMA&#x2F;CD协议多用于<strong>总线型的有线</strong>局域网，而对于无线的局域网，CSMA&#x2F;CD协议并不容易实现。</p>
<p>因此对于无线的局域网，CSMA将碰撞检测改成了碰撞避免，所以就出现了CSMA&#x2F;CA。</p>
<p><strong>基本思路：</strong></p>
<blockquote>
<ul>
<li>发送数据前，先检测信道是否空闲。</li>
<li>空闲则发出<strong>RTS</strong>，RTS包括发送端的地址、接收端的地址、下一份数据将持续发送的时间等信息。</li>
<li>信道繁忙则等待。</li>
<li>接收端收到RTS后，将响应<strong>CTS</strong>。</li>
<li>发送端接收到CTS后，开始发送数据（同时<strong>预约信道</strong>，即发送方告知其他站点自己要占用多长时间）</li>
<li>接收端接收到数据后进行<strong>CRC检错</strong>，如无误则回复ACK。</li>
<li>发送端收到ACK就继续发送下一个数据帧，若没有则<strong>采用二进制指数退避算法（详看CSMA&#x2F;CD）来界定推迟重传的时间（也是有重传次数上限的）。</strong></li>
</ul>
</blockquote>
<p><strong>注意：</strong>接收方收到RTS后将不再接收除发送RTS的结点外的其他数据；其他结点没收到CTS也不会发送数据。</p>
<p><strong>与CSMA&#x2F;CD的区别：</strong></p>
<blockquote>
<ul>
<li><strong>传输介质不同：</strong>CSMA&#x2F;CD用于总线型以太网（有线），而CSMA&#x2F;CA用于无线局域网（无线）。</li>
<li><strong>载波检测方式不同：</strong>CSMA&#x2F;CD基于电压的起伏来检测，CSMA&#x2F;CA基于能量来检测。</li>
<li><strong>CSMA&#x2F;CD侧重于检测冲突，CSMA&#x2F;CA侧重于避免冲突</strong></li>
</ul>
</blockquote>
</blockquote>
<h3 id="轮询访问介质访问控制"><a href="#轮询访问介质访问控制" class="headerlink" title="轮询访问介质访问控制"></a>轮询访问介质访问控制</h3><blockquote>
<p><strong>轮询协议：</strong></p>
<blockquote>
<p><strong>思路：</strong>在网络中有一台主机作为控制主机，该主机<strong>按一定顺序询问网络中其他主机是否发送数据</strong>。只有<strong>收到询问帧</strong>的主机才能发送数据。</p>
</blockquote>
<p><strong>令牌传递协议：</strong></p>
<blockquote>
<p><strong>思路：</strong>一个令牌在各节点之间以某个<strong>固定次序</strong>进行交换（令牌是一组特殊的比特而组成的帧）。当环上的一个站想要传输帧的时候，必须等待令牌。只有收到令牌以后才可以启动发送帧。</p>
<p><strong>使用过程：</strong>当某一结点需要发送数据帧的时候，会先将令牌设置为占用的状态，然后再发送数据，这个时候其他结点在接收到数据帧后如果不是给自己的都转发出去，直到找到目的结点。目的结点收到数据帧后会复制一份，然后让原数据帧传回原节点。原节点收到循环一圈的数据帧后查看数据帧是否出错，如果出错就进行重传。</p>
<p><strong>注意：</strong>令牌传递协议中每个节点持有令牌的时间都是有限的，如果时间用完则需要将令牌交给下一个节点。 </p>
</blockquote>
<p><strong>特点：</strong>轮询访问介质访问控制<strong>适合用于负载较高的信道</strong>。</p>
</blockquote>
<h2 id="广域网："><a href="#广域网：" class="headerlink" title="广域网："></a>广域网：</h2><h3 id="广域网的定义"><a href="#广域网的定义" class="headerlink" title="广域网的定义"></a>广域网的定义</h3><blockquote>
<p><strong>定义：</strong>通常跨界很大的物理范围，覆盖范围从几十公里到几千公里。可以连接多个城市或国家，甚至横跨几个洲并能提供远距离通信，形成国际性的远程网络。</p>
<p><strong>特点：</strong>广域网的通信子网主要使用<strong>分组交换</strong>技术，该通信子网利用各类公用交换网将分布在<strong>不同地区的局域网或计算机系统</strong>互连起来，实现<strong>资源共享</strong>的目的。（因特网是世界范围内最大的广域网）</p>
<p><strong>广域网结构图：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%B9%BF%E5%9F%9F%E7%BD%91%E7%BB%93%E6%9E%84.png" alt="广域网结构"></p>
</blockquote>
<h3 id="PPP协议特点"><a href="#PPP协议特点" class="headerlink" title="PPP协议特点"></a>PPP协议特点</h3><blockquote>
<p><strong>特点：</strong>PPP协议又称<strong>点对点协议</strong>（Point-to-Point），是目前使用最广泛的链路层协议。在用户计算机和ISP进行通信时所使用的数据链路层协议。（<strong>PPP协议只支持全双工链路</strong>）</p>
<p><strong>PPP协议需满足的要求：</strong></p>
<blockquote>
<ul>
<li><strong>简单：</strong>对于链路层的帧，无需纠错（<strong>但需要检错</strong>），无须序号，无需流量控制。</li>
<li><strong>封装成帧：</strong>规定帧定界符。</li>
<li><strong>透明传输：</strong>数据部分出现与帧定界符一致的比特组合应如何处理：<strong>异步线路用字节填充，同步线路用比特填充</strong>。</li>
<li><strong>多类型网络层协议：</strong>在同一条物理链路上需要同时支持多种网络层协议。</li>
<li><strong>多类型链路：</strong>支持多种类型的链路。如，串行&#x2F;并行链路，同步&#x2F;异步的链路，电信号&#x2F;光信号的链路等等。</li>
<li><strong>差错检测：</strong>检测到错误的帧立即丢弃。</li>
<li><strong>检测连接状态：</strong>及时自动检测链路是否正常工作。</li>
<li><strong>最大传送单元：</strong>规定数据部分最大长度MTU。</li>
<li><strong>网络层地址协商：</strong>通过某种机制知道通信双方网络层的地址（如IP地址）。</li>
<li><strong>数据压缩协商：</strong>提供一种方法来协商使用一种数据压缩的算法。</li>
</ul>
</blockquote>
<p><strong>PPP协议无需满足的要求：</strong></p>
<blockquote>
<ul>
<li><strong>纠错</strong></li>
<li><strong>流量控制</strong></li>
<li><strong>序号：</strong>无需对帧进行编号</li>
<li><strong>无需支持多点线路：</strong>直须满足点对点的线路即可。</li>
</ul>
</blockquote>
</blockquote>
<h3 id="PPP协议的组成"><a href="#PPP协议的组成" class="headerlink" title="PPP协议的组成"></a>PPP协议的组成</h3><blockquote>
<ul>
<li><strong>将IP数据报封装到串行链路（同步串行&#x2F;异步串行）的方法</strong></li>
<li><strong>链路控制协议：</strong>建立并维护数据链路连接（实际上就是进行身份验证）</li>
<li><strong>网络控制协议NCP：</strong>PPP支持多种网络层的协议，每一种协议都需要相应的NCP来配置，为网络层协议建立与配置<strong>逻辑连接</strong>。</li>
</ul>
<p><strong>PPP协议的状态图：</strong></p>
<blockquote>
<img src="/picture/学习/计算机网络上的图/数据链路层/PPP协议的状态图.png" alt="PPP协议的状态图" style="zoom:60%;" />
</blockquote>
<p><strong>PPP协议的帧格式：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/PPP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" alt="PPP协议的帧格式"></p>
<p><strong>注释：</strong></p>
<ul>
<li><p>F部分为标志字段也是<strong>帧定界符</strong>。</p>
</li>
<li><p>A为地址字段，C为控制字段，但这两个到目前为止并无实际意义。</p>
</li>
<li><p>协议用来表示信息部分是什么（也可以理解为解释这一个帧是做什么的）。</p>
</li>
<li><p>FCS是CRC的帧检验序列。</p>
</li>
</ul>
<p><strong>补充：</strong>由PPP协议的帧格式可以看出，PPP协议面向的是<strong>字节传输</strong>的数据链路层协议。</p>
</blockquote>
</blockquote>
<h3 id="HDLC协议"><a href="#HDLC协议" class="headerlink" title="HDLC协议"></a>HDLC协议</h3><blockquote>
<p><strong>介绍：</strong>HDLC协议全称<strong>高级数据链路控制</strong>，该协议是ISO的面向<strong>比特</strong>的数据链路层协议（<strong>PPP协议是面向字节的</strong>）</p>
<p><strong>特点：</strong></p>
<blockquote>
<ul>
<li>数据报文使用<strong>0比特填充</strong>实现<strong>透明传输</strong></li>
<li><strong>全双工通信</strong></li>
<li>所有帧<strong>采用CRC检验</strong></li>
<li>传输控制功能与处理功能分离</li>
</ul>
</blockquote>
<p>HDLC适用于链路的两种基本配置：<strong>非平衡配置</strong>和<strong>平衡配置</strong></p>
<blockquote>
<ul>
<li><strong>非平衡配置</strong>：特点是<strong>由一个主站控制整个链路的工作</strong></li>
<li><strong>平衡配置</strong>：特点是两个站都是复合站，每个复合站都可以<strong>平等地发起数据传输</strong>，而不需要得到对方复合站的允许</li>
</ul>
</blockquote>
<p><strong>HDLC站的种类</strong>：</p>
<blockquote>
<ul>
<li><strong>主站：</strong>负责控制链路的操作，主站发出的帧称为<strong>命令帧</strong>。</li>
<li><strong>从站：</strong>受控于主站，按主站的命令进行操作，从站发出的帧称为<strong>响应帧</strong>。</li>
<li><strong>复合站：</strong>既具有主站的功能，又具有从站的功能，复合站可以发出命令帧和响应帧。</li>
</ul>
</blockquote>
<p><strong>数据操作方式：</strong></p>
<blockquote>
<ul>
<li><strong>正常响应方式：</strong>是一种非平衡结构操作方式，主站向从站传输数据，从站只有在得到主站的许可后才进行响应。</li>
<li><strong>异步平衡方式：</strong>是一种平衡结构操作方式，每个复合站都可以进行对另一个站的数据传输。</li>
<li><strong>异步响应方式：</strong>是一种非平衡结构操作方式，从站即使未受到主站的允许，也可以进行传输。</li>
</ul>
</blockquote>
<p><strong>HDLC帧：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/HDLC%E5%B8%A7%E5%8D%8F%E8%AE%AE.png" alt="HDLC帧协议"></p>
<ul>
<li><p><strong>标志F：</strong>为01111110，用于确认HDLC帧的开头与结束，利用0比特填充来进行透明传输。</p>
</li>
<li><p><strong>地址A：</strong>使用<strong>非平衡方式</strong>传输数据的时候，地址A写入的是<strong>从站</strong>的地址；在<strong>平衡方式</strong>传输数据时，地址A填入<strong>应答站</strong>的地址</p>
</li>
<li><p><strong>控制C：</strong>根据第1位，或第1，2位的取值，可以将HDLC帧分成三类：</p>
<blockquote>
<ul>
<li><strong>信息帧：</strong>第1位为0，用于<strong>传输数据信息</strong>，或使用捎带技术<strong>对数据进行确认</strong>。</li>
<li><strong>监督帧：</strong>第1、2位分别为1、0，用于<strong>流量控制</strong>和<strong>差错控制</strong>，执行<strong>对信息帧的确认，请求重发</strong>和<strong>请求暂停发送</strong>等功能。</li>
<li><strong>无编号帧：</strong>第1、2位都为1，用于对<strong>链路的建立、拆除</strong>等功能。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>与PPP协议帧的区别：</strong></p>
<blockquote>
<ul>
<li>PPP协议是面向字节的，HDLC协议是面向比特的。</li>
<li>PPP帧比HDLC帧多一个2字节的协议字段。</li>
<li>PPP协议不使用序号和确认机制，<strong>只确保无差错接收（CRC检验）</strong>，HDLC协议的信息帧使用编号和确认机制，能够提供可靠传输。</li>
</ul>
</blockquote>
</blockquote>
<h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><blockquote>
<p><strong>定义：</strong>局域网，简称LAN(Local Area Network)，指在<strong>某一区域内</strong>由多台计算机互联成的计算机组，使用<strong>广播信道</strong>。</p>
<p><strong>分类：</strong> <strong>以太网</strong>、令牌环网、FDDI网、ATM网和<strong>无线局域网</strong>。</p>
<p><strong>特点：</strong></p>
<blockquote>
<ul>
<li><strong>覆盖的地理范围较小。</strong></li>
<li>使用<strong>专门铺设的传输介质进行联网，数据传输速率高</strong>（10Mb&#x2F;s~10Gb&#x2F;s）。</li>
<li><strong>通信延迟时间短，误码率低，可靠性强。</strong></li>
<li>各站平等，<strong>共享传输信道</strong>。</li>
<li>多采用分布式控制和广播式通信，能进行<strong>广播</strong>和<strong>组播</strong>。</li>
</ul>
</blockquote>
<p><strong>决定局域网的主要要素：</strong> <strong>网络拓扑</strong>、<strong>传输介质</strong>和<strong>介质访问控制方法</strong>。</p>
</blockquote>
<h3 id="局域网的拓扑结构"><a href="#局域网的拓扑结构" class="headerlink" title="局域网的拓扑结构"></a>局域网的拓扑结构</h3><blockquote>
<ul>
<li><p><strong>星型拓扑：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%98%9F%E5%9E%8B%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84.png" alt="星型拓扑结构"></p>
<p><strong>特点：</strong>中心结点是控制中心，任意两个结点间的通信最多只需<strong>两步</strong>，传输速度快，且网络结构简单、建网容易、便于控制与管理。但可靠性低，网络共享能力差。</p>
</blockquote>
</li>
<li><p><strong>总线型拓扑：</strong></p>
<blockquote>
<p><img src="/../%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%80%BB%E7%BA%BF%E5%9E%8B%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84.png" alt="总线型拓扑结构"></p>
<p><strong>特点：</strong>网络可靠性高、网络结点间响应速度快、网络共享能力强、设备投入量少，接入简单。当某个节点出现问题，对整个网络系统影响小。</p>
</blockquote>
</li>
<li><p><strong>环型拓扑：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%8E%AF%E5%9E%8B%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84.png" alt="环型拓扑结构"></p>
<p><strong>特点：</strong>系统中通信设备和线路比较节省，有<strong>单点故障问题</strong>，即不便于扩充，系统响应时间长，中间某节点出现问题，对网络系统影响大。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="局域网介质访问控制方法"><a href="#局域网介质访问控制方法" class="headerlink" title="局域网介质访问控制方法"></a>局域网介质访问控制方法</h3><blockquote>
<ul>
<li><strong>CSMA&#x2F;CD：</strong>常用于<strong>总线型局域网</strong>，也用于树型网络。</li>
<li><strong>令牌总线：</strong>常用于<strong>总线型局域网</strong>。它把总线型网络中的各个工作站按一定顺序形成一个逻辑环。只有令牌持有者才能控制总线，才能发送信息。</li>
<li><strong>令牌环：</strong>用于环型局域网。</li>
</ul>
</blockquote>
<h3 id="局域网中数据链路的两个子层"><a href="#局域网中数据链路的两个子层" class="headerlink" title="局域网中数据链路的两个子层"></a>局域网中数据链路的两个子层</h3><blockquote>
<p>IEEE802委员会把局域网数据链路层拆分为两个子层：<strong>逻辑链路控制LLC</strong>子层和<strong>媒体接入控制MAC</strong>子层。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%AD%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%AD%90%E5%B1%82.png" alt="局域网中的两个子层"></p>
<ul>
<li><p><strong>逻辑链路控制LLC：</strong></p>
<blockquote>
<p>负责识别网络层协议，然后对它们进行封装。LLC报头告诉数据链路层一旦帧被接收到，应该对数据包做什么处理。</p>
</blockquote>
</li>
<li><p><strong>媒体接入控制MAC：</strong></p>
<blockquote>
<p>主要功能包括数据帧的封装&#x2F;拆卸，帧的寻址和识别，帧的接收和发送，链路的管理，帧的差错控制等。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><blockquote>
<p>以太网是当今现有局域网采用最通用的通信协议标准，是一种<strong>基带总线局域网规范</strong>。以太网使用<strong>CSMA&#x2F;CD技术</strong>。</p>
<p><strong>以太网两个标准：</strong></p>
<blockquote>
<ul>
<li><strong>DIX Ethernet V2：</strong>第一个局域网产品（以太网）规约。</li>
<li><strong>IEEE 802.3：</strong>第一个IEEE的以太网标准。</li>
</ul>
</blockquote>
<p><strong>以太网提供无连接、不可靠的服务：</strong></p>
<blockquote>
<ul>
<li><strong>无连接：</strong>发送方与接收方之间无“握手过程”。</li>
<li><strong>不可靠：</strong>不对发送方的数据帧编号，接收方不向发送方进行确认，差错帧直接丢弃不进行纠错。</li>
</ul>
</blockquote>
<p><strong>以太网的拓扑结构：</strong>逻辑上总线型，物理上星型。</p>
<p><strong>10BASE-T 以太网：</strong></p>
<blockquote>
<p><strong>定义：</strong>是传输<strong>基带信号</strong>的双绞线以太网，T表示采用双绞线，现10BASE-T采用<strong>无屏蔽双绞线</strong>，<strong>传输速率是10Mb&#x2F;s</strong>。</p>
<p><strong>特点：</strong></p>
<blockquote>
<ul>
<li><strong>物理上采用星型拓扑，逻辑上为总线型</strong>，每段双绞线最长为<strong>100m</strong>。</li>
<li>采用<strong>曼彻斯特编码</strong>。</li>
<li>采用<strong>CSMA&#x2F;CD</strong>介质访问控制。</li>
</ul>
</blockquote>
</blockquote>
<p><strong>适配器与MAC地址</strong></p>
<blockquote>
<p><strong>适配器：</strong>计算机与外界局域网的连接需要<strong>通信适配器</strong>。</p>
<img src="/picture/学习/计算机网络上的图/数据链路层/网卡.png" alt="网卡" style="zoom:60%;" />

<p><strong>特点：</strong>适配器上有独立的处理器和存储器（包括RAM和ROM）。在ROM上有计算机硬件地址<strong>MAC地址</strong>。</p>
<p>在局域网中，硬件地址又称<strong>物理地址</strong>，或<strong>MAC地址</strong>。</p>
<p><strong>MAC地址：</strong>每个适配器有一个<strong>全球唯一</strong>的48位二进制地址，其中前24位代表厂家（由IEEE规定），后24位厂家自己指定。常用6个十六进制数表示，如：02-60-8c-e4-b1-21</p>
</blockquote>
<p><strong>以太网MAC帧</strong></p>
<blockquote>
<p>最常用的MAC帧是以太网V2的格式（使用以太网第一个标准）。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/MAC%E5%B8%A7.png" alt="MAC帧"></p>
<ul>
<li><p><strong>目的地址：</strong>包括<strong>单播地址（单播帧）</strong>即在本局域网中进行一对一通信站点的MAC地址、<strong>广播地址（广播帧）</strong>即发送给本局域网上所有站点且地址为全1、<strong>多播地址（多播帧）</strong>即发送给本局域网中多个站点的地址。</p>
</li>
<li><p><strong>源地址：</strong>发送端的MAC地址。</p>
</li>
<li><p><strong>类型：</strong>表示网络层所使用的协议。</p>
</li>
<li><p><strong>数据：</strong>数据部分，以太网最小帧的长度是64字节，因此这里的数据最小值为46字节。</p>
</li>
<li><p><strong>FCS：</strong>CRC验证的冗余码。</p>
</li>
</ul>
<p><strong>补充：</strong>MAC帧没有帧结束定界符是因为曼彻斯特编码特点是一个时钟周期中有两种电信号，如果帧发送结束后，一个时钟周期内只有一种电信号，因此没有必要加上帧的结束定界符。</p>
<p><strong>与IEEE 802.3标准下的MAC帧的区别：</strong></p>
<blockquote>
<ul>
<li>IEEE 802.3标准下的MAC帧中第三个字段是<strong>长度&#x2F;类型</strong>。</li>
<li>当长度&#x2F;类型字段值小于0x 0600时，数据字段必须装入LLC子层。</li>
</ul>
</blockquote>
</blockquote>
<p><strong>高速以太网</strong></p>
<blockquote>
<p><strong>定义：</strong>速率大于100Mb&#x2F;s的以太网称为高速以太网。</p>
<p><strong>种类：</strong></p>
<ul>
<li><strong>100BASE-T以太网：</strong>在<strong>双绞线</strong>上传输<strong>100Mb&#x2F;s基带信号</strong>的<strong>星型</strong>拓扑以太网，使用<strong>CSMA&#x2F;CD协议</strong>，支持<strong>全双工</strong>和<strong>半双工</strong>。</li>
<li><strong>吉比特以太网：</strong>在<strong>光纤</strong>或<strong>双绞线</strong>上传输<strong>1Gb&#x2F;s信号</strong>。支持<strong>全双工</strong>和<strong>半双工</strong>。</li>
<li><strong>10吉比特以太网：</strong>在<strong>光纤</strong>上传输<strong>10Gb&#x2F;s信号</strong>。只支持<strong>全双工</strong>。</li>
</ul>
</blockquote>
</blockquote>
<h3 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h3><blockquote>
<p><strong>IEEE 802.11标准：</strong>是<strong>无线局域网</strong>通用的标准，它有多个衍生标准都是对无线局域网的规定。</p>
<p><strong>MAC帧头格式：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/MAC%E5%B8%A7%E5%A4%B4%E6%A0%BC%E5%BC%8F.png" alt="MAC帧头格式"></p>
<ul>
<li><strong>DA：</strong>实际通信设备<strong>接收端</strong>的MAC地址。</li>
<li><strong>SA：</strong>实际通信设备<strong>发送端</strong>的MAC地址。</li>
<li><strong>RA：</strong>通信过程中<strong>离接收端最近的基站</strong>的MAC地址。</li>
<li><strong>TA：</strong>通信过程中<strong>离发送端最近的基站</strong>的MAC地址。**</li>
</ul>
</blockquote>
<p><strong>其他的帧头格式：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%85%B6%E4%BB%96MAC%E5%B8%A7%E5%A4%B4%E6%A0%BC%E5%BC%8F.png" alt="其他MAC帧头格式"></p>
<p><strong>注意：</strong>图中AP代表基站。BSSID表示基站的MAC地址。</p>
</blockquote>
<p><strong>无线局域网的类型：</strong></p>
<ul>
<li><p><strong>有固定基础设施无线局域网</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%9C%89%E5%9B%BA%E5%AE%9A%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91.png" alt="有固定基础设施无线局域网"></p>
<p><strong>漫游：</strong>指一个设备可以联系到另一个基站内的设备（长途电话）。</p>
</blockquote>
</li>
<li><p><strong>无固定基础设施无线局域网的自组织网络</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%97%A0%E5%9B%BA%E5%AE%9A%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9A%84%E8%87%AA%E7%BB%84%E7%BB%87%E7%BD%91%E7%BB%9C.png" alt="无固定基础设施无线局域网的自组织网络"></p>
<p>该网络中只有主机，没有转发设备，也没有集线器，每一台主机都是平等的。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="拓展的以太网"><a href="#拓展的以太网" class="headerlink" title="拓展的以太网"></a>拓展的以太网</h2><h3 id="物理层拓展以太网"><a href="#物理层拓展以太网" class="headerlink" title="物理层拓展以太网"></a>物理层拓展以太网</h3><blockquote>
<p>已知传统的以太网的覆盖距离都非常短，否则主机之间的通信信号会衰弱到CSMA&#x2F;CD协议都无法识别。以此提出了对以太网进行拓展的想法。</p>
<ul>
<li><p>第一种想法就是利用光纤对以太网进行拓展。</p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%8B%93%E5%B1%95%E4%BB%A5%E5%A4%AA%E7%BD%911.png" alt="拓展以太网1"></p>
<p>其中光纤调制器就是将光信号和电信号进行相互转换。</p>
</blockquote>
</li>
<li><p>第二种就是使用多个集线器对以太网进行连接。</p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%8B%93%E5%B1%95%E4%BB%A5%E5%A4%AA%E7%BD%912.png" alt="拓展以太网2"><br>不过也会导致通信效率降低，如在主干集线器中发生冲突的概率也会增大，当一台主机在发送数据时，其他主机如果也发送就会导致冲突的发生。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="链路层拓展以太网"><a href="#链路层拓展以太网" class="headerlink" title="链路层拓展以太网"></a>链路层拓展以太网</h3><blockquote>
<p><strong>网桥：</strong>对收到的帧根据其MAC的目的地址进行<strong>转发</strong>和<strong>过滤</strong>。当网桥收到一个帧时，并不会向所有接口转发，而是根据转发表确定该帧转发到哪一个接口，或者把它丢弃（即过滤）。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BD%91%E6%A1%A5.png" alt="网桥"><br><strong>网桥的优点：</strong></p>
<blockquote>
<ul>
<li>过滤通信量，增发吞吐量</li>
<li>扩大了物理传输范围。</li>
<li>提高了整体网络的可靠性。</li>
<li>可互连不同物理层、不同MAC子层和不同速率的以太网。</li>
</ul>
</blockquote>
<p><strong>网桥分类：</strong></p>
<blockquote>
<ul>
<li><strong>透明网桥：</strong>指以太网上的站点并不知道所发送的帧要经过哪几个网桥，是一种即插即用的设备。（网桥中的转发表一开始是空的，需要通过自学习的方式逐步丰富转发表）</li>
<li><strong>源路由网桥：</strong>在发送帧时，把详细的最佳路由信息（路由最少&#x2F;时间最短）放到帧的首部。</li>
</ul>
</blockquote>
<p><strong>交换机（多接口网桥）：</strong></p>
<blockquote>
<p>网桥的升级版，网桥一般只有少数的转发接口。交换机通常有十几个甚至更多的接口。</p>
<p>交换机相较于网桥来说能使多对主机同时通信，相互通信的主机都是<strong>独占传输媒体，无碰撞地传输数据</strong>。</p>
</blockquote>
<p><strong>交换机原理：</strong>检测从以太端口来的数据帧的源和目的地址的MAC地址，然后与系统内部的动态查找表进行比较，若数据帧的源MAC地址不在查找表中，则将该地址加入查找表，并将数据帧发送给相应的目的端口。</p>
<p><strong>交换机的种类：</strong></p>
<blockquote>
<ul>
<li><strong>直通式交换机：</strong>查看完目的地址就立刻转发。特点是延迟小，可靠性低。</li>
<li><strong>存储转发式交换机：</strong>将帧放入高速缓存，检测是否正确。特点式可靠高，但延迟也高。</li>
</ul>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>基础学科</tag>
      </tags>
  </entry>
  <entry>
    <title>支持向量机（SVM）</title>
    <url>/2021/10/10/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%EF%BC%88SVM%EF%BC%89/</url>
    <content><![CDATA[<h4 id="SVM的介绍"><a href="#SVM的介绍" class="headerlink" title="SVM的介绍"></a><b>SVM的介绍</b></h4><blockquote>
<ul>
<li>SVM全程为Support Vector Machine,中文名为支持向量机，是一种监督学习的算法。</li>
<li>在机器学习中，SVM算法说白了就是通过训练样本与算法划出一些可以分类的线，然后找到间隔最大的一条线。</li>
<li>SVM算法的最大优点是可以应用在训练样本点较少的训练集上。<br><b>支持向量机的结构图：</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/SVM/SVM%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="SVM的结构" title="结构图"><br><b>支持向量机由简至繁可以分为：</b><blockquote>
<ul>
<li><b>线性可分支持向量机</b>（类似与感知机，数据严格线性可分，其中的间隔叫做<b>硬间隔</b>）</li>
<li><b>线性支持向量机</b>（条件放宽了，除去一些误差点，大部分数据都是线性可分的，其中的间隔叫做<b>软间隔</b>）</li>
<li><b>线性不可分支持向量机</b>（这个需要用到核技巧，后面会细讲）</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="线性可分支持向量机"><a href="#线性可分支持向量机" class="headerlink" title="线性可分支持向量机"></a><b>线性可分支持向量机</b></h4><blockquote>
<p>首先先通过图来直观感受<b>线性可分支持向量机</b>。</p>
<blockquote>
<p> <img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/SVM/%E7%BA%BF%E6%80%A7SVM.jpg" alt="线性SVM" title="线性SVM"><br><b>注释：</b></p>
<ul>
<li>SVM就是要找中间这样的一条线（超平面）来将样本点分开。</li>
<li>中间这条线（或平面、超平面）上下移动时，接触到的第一个样本点称为<b>支持向量</b>。</li>
<li>两个支持向量之间的距离d称为<b>间隔</b>。硬间隔软间隔就是这个东西。</li>
<li>SVM的最终目的就是要求d最大时的参数值。</li>
</ul>
</blockquote>
<p>假设一个特征空间上的训练数据集（为线性可分的）</p>
<blockquote>
<p>$$T &#x3D; (x_1,y_1),(x_2,y_2),…,(x_n,y_n)$$<br>其中$y_i \in (+1,-1)$，$x_i$为第i个特征向量，称为示例。<br>$y_i$为$x_i$的类标记，当$y_i&#x3D;+1$时，$x_i$为正例，当$y_i&#x3D;-1$时，$x_i$为反例。<br>$(x_i,y_i)$称为样本点。<br>学习的目标就是在特征空间里找到一个分离超平面，能够将示例分成两类，并且使得间距达到最大。</p>
</blockquote>
<p><b>定义：</b></p>
<blockquote>
<p>给定线性可分的数据集，通过最大化间距学习得到的超平面为<br>$$w^{*T} x+b^*&#x3D;0$$<br>那么相应的分类决策函数为：<br>$$f(x)&#x3D;sign(w^{*T} x+b^*) \quad \quad f(x) \in (-1,1)$$</p>
</blockquote>
</blockquote>
<h5 id="函数距离与几何距离"><a href="#函数距离与几何距离" class="headerlink" title="函数距离与几何距离"></a><b>函数距离与几何距离</b></h5><blockquote>
<p>一般来说,当分离超平面$w^{*T}x+b^*&#x3D;0$确定后，<br>$|wx_i+b|$能相对地确定该点到超平面的远近<br> 而$y_i(wx_i+b)$的值可以确定分类的确定性以及可信度。</p>
<ul>
<li><p><b>函数距离（函数间隔）</b></p>
<blockquote>
<p>$$\gamma_i&#x3D;y_i(w^T x_i+b)$$</p>
<p>那么我们取上述的最小值作为函数距离，即</p>
<p>$$\gamma &#x3D; min_{i&#x3D;1…m}y_i(w^T x_i+b)$$</p>
<p><b>示意图：</b><br> <img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/SVM/%E5%87%BD%E6%95%B0%E8%B7%9D%E7%A6%BB.png" alt="函数距离" title="函数距离"></p>
<p>其中d就是点到超平面的函数距离，其中原点就表示为超平面。而这个距离越大就代表着点离超平面的距离越远，分类的可信度就越大（支持向量的函数距离是他所属类中最小的）。</p>
<p>另外，分类正确的点的函数距离一定是一个正数（这个可以代具体例子进行校验）。</p>
<p><b>补充：</b>在函数距离中，$w$和$b$等比例放大或缩小，如$w \to 2w,b \to 2b$这些变化只会使得函数距离发生等比例扩大或缩小，并不会对超平面$w^{<em>T}x+b^</em>&#x3D;0$造成影响。</p>
<p>仅仅只知道函数距离并不足以让我们描述间距的大小，所以我们还需要引入几何距离。</p>
</blockquote>
</li>
<li><p><b>几何距离（几何间隔）</b></p>
<blockquote>
<p>在函数距离中，我们知道如果将$w$和$b$等比例放大或缩小，都不会对超平面造成影响。那么我们令$w$和$b$同时除以$||w||$，那么可以得到$\frac{w^Tx_i}{||w||}+\frac{b}{||w||}$，那么我们就得到了几何距离定义的雏形了。</p>
<p>因此我们可以将几何距离定义为：<br>$$d_i&#x3D;\frac{y_i(w^Tx_i+b)}{||w||}\quad \quad y_i \in (-1,1)$$<br>那么我们取上述的最小值作为几何距离，即<br>$$d &#x3D; min_{i&#x3D;1…m}\frac{y_i(w^Tx_i+b)}{||w||}\quad \quad y_i \in (-1,1)$$<br><b>示意图：</b><br> <img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/SVM/%E5%87%A0%E4%BD%95%E8%B7%9D%E7%A6%BB.png" alt="几何距离" title="几何距离"> </p>
<p><b>补充:</b></p>
<ul>
<li><p>当然我们也可以通过点到线的距离公式$d&#x3D;\frac{|w_1x+w_2y+b|}{\sqrt{w_1^2+w_2^2}}$来理解几何距离。</p>
</li>
<li><p>几何间隔与函数间隔有以下关系：</p>
<blockquote>
<p>$$d_i &#x3D; \frac{\gamma_i}{||w||}$$</p>
<p>$$d &#x3D; \frac{\gamma}{||w||}$$</p>
<p>因此如果$w$和$b$成比例地放大或缩小，改变的只有函数间隔，几何间隔并不受影响。</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><b>间隔最大化</b> </p>
<blockquote>
<ul>
<li>支持向量机的基本学习思想是求解出一个可以正确划分训练数据集<b>并且几何间隔最大</b>的超平面。</li>
<li>对于线性可分的数据集来说，能正确划分数据集的超平面有无数个（类似于感知机），而几何间隔最大的超平面只有一个，因此这是一个求最优化的问题。</li>
<li>对于间隔最大化的通俗解释是：几何间隔最大的超平面意味着对分类确信度普遍较高，并且对于预测的泛化能力也比较强。对于较难分类的点（支持向量）也有较好的分类确信度。</li>
</ul>
</blockquote>
</li>
<li><p><b>最大间隔分离超平面</b></p>
<blockquote>
<ul>
<li>我们的目的是找到一个几何间隔最大的分离超平面，那么我们可以定义成：<br>$$max_{w,b}\ d$$</li>
</ul>
<p>$$s.t. \quad y_i(\frac{w^Tx_i+b}{||w||})\ge d_i \quad i&#x3D;1,2,…,N$$</p>
<ul>
<li>根据几何间隔与函数间隔之间的关系，可以将上式转化成函数间隔形式：<br>$$max_{w,b}\ \frac{\gamma}{||w||}$$</li>
</ul>
<p>$$s.t. \quad y_i(w^Tx_i+b)\ge \gamma_i \quad i&#x3D;1,2,…,N$$</p>
<ul>
<li><p>实际上，我们已知函数间隔$\gamma_i$并不影响几何间隔，那么求解$max_{w,b}\ \frac{\gamma}{||w||}$可以转化成求解$max_{w,b}\ \frac{1}{||w||}$，也就等价于求解$min_{w,b}\ ||w||$</p>
</li>
<li><p>甚至$\gamma_i$可以进行伸缩变化成1，那么约束条件$y_i(w^Tx_i+b)\ge \gamma_i$可以转化为$y_i(w^Tx_i+b)\ge 1$</p>
</li>
<li><p>所以这个最大间隔优化问题可以转化为：<br>$$min_{w,b}\ \frac{1}{2}||w||^2$$</p>
</li>
</ul>
<p>$$s.t. \quad y_i(w^Tx_i+b)-1 \ge 0 \quad i&#x3D;1,2,…,N$$</p>
<p><b>补充：</b>$min_{w,b}\ \frac{1}{2}||w||^2$与$min_{w,b}\ ||w||$的解是一样的，因为式子里要求的是最小值下的$w$和$b$，而不是求它们的最小值。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h5 id="学习的对偶算法"><a href="#学习的对偶算法" class="headerlink" title="学习的对偶算法"></a><b>学习的对偶算法</b></h5><blockquote>
<ul>
<li><b>注意：</b>详细的数学推导、解释见这篇文章：<a href="/2021/10/21/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E5%AD%90%E6%B3%95/index.html">拉格朗日乘子法</a></li>
</ul>
<p>为了求解线性可分支持向量机的最优化问题，我们最终得到了形如上式的一个带约束条件的最优化问题。</p>
<p>为了求解出最优解，我们将它作为原始最优化问题，应用拉格朗日对偶性，通过对偶问题得到原始问题的最优解。</p>
<p>这样做的优点：</p>
<blockquote>
<ul>
<li>对偶问题往往更容易求解。</li>
<li>容易引入核函数，从而推广到非线性可分的支持向量机。</li>
</ul>
</blockquote>
<ul>
<li><p>首先将原始问题改造成标准形式：</p>
<blockquote>
<p>$$min_{w,b}\ \frac{1}{2}||w||^2$$</p>
<p>$$s.t. \quad 1 - y_i(w^Tx_i+b) \le 0 \quad i&#x3D;1,2,…,N$$</p>
</blockquote>
</li>
<li><p>然后构建拉格朗日函数，即对每一个不等式约束引进一个拉格朗日乘子$\alpha_i \ge 0, \ \ i&#x3D;1,2,…,N$，定义的拉格朗日函数为：</p>
<blockquote>
<p>$$L(w,b,\alpha)&#x3D;\frac{1}{2}||w||^2 - \sum^N_{i&#x3D;1} \alpha_i y_i(w x_i +b)+\sum^N_{i&#x3D;1} \alpha_i$$<br>其中，$\alpha &#x3D; (\alpha_1,\alpha_2,…,\alpha_N)^T$为拉格朗日乘子向量。</p>
</blockquote>
</li>
<li><p>根据此拉格朗日函数我们可得原问题的对偶问题为：</p>
<blockquote>
<p>$$max_{\alpha} \ min_{w,b} \ L(w,b,\alpha)$$</p>
</blockquote>
</li>
</ul>
<p>根据上面对偶问题的公式，我们需要先对$w,b$求$L(w,b,\alpha)$的最小值，再对$\alpha$求L(w,b,\alpha)$的最大值。</p>
<ul>
<li><p>求$min_{w,b} \ L(w,b,\alpha)$</p>
<blockquote>
<ul>
<li>将拉格朗日函数$L(w,b,\alpha)$分别对$w,b$求偏导，并令其等于0。<blockquote>
<p>$$\nabla_w \ L(w,b,\alpha) &#x3D; w - \sum_{i&#x3D;1}^N \alpha_i y_i x_i &#x3D; 0$$</p>
<p>（其中$\frac{1}{2}||w||^2$的求导思路是，将其范数形式写出来，然后对每一项的$w_i$求偏导，最终得到一个向量。）</p>
<p>$$\nabla_b \ L(w,b,\alpha) &#x3D; -\sum^N_{i&#x3D;1} \alpha_i y_i&#x3D;0$$</p>
</blockquote>
</li>
</ul>
<p>得到，</p>
<blockquote>
<p>$$\sum_{i&#x3D;1}^N \alpha_i y_i x_i &#x3D; w$$</p>
<p>$$\sum^N_{i&#x3D;1} \alpha_i y_i&#x3D;0$$</p>
</blockquote>
<ul>
<li>将上面得到的结果代会拉格朗日函数$L(w,b,\alpha)$中得，<blockquote>
<p>$$L(w,b,\alpha) &#x3D; \frac{1}{2}\sum_{i&#x3D;1}^N \sum_{j&#x3D;1}^N \alpha_i \alpha_j y_i y_j(x_i x_j) - \sum^N_{i&#x3D;1} \alpha_i y_i((\sum_{j&#x3D;1}^N \alpha_j y_j x_j)x_i +b)+ \sum_{i&#x3D;1}^N \alpha_i$$</p>
<ul>
<li><p>化简亿下得到：<br>$$L(w,b,\alpha) &#x3D; \frac{1}{2}\sum_{i&#x3D;1}^N \sum_{j&#x3D;1}^N \alpha_i \alpha_j y_i y_j(x_i x_j) - \sum_{i&#x3D;1}^N \sum_{j&#x3D;1}^N \alpha_i \alpha_j y_i y_j(x_i x_j) -\sum_{i&#x3D;1}^N \alpha_iy_ib + \sum_{i&#x3D;1}^N \alpha_i$$</p>
</li>
<li><p>其中$\sum^N_{i&#x3D;1} \alpha_i y_i&#x3D;0$，所以$\sum_{i&#x3D;1}^N \alpha_iy_ib&#x3D;0$，最终得到：<br>$$L(w,b,\alpha) &#x3D; -\frac{1}{2}\sum_{i&#x3D;1}^N \sum_{j&#x3D;1}^N \alpha_i \alpha_j y_i y_j(x_i x_j) + \sum_{i&#x3D;1}^N \alpha_i$$</p>
</li>
</ul>
<p><b>补充：</b>在这补充一下为什么有$\sum^N_{i&#x3D;1} \alpha_i y_i&#x3D;0$，所以$\sum_{i&#x3D;1}^N \alpha_iy_ib&#x3D;0$，而$\sum_{j&#x3D;1}^N \alpha_j y_j x_j \neq 0$。<br>首先，$\sum^N_{i&#x3D;1} \alpha_i y_i&#x3D;0$指的是它的总和为0，但是每一项不一定为0，所以如果每一项都乘以一个不同得数，那么最终的求和结果有极大概率会改变，即$\sum_{j&#x3D;1}^N \alpha_j y_j x_j \neq 0$。<br>但是如果它每一项都乘以一个相同的数，那么它最终的结果还是0，即$\sum_{i&#x3D;1}^N \alpha_iy_ib&#x3D;0$，也可以理解为$b\sum_{i&#x3D;1}^N \alpha_iy_i&#x3D;0$。</p>
</blockquote>
</li>
</ul>
<p>最终我们求出了$min_{w,b} \ L(w,b,\alpha) &#x3D; -\frac{1}{2}\sum_{i&#x3D;1}^N \sum_{j&#x3D;1}^N \alpha_i \alpha_j y_i y_j(x_i x_j) + \sum_{i&#x3D;1}^N \alpha_i$</p>
</blockquote>
</li>
<li><p>求$min_{w,b}L(w,b,\alpha)$对$\alpha$的极大，即</p>
<blockquote>
<p>$$max_{\alpha} \ \  -\frac{1}{2}\sum_{i&#x3D;1}^N \sum_{j&#x3D;1}^N \alpha_i \alpha_j y_i y_j(x_i x_j) + \sum_{i&#x3D;1}^N \alpha_i$$</p>
<p>$$s.t. \quad \sum^N_{i&#x3D;1} \alpha_iy_i&#x3D;0$$</p>
<p>$$\quad \quad \alpha_i \ge 0 \quad i&#x3D;1,2,…,N$$</p>
<ul>
<li>将最大化问题转化成求最小化问题得，<br>$$min_{\alpha} \ \  \frac{1}{2}\sum_{i&#x3D;1}^N \sum_{j&#x3D;1}^N \alpha_i \alpha_j y_i y_j(x_i x_j) - \sum_{i&#x3D;1}^N \alpha_i$$</li>
</ul>
<p>$$s.t. \quad \sum^N_{i&#x3D;1} \alpha_iy_i&#x3D;0$$</p>
<p>$$\quad \quad \alpha_i \ge 0 \quad i&#x3D;1,2,…,N$$</p>
<ul>
<li>考虑原始最优化问题：<br>$$min_{w,b}\ \frac{1}{2}||w||^2$$</li>
</ul>
<p>$$s.t. \quad 1 - y_i(w^Tx_i+b) \le 0 \quad i&#x3D;1,2,…,N$$</p>
<ul>
<li>满足对偶问题中<b>定理一</b>：<blockquote>
<p>若$f(x)$和$c_i(x)$是凸函数，$h_j(x)$是仿射函数(这没$h_j(x)$)，$c_i(x)$是严格可行的，即存在x对于所有i都有$c_i(x)&lt;0$,那么存在$x^∗,α^∗,β^∗$，$x^∗$是原始问题的解，$\alpha^∗,\beta^∗$是对偶问题的解，<b>那么求解原始问题可以转化成求解对偶问题的解了</b>。</p>
</blockquote>
</li>
</ul>
<p><b>补充：</b>为什么$c_i(x)$是严格可行的？因为满足条件$1 - y_i(w^Tx_i+b) &#x3D; 0 \quad i&#x3D;1,2,…,N$的只有支持向量，其他计算出来的结果一定小于0的，所以说存在x使得$c_i(x)$严格可行。</p>
<ul>
<li>设$\alpha^*&#x3D;(\alpha_1^*,\alpha_2^*,\alpha_3^*,…,\alpha_N^*)^T$是对偶最优化问题的解，那么可以由此求得原始问题对$(w,b)$的解$w^*,b^*$,有以下定理：<blockquote>
<p>设$\alpha^*&#x3D;(\alpha_1^*,\alpha_2^*,\alpha_3^*,…,\alpha_N^*)^T$是对偶最优化问题的解，则存在下标j，使得$\alpha_j^* &gt; 0$，使得$w^*,b^*$满足以下式子：<br>$$w^* &#x3D;\sum_{i&#x3D;1}^N \alpha_i^* y_i x_i$$</p>
<p>$$b^* &#x3D; y_j - \sum_{i&#x3D;1}^N \alpha_i^* y_i (x_i x_j)$$</p>
</blockquote>
</li>
</ul>
<p><b>补充：</b>以上式子可以根据KKT条件进行证明。</p>
</blockquote>
</li>
</ul>
<p>因此分离超平面可以写成：</p>
<blockquote>
<p>$$\sum^N_{i&#x3D;1}\alpha^*_i y_i(x x_i)+b^*&#x3D;0$$</p>
</blockquote>
<p>分类决策函数可以写成：</p>
<blockquote>
<p>$$f(x)&#x3D;sign(\sum^N_{i&#x3D;1}\alpha^*_i y_i(x x_i)+b^*)$$</p>
</blockquote>
<p><b>补充：</b></p>
<blockquote>
<ul>
<li>由上式可知，分类决策函数只依赖于输入x和训练样本输入的内积。</li>
<li>而且$\alpha$的维度与训练集的个数相关，训练集有多少个，那么$\alpha$就有多少维。</li>
</ul>
</blockquote>
</blockquote>
<h5 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a><b>算法描述</b></h5><blockquote>
<ul>
<li><b>线性可分支持向量机学习算法：</b><blockquote>
<p><b>输入：</b>线性可分训练集$T&#x3D;[(x_1,y_1),(x_2,y_2),…,(x_N,y_N)]$，其中$x_i \in R^n,y_i \in (-1,1), \quad i&#x3D;1,2,…,N$<br><b>输出：</b>分离超平面和分类决策函数。</p>
<ul>
<li><p>构造并求解约束最优化问题</p>
<blockquote>
<p>$$min_{\alpha} \ \  \frac{1}{2}\sum_{i&#x3D;1}^N \sum_{j&#x3D;1}^N \alpha_i \alpha_j y_i y_j(x_i x_j) - \sum_{i&#x3D;1}^N \alpha_i$$</p>
<p>$$s.t. \quad \sum^N_{i&#x3D;1} \alpha_iy_i&#x3D;0$$</p>
<p>$$\quad \quad \alpha_i \ge 0 \quad i&#x3D;1,2,…,N$$</p>
<p>利用SMO算法求出最优解$\alpha^*&#x3D;(\alpha_1^*,\alpha_2^*,\alpha_3^*,…,\alpha_N^*)^T$。</p>
</blockquote>
</li>
<li><p>计算</p>
<blockquote>
<p>$$w^* &#x3D; \sum^N_{i&#x3D;1}\alpha^*_i y_i x_i$$ </p>
<p>选择$\alpha^*$的一个正分量$\alpha_j^* &gt; 0$，计算<br>$$b^* &#x3D; y_j - \sum_{i&#x3D;1}^N \alpha_i^* y_i (x_i x_j)$$</p>
<p><b>补充：</b>计算$b^*$时的$(x_j,y_j)$是一个随机的一个支持向量。</p>
</blockquote>
</li>
<li><p>求得分离超平面</p>
<blockquote>
<p>$$\sum^N_{i&#x3D;1}\alpha_i^* y_i(x x_i)+b^*&#x3D;0$$<br>分类决策函数：<br>$$f(x)&#x3D;sign(\sum^N_{i&#x3D;1}\alpha_i^* y_i(x x_i)+b^*)$$</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h5 id="支持向量"><a href="#支持向量" class="headerlink" title="支持向量"></a><b>支持向量</b></h5><blockquote>
<p>由</p>
<blockquote>
<p>$$w^* &#x3D; \sum^N_{i&#x3D;1}\alpha^*_i y_i x_i$$ </p>
<p>$$b^* &#x3D; y_j - \sum_{i&#x3D;1}^N \alpha_i^* y_i (x_i x_j)$$</p>
</blockquote>
<p>可知，$w^*$和$b^*$只依赖于训练数据中对应$\alpha_i^* &gt; 0$的样本点（在SMO算法中我们可以算出只有少数的一些点的$\alpha_i^*$大于0），而其他样本点对$w^*$和$b^*$基本没影响。<br>我们将训练集中对应$\alpha_i^* &gt; 0$的样本点称之为<b>支持向量</b>。<br><b>定义：</b></p>
<blockquote>
<p>考虑原始最优化问题及对偶最优化问题，将训练数据集中对应$\alpha_i^* &gt; 0$的样本点$(x_i,y_i)$的实例$x_i \in R^n$称为<b>支持向量</b>。</p>
</blockquote>
<p><b>补充：</b><br>根据该定义，支持向量一定在间隔边界上。由KKT互补条件：</p>
<blockquote>
<p>$$\alpha_i^*(y_i(w^* x_i +b^*)-1)&#x3D;0, \quad i&#x3D;1,2,…,N$$</p>
<p>对应于$\alpha_i^* &gt; 0$的实例$x_i$，有</p>
<p>$$y_i(w^* x_i +b^*)-1 &#x3D; 0$$<br>或<br>$$w^* x_i +b^* &#x3D; \pm 1$$</p>
</blockquote>
<p>即它的函数距离一定等于1，那么$x_i$一定在间隔边界上。（根据这个特性，证明只有少数的点都可以训练出一个分离超平面。）</p>
</blockquote>
<h4 id="SMO算法"><a href="#SMO算法" class="headerlink" title="SMO算法"></a><b>SMO算法</b></h4><h4 id="非线性支持向量机"><a href="#非线性支持向量机" class="headerlink" title="非线性支持向量机"></a><b>非线性支持向量机</b></h4><h5 id="高维映射"><a href="#高维映射" class="headerlink" title="高维映射"></a><b>高维映射</b></h5><h5 id="核方法"><a href="#核方法" class="headerlink" title="核方法"></a><b>核方法</b></h5>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>深渊巨坑</tag>
        <tag>机器学习</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库操作</title>
    <url>/2023/06/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BB%A5mysql%E4%B8%BA%E4%BE%8B%EF%BC%89/</url>
    <content><![CDATA[<h4 id="登录数据库"><a href="#登录数据库" class="headerlink" title="登录数据库"></a>登录数据库</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u 用户名 -p</span><br></pre></td></tr></table></figure>

<p><strong>例子：</strong></p>
<blockquote>
<p>登录root用户</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95.png" alt="用户登录"></p>
</blockquote>
</blockquote>
<h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create user &#x27;用户名&#x27; @&#x27;地址&#x27; identified by &#x27;密码&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>例子：</strong></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create user &#x27;Test&#x27;@&#x27;localhost&#x27; identified by&#x27;123456&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop user &#x27;用户名&#x27;@&#x27;地址&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>例子：</strong></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop user &#x27;Test&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h4 id="查看所有用户"><a href="#查看所有用户" class="headerlink" title="查看所有用户"></a>查看所有用户</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select user,host from mysql.user;</span><br></pre></td></tr></table></figure>

<p><strong>例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/%E6%9F%A5%E8%AF%A2%E7%94%A8%E6%88%B7.png" alt="查询用户"></p>
</blockquote>
</blockquote>
<h4 id="查询当前用户"><a href="#查询当前用户" class="headerlink" title="查询当前用户"></a>查询当前用户</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select user();</span><br></pre></td></tr></table></figure>

<p><strong>例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/%E6%9F%A5%E8%AF%A2%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7.png" alt="查询当前用户"></p>
</blockquote>
</blockquote>
<h4 id="修改用户密码"><a href="#修改用户密码" class="headerlink" title="修改用户密码"></a>修改用户密码</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter user &#x27;用户名&#x27;@&#x27;localhost&#x27; identified by &#x27;新密码&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/%E7%94%A8%E6%88%B7%E6%9B%B4%E6%94%B9%E5%AF%86%E7%A0%81.png" alt="用户更改密码"></p>
</blockquote>
</blockquote>
<h4 id="查看用户权限"><a href="#查看用户权限" class="headerlink" title="查看用户权限"></a>查看用户权限</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show grants for &#x27;用户名&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/%E6%9F%A5%E7%9C%8B%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90.png" alt="查看用户权限"></p>
</blockquote>
</blockquote>
<h4 id="授予权限"><a href="#授予权限" class="headerlink" title="授予权限"></a>授予权限</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant 权限 on 数据库.范围 to 用户名@地址;</span><br></pre></td></tr></table></figure>

<p><strong>例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/%E6%8E%88%E4%BA%88%E6%9D%83%E9%99%90.png" alt="授予权限"></p>
</blockquote>
<p><strong>注意：</strong></p>
<blockquote>
<p>GRANT 和 REVOKE 可在几个层次上控制访问权限:</p>
<ul>
<li>整个服务器，使用 GRANT ALL 和 REVOKE ALL；</li>
<li>整个数据库，使用 ON database.*；</li>
<li>特定的表，使用 ON database.table；</li>
<li>特定的列；</li>
<li>特定的存储过程。</li>
</ul>
</blockquote>
</blockquote>
<h4 id="删除权限"><a href="#删除权限" class="headerlink" title="删除权限"></a>删除权限</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">revoke 权限 on 数据库.范围 to 用户名@地址;</span><br></pre></td></tr></table></figure>

<p><strong>例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/%E6%92%A4%E9%94%80%E6%9D%83%E9%99%90.png" alt="撤销权限"></p>
</blockquote>
</blockquote>
<h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create DataBase 数据库名;</span><br></pre></td></tr></table></figure>

<p><strong>例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="创建数据库"></p>
</blockquote>
<p><strong>使用数据库：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="使用数据库"></p>
</blockquote>
</blockquote>
<h4 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名 (</span><br><span class="line">    属性名 数据类型 NOT NULL AUTO_INCREMENT,</span><br><span class="line">    col1 INT NOT NULL DEFAULT 1,</span><br><span class="line">    col2 VARCHAR(45) NULL,</span><br><span class="line">    col3 DATE NULL,</span><br><span class="line">    PRIMARY KEY (`id`));</span><br></pre></td></tr></table></figure>

<p><strong>例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/%E5%88%9B%E5%BB%BA%E8%A1%A81.png" alt="创建表1"></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/%E5%88%9B%E5%BB%BA%E8%A1%A8.png" alt="创建表"></p>
</blockquote>
</blockquote>
<h4 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h4><blockquote>
<ul>
<li><p><strong>添加列：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Alter Table mytable Add col Char(20);</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>修改列和属性：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//ALTER TABLE 表名 CHANGE 原字段名 新字段名 字段类型 约束条件</span><br><span class="line">ALTER TABLE mytable CHANGE col col1 CHAR(32) NOT NULL DEFAULT &#x27;123&#x27;;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>删除列：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Alter Table mytable Drop Column col;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>删除表：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Drop Table mytable;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<h4 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h4><blockquote>
<ul>
<li><p><strong>普通插入：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Insert Into mytable(col1, col2) Values(数值1, 数值2);</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>插入检索出来的数据：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO mytable1(col1, col2)</span><br><span class="line">SELECT col1, col2</span><br><span class="line">FROM mytable2;</span><br></pre></td></tr></table></figure>

<p>从mytable2中检索出col1和col2的值插入mytable1中的col1、col2上。</p>
</li>
<li><p><strong>将一个表的内容插入到一个新表中</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Create Table 新表名 As Select * From 旧表名;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Update 表名 Set 列名 = 修改后的值 Where 主键=主键值;</span><br></pre></td></tr></table></figure>

<p><strong>例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0.png" alt="数据更新"></p>
</blockquote>
</blockquote>
<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Delete From 表名 Where 主键=主键值;</span><br></pre></td></tr></table></figure>

<p><strong>例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4.png" alt="数据删除"></p>
</blockquote>
<p><strong>删除所有行：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Truncate Table mytable;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h4><blockquote>
<p>相同值只会出现一次，作用于所有列，也就是说所有列的值都相同才算相同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Select Distinct 列名1，列名2 from 表名;</span><br></pre></td></tr></table></figure>

<p><strong>例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/%E6%9F%A5%E8%AF%A21.png" alt="查询1"></p>
</blockquote>
<p><strong>LIMIT：</strong></p>
<blockquote>
<p>限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM mytable LIMIT 2,3;</span><br></pre></td></tr></table></figure>

<p>显示mytable中第3~第4行的数据（因为Limit是从0开始计算的）。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/%E6%9F%A5%E8%AF%A22.png" alt="查询2"></p>
</blockquote>
</blockquote>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM mytable Order By col1 Desc;</span><br></pre></td></tr></table></figure>

<p><strong>例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/%E6%8E%92%E5%BA%8F.png" alt="排序"></p>
</blockquote>
<ul>
<li><strong>ASC</strong> : 升序(默认)</li>
<li><strong>DESC</strong> : 降序</li>
</ul>
<p>可以按多个列进行排序，并且为每个列指定不同的排序方式:</p>
</blockquote>
<h4 id="过滤查询"><a href="#过滤查询" class="headerlink" title="过滤查询"></a>过滤查询</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Select * from 表名 Where 列名 操作符 条件;</span><br></pre></td></tr></table></figure>

<p><strong>例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/%E8%BF%87%E6%BB%A4%E6%9F%A5%E8%AF%A2.png" alt="过滤查询"></p>
</blockquote>
<p>下面是Where子句可用的操作符</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#x3D;</td>
<td align="center">等于</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">小于</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">大于</td>
</tr>
<tr>
<td align="center">&lt;&#x3D;</td>
<td align="center">小于等于</td>
</tr>
<tr>
<td align="center">&gt;&#x3D;</td>
<td align="center">大于等于</td>
</tr>
<tr>
<td align="center">!&#x3D;</td>
<td align="center">不等于</td>
</tr>
<tr>
<td align="center">Between</td>
<td align="center">在两个值之间</td>
</tr>
<tr>
<td align="center">Is Null</td>
<td align="center">为Null值</td>
</tr>
</tbody></table>
<p><strong>注意：</strong></p>
<ul>
<li><p><strong>AND 和 OR</strong> 用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。</p>
</li>
<li><p><strong>IN</strong> 操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。</p>
</li>
<li><p><strong>NOT</strong> 操作符用于否定一个条件。</p>
</li>
</ul>
</blockquote>
<h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><blockquote>
<p>通配符可以用作过滤语句中，但是只能用于文本字段</p>
<ul>
<li>通配符“%”，用于匹配&gt;&#x3D;0个任意字符</li>
<li>通配符“_”，用于匹配&#x3D;&#x3D;1个任意字符</li>
</ul>
<p><strong>例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/%E9%80%9A%E9%85%8D%E7%AC%A6%E4%BE%8B%E5%AD%90.png" alt="通配符例子"></p>
</blockquote>
</blockquote>
<h4 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h4><blockquote>
<p>计算字段通常需要使用As来取别名，否则输出的字段名为计算表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Select 列名1 计算符 列名2 As 别名 from 表名;</span><br></pre></td></tr></table></figure>

<p><strong>例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5.png" alt="计算字段"></p>
</blockquote>
<p><strong>Concat（）</strong>可以用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 <strong>TRIM()</strong> 可以去除首尾空格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Select Concat(Trim(col1), &#x27;(&#x27;, Trim(col2), &#x27;)&#x27;) As concat_col From mytable;</span><br></pre></td></tr></table></figure>

<p><strong>例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5-concat.png" alt="计算字段-concat"></p>
</blockquote>
</blockquote>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><blockquote>
<ul>
<li><p><strong>常用函数</strong></p>
<blockquote>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Avg()</td>
<td align="center">返回某列的平均值</td>
</tr>
<tr>
<td align="center">Count()</td>
<td align="center">返回某列的行数</td>
</tr>
<tr>
<td align="center">Max()</td>
<td align="center">返回某列的最大值</td>
</tr>
<tr>
<td align="center">Min()</td>
<td align="center">返回某列的最小值</td>
</tr>
<tr>
<td align="center">Sum()</td>
<td align="center">返回某列值之和</td>
</tr>
</tbody></table>
<p><strong>补充：</strong></p>
<blockquote>
<ul>
<li><p>Avg()会忽略值为NULL的行</p>
</li>
<li><p>使用Distinct可以让汇总函数值汇总不同的值</p>
</li>
</ul>
</blockquote>
<p><strong>例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/%E6%B1%82%E5%88%97%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC.png" alt="求列的平均值"></p>
</blockquote>
</blockquote>
</li>
<li><p><strong>文本处理：</strong></p>
<blockquote>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Left()</td>
<td align="center">显示左边的字符</td>
</tr>
<tr>
<td align="center">Right()</td>
<td align="center">显示右边的字符</td>
</tr>
<tr>
<td align="center">Lower()</td>
<td align="center">转换为小写字符</td>
</tr>
<tr>
<td align="center">Upper()</td>
<td align="center">转换为大写字符</td>
</tr>
<tr>
<td align="center">Ltrim()</td>
<td align="center">去除左边的空格</td>
</tr>
<tr>
<td align="center">Rtrim()</td>
<td align="center">去除右边的空格</td>
</tr>
<tr>
<td align="center">Length()</td>
<td align="center">长度</td>
</tr>
<tr>
<td align="center">Soundex()</td>
<td align="center">转化为语音值</td>
</tr>
</tbody></table>
<p>其中， <strong>SOUNDEX()</strong> 可以将一个字符串转换为描述其语音表示的字母数字模式。</p>
</blockquote>
</li>
<li><p><strong>日期和时间处理</strong></p>
<blockquote>
<p><strong>日期格式：</strong>YYYY-MM-DD</p>
<p><strong>时间格式：</strong>HH:MM:SS</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AddDate()</td>
<td align="center">增加一个日期</td>
</tr>
<tr>
<td align="center">AddTime()</td>
<td align="center">增加一个时间</td>
</tr>
<tr>
<td align="center">CurDate()</td>
<td align="center">返回当前日期</td>
</tr>
<tr>
<td align="center">CurTime()</td>
<td align="center">返回当前时间</td>
</tr>
<tr>
<td align="center">Date()</td>
<td align="center">返回日期时间的日期部分</td>
</tr>
<tr>
<td align="center">DateDiff()</td>
<td align="center">计算两个日期之差</td>
</tr>
<tr>
<td align="center">Date_Add()</td>
<td align="center">日期运算函数</td>
</tr>
<tr>
<td align="center">Date_Format()</td>
<td align="center">返回一个格式化的日期或时间串</td>
</tr>
<tr>
<td align="center">Day()</td>
<td align="center">返回一个日期的天数部分</td>
</tr>
<tr>
<td align="center">DayOfWeek()</td>
<td align="center">返回一个日期对应的星期几</td>
</tr>
<tr>
<td align="center">Hour()</td>
<td align="center">返回一个时间的小时部分</td>
</tr>
<tr>
<td align="center">Minute()</td>
<td align="center">返回一个时间的分钟部分</td>
</tr>
<tr>
<td align="center">Month()</td>
<td align="center">返回一个日期的月份部分</td>
</tr>
<tr>
<td align="center">Now()</td>
<td align="center">返回当前日期和时间</td>
</tr>
<tr>
<td align="center">Second()</td>
<td align="center">返回一个时间的秒部分</td>
</tr>
<tr>
<td align="center">Time()</td>
<td align="center">返回一个日期时间的时间部分</td>
</tr>
<tr>
<td align="center">Year()</td>
<td align="center">返回一个日期的年份部分</td>
</tr>
</tbody></table>
<p><strong>例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0.png" alt="时间函数"></p>
</blockquote>
</blockquote>
</li>
<li><p><strong>数值处理：</strong></p>
<blockquote>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SIN()</td>
<td align="center">正弦</td>
</tr>
<tr>
<td align="center">COS()</td>
<td align="center">余弦</td>
</tr>
<tr>
<td align="center">TAN()</td>
<td align="center">正切</td>
</tr>
<tr>
<td align="center">ABS()</td>
<td align="center">绝对值</td>
</tr>
<tr>
<td align="center">SQRT()</td>
<td align="center">平方根</td>
</tr>
<tr>
<td align="center">MOD()</td>
<td align="center">余数</td>
</tr>
<tr>
<td align="center">EXP()</td>
<td align="center">指数</td>
</tr>
<tr>
<td align="center">PI()</td>
<td align="center">圆周率</td>
</tr>
<tr>
<td align="center">RAND()</td>
<td align="center">随机数</td>
</tr>
</tbody></table>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><blockquote>
<p>分组就是把具有相同的数据值的行放在同一组中</p>
<p>可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值</p>
<p>指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序</p>
<ul>
<li><p><strong>将数据按某列的值进行统计：</strong></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select col2,count(*) As num from mytable Group by col2;</span><br></pre></td></tr></table></figure>

<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/%E5%88%86%E7%BB%841.png" alt="分组1"></p>
</blockquote>
</li>
<li><p>GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select col2,count(*) As num from mytable Group by col2 Order by num;</span><br></pre></td></tr></table></figure>

<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/%E5%88%86%E7%BB%842.png" alt="分组2"></p>
<p>分组结果可以使用order by来进行排序</p>
</blockquote>
</li>
<li><p>WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select col1,count(*) As num from mytable where col1&gt;=2 Group by col1 Having num &gt;=1;</span><br></pre></td></tr></table></figure>

<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/%E5%88%86%E7%BB%843.png" alt="分组3"></p>
</blockquote>
</li>
</ul>
<p><strong>分组规定：</strong></p>
<blockquote>
<ul>
<li><strong>GROUP BY子句出现在WHERE子句之后，ORDER BY子句之前</strong>；</li>
<li>除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；</li>
<li>NULL 的行会单独分为一组；</li>
<li>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。</li>
</ul>
</blockquote>
</blockquote>
<h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><blockquote>
<p>子查询只能返回一个字段的数据。</p>
<ul>
<li><p>将子查询作为where语句的过滤条件；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from mytable1 where id in (select id from mytable);</span><br></pre></td></tr></table></figure>

<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/%E5%AD%90%E6%9F%A5%E8%AF%A21.png" alt="子查询1"></p>
<p>其中（select id from mytable）就是一个子查询，在语句中用作where的过滤条件</p>
</li>
</ul>
</blockquote>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><blockquote>
<p>连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE.</p>
<p>连接可以替换子查询，并且比子查询的效率更快</p>
<p>可以用As给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表.</p>
<ul>
<li><p><strong>内连接</strong></p>
<blockquote>
<p>内连接又称等值连接，使用Inner Join关键字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select A.col2,B.col1 from mytable As A Inner Join mytable1 As B On A.id=B.id;</span><br></pre></td></tr></table></figure>

<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/%E5%86%85%E8%BF%9E%E6%8E%A5.png" alt="内连接"></p>
<p>当然也可以不明确使用Inner Join，而使用普通查询并在Where中将两个表中要连接的列用等值方法连接起来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Select A.col2,B.col1 from mytable As A, mytable1 As B Where A.id=B.id</span><br></pre></td></tr></table></figure>

<p>在没有条件语句的情况下返回笛卡尔积。</p>
</blockquote>
</li>
<li><p><strong>自连接</strong></p>
<blockquote>
<p>自连接可以看成内连接的一种，只是连接的表是自身而已</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/%E8%87%AA%E8%BF%9E%E6%8E%A5.png" alt="自连接"></p>
</blockquote>
</li>
<li><p><strong>自然连接</strong></p>
<blockquote>
<p>自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。</p>
<p>内连接和自然连接的区别: 内连接提供连接的列，而自然连接自动连接所有同名列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select A.co3,B.col1 from mytable1 As A Natural Join mytable As B;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>外连接</strong></p>
<blockquote>
<p>外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select mytable.col1,mytable1.col2 from mytable left outer join mytable1 on mytable.id=mytable.id;</span><br></pre></td></tr></table></figure>

<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/%E5%A4%96%E8%BF%9E%E6%8E%A5.png" alt="外连接"></p>
</blockquote>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>基础学科</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>朴素贝叶斯分类器代码实现</title>
    <url>/2021/08/30/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a><b>算法描述</b></h4><blockquote>
<p>贝叶斯公式：<br>$$P(Y|X)&#x3D;\frac{P(X|Y)P(Y)}{P(X)}$$<br>根据公式可以得到以下算法：</p>
<blockquote>
<ul>
<li>整理数据</li>
<li>分别计算$P(x_i|Y)$与P(Y)的值</li>
<li>计算$P(y) \prod_{i&#x3D;0}^m P(x_i|x_n,y)$的值</li>
<li>根据$max \ P(y) \prod_{i&#x3D;0}^m P(x_i|x_n,y)$来进行分类</li>
</ul>
</blockquote>
</blockquote>
<h4 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a><b>代码区</b></h4><blockquote>
<p><b>导入的包</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>
</blockquote>
<p><b>创建数据集</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">DataSet</span>():</span><br><span class="line">   postingList = [[<span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;has&#x27;</span>, <span class="string">&#x27;flea&#x27;</span>, <span class="string">&#x27;problems&#x27;</span>, <span class="string">&#x27;help&#x27;</span>, <span class="string">&#x27;please&#x27;</span>],  <span class="comment"># 切分的词条</span></span><br><span class="line">                  [<span class="string">&#x27;maybe&#x27;</span>, <span class="string">&#x27;not&#x27;</span>, <span class="string">&#x27;take&#x27;</span>, <span class="string">&#x27;him&#x27;</span>, <span class="string">&#x27;to&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;park&#x27;</span>, <span class="string">&#x27;stupid&#x27;</span>],</span><br><span class="line">                  [<span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;dalmation&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;so&#x27;</span>, <span class="string">&#x27;cute&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;love&#x27;</span>, <span class="string">&#x27;him&#x27;</span>],</span><br><span class="line">                  [<span class="string">&#x27;stop&#x27;</span>, <span class="string">&#x27;posting&#x27;</span>, <span class="string">&#x27;stupid&#x27;</span>, <span class="string">&#x27;worthless&#x27;</span>, <span class="string">&#x27;garbage&#x27;</span>],</span><br><span class="line">                  [<span class="string">&#x27;mr&#x27;</span>, <span class="string">&#x27;licks&#x27;</span>, <span class="string">&#x27;ate&#x27;</span>, <span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;steak&#x27;</span>, <span class="string">&#x27;how&#x27;</span>, <span class="string">&#x27;to&#x27;</span>, <span class="string">&#x27;stop&#x27;</span>, <span class="string">&#x27;him&#x27;</span>],</span><br><span class="line">                  [<span class="string">&#x27;quit&#x27;</span>, <span class="string">&#x27;buying&#x27;</span>, <span class="string">&#x27;worthless&#x27;</span>,<span class="string">&#x27;stupid&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;food&#x27;</span>, <span class="string">&#x27;stupid&#x27;</span>],</span><br><span class="line">                  [<span class="string">&#x27;stupid&#x27;</span>,<span class="string">&#x27;my&#x27;</span>]]</span><br><span class="line">   classVec = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]            <span class="comment"># 0代表词条列表中没有侮辱类的词，1代表词条列表中有侮辱类的词</span></span><br><span class="line">   <span class="keyword">return</span> postingList, classVec          <span class="comment"># 返回一个数据集和数据集的标签</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><b>构建一个基于训练集的词汇表</b>、</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 去掉重复的单词，构建一个没有重复单词的词汇表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createVocabList</span>(<span class="params">dataSet</span>):</span><br><span class="line">   vocabSet = <span class="built_in">set</span>([])</span><br><span class="line">   <span class="keyword">for</span> document <span class="keyword">in</span> dataSet:</span><br><span class="line">       vocabSet = vocabSet | <span class="built_in">set</span>(document)    <span class="comment"># 通过取并集来消除重复的单词</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">list</span>(vocabSet)</span><br></pre></td></tr></table></figure>
</blockquote>
<p><b>根据词汇表对训练数据进行向量化</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据vocabList，将inputSet向量化，向量长度与vocabList一样，每个向量元素为1或0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setOfWordsToVec</span>(<span class="params">vocabList, inputSet</span>):</span><br><span class="line">   returnVec = [<span class="number">0</span>] * <span class="built_in">len</span>(vocabList)            <span class="comment"># 创建一个全部为0的返回向量</span></span><br><span class="line">   <span class="keyword">for</span> word <span class="keyword">in</span> inputSet:                       <span class="comment"># 遍历inputSet中的元素</span></span><br><span class="line">       <span class="keyword">if</span> word <span class="keyword">in</span> vocabList:                   <span class="comment"># 如果inputSet中的某个元素在vocabList中，则将returnVec对应位置置为1</span></span><br><span class="line">           returnVec[vocabList.index(word)] = <span class="number">1</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">&quot;the word: %s is not in my Vocabulary!&quot;</span> % word)</span><br><span class="line">   <span class="keyword">return</span> returnVec</span><br></pre></td></tr></table></figure>
</blockquote>
<p><b>计算似然概率以及先验概率的函数</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">trainNB0</span>(<span class="params">trainMatrix,trainCategory</span>):</span><br><span class="line">   numTrainDocs = <span class="built_in">len</span>(trainMatrix)         <span class="comment"># 训练的文档数目(本例为6)</span></span><br><span class="line">   numWords = <span class="built_in">len</span>(trainMatrix[<span class="number">0</span>])          <span class="comment"># 一个文档中的词条（单词）数(本例为32)</span></span><br><span class="line">   pAbusive = <span class="built_in">sum</span>(trainCategory) / <span class="built_in">float</span>(numTrainDocs)   <span class="comment"># 计算文档属于侮辱类的概率</span></span><br><span class="line">   p0Num = np.ones(numWords)              <span class="comment"># 创建两个大小为numWords的全1矩阵</span></span><br><span class="line">   p1Num = np.ones(numWords)              <span class="comment"># 为什么是1呢，问就是拉普拉斯平滑，下面的2也是</span></span><br><span class="line">   p0Denom = <span class="number">2.0</span></span><br><span class="line">   p1Denom = <span class="number">2.0</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numTrainDocs):</span><br><span class="line">       <span class="keyword">if</span> trainCategory[i] == <span class="number">1</span>:        <span class="comment"># 统计属于侮辱类的条件概率所需的数据</span></span><br><span class="line">           p1Num += trainMatrix[i]      <span class="comment"># 统计有侮辱类（正例）中各单词的出现频率</span></span><br><span class="line">           p1Denom += <span class="built_in">sum</span>(trainMatrix[i])  <span class="comment"># 统计有侮辱类（正例）中各单词的总数</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           p0Num += trainMatrix[i]      <span class="comment"># 统计没有侮辱类（反例）中各单词的出现频率</span></span><br><span class="line">           p0Denom += <span class="built_in">sum</span>(trainMatrix[i])  <span class="comment"># 统计没有侮辱类（反例）中各单词的总数</span></span><br><span class="line">   p1Vect = np.log(p1Num / p1Denom)            <span class="comment"># 列表除以同一个数，计算在有侮辱类（正例）中各单词的概率，即P(w0|1),P(w1|1),P(w2|1)...P(w32|1)</span></span><br><span class="line">   p0Vect = np.log(p0Num / p0Denom)            <span class="comment"># 与上同理（防止下溢导致结果为0）</span></span><br><span class="line">   <span class="keyword">return</span> p0Vect, p1Vect, pAbusive     <span class="comment"># 返回属于侮辱类的条件概率数组，属于非侮辱类的条件概率数组，文档属于侮辱类的概率</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><b>朴素贝叶斯分类器的训练函数</b>、</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   朴素贝叶斯分类器</span></span><br><span class="line"><span class="string">vec2Classify - 待分类的词条数组</span></span><br><span class="line"><span class="string">p0Vec - 侮辱类的条件概率数组</span></span><br><span class="line"><span class="string">p1Vec -非侮辱类的条件概率数组</span></span><br><span class="line"><span class="string">pClass1 - 文档属于侮辱类的概率</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">classifyNB</span>(<span class="params">vec2Classify, p0Vec, p1Vec, pClass1</span>):</span><br><span class="line">   <span class="comment"># p1 = reduce(lambda x, y:x*y, vec2Classify * p1Vec) * pClass1            # 计算P(Y|X)*P(Y)</span></span><br><span class="line">   <span class="comment"># p0 = reduce(lambda  x, y:x*y, vec2Classify * p0Vec) * (1.0 - pClass1)</span></span><br><span class="line">   p1 = <span class="built_in">sum</span>(vec2Classify * p1Vec) + np.log(pClass1)  <span class="comment"># 对应元素相乘。logA * B = logA + logB，所以这里加上log(pClass1)</span></span><br><span class="line">   p0 = <span class="built_in">sum</span>(vec2Classify * p0Vec) + np.log(<span class="number">1.0</span> - pClass1)</span><br><span class="line">   <span class="comment"># # 可删除选项</span></span><br><span class="line">   <span class="comment"># print(&#x27;p0:&#x27;, p0)</span></span><br><span class="line">   <span class="comment"># print(&#x27;p1:&#x27;, p1)</span></span><br><span class="line">   <span class="keyword">if</span> p1 &gt; p0:</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><b>整体代码</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建数据集</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">DataSet</span>():</span><br><span class="line">   postingList = [[<span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;has&#x27;</span>, <span class="string">&#x27;flea&#x27;</span>, <span class="string">&#x27;problems&#x27;</span>, <span class="string">&#x27;help&#x27;</span>, <span class="string">&#x27;please&#x27;</span>],  <span class="comment"># 切分的词条</span></span><br><span class="line">                  [<span class="string">&#x27;maybe&#x27;</span>, <span class="string">&#x27;not&#x27;</span>, <span class="string">&#x27;take&#x27;</span>, <span class="string">&#x27;him&#x27;</span>, <span class="string">&#x27;to&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;park&#x27;</span>, <span class="string">&#x27;stupid&#x27;</span>],</span><br><span class="line">                  [<span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;dalmation&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;so&#x27;</span>, <span class="string">&#x27;cute&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;love&#x27;</span>, <span class="string">&#x27;him&#x27;</span>],</span><br><span class="line">                  [<span class="string">&#x27;stop&#x27;</span>, <span class="string">&#x27;posting&#x27;</span>, <span class="string">&#x27;stupid&#x27;</span>, <span class="string">&#x27;worthless&#x27;</span>, <span class="string">&#x27;garbage&#x27;</span>],</span><br><span class="line">                  [<span class="string">&#x27;mr&#x27;</span>, <span class="string">&#x27;licks&#x27;</span>, <span class="string">&#x27;ate&#x27;</span>, <span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;steak&#x27;</span>, <span class="string">&#x27;how&#x27;</span>, <span class="string">&#x27;to&#x27;</span>, <span class="string">&#x27;stop&#x27;</span>, <span class="string">&#x27;him&#x27;</span>],</span><br><span class="line">                  [<span class="string">&#x27;quit&#x27;</span>, <span class="string">&#x27;buying&#x27;</span>, <span class="string">&#x27;worthless&#x27;</span>,<span class="string">&#x27;stupid&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;food&#x27;</span>, <span class="string">&#x27;stupid&#x27;</span>],</span><br><span class="line">                  [<span class="string">&#x27;stupid&#x27;</span>,<span class="string">&#x27;my&#x27;</span>]]</span><br><span class="line">   classVec = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]            <span class="comment"># 0代表词条列表中没有侮辱类的词，1代表词条列表中有侮辱类的词</span></span><br><span class="line">   <span class="keyword">return</span> postingList, classVec          <span class="comment"># 返回一个数据集和数据集的标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据vocabList，将inputSet向量化，向量长度与vocabList一样，每个向量元素为1或0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setOfWordsToVec</span>(<span class="params">vocabList, inputSet</span>):</span><br><span class="line">   returnVec = [<span class="number">0</span>] * <span class="built_in">len</span>(vocabList)            <span class="comment"># 创建一个全部为0的返回向量</span></span><br><span class="line">   <span class="keyword">for</span> word <span class="keyword">in</span> inputSet:                       <span class="comment"># 遍历inputSet中的元素</span></span><br><span class="line">       <span class="keyword">if</span> word <span class="keyword">in</span> vocabList:                   <span class="comment"># 如果inputSet中的某个元素在vocabList中，则将returnVec对应位置置为1</span></span><br><span class="line">           returnVec[vocabList.index(word)] = <span class="number">1</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">&quot;the word: %s is not in my Vocabulary!&quot;</span> % word)</span><br><span class="line">   <span class="keyword">return</span> returnVec</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去掉重复的单词，构建一个没有重复单词的词汇表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createVocabList</span>(<span class="params">dataSet</span>):</span><br><span class="line">   vocabSet = <span class="built_in">set</span>([])</span><br><span class="line">   <span class="keyword">for</span> document <span class="keyword">in</span> dataSet:</span><br><span class="line">       vocabSet = vocabSet | <span class="built_in">set</span>(document)    <span class="comment"># 通过取并集来消除重复的单词</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">list</span>(vocabSet)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 朴素贝叶斯分类器训练函数，返回（侮辱类的条件概率数组、非侮辱类的条件概率数组、文档属于侮辱类的概率）</span></span><br><span class="line"><span class="comment"># trainMatrix - 训练文档矩阵，即setOfWords2Vec返回的returnVec构成的矩阵</span></span><br><span class="line"><span class="comment"># trainCategory - 训练类别标签向量，即loadDataSet返回的classVec</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trainNB0</span>(<span class="params">trainMatrix,trainCategory</span>):</span><br><span class="line">   numTrainDocs = <span class="built_in">len</span>(trainMatrix)         <span class="comment"># 训练的文档数目(本例为6)</span></span><br><span class="line">   numWords = <span class="built_in">len</span>(trainMatrix[<span class="number">0</span>])          <span class="comment"># 一个文档中的词条（单词）数(本例为32)</span></span><br><span class="line">   pAbusive = <span class="built_in">sum</span>(trainCategory) / <span class="built_in">float</span>(numTrainDocs)   <span class="comment"># 计算文档属于侮辱类的概率</span></span><br><span class="line">   p0Num = np.ones(numWords)              <span class="comment"># 创建两个大小为numWords的全1矩阵</span></span><br><span class="line">   p1Num = np.ones(numWords)              <span class="comment"># 为什么是1呢，问就是拉普拉斯平滑，下面的2也是</span></span><br><span class="line">   p0Denom = <span class="number">2.0</span></span><br><span class="line">   p1Denom = <span class="number">2.0</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numTrainDocs):</span><br><span class="line">       <span class="keyword">if</span> trainCategory[i] == <span class="number">1</span>:        <span class="comment"># 统计属于侮辱类的条件概率所需的数据</span></span><br><span class="line">           p1Num += trainMatrix[i]      <span class="comment"># 统计有侮辱类（正例）中各单词的出现频率</span></span><br><span class="line">           p1Denom += <span class="built_in">sum</span>(trainMatrix[i])  <span class="comment"># 统计有侮辱类（正例）中各单词的总数</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           p0Num += trainMatrix[i]      <span class="comment"># 统计没有侮辱类（反例）中各单词的出现频率</span></span><br><span class="line">           p0Denom += <span class="built_in">sum</span>(trainMatrix[i])  <span class="comment"># 统计没有侮辱类（反例）中各单词的总数</span></span><br><span class="line">   p1Vect = np.log(p1Num / p1Denom)            <span class="comment"># 列表除以同一个数，计算在有侮辱类（正例）中各单词的概率，即P(w0|1),P(w1|1),P(w2|1)...P(w32|1)</span></span><br><span class="line">   p0Vect = np.log(p0Num / p0Denom)            <span class="comment"># 与上同理（防止下溢导致结果为0）</span></span><br><span class="line">   <span class="keyword">return</span> p0Vect, p1Vect, pAbusive     <span class="comment"># 返回属于侮辱类的条件概率数组，属于非侮辱类的条件概率数组，文档属于侮辱类的概率</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   朴素贝叶斯分类器</span></span><br><span class="line"><span class="string">vec2Classify - 待分类的词条数组</span></span><br><span class="line"><span class="string">p0Vec - 侮辱类的条件概率数组</span></span><br><span class="line"><span class="string">p1Vec -非侮辱类的条件概率数组</span></span><br><span class="line"><span class="string">pClass1 - 文档属于侮辱类的概率</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">classifyNB</span>(<span class="params">vec2Classify, p0Vec, p1Vec, pClass1</span>):</span><br><span class="line">   <span class="comment"># p1 = reduce(lambda x, y:x*y, vec2Classify * p1Vec) * pClass1            # 计算P(Y|X)*P(Y)</span></span><br><span class="line">   <span class="comment"># p0 = reduce(lambda  x, y:x*y, vec2Classify * p0Vec) * (1.0 - pClass1)</span></span><br><span class="line">   p1 = <span class="built_in">sum</span>(vec2Classify * p1Vec) + np.log(pClass1)  <span class="comment"># 对应元素相乘。logA * B = logA + logB，所以这里加上log(pClass1)</span></span><br><span class="line">   p0 = <span class="built_in">sum</span>(vec2Classify * p0Vec) + np.log(<span class="number">1.0</span> - pClass1)</span><br><span class="line">   <span class="comment"># # 可删除选项</span></span><br><span class="line">   <span class="comment"># print(&#x27;p0:&#x27;, p0)</span></span><br><span class="line">   <span class="comment"># print(&#x27;p1:&#x27;, p1)</span></span><br><span class="line">   <span class="keyword">if</span> p1 &gt; p0:</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 整合包</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">testNB</span>(<span class="params">testEntry</span>):</span><br><span class="line">   listOPosts, listClasses = DataSet()                                 <span class="comment"># 创建训练样本</span></span><br><span class="line">   myVocabList = createVocabList(listOPosts)                           <span class="comment"># 创建不重复的词汇表</span></span><br><span class="line">   trainMat = []</span><br><span class="line">   <span class="keyword">for</span> postinDoc <span class="keyword">in</span> listOPosts:</span><br><span class="line">       trainMat.append(setOfWordsToVec(myVocabList, postinDoc))        <span class="comment"># 将训练样本向量化</span></span><br><span class="line">   p0V, p1V, pAb = trainNB0(np.array(trainMat), np.array(listClasses)) <span class="comment"># 计算训练样本的条件概率（本例32个）和反例的概率</span></span><br><span class="line">   thisDoc = np.array(setOfWordsToVec(myVocabList, testEntry))</span><br><span class="line">   <span class="keyword">if</span> classifyNB(thisDoc, p0V, p1V, pAb) == <span class="number">1</span>:</span><br><span class="line">       <span class="built_in">print</span>(testEntry, <span class="string">&#x27;属于侮辱类&#x27;</span>)</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">       <span class="built_in">print</span>(testEntry, <span class="string">&#x27;属于非侮辱类&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   testEntry = [<span class="string">&#x27;love&#x27;</span>, <span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;dalmation&#x27;</span>]</span><br><span class="line">   testNB(testEntry)</span><br><span class="line">   test = [<span class="string">&#x27;love&#x27;</span>,<span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;dalmation&#x27;</span>, <span class="string">&#x27;stupid&#x27;</span>]</span><br><span class="line">   testNB(test)</span><br><span class="line">   test2 = [<span class="string">&#x27;stupid&#x27;</span>]</span><br><span class="line">   testNB(test2)</span><br></pre></td></tr></table></figure>

<p><b>运行结果：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;love&#x27;, &#x27;my&#x27;, &#x27;dalmation&#x27;] 属于非侮辱类</span><br><span class="line">[&#x27;love&#x27;, &#x27;my&#x27;, &#x27;dalmation&#x27;, &#x27;stupid&#x27;] 属于侮辱类</span><br><span class="line">[&#x27;stupid&#x27;] 属于侮辱类</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>在使用朴素贝叶斯训练之前要处理亿下数据</li>
<li>如果是分类文本类别，那么将词汇向量化是很重要的一步</li>
<li>拉普拉斯平滑对于改善朴素贝叶斯分类起到很大的作用</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>深渊巨坑</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>极大似然估计与贝叶斯估计</title>
    <url>/2021/03/14/%E6%9E%81%E5%A4%A7%E6%96%AF%E7%84%B6%E4%BC%B0%E8%AE%A1%E4%B8%8E%E8%B4%9D%E5%8F%B6%E6%96%AF%E4%BC%B0%E8%AE%A1/</url>
    <content><![CDATA[<h4 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a><b>极大似然估计</b></h4><blockquote>
<p><b>极大似然估计的思想：</b></p>
<blockquote>
<p>首先我们得到了一个实验结果y，但不知道导致结果y出现的参数$\theta$的值是多少，那么我们可以通过计算结果y出现概率最大时的$\theta^*$，然后用$\theta^*$来代替$\theta$。</p>
</blockquote>
<p><b>似然函数：</b></p>
<blockquote>
<p>$$P(y|\theta)$$</p>
<p>上式输入有两个数：y表示某一个具体的结果;$\theta$表示模型的参数。</p>
<ul>
<li>如果$\theta$是已知的，y是变量，那么这个函数$P(y|\theta)$叫做<b>概率函数</b>。</li>
<li>如果y是已知的，$\theta$是变量，那么这个函数$P(y|\theta)$叫做<b>似然函数</b>。</li>
</ul>
</blockquote>
<p><b>极大后验概率估计</b></p>
<blockquote>
<p>最大似然估计是通过求参数$\theta$, 使似然函数$P(y|\theta)$最大。</p>
</blockquote>
<p><b>例如：</b></p>
<blockquote>
<p>我们抛一个硬币，一共抛了10次，得到结果y为：反正正正正反正正正反。现在我们想求的正面概率$\theta$是模型参数，根据抛硬币模型，我们假设为二项分布。<br>那么该实验的<b>似然函数</b>为$f(y,\theta)&#x3D;\theta^7(1-\theta)^3&#x3D;f(\theta)$<br>对该<b>似然函数</b>求最大值，<br>对似然函数求导，$f(\theta)’&#x3D;7\theta^6(1-\theta)^3-3\theta^7(1-\theta)^2&#x3D;\theta^6(1-\theta)^27(1-\theta)-3\theta&#x3D;0$<br>解得，当$\theta&#x3D;0.7$时，似然函数取得最大值。<br>所以根据合理计算和合理猜测，<b>该硬币的正面概率为0.7</b>。<del>(实际上是实验次数不够多)</del></p>
</blockquote>
<p><b>数学描述：</b></p>
<blockquote>
<p>有一组样本$(y_1,y_2,…,y_n)$，它的概率密度函数为$f(y_i|\theta)$,其中$\theta$为未知参数<br>设$\theta^*$是$\theta$的极大似然估计值，即估计值$\theta^*$使得事件发生的可能性最大。<br>那么就有，<br>$$L(\theta|y)&#x3D;f(y|\theta)&#x3D;f(y_1,y_2,…,y_n|\theta)&#x3D;\prod^n_{i&#x3D;1}f(x_i|\theta)$$</p>
<p>$$\theta^*&#x3D;arg\max_{\theta}L(\theta|x)$$</p>
</blockquote>
</blockquote>
<h4 id="贝叶斯估计"><a href="#贝叶斯估计" class="headerlink" title="贝叶斯估计"></a><b>贝叶斯估计</b></h4><blockquote>
<ul>
<li><p><b>先验概率</b></p>
<blockquote>
<p>根据统计或自身经验所得到的一个概率值，记作$P(\theta)$。</p>
</blockquote>
</li>
<li><p><b>后验概率</b></p>
<blockquote>
<p>在某个概率事件发生后，根据先验概率求该事件发生的可能性,记作$P(\theta|D)$。<br><b>例子:</b><br>假设一个学校的男女比例为6：4(这个6：4就是<b>先验概率</b>)，女生中一半人穿裙子，另一半穿裤子，男生全部穿裤子。现在看到一个穿裤子的学生，求这名学生是男生的概率。（这个概率就是<b>后验概率</b>）</p>
</blockquote>
</li>
</ul>
<p><b>贝叶斯定理</b></p>
<blockquote>
<p>$$P(\theta|D)&#x3D;\frac{P(D|\theta)P(\theta)}{P(D)}$$</p>
<p>其中$P(D|\theta)$称为<b>似然函数</b>，$P(\theta)$和$P(D)$分别为$\theta$和D的先验概率。</p>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>数学基础</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title>栈和队列</title>
    <url>/2021/01/28/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a><b>栈</b></h3><p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E6%A0%88.gif" alt="栈的结构" title="栈"></p>
<blockquote>
<ul>
<li>栈是一种特殊的数据结构，它的运算规则为<b>先进后出</b>。</li>
<li>栈只能对栈顶元素进行操作。它主要操作为<b>入栈</b>、<b>出栈</b>和<b>取栈顶元素</b></li>
<li>用<b>顺序栈</b>或<b>链栈</b>存储均可，但以顺序栈更常见.</li>
<li><b>栈的操作：</b>(例子用的是链栈)<blockquote>
<ul>
<li><b>入栈：</b><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(LinkStack*&amp; S,<span class="type">char</span> e)</span>		<span class="comment">//进栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkStack* p;</span><br><span class="line">p = <span class="keyword">new</span> LinkStack;</span><br><span class="line">p-&gt;elem = e;</span><br><span class="line"></span><br><span class="line">p-&gt;next = S-&gt;next;</span><br><span class="line">S-&gt;next = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><b>出栈：</b><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">(LinkStack*&amp; S)</span>			<span class="comment">//出栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkStack* p;</span><br><span class="line"><span class="keyword">if</span> (S-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;栈为空，出栈失败！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p = S-&gt;next;</span><br><span class="line">S-&gt;next = p-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><b>取栈顶元素：</b><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkStack <span class="title">GetStackTop</span><span class="params">(LinkStack* S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(S-&gt;!=<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> S-&gt;next;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a><b>队列</b></h3><p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E9%98%9F%E5%88%97.gif" alt="队列的结构" title="队列"></p>
<blockquote>
<ul>
<li>队列也是一种特殊的数据结构，它的运算规则为<b>先进先出</b>。</li>
<li>对于队列来说，常见操作为<b>出队</b>和<b>入队</b></li>
<li>用<b>顺序队</b>或<b>链队</b>均可，以<b>循环顺序队列</b>更常见。</li>
<li><b>队列的操作：</b>(例子用的是链队)<blockquote>
<ul>
<li><b>出队：</b><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deQueue</span><span class="params">(LinkQuNode*&amp; q, <span class="type">char</span>&amp; e)</span>		<span class="comment">//e用来存储出队的数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DataNode* t; <span class="type">char</span> temp;</span><br><span class="line"><span class="keyword">if</span> (q-&gt;rear == <span class="literal">NULL</span>)		<span class="comment">//队列为空</span></span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;队列为空！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">t = q-&gt;front;</span><br><span class="line"><span class="keyword">if</span> (q-&gt;front == q-&gt;rear)	<span class="comment">//队列只有一个元素</span></span><br><span class="line">&#123;</span><br><span class="line">	temp = q-&gt;front-&gt;data;</span><br><span class="line">	q-&gt;front = q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>		<span class="comment">//队列有多个元素</span></span><br><span class="line">&#123;</span><br><span class="line">	temp = q-&gt;front-&gt;data;</span><br><span class="line">	q-&gt;front = q-&gt;front-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">e = t-&gt;data;</span><br><span class="line"><span class="keyword">delete</span> t;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;出队的元素为：&quot;</span> &lt;&lt;temp&lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;出队成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><b>入队：</b><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">enQueue</span><span class="params">(LinkQuNode*&amp; q, <span class="type">char</span> e)</span>	<span class="comment">//入队</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DataNode* p;</span><br><span class="line">p = <span class="keyword">new</span> DataNode;</span><br><span class="line">p-&gt;data = e;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (q-&gt;rear == <span class="literal">NULL</span>)</span><br><span class="line">	q-&gt;front = q-&gt;rear = p;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	q-&gt;rear-&gt;next = p;</span><br><span class="line">	q-&gt;rear = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<p><b>补充：</b><br>对与栈和队列，C++里有相应的头文件可以直接使用。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>基础学科</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>查找算法</title>
    <url>/2020/12/28/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="1、顺序查找"><a href="#1、顺序查找" class="headerlink" title="1、顺序查找"></a>1、顺序查找</h3><blockquote>
<p><b>顺序查找</b>是最简单的查找算法，它思路是直接从表的一端开始向另一端和待查元素k作比较，如果匹<br>配则直接输出查找结果，不匹配则继续向下查找，直到查找完毕。</p>
</blockquote>
<p><b>代码如下：</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">SeqSearch</span><span class="params">(RecType R[],<span class="type">int</span> n, KeyType k)</span> 	<span class="comment">//n为表R的长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n &amp;&amp; R[].key!=k)</span><br><span class="line">    &#123;</span><br><span class="line">        i++; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=n)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">//没找到的话返回0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	<span class="keyword">return</span> i+<span class="number">1</span>;	<span class="comment">//找到的话返回元素在表中的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><b>顺序查找</b>的时间复杂度级别一般为o(n)，空间复杂度为o(0)。该算法适用绝大多数的查找。</p>
</blockquote>
<h3 id="2、折半查找"><a href="#2、折半查找" class="headerlink" title="2、折半查找"></a>2、折半查找</h3><blockquote>
<p><b>折半查找</b>又称二分查找，在使用折半查找时必须将要查表排成<b>有序表</b>，它的基本思路为：在表中取low、mid、high三个点，将表分为两份。让要查元素和下表为mid的元素进行比较，如果匹配则直接输出要查元素的位置，如果小于或大于下标为mid的元素，那就将大于或小于mid元素的那半部分删去，在小于mid元素的那部分重新设置low、mid、high三个点，以此循环，如果到low&#x3D;high也没匹配到，那么就返回0。</p>
</blockquote>
<blockquote>
<p><b>代码如下：</b></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinSearch</span><span class="params">(RecType R[],<span class="type">int</span> n,KeyType k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>;<span class="type">int</span> high = n<span class="number">-1</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">	mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(k==R[mid].key)</span><br><span class="line">	    <span class="keyword">return</span> mid+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(k&lt;R[mid].key)</span><br><span class="line">	    high=mid<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	    low=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><b>折半查找</b>是查找里比较快速的算法，其时间复杂度为n(log2 N)，空间复杂度为o(1)。<b>但是有个限制条件，那就是查询的表必须是有序的。</b></p>
</blockquote>
<p>。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>基础学科</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>树与二叉树</title>
    <url>/2021/01/30/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="树"><a href="#树" class="headerlink" title="树"></a><b>树</b></h3><h4 id="树的定义："><a href="#树的定义：" class="headerlink" title="树的定义："></a><b>树的定义：</b></h4><blockquote>
<p><b>树</b>是n(n&gt;&#x3D;0)个结点的有限集合，它或为空树(n&#x3D;0),或为非空树，对于非空树：</p>
<blockquote>
<ul>
<li>有且只有一个称之为根的结点。</li>
<li>除根结点之外的其余结点可分为m(m&gt;0)个互不相交的有限集$T_1,T_2,…,T_m$，其中每一个集合本身又是一棵树，且称为根的<b>子树</b>。</li>
</ul>
</blockquote>
<p><b>树的结构：</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="树的结构" title="树的结构"><br><b>树的表示方法：</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%A0%91%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95(1).png" alt="树的表示" title="树的表示"><br><b>树的结点代码：</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line">DataType Elem;</span><br><span class="line">Tree *child1;		<span class="comment">//以下都是树的孩子结点</span></span><br><span class="line">Tree *child2;</span><br><span class="line">Tree *child3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a><b>二叉树</b></h3><blockquote>
<p><b>二叉树的定义：</b></p>
<blockquote>
<ul>
<li>有且仅有一个称之为根的结点 </li>
<li>除根以外的其余结点分为两个互不相交的子集$T_1$和$T_2$，分别称为T的<b>左子树</b>和<b>右子树</b>，而这两棵子树又是一棵二叉树。<br><b>二叉树的结构：</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" alt="二叉树的结构" title="二叉树的结构"><br><b>二叉树的结点代码：</b></li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BTree</span></span><br><span class="line">&#123;</span><br><span class="line">DataType Elem;</span><br><span class="line">BTree *lchild;		</span><br><span class="line">BTree *rchild;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a><b>满二叉树</b></h4><blockquote>
<p><b>定义：</b><br>深度为k，且拥有$2^{k}-1$个结点的二叉树。<br><b>例如：</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="满二叉树的结构" title="满二叉树的结构"></p>
</blockquote>
<h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a><b>完全二叉树</b></h4><blockquote>
<p><b>定义：</b><br>深度为k的，有n个结点的二叉树，当且仅当每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应。<br><b>例如：</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" alt="完全二叉树的结构" title="完全二叉树的结构"></p>
</blockquote>
<h4 id="二叉树的遍历："><a href="#二叉树的遍历：" class="headerlink" title="二叉树的遍历："></a><b>二叉树的遍历：</b></h4><blockquote>
<p>二叉树的遍历主要有三种：</p>
<ul>
<li><b>先序遍历：</b>遍历顺序：根结点-&gt;左子树-&gt;右子树</li>
<li><b>中序遍历：</b>遍历顺序：左子树-&gt;根结点-&gt;右子树</li>
<li><b>后序遍历：</b>遍历顺序：左子树-&gt;右子树-&gt;根结点<br>遍历可以分为<b>递归型</b>和<b>非递归型</b>。</li>
<li><b>递归型：</b>（以先序遍历为例）<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BTree *T)</span>		</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;T-&gt;data;			<span class="comment">//根结点</span></span><br><span class="line"><span class="built_in">PreOrderTraverse</span>(T-&gt;lchild);	<span class="comment">//遍历左子树</span></span><br><span class="line"><span class="built_in">PreOrderTraverse</span>(T-&gt;rchild);	<span class="comment">//遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><b>非递归型：</b>（以中序遍历为例）<br><b>思路：</b></li>
<li>初始化一个空栈S，指针p指向根结点。</li>
<li>申请一个结点空间q，用来存放栈顶弹出的元素。</li>
<li>当p非空或栈S非空时，循环执行以下操作：<blockquote>
<ul>
<li>如果p非空，将p进栈，p指向该结点的左孩子。</li>
<li>如果p为空，则弹出栈顶元素并访问，将p指向该结点的右孩子。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id=""><a href="#" class="headerlink" title=""></a><b></b></h4>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>基础学科</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>文件管理</title>
    <url>/2022/08/11/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="一、文件系统基础"><a href="#一、文件系统基础" class="headerlink" title="一、文件系统基础"></a>一、文件系统基础</h2><h3 id="1、文件系统的基本概念"><a href="#1、文件系统的基本概念" class="headerlink" title="1、文件系统的基本概念"></a>1、文件系统的基本概念</h3><blockquote>
<p><strong>文件：</strong>文件是以计算机硬盘为载体的存储在计算机上的信息集合，文件可以是文本文档、图片、程序等。在用户进行的输入、输出中，是以文件作为基本单位的。</p>
<p><strong>文件系统：</strong>操作系统中提供的一个文件管理系统。</p>
<p><strong>文件的属性：</strong></p>
<blockquote>
<ul>
<li><strong>名称：</strong>文件名称是唯一的，以易读取的形式保存</li>
<li><strong>标识符：</strong>标识符是系统内文件的唯一标签，通常为数字，对用户透明的一种内部名称</li>
<li><strong>类型：</strong>指文件的种类，常见的有.txt、.jpg、.mp4等文件类型</li>
<li><strong>位置：</strong>指向设备和设备上文件的指针</li>
<li><strong>大小：</strong>指文件所占的空间大小</li>
<li><strong>保护：</strong>指对文件进行保护的访问控制信息</li>
<li><strong>时间、日期和用户标识：</strong>文件创建、上次修改和上次访问的相关信息，用于保护和追踪文件的使用</li>
</ul>
</blockquote>
<p><strong>文件的基本操作：</strong></p>
<blockquote>
<p>​        文件是一种抽象的数据类型，对于文件的操作。操作系统提供了系统调用，它可以对文件进行<strong>创建、读取、写、重定位、删除</strong>和<strong>截断</strong>。</p>
<ul>
<li><strong>创建文件：</strong>创建文件可以分为两步：①、在文件系统中为文件找到空间；②、在目录中为新文件创建条目。</li>
<li><strong>写文件：</strong>通过执行write系统调用，指明文件名称和要写入文件的内容。系统需要为该文件维护一个写位置的指针，每当发生写操作时，便更新写指针。</li>
<li><strong>读文件：</strong>通过执行read系统调用，指明文件名称和要读入文件块的内存位置。读文件时也需要使用一个指针，而对一个文件在同一时刻只能是读或写，因此读写可以共用一个指针</li>
<li><strong>文件重定位：</strong>按照某条件搜索目录，不会读、写文件</li>
<li><strong>删除文件：</strong>先从目录中找到要删除文件的目录项，使之成为空项，然后回收该文件所占用的存储空间</li>
<li><strong>截断文件：</strong>允许文件所有属性不变，只删除文件内容，使文件长度变为0</li>
</ul>
<p><strong>注意：</strong>以上的读文件和写文件都需要用到<strong>文件的打开（open）和关闭（close）</strong>两个操作.</p>
</blockquote>
</blockquote>
<h3 id="2、文件的逻辑结构"><a href="#2、文件的逻辑结构" class="headerlink" title="2、文件的逻辑结构"></a>2、文件的逻辑结构</h3><blockquote>
<p>​        文件的逻辑结构是指文件的组织形式，文件的<strong>物理结构</strong>是从现实观点出发看到的文件在外存上的存储组织形式，与存储介质特性密切相关。文件的<strong>逻辑结构</strong>指的是数据在逻辑上是如何组织起来的，与存储介质特性无关。根据逻辑结构的不同，可以将文件划分为：<strong>无结构文件</strong>和<strong>有结构文件</strong>两种</p>
<ul>
<li><p><strong>无结构文件</strong></p>
<blockquote>
<p>​        无结构文件又称为<strong>流式文件</strong>，无结构文件将数据<strong>以字节为单位，将数据按顺序组织成记录并累积、保存</strong>（实际上就是按字节流的顺序存储数据）</p>
</blockquote>
</li>
<li><p><strong>有结构文件</strong></p>
<blockquote>
<p>​        有结构文件又称<strong>记录式文件</strong>，有结构文件将数据分为一个个的<strong>数据项</strong>每一个数据项有统一的格式，根据数据项中的记录是否可变长，又可以分为：<strong>可变长记录</strong>和<strong>定长记录</strong></p>
<ul>
<li><p><strong>顺序文件：</strong></p>
<blockquote>
<p>​        文件中的记录一个接一个地顺序排列，记录可以是定长或可变长的，可以<strong>顺序存储</strong>或以<strong>链式形式存储</strong>。顺序文件有以下两种结构：<strong>串结构</strong>（记录之间的顺序与关键字无关，通常顺序由时间决定）和<strong>顺序结构</strong>（文件中的所有记录按关键字排序）</p>
<p><strong>特点：</strong>在读写一大批记录时，顺序结构的文件具有极好的效率；但顺序文件对于修改、增加和删除等操作就相对繁琐。</p>
<p><strong>分类：</strong></p>
<blockquote>
<p><strong>链式存储：</strong>无论定长&#x2F;可变长记录，都无法实现随机存取，每次只能从第一个记录开始依次往后查找。</p>
<p><strong>顺序存储：</strong></p>
<blockquote>
<ul>
<li><p><strong>可变长记录：</strong>无法实现随机存储，因为每一条记录的长度可不同</p>
</li>
<li><p><strong>定长记录：</strong>可实现随机存取</p>
<blockquote>
<ul>
<li>采用<strong>串结构</strong>，无法快速找到某关键字对应的记录</li>
<li>采用<strong>顺序结构</strong>，可快速找到某关键字对应的记录</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><p><strong>索引文件：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6.png" alt="索引文件"></p>
<p>​        建立一张索引表，每条记录对应一个索引项，而每个索引项都有一个指针指向相应的物理块（这些物理块可以离散地存放，<strong>类似于内存管理中的页表</strong>）</p>
<p><strong>特点：</strong>索引表本身就是定长记录的顺序文件，因此可以快速查找到某一记录的索引项，而在物理地址上的记录块可以离散存储，因此记录块不会被限制。因此索引文件常用于对信息处理的及时性要求比较高的场合；但存储索引表也需要一定的空间，因此使用索引文件结构时，可能需要额外的地址空间（空间换时间策略）</p>
</blockquote>
</li>
<li><p><strong>索引顺序文件</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6.png" alt="索引顺序文件"></p>
<p>​        索引顺序文件是索引文件和顺序文件思想的结合。在索引顺序文件中：<strong>一组记录对应一个索引表项</strong>（即一个索引表项对应一组的记录）。因此在查询某条记录时，需要<strong>先查询索引表</strong>找到相应组，然后<strong>在相应组中找到需要的记录</strong>。</p>
<p><strong>注意：</strong>索引顺序文件可以根据需要分为多级的文件结构，即</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95%E8%A1%A8.png" alt="多级索引表"></p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="3、文件目录结构"><a href="#3、文件目录结构" class="headerlink" title="3、文件目录结构"></a>3、文件目录结构</h3><blockquote>
<p><strong>文件控制块和索引结点</strong></p>
<blockquote>
<ul>
<li><p><strong>文件控制块</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%9D%97.png" alt="文件控制块"></p>
<p>​        如图中红框所表示的就是一个<strong>文件控制块（FCB）</strong>，而多个文件控制块组成的集合被称为<strong>文件目录</strong>（注意，文件目录也是一种文件）。</p>
<p>​        当在目录中创建一个新文件，系统会为其分配一个FCB并存放在文件目录中，成为<strong>目录项</strong>（就是FCB）。</p>
<p><strong>FCB主要包括以下信息：</strong></p>
<blockquote>
<ul>
<li><strong>基本信息</strong>，如<strong>文件名、文件的物理地址</strong>（最重要，文件检索时所使用的两个信息）、文件的逻辑结构、文件的物理结构等</li>
<li><strong>存取控制信息</strong>，如文件的存取权限等</li>
<li><strong>使用信息</strong>，如文件建立时间、修改时间等</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>索引结点</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E7%B4%A2%E5%BC%95%E7%BB%93%E7%82%B9.png" alt="索引结点"></p>
<p>​        在检索目录文件时，一般只用到了文件名，而仅当找到一个目录项时，才需要从该目录项中读出该文件的物理地址。因此在文件控制块的基础上，我们可以在找到相应文件夹时，才将相关信息放入内存中。</p>
<p>​        使用索引结点时，目录表只每一项只有<strong>文件名</strong>和<strong>索引指针</strong>。文件名在查找时用，而索引结点指针则指向一个索引结点，在索引结点内存放着对应文件名的详细信息（如物理地址、逻辑结构、权限信息等），且只有用户访问时，才会将这些信息读入内存中。这样一来可以<strong>减少目录项的长度</strong>，降低其冗余值。同时也可以降低目录存放所需的磁盘块，从而<strong>加快读取速度</strong>。（本质就是文件控制块的优化版）</p>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>目录结构</strong></p>
<blockquote>
<p>​        在一个文件系统中，对目录项的操作有以下几种：搜索、创建、删除、显示、修改。而操作时，常见以下几种目录结构：</p>
<ul>
<li><p><strong>单级目录结构：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E5%8D%95%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="单级目录结构"></p>
<p>在整个文件系统中之间了一张目录表，每个文件占一个目录项。</p>
<p>在创建新的文件目录时，必须先检索所有目录项是否有“重名”现象，只有确认没有重名目录项后，才能在目录表中创建并加入一个新的目录项。</p>
<p><strong>特点：</strong></p>
<blockquote>
<ul>
<li>单级目录结构实现了“按名存取”，但查询速度慢、文件不能重名等</li>
<li>在单级目录结构中系统难以实现共享（多人容易造成文件重名），即<strong>不适用于多用户的操作系统</strong></li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>两级目录结构：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E4%B8%A4%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="两级目录结构"></p>
<p>为了提高文件系统的共享性，在单级文件系统的基础上，又提出了两级文件系统。将文件目录分为<strong>主文件目录</strong>（用于记录不同用户的文件目录）和<strong>用户文件目录</strong>（每个用户专属的文件目录）。</p>
<p>这样一来，在两个不同用户文件目录中，就可以放置同名的文件了。</p>
<p><strong>特点：</strong>两级目录依旧缺乏灵活性，且不能对文件进行分类。</p>
</blockquote>
</li>
<li><p><strong>多级目录结构（树形目录结构）：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E5%A4%9A%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="多级目录结构"></p>
<p>在两级目录结构的基础上，进一步拓展了文件目录的层次关系，将其变成了多级的目录结构。</p>
<p>在多级的目录结构中，只要在不同目录下，文件是可以重名的。而且其结构如图.</p>
<p>系统在找相应的文件时，假如寻找图中的自拍.jpg</p>
<blockquote>
<ul>
<li>将根目录读取到内存中，找到照片这一项</li>
<li>跟据照片，找到其目录，读取到内存中，找到2015-08这一项</li>
<li>找到2015-08这个目录中自拍.jpg，然后再去磁盘中将相应的文件读取到内存中</li>
</ul>
<p>因此<strong>如果文件所在位置越深，那么需要读取磁盘的次数就越多</strong></p>
</blockquote>
<p><strong>特点：</strong>增加了磁盘读取的次数；不便于文件间的共享</p>
<p><strong>补充：</strong></p>
<blockquote>
<ul>
<li><strong>绝对路径：</strong>从根目录出发的路径</li>
<li><strong>相对路径：</strong>从当前目录出发的路径</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>无环图目录结构：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%97%A0%E7%8E%AF%E5%9B%BE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="无环图目录结构"></p>
<p>在树型目录结构的基础上，又增加了一些指向同一结点的有向边，使得整个目录变成一个<strong>有向无环图</strong>。可以增加系统的可共享性。</p>
<p><strong>注意：</strong></p>
<blockquote>
<p>对于无环图目录结构的文件删除，其操作与上面的目录结构有所不同：</p>
<ul>
<li><strong>每个共享结点中都设置了一个共享计数器</strong></li>
<li><strong>每当有一个用户接上这个共享结点时，计数器就加1</strong></li>
<li><strong>当用户删除这个结点时，仅删除这个用户目录的这一条边，且计数器减1</strong></li>
<li><strong>当这个共享结点的计数器为0时，才真正删除这个结点</strong></li>
</ul>
</blockquote>
</blockquote>
</li>
</ul>
<p><strong>注意：</strong></p>
<blockquote>
<p>这里提到的每一个目录中的一项都代表这一个文件，即一个目录项代表一个文件。整个目录表才能代表熟知的目录。</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="4-、文件系统层次结构"><a href="#4-、文件系统层次结构" class="headerlink" title="$4^*$、文件系统层次结构"></a>$4^*$、文件系统层次结构</h3><blockquote>
<img src="/picture/学习/操作系统上的图/文件管理/文件系统层次结构.png" alt="文件系统层次结构" style="zoom:67%;" />

<ul>
<li><strong>用户接口</strong>：为用户提供文件及目录的相关调用，如新键、打开、读写、关闭、删除文件，建立、删除目录等</li>
<li><strong>文件目录系统</strong>：主要管理文件目录，如过来活跃文件目录表、用户进程的打开目录表、存储设备上的文件目录结构等</li>
<li><strong>存取控制模块</strong>：对用户的访问请求与FCB中指示的访问控制权限进行比较，确定访问是否合法</li>
<li><strong>逻辑文件系统与文件信息缓冲区</strong>：将用户要读写的逻辑记录转化成文件逻辑结构内的相应块号</li>
<li><strong>物理文件系统</strong>：把逻辑结构对应的块号转化成实际的物理地址</li>
<li><strong>辅助分配模块</strong>：负责分配磁盘的空闲空间和回收磁盘空间</li>
<li><strong>设备管理模块：</strong>分配设备读写用的缓冲区、磁盘调度、启动设备、设备中断处理、释放读写缓冲区、释放设备等</li>
</ul>
</blockquote>
<h3 id="5、文件系统的全局结构"><a href="#5、文件系统的全局结构" class="headerlink" title="5、文件系统的全局结构"></a>5、文件系统的全局结构</h3><blockquote>
<p><strong>磁盘的格式化</strong></p>
<blockquote>
<ul>
<li><p><strong>原始磁盘：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E5%8E%9F%E5%A7%8B%E7%A3%81%E7%9B%98.png" alt="原始磁盘"></p>
<p>指一块刚被生产出来的磁盘，上面还没有划分扇区</p>
</blockquote>
</li>
<li><p><strong>物理格式化：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E7%89%A9%E7%90%86%E6%A0%BC%E5%BC%8F%E5%8C%96.png" alt="物理格式化"></p>
<p>即低级格式化，为磁盘划分扇区并检测坏扇区，并且使用备用扇区来替换坏扇区。（这个替换是磁盘驱动自动完成的，对操作系统来说是透明的）</p>
</blockquote>
</li>
<li><p><strong>逻辑格式化：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E9%80%BB%E8%BE%91%E6%A0%BC%E5%BC%8F%E5%8C%96.png" alt="逻辑格式化"></p>
<ul>
<li><strong>逻辑格式化：</strong>磁盘分区（分卷），完成各分区的文件系统初始化（即灰色部分的数据就是此时写入的）</li>
<li>引导块的内容在第一章中操作系统的引道中有详细说明</li>
<li>i结点区就是文件系统连续存放索引结点的地方</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>文件系统在内存中的结构</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="文件系统在内存中的结构"></p>
<ul>
<li><p>在内存中，存在着三部分：</p>
<blockquote>
<ul>
<li><strong>目录缓存：</strong>存放着曾经打开过的文件的FCB（用户第二次打开时可以直接查询缓存，不用再查询外存，提高效率）</li>
<li><strong>系统打开文件表：</strong>记录当前系统中各文件的打开情况（打开计数指的是该文件当前被多少各用户打开）</li>
<li><strong>进程(用户)打开文件表：</strong>该进程的打开文件表</li>
</ul>
</blockquote>
</li>
<li><p>文件打开顺序：</p>
<blockquote>
<ul>
<li>根据路径将相应文件的FCB读取到缓存中（或检查缓存中是否有相应文件的FCB）</li>
<li>将相应文件的FCB复制到系统打开文件表</li>
<li>在进程（用户）打开文件表中新键一个条目，并返回<strong>文件描述符（文件句柄）</strong></li>
<li>进程（户用）就可以用文件描述符（文件句柄）对相应文件进行操作</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<h3 id="6、虚拟文件系统"><a href="#6、虚拟文件系统" class="headerlink" title="6、虚拟文件系统"></a>6、虚拟文件系统</h3><blockquote>
<p><strong>虚拟文件系统</strong></p>
<blockquote>
<p>​        在日常使用中，可能会遇到一个系统中出现多个文件系统（磁盘、移动硬盘、U盘），而这些文件系统之间的调用函数各不相同，在使用的时候非常不方便，因此引入一个虚拟文件系统对此进行统一管理。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png" alt="虚拟文件系统"></p>
<ul>
<li><p>向上层用户进程提供统一标准的系统调用接口，并且屏蔽了底层具体文件系统的实现差异</p>
</li>
<li><p>虚拟文件系统要求下层的文件系统必须实现规定标准的函数功能，如open&#x2F;read&#x2F;write</p>
</li>
<li><p>为不同的文件系统的目录项<strong>提供一个统一的表示方式</strong></p>
<blockquote>
<img src="/picture/学习/操作系统上的图/文件管理/v结点.png" alt="v结点" style="zoom:60%;" />

<p>​        即无论是哪种文件系统的目录项，在打开一个文件后，虚拟文件系统会给它创建一个v结点，并且将相应的信息复制到v结点中。</p>
<p><strong>注意：</strong> <strong>v结点只会存在于内存中，i结点既可被调入内存中，也会存在磁盘中</strong></p>
<ul>
<li><p><strong>函数功能指针：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD%E6%8C%87%E9%92%88.png" alt="函数功能指针"></p>
<p>每个v结点的函数功能指针都会指向它所属的文件系统所提供的具体函数。（即v结点可以通过函数功能指针来找到相应的函数）</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>文件系统的挂载</strong></p>
<blockquote>
<p>文件系统的挂载需要做以下的事：</p>
<ul>
<li>在虚拟文件系统中注册新挂载的文件系统。即在<strong>内存中的挂在表（mount table）</strong>中写入该文件系统的相关信息</li>
<li>新挂载的文件系统要向虚拟文件系统提供一个<strong>函数地址列表</strong>（相应文件系统的函数地址）</li>
<li>将新文件系统加到<strong>挂载点</strong>，即将新文件系统挂载到某个父目录之下</li>
</ul>
</blockquote>
</blockquote>
<h2 id="二、文件系统实现"><a href="#二、文件系统实现" class="headerlink" title="二、文件系统实现"></a>二、文件系统实现</h2><h3 id="1、文件分配方式（文件的物理结构）"><a href="#1、文件分配方式（文件的物理结构）" class="headerlink" title="1、文件分配方式（文件的物理结构）"></a>1、文件分配方式（文件的物理结构）</h3><blockquote>
<p>文件分配方式就是指当要存储新文件到磁盘上时，操作系统系统要按照什么样的方式给它分配空间。</p>
<p><strong>前提知识：</strong></p>
<blockquote>
<ul>
<li>类似于内存管理，磁盘中的空间也是分成许多个等大的小分块，且操作系统以这些分块为基本单位来给文件分配空间</li>
<li>磁盘中的分块一般与内存中的分页有着相同的大小</li>
<li>因为磁盘也是分成一小块一小块地，所以每个文件在存入磁盘时也会有一个表来记录文件的位置。（这与内存的分页很类似）</li>
<li>相同地，文件本身的记录表上的都是逻辑地址，在查询时需要经过地址转换（这与内存的分页也很类似）</li>
</ul>
</blockquote>
<ul>
<li><p><strong>连续分配</strong></p>
<blockquote>
<p><strong>思想：</strong>连续分配方法就是将一组连续的块分配给磁盘。</p>
<img src="/picture/学习/操作系统上的图/文件管理/连续分配.png" alt="连续分配" style="zoom:67%;" />

<img src="/picture/学习/操作系统上的图/文件管理/连续分配的记录表.png" alt="连续分配的记录表" style="zoom:67%;" />

<p>由于文件的物理地址和逻辑地址都是连续的，因此在进行<strong>地址转换</strong>时，可以直接：<strong>物理地址&#x3D;逻辑块号+初始块号</strong>（注意要判断是否越界）</p>
<p><strong>优点：</strong></p>
<blockquote>
<ul>
<li>可以支持<strong>顺序访问</strong>和<strong>直接访问（随机访问）</strong></li>
<li>访问磁盘时需要的寻道数和巡道时间最短</li>
</ul>
</blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<ul>
<li>文件长度不宜动态增加（因为增加时如果后面没有空闲位置，需要对整个文件进行搬迁，直到找到能放得下的位置）</li>
<li>反复增删文件会产生外部碎片（类似于内存管理中的连续分配）</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>链接分配</strong></p>
<blockquote>
<p>链式分配采取<strong>离散分配</strong>的方式，消除了外部碎片，因此可以提高磁盘的空间利用率。链式分配可以分为：<strong>隐式链接</strong>和<strong>显式链接</strong></p>
<ul>
<li><p><strong>隐式链接：</strong></p>
<blockquote>
<img src="/picture/学习/操作系统上的图/文件管理/隐式链接.png" alt="隐式链接" style="zoom:67%;" />

<ul>
<li><p>每个文件对应一个磁盘块的链表。</p>
</li>
<li><p>磁盘块可以分布在磁盘的任何地方。</p>
</li>
<li><p>除去最后一个磁盘块外，每个磁盘块都有指向下一个盘块的指针，而<strong>这些指针对用户是透明的</strong></p>
</li>
<li><p>当用户访问文件的某一个盘块时，只能先找到起始块号，然后使用<strong>顺序查找</strong>来查询所需要的盘块</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<blockquote>
<ul>
<li>无法直接访问某一盘块，只能顺序访问文件，且盘块指针会消耗一定的存储空间	</li>
<li>当链表中某一块的指针丢失时，会造成整个文件损坏</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>显式链接：</strong></p>
<blockquote>
<img src="/picture/学习/操作系统上的图/文件管理/显示链接.png" alt="显示链接" style="zoom:67%;" />

<ul>
<li>显示链接就是把用于链接物理块得指针，从每个物理块末尾中提取出来，<strong>显示地存放在内存得一张链接表中</strong></li>
<li>该表在整个磁盘中仅设置一张（即一个磁盘一张表），被称为<strong>文件分配表（FAT）</strong></li>
<li>读取文件某一块时，系统会先查链接表，然后根据查到得结果再去读取磁盘（只读一次，而隐式链接需要顺序地读取多次磁盘）</li>
</ul>
<p><strong>优点：</strong></p>
<blockquote>
<ul>
<li>方便拓展，不会产生外部碎片，</li>
<li>支持随机存取</li>
<li>相较于隐式链接，地址转换时不需要读取磁盘</li>
</ul>
</blockquote>
<p><strong>缺点：</strong>文件分配表需要占用一定内存空间</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>索引分配</strong></p>
<blockquote>
<p>​        索引分配允许文件离散地分配在各个磁盘块中，系统会为<strong>每个文件建立一张索引表</strong>，索引表中记录了文件各个逻辑块对应的物理块（类似于内存管理中的页表）。</p>
<p>​        存放索引表的磁盘块称为<strong>索引块</strong>，存放文件数据的磁盘块称为<strong>数据块</strong>。</p>
<img src="/picture/学习/操作系统上的图/文件管理/索引分配.png" alt="索引分配" style="zoom:67%;" />

<ul>
<li>每一个文件都有一个索引表</li>
<li>读取文件的某一块的内容时，需要先在该文件的FCB中，找到<strong>索引块</strong>；然后根据索引块上的索引表，找到需要的逻辑块号并找到对应的物理块号。</li>
</ul>
<p><strong>优点：</strong></p>
<blockquote>
<ul>
<li>索引分配方式支持随机访问</li>
<li>文件拓展耶很容易实现</li>
</ul>
</blockquote>
<p><strong>缺点：</strong>索引表需要占用一定的存储空间</p>
<p>假如一个磁盘块为1KB，一个索引表项4B，则一个磁盘块只能存放256个索引表（即一个索引块最多只能表示256KB大小的文件），对于超过大小的文件，通常有以下的解决方法：</p>
<blockquote>
<ul>
<li><p><strong>链接方案</strong></p>
<blockquote>
<p>当索引表太大时，可以将多个索引块链接起来存放，即</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E9%93%BE%E6%8E%A5%E6%96%B9%E6%A1%88.png" alt="链接方案"></p>
<p>当一个索引块存满后依旧不能完整表示整个文件，则<strong>空出一部分空间来表示下一个索引块的地址</strong>。</p>
<p><strong>缺点：</strong>如果需要查找最后一个索引块时，就需要顺序查找，因此执行效率低</p>
</blockquote>
</li>
<li><p><strong>多层索引</strong></p>
<blockquote>
<p>建立多层索引（类似于多级页表）。使用第一层索引块来指向第二层的索引块（当然还可以以此类推建立第三层、第四层的索引块），如图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95.png" alt="多级索引"></p>
<p>采用多层索引时，则<strong>各层索引表不能超过一个磁盘块</strong></p>
<p>如上图的结构，假设要查找1026好逻辑块，则</p>
<p>$1026&#x2F;256&#x3D;4$，$1026% 256&#x3D;2$,查找一级索引表中的4号索引表，再查找二级索引表中的2号逻辑块。</p>
<p>访问一个二级索引结构，则需要访问3次读磁盘的操作。</p>
</blockquote>
</li>
<li><p><strong>混合索引</strong></p>
<blockquote>
<p>多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含<strong>直接地址索引</strong>（直接指向数据块），又包含<strong>一级间接索引</strong>（单层索引表），还包含<strong>两级间接索引</strong>（两层索引表），如图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%B7%B7%E5%90%88%E7%B4%A2%E5%BC%95.png" alt="混合索引"></p>
<p>在混合索引表中，一般直接地址较多，且需要访问磁盘的次数最少，依次是一级间接索引，二级间接索引。</p>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
</li>
</ul>
<p><strong>三种分配方式的区别：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E4%B8%89%E7%A7%8D%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="三种分配方式的区别"></p>
</blockquote>
</blockquote>
<h3 id="2、文件存储空间管理"><a href="#2、文件存储空间管理" class="headerlink" title="2、文件存储空间管理"></a>2、文件存储空间管理</h3><blockquote>
<p>文件存储空间管理是指管理磁盘中未被分配的空闲块。</p>
<p><strong>文件存储器空间的划分和初始化：</strong></p>
<blockquote>
<img src="/picture/学习/操作系统上的图/文件管理/逻辑卷和物理盘的关系.png" alt="逻辑卷和物理盘的关系" style="zoom:67%;" />

<ul>
<li>逻辑卷是操作系统对物理盘的一个划分</li>
<li>一个逻辑卷可以分为<strong>目录区</strong>和<strong>文件区</strong>。</li>
<li>一个物理盘可以划分为多个逻辑卷，一个逻辑卷也可以由多个物理盘组成</li>
</ul>
</blockquote>
<p><strong>文件存储器空间管理：</strong></p>
<blockquote>
<p>​        文件存储设备分成许多大小相同的物理块，文件存储设备的管理实质上是对空间块的组织和管理（它包括空闲块的组织、分配和回收）。</p>
<ul>
<li><p><strong>空闲表法</strong></p>
<blockquote>
<p>​        空闲表法属于<strong>连续分配方式</strong>，与内存动态方式类似。系统为磁盘上所有空闲区建立了一张空闲盘块表，每个空闲区对应一个空闲表项。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E7%A9%BA%E9%97%B2%E8%A1%A8%E6%B3%95.png" alt="空闲表法"></p>
<ul>
<li>每一项表示一段空闲盘块。第一个空闲盘块：这段空闲盘块中的第一个；空闲盘块数：指这段空闲盘块中的个数</li>
</ul>
<p><strong>分配：</strong>与内存的动态分配类似，同样可以采用首次适应算法、循环首次适应算法等</p>
<p><strong>回收：</strong>在回收时，要注意回收区是否与空闲表的前区和后区相邻接，对相邻的要进行合并（即回收区块时，如果前后都是空闲区块，则需要将这两项空闲盘块表项进行合并）</p>
</blockquote>
</li>
<li><p><strong>空闲链表法</strong></p>
<blockquote>
<p>将所有空闲盘区拉成一条空闲链，根据空闲链的基本元素不同，可以把链表分成两类：</p>
<ul>
<li><p><strong>空闲盘块链</strong></p>
<blockquote>
<p>把磁盘上的所有空闲空间以盘块为单位拉成一条链</p>
<img src="/picture/学习/操作系统上的图/文件管理/空闲盘块链.png" alt="空闲盘块链" style="zoom:67%;" />
</blockquote>
</li>
<li><p><strong>空闲盘区链</strong></p>
<blockquote>
<p>把磁盘上的所有空闲盘区（每个盘区包含若干个盘块）为单位组成一条链</p>
<img src="/picture/学习/操作系统上的图/文件管理/空闲盘区链.png" alt="空闲盘区链" style="zoom:67%;" /></blockquote>
</li>
</ul>
<p><strong>分配：</strong>无论是哪种链接方式，分配时也可以使用与内存动态分区类似的算法，<strong>常用的是首次适应算法</strong></p>
<p><strong>回收：</strong>回收盘块时，同样要注意回收区相邻接的空闲盘区的合并问题</p>
<p><strong>注意：</strong>两种链接方式中，都需要分配一定的空间来指向下一个空闲块的地址；系统只需要保存头指针和尾指针。</p>
</blockquote>
</li>
<li><p><strong>位示图法</strong></p>
<blockquote>
<p>利用二进制的一位来表示磁盘中某一个磁盘块的使用情况，即磁盘上的每一个磁盘块都有一位二进制位与之对应。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E4%BD%8D%E7%A4%BA%E5%9B%BE%E6%B3%95.png" alt="位示图法"></p>
<ul>
<li>横向的称为<strong>字号</strong>；纵向的称为<strong>位号</strong>（实际上就是一个二维数组的行号和列号）</li>
<li>一对字号和位号（字号, 位号）可以转化成一个逻辑地址，反之也成立。</li>
<li>通常以“1”表示该盘块已分配，“0”表示该盘块未分配</li>
</ul>
<p><strong>分配：</strong>①、顺序扫描位示图，找到k个相邻或不相邻的“0”；②、根据字号、位号算出对应的盘块号，将相应盘块分配给文件；③、将分配的位设置为“1”</p>
<p><strong>回收：</strong>①、根据回收的盘块号计算出对应的字号、位号；②、将相应的二进制位设为“0”</p>
</blockquote>
</li>
<li><p><strong>成组链接法</strong></p>
<blockquote>
<p>​        为了适应大文件系统，UNIX系统中采用了<strong>成组链接法</strong>对磁盘空间块进行管理。</p>
<p>​        <strong>文件卷的目录区中</strong>专门用一个磁盘块作为“<strong>超级块</strong>”，当系统启动时就将超级块读入内存。并且保证内存与外存中的“超级块”数据一致</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%88%90%E7%BB%84%E9%93%BE%E6%8E%A5%E6%B3%95.png" alt="成组链接法"></p>
<ul>
<li>超级块中第一行记录的是该分组空闲盘块的数量</li>
<li>第二行的空闲块记录的是下一个分组的地址</li>
<li>第三行直到后面指的是可用的盘块地址（可以不连续）</li>
<li>第二行空闲块记录的是300，是一个新的分组，它的第一行也是表示该分组空闲盘块的数量，第二行记录的是下一个分组的地址，而后续的则记录的是可用的盘块地址</li>
<li>依次类推，直到最后一个分组，第二行用特殊数字-1表示本组就是最后一组</li>
</ul>
<p><strong>分配：</strong>检查本组空闲块是否足够，够则直接分配（分配时注意每个分组的第一块记录的是下一个分组的地址信息）；不够可以跨组分配</p>
<p><strong>回收：</strong>回收时注意本分组的空闲块是否已满，如果满了就需要新开一个分组，然后更改第二行空闲块的内容</p>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<h3 id="3、文件的基本操作"><a href="#3、文件的基本操作" class="headerlink" title="3、文件的基本操作"></a>3、文件的基本操作</h3><blockquote>
<ul>
<li><p><strong>创建文件</strong></p>
<blockquote>
<p>在用户创建文件的时候，系统在背后自动调用<strong>“create”系统调用</strong>，在进行系统调用时，需要提供以下几个参数：</p>
<ul>
<li>所需的外存空间大小</li>
<li>文件存放路径</li>
<li>文件名</li>
</ul>
<p>而上述参数都是可以由系统自动补全的。而操作系统在处理系统调用时，主要做了两件事：</p>
<ul>
<li><strong>在外存找到文件所需要的空间</strong></li>
<li>根据文件存放路径的信息找到该目录对应的目录文件，在目录中<strong>创建该文件对应的目录项</strong>（目录项中包含了文件名、文件在外存中的存放位置等信息）</li>
</ul>
</blockquote>
</li>
<li><p><strong>删除文件</strong></p>
<blockquote>
<p>在用户删除文件时，系统会自动调用<strong>“delete”系统调用</strong>，在进行系统调用时，需要提供以下几个参数：</p>
<ul>
<li>文件存放路径</li>
<li>文件名</li>
</ul>
<p>而上述参数都是可以由系统自动补全的。而操作系统在处理系统调用时，主要做了三件事：</p>
<ul>
<li>根据文件存放路径找到相应的目录文件，从目录中<strong>找到文件名所对应的目录项</strong></li>
<li>根据该目录项记录的文件在外存的存放位置、文件大小等信息，<strong>回收文件占用的磁盘块</strong></li>
<li>从目录表中<strong>删除文件对应的目录项</strong></li>
</ul>
</blockquote>
</li>
<li><p><strong>写文件</strong></p>
<blockquote>
<p>在进行写文件时，操作系统会自动调用<strong>write系统调用</strong>，然后系统调用会自动完成打开文件这一操作。</p>
<p>进程调用write系统调用时，需要指明是哪个文件（提供打开文件表中的索引号即可），还需要指明要写入多少数据、指明写入的数据要放在内存中的什么位置。</p>
</blockquote>
</li>
<li><p><strong>读文件</strong></p>
<blockquote>
<p>在进行读文件时，操作系统会自动调用<strong>read系统调用</strong>，将文件数据读入内存中。而系统调用会自动完成打开文件这一操作。</p>
<p>进程调用read系统调用时，需要指明是哪个文件（提供打开文件表中的索引号即可），还需要指明要读入多少数据、指明读入的数据要放在内存中的什么位置。</p>
</blockquote>
</li>
<li><p><strong>打开文件</strong></p>
<blockquote>
<p>在操作系统中，在对文件进行操作之前，需要先使用<strong>“open”系统调用</strong>，“打开文件”需要提供以下的参数：</p>
<ul>
<li>文件保存路径</li>
<li>文件名</li>
<li>要对文件的操作类型（如，只读操作，读写操作等）</li>
</ul>
<p>操作系统处理open系统调用时，主要做了几件事：</p>
<ul>
<li>根据文件存放路径找到对应的目录文件，从目录中<strong>找到文件名对应的目录项</strong>，并<strong>检查用户是否拥有该操作的权限</strong></li>
<li><strong>将目录项复制到内存中的“打开文件表”中</strong>，并将对应目录表的目的编号返回给用户。之后<strong>用户使用该编号来指明要操作的文件</strong>（此时文件被放到内存中了）</li>
</ul>
<p><strong>打开文件表：</strong></p>
<blockquote>
<p> <img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E8%A1%A8.png" alt="打开文件表"></p>
<ul>
<li>系统具有一个总的打开文件表</li>
<li>每个用户进程也有一个局部的打开文件表（只用于记录本进程打开的文件）</li>
<li><strong>打开计数器：</strong>对文件正在被打开的次数</li>
<li><strong>读写指针：</strong>指文件中读写的位置</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>关闭文件</strong></p>
<blockquote>
<p>进程使用完文件后，要“关闭文件”，操作系统在处理close系统调用时，主要做了几件事：</p>
<ul>
<li>将进程的打开文件表相应表项删除</li>
<li>回收分配给该文件的内存空间等资源</li>
<li>系统打开文件表的打开计数器减1，若count&#x3D;0，则删除对应表项</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="4、文件共享"><a href="#4、文件共享" class="headerlink" title="4、文件共享"></a>4、文件共享</h3><blockquote>
<p>文件共享可以使多个用户（进程）共享同一个文件，<strong>系统中只保留该文件的一个副本</strong>。现在常用的共享方式有以下两种：</p>
<ul>
<li><p><strong>基于索引结点的共享方式（硬链接）</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6_%E7%A1%AC%E9%93%BE%E6%8E%A5.png" alt="共享文件_硬链接"></p>
<p>​        硬链接是根据目录结构中提到的一种目录结构——索引结点，用户通过<strong>索引结点指针</strong>来共同指向一个索引结点（这个索引结点指向一个文件），从而达到共享文件的效果。</p>
<p><strong>注意：</strong></p>
<ul>
<li>索引结点上有一个参数Count，这个参数记录了<strong>链接到本结点的用户数</strong></li>
<li>用户删除相应文件时，只会删除相应的索引节点指针，然后相应索引结点中的Count会自动减1。直到Count&#x3D;0时，该文件才会从系统中删除</li>
<li>当有新用户需要连接这个文件时，该用户的目录表中会创建一个索引节点指针指向该索引结点，然后相应索引结点中的Count会自动加1</li>
</ul>
</blockquote>
</li>
<li><p><strong>利用符号链实现文件共享（软链接）</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB_%E8%BD%AF%E9%93%BE%E6%8E%A5.png" alt="文件共享_软链接"></p>
<p>​        软链接是可以让用户3使用到共享用户的文件，它由系统创建一个<strong>LINK类型的文件</strong>，该文件记录了通过User1访问文件1的存放路径（类似于Windows上的快捷方式）</p>
<p><strong>注意：</strong></p>
<ul>
<li>软链接是在其它用户的硬链接的基础上实现的，因此如果该用户的硬链接断开，那么软连接也会随之失效（即无法访问目标文件）</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="5、文件保护"><a href="#5、文件保护" class="headerlink" title="5、文件保护"></a>5、文件保护</h3><blockquote>
<p>​        文件保护是为了防止文件共享时可能会导致文件被破坏或未经批准的用户修改文件，其主要手段为：<strong>口令保护</strong>、<strong>加密保护</strong>、<strong>访问控制</strong>。</p>
<ul>
<li><p><strong>口令保护</strong></p>
<blockquote>
<p>​        口令保护是指用户在创建一个文件时提供一个<strong>口令</strong>，而系统会在创建文件PCB时放入相应的口令。同时所有用户在访问该文件时都需要提供该口令。</p>
<p><strong>优点：</strong>开销不大，匹配迅速</p>
<p><strong>缺点：</strong>口令直接存放在系统内部，不够安全</p>
</blockquote>
</li>
<li><p><strong>加密保护</strong></p>
<blockquote>
<p>​        加密保护是指用户对文件进行加密，文件被访问时，需要用密钥来进行解密后才会显示原始数据。如</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E5%8A%A0%E5%AF%86%E4%BF%9D%E6%8A%A4.png" alt="加密保护"></p>
<ul>
<li>即如果使用的不是正确的密码，那么解密出来的结果依旧会是乱码数据</li>
</ul>
<p><strong>优点：</strong>安全性高</p>
<p><strong>缺点：</strong>解密过程需要消耗一定时间</p>
</blockquote>
</li>
<li><p><strong>访问控制</strong></p>
<blockquote>
<p>​        访问控制是指<strong>根据用户身份进行控制</strong>，即在每个文件和目录中增加一个<strong>访问控制表</strong>，上面记录了每个用户名及其允许访问的类型。如</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6.png" alt="访问控制"></p>
<ul>
<li>通过0和1来表示是否拥有相应权限</li>
</ul>
<p>而随着用户越来越多，后来又多了一种优化方式，即为每个文件和目录创建一个<strong>精简的访问列表</strong>，上面记录的是一个分组的名字及其允许访问的类型，而一个组里可以又多个不同的用户。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E7%B2%BE%E7%AE%80%E7%9A%84%E8%AE%BF%E9%97%AE%E5%88%97%E8%A1%A8.png" alt="精简的访问列表"></p>
<ul>
<li>这个列表也是存放在文件的PCB中</li>
<li>在同一个组内的所有用户对该文件的权限都是一样的</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="三、磁盘组织与管理"><a href="#三、磁盘组织与管理" class="headerlink" title="三、磁盘组织与管理"></a>三、磁盘组织与管理</h2><h3 id="1、磁盘的结构"><a href="#1、磁盘的结构" class="headerlink" title="1、磁盘的结构"></a>1、磁盘的结构</h3><blockquote>
<img src="/picture/学习/操作系统上的图/文件管理/磁盘结构.png" alt="磁盘结构" style="zoom:67%;" />

<ul>
<li><strong>磁盘：</strong>由表面涂有磁性唔知的金属或塑料构成的圆形盘片，通过一个称为<strong>磁头</strong>的导体线圈从磁盘存取数据</li>
<li><strong>盘面：</strong>磁盘盘片的一面</li>
<li><strong>磁道：</strong>指磁盘盘面上存储数据的一个同心圆（即盘面上的一圈就是一个磁道）</li>
<li><strong>扇区：</strong>将一个盘面划分为若干内角相同的扇形，这样盘面上的<strong>每个磁道</strong>就被分为若干段圆弧，每段圆弧叫做一个扇区（一个磁道上分割的才叫扇区）</li>
<li><strong>柱面：</strong>所有盘面上的统一磁道所构成的一个圆柱（空心圆柱）</li>
</ul>
<p>对于一个磁盘块，可以用（<strong>柱面号</strong>，<strong>盘面号</strong>（有时也叫磁头号），<strong>扇区号</strong>）来表示</p>
<p><strong>磁盘读取磁盘块的方法：</strong></p>
<blockquote>
<ul>
<li>根据柱面号移动磁臂，让磁头指向指定柱面</li>
<li>激活指定盘面对应的磁头</li>
<li>磁盘旋转过程中，指定的扇区会从磁头下划过，这样就可对指定扇区进行读写操作</li>
</ul>
</blockquote>
<p><strong>注意：</strong></p>
<blockquote>
<ul>
<li>磁盘中的信息存储密度不同，内侧的信息密度大于外侧的信息密度，且<strong>磁盘的存储空间大小取决于内侧的信息密度</strong></li>
<li>相邻磁道和扇区之间都会有一定的间隔进行分割</li>
<li>所有次有都连在统一各磁臂上，即所有磁头移动时方向一致</li>
<li>每个扇区大小固定，且<strong>一个扇区称为一个盘块</strong></li>
</ul>
</blockquote>
<p><strong>磁盘的分类：</strong></p>
<blockquote>
<p><strong>根据磁头：</strong></p>
<blockquote>
<ul>
<li><strong>固定头磁盘</strong>：每个磁道一个磁头，磁头不能移动的磁盘</li>
<li><strong>活动头磁盘</strong>：每一个磁面一个磁头，磁头可以移到不同磁道上的磁盘</li>
</ul>
</blockquote>
<p><strong>根据磁盘片：</strong></p>
<blockquote>
<ul>
<li><strong>固定盘磁盘：</strong>磁盘永久固定在磁盘驱动器内的磁盘</li>
<li><strong>可换盘磁盘：</strong>磁盘可移动和替换的磁盘</li>
</ul>
</blockquote>
</blockquote>
</blockquote>
<h3 id="2、磁盘调度算法"><a href="#2、磁盘调度算法" class="headerlink" title="2、磁盘调度算法"></a>2、磁盘调度算法</h3><blockquote>
<p><strong>磁盘操作时间计算</strong></p>
<blockquote>
<p>一次磁盘的读写操作的时间由<strong>寻找（寻道）时间、旋转延迟时间</strong>和<strong>传输时间</strong>决定</p>
<ul>
<li><p><strong>寻道时间</strong>$T_s$：将磁头移动到指定磁道所花费的时间</p>
<blockquote>
<ul>
<li><strong>启动磁头臂</strong>所需要的时间，假设为s</li>
<li><strong>移动磁头</strong>所需要的时间，假设磁头匀速移动，每跨越一个磁道耗时为m，总共需要跨越n条磁道，则</li>
</ul>
<p>$$<br>寻道时间T_s&#x3D;s+m\times n<br>$$</p>
</blockquote>
</li>
<li><p><strong>旋转延迟时间</strong>$T_r$：通过旋转磁盘，使磁头定位道目标扇区所需要的时间。</p>
<blockquote>
<p>假设磁盘转速为r，且找到目标扇区平均需要转$\frac{1}{2}$圈，因此<br>$$<br>T_r&#x3D;\frac{1}{2r}<br>$$</p>
</blockquote>
</li>
<li><p><strong>传输时间</strong>$T_t$：从硬盘读出或写入数据所经历的时间。</p>
<blockquote>
<p>这个时间取决于每次读写的字节数b和磁盘的转速r，假设N为一个磁道上的字节数即<br>$$<br>T_t&#x3D;\frac{b}{rN}\quad(其中\frac{b}{N}为需要转的圈数)<br>$$</p>
</blockquote>
</li>
</ul>
<p>因此，总的操作时间为：<br>$$<br>T_a&#x3D;T_s+\frac{1}{2r}+\frac{b}{rN}<br>$$</p>
</blockquote>
<p><strong>磁盘的调度算法：</strong></p>
<blockquote>
<ul>
<li><p><strong>先来先服务算法</strong>（FCFS）</p>
<blockquote>
<p>​        先来先服务算法<strong>根据进程请求访问磁盘的先后顺序进行调度</strong>，是一种最简单的调度算法。</p>
<p>​        假如磁盘的请求队列中的请求顺序分别为55，58，39，18，90，160，150，38，184，磁头的初始位置在100，那么它的调度顺序如下图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6.png" alt="先来先服务调度"></p>
<p>磁头一共移动了$45+3+19+21+72+70+10+112+146&#x3D;498$个磁道，平均寻找长度为$498&#x2F;9&#x3D;55.3$</p>
<p><strong>优点：</strong>实现简单，公平</p>
<p><strong>缺点：</strong>性能不佳，近乎于随机调度算法</p>
</blockquote>
</li>
<li><p><strong>最短寻找时间优先算法</strong>（SSTF）</p>
<blockquote>
<p>​        最短寻找时间优先算法会选择调度处理的磁道是<strong>当前磁头所在磁道距离最近的磁道</strong>，以便使每次寻找的时间最短（局部最优解）</p>
<p>​        假如磁盘的请求队列中的请求顺序分别为55，58，39，18，90，160，150，38，184，磁头的初始位置在100，那么它的调度顺序如下图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%9C%80%E7%9F%AD%E5%AF%BB%E6%89%BE%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95.png" alt="最短寻找时间优先算法"></p>
<p>磁头一共移动了$10+32+3+16+1+20+132+10+24&#x3D;248$个磁道，平均寻找长度为$248&#x2F;9&#x3D;27.5$</p>
<p><strong>注意</strong>：虽然SSTF算法每一步都寻找最优解，但是不一定是全局的最优解。</p>
<p><strong>优点：</strong>寻道时间短，效率高</p>
<p><strong>缺点：</strong>如果在某一区段内源源不断地出现新请求，那么可能会对其它区段内的请求造成“饥饿”现象</p>
</blockquote>
</li>
<li><p><strong>扫描算法</strong>（SCAN）</p>
<blockquote>
<p>​        在扫描算法中，<strong>磁头只有移动道最外侧磁道是才能往内移动，移动道最内侧磁道才能往外移动</strong>。</p>
<p>​        假如磁盘的请求队列中的请求顺序分别为55，58，39，18，90，160，150，38，184，磁头的初始位置在100，那么它的调度顺序如下图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E6%89%AB%E6%8F%8F%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.png" alt="扫描调度算法"></p>
<p>磁头一共移动了$50+10+24+16+110+32+3+16+1+20&#x3D;282$个磁道，平均寻道长度为$282&#x2F;9&#x3D;31.33$</p>
<p><strong>优点：</strong>不会产生饥饿现象，性能较好，平均寻道时间短</p>
<p><strong>缺点：</strong></p>
<blockquote>
<ul>
<li>只有到达最边上的磁道时才能改变磁道方向（很多时候都不用到最边上）</li>
<li>对于各个位置磁道的响应频率不平均</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>循环扫描算法</strong>（C-SCAN）</p>
<blockquote>
<p>​        在扫描算法的基础之上，<strong>规定磁头朝某个特定方向移动时才处理磁道访问请求，而返回时快速移动至始端而不处理任何请求</strong></p>
<p>​        假如磁盘的请求队列中的请求顺序分别为55，58，39，18，90，160，150，38，184，磁头的初始位置在100，那么它的调度顺序如下图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E5%BE%AA%E7%8E%AF%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95.png" alt="循环扫描算法"></p>
<p><strong>优点：</strong>比起扫描算法，对于各个位置磁道的响应频率都很平均</p>
<p><strong>缺点：</strong>依旧存在“只有到达最边上的磁道时才能改变磁道方向”的问题</p>
</blockquote>
</li>
<li><p><strong>LOCK算法</strong></p>
<blockquote>
<p>​        在扫描算法的基础之上，<strong>规定在磁头移动方向上已经没有别的请求时，就可以改变磁头的移动方向了</strong></p>
<p>​        假如磁盘的请求队列中的请求顺序分别为55，58，39，18，90，160，150，38，184，磁头的初始位置在100，那么它的调度顺序如下图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/LOCK%E7%AE%97%E6%B3%95.png" alt="LOCK算法"></p>
<p><strong>优点：</strong>比起扫描算法，不需要每次移动到最外侧或最内侧才改变磁头方向，使得寻道时间进一步缩短。</p>
<p>如果将LOCK于循环扫描相结合可以得到<strong>C-LOCK算法</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/C_LOCK%E7%AE%97%E6%B3%95.png" alt="C_LOCK算法"></p>
</blockquote>
</li>
</ul>
<p><strong>算法之间的总结：</strong></p>
<blockquote>
<ul>
<li><strong>先来先服务算法</strong>（SCFS）太简单，性能差，仅在请求队列长度接近于1时才较为理想</li>
<li><strong>最短寻找时间优先算法</strong>（SSTF）较为通用和自然</li>
<li><strong>扫描算法</strong>（SCAN）和<strong>循环扫描算法</strong>（C-SCAN）在磁盘负载较大时（磁盘请求多时）比较占优势</li>
</ul>
</blockquote>
</blockquote>
</blockquote>
<h3 id="3、减少磁盘旋转延迟的方法"><a href="#3、减少磁盘旋转延迟的方法" class="headerlink" title="3、减少磁盘旋转延迟的方法"></a>3、减少磁盘旋转延迟的方法</h3><blockquote>
<p>除了减少寻道时间外，减少延迟时间也是提高磁盘传输效率的重要	因素。</p>
<ul>
<li><p><strong>交替编号</strong></p>
<blockquote>
<p><strong>原理：</strong>磁头读完一个扇区后需要一段处理时间才可以继续读下一个扇区</p>
<p><strong>具体做法：</strong>让编号相邻的扇区在物理上不相邻</p>
<img src="/picture/学习/操作系统上的图/文件管理/交替编号.png" alt="交替编号" style="zoom:60%;" />

<p>这样一来，磁头每读完一个扇区后，就可以利用经过一些不需要读取的扇区的时间作为处理时间。等到处理结束后，就又可以读取下一个需要的扇区了</p>
</blockquote>
</li>
<li><p><strong>错位命名</strong></p>
<blockquote>
<p><strong>原理：</strong>连续地址有时会需要跨盘面读取，而所有盘面都是共同旋转的</p>
<p><strong>具体做法：</strong>让相邻盘面的扇区编号“错位”</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E9%94%99%E4%BD%8D%E5%91%BD%E5%90%8D.png" alt="错位命名"></p>
<p>这样一来，磁头如果需要跨盘面读取时，上盘面读取完，就可以恰好让下盘面的磁头在需要读取的扇区前。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="4、磁盘的管理"><a href="#4、磁盘的管理" class="headerlink" title="4、磁盘的管理"></a>4、磁盘的管理</h3><blockquote>
<ul>
<li><p><strong>磁盘初始化</strong></p>
<blockquote>
<ul>
<li><p><strong>低级格式化（物理格式化）：</strong></p>
<blockquote>
<p>磁盘在出厂时，根据需要<strong>将各个磁道划分为扇区</strong>，这一操作被称为物理格式化</p>
<img src="/picture/学习/操作系统上的图/文件管理/低级格式化.png" alt="低级格式化" style="zoom:60%;" />

<p>而一个扇区可以分为三部分：<strong>头部</strong>、<strong>数据区域</strong>（如512B大小）、<strong>尾部</strong>。</p>
<p>管理扇区所需要的各种数据结构一般存放在头、尾两个部分，如扇区校验码，扇区的指针等</p>
</blockquote>
</li>
<li><p><strong>逻辑格式化：</strong></p>
<blockquote>
<p>将磁盘分区，每个分区由若干柱面组成</p>
<img src="/picture/学习/操作系统上的图/文件管理/逻辑格式化2.png" alt="逻辑格式化2" style="zoom:60%;" />

<p>创建文件系统，包括创建文件系统的根目录、初始化存储空间管理所用的数据结构（如位示图、空闲分区表等）</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>引导块</strong></p>
<blockquote>
<p><strong>自举程序（初始化程序）：</strong>指计算机开机时需要进行一系列初始化的工作，完成这些工作的程序就称为<strong>自举程序</strong>。</p>
<ul>
<li>在过去，自举程序一般存放在ROM中，随着计算机生产时就写入，然后就无法更改了</li>
<li>现在，ROM中不在存放自举程序，而是存放<strong>自举装入程序</strong>，自举装入程序可以引导系统在磁盘上找到自举程序，并读入内存。而完整的自举程序放在磁盘的<strong>启动块</strong>中，启动块位于磁盘的固定位置。</li>
</ul>
<p><strong>补充：</strong>拥有启动分区的磁盘称为<strong>启动磁盘</strong>或<strong>系统磁盘</strong></p>
</blockquote>
</li>
<li><p><strong>坏块管理</strong></p>
<blockquote>
<ul>
<li><p>对于简单的磁盘，可以在逻辑格式化时，对整个磁盘进行坏块检查，标明哪些扇区时坏块。（注意：在这种方式中，<strong>坏块对操作系统不透明</strong>）</p>
</li>
<li><p>对于复杂的磁盘，<strong>磁盘控制器</strong>（磁盘设备内部的一个硬件部件）会维护一个坏块链表。在磁盘进行低级格式化时就会将坏块链进行初始化。同时保留一些备用扇区，用于替换坏块，这种方案称为<strong>扇区备用</strong>（注意：在这种方式中，<strong>坏块对操作系统透明</strong>）</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E5%9D%8F%E5%9D%97%E7%9A%84%E7%AE%A1%E7%90%86.png" alt="坏块的管理"></p>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="5、固态硬盘-SSD"><a href="#5、固态硬盘-SSD" class="headerlink" title="5、固态硬盘(SSD)"></a>5、固态硬盘(SSD)</h3><blockquote>
<p><strong>组成</strong></p>
<blockquote>
<img src="/picture/学习/操作系统上的图/文件管理/固态硬盘的结构.png" alt="固态硬盘的结构" style="zoom:50%;" />

<p>固态硬盘的存储技术：<strong>闪存技术</strong>，属于电可擦除ROM。</p>
<img src="/picture/学习/操作系统上的图/文件管理/固态硬盘结构.png" alt="固态硬盘结构"  />

<ul>
<li>固态硬盘上有许多的<strong>闪存芯片</strong></li>
<li>每个闪存芯片内又有许多的<strong>块</strong></li>
<li>每一个块又可以分成许多<strong>页</strong>（这一页相对应于磁盘中的一个扇区）</li>
</ul>
</blockquote>
<p><strong>读写性能特性</strong></p>
<blockquote>
<ul>
<li>固态硬盘<strong>以页为单位</strong>进行读写</li>
<li>但<strong>以块为单位</strong>进行擦除，其中每页可以写一次，读无数次。因此进行某一页的擦除时，<strong>需要将块内其它页全部都复制到一个新的块中</strong></li>
<li>支持随机访问，系统给定一个逻辑地址，闪存翻译层可以通过电路迅速定位到对应的物理地址</li>
<li>读取快，写入慢。因为要写的页有数据时，需要将其擦除后再写，而擦除操作又是以块为单位的，需要将其它无关页写到其它块中。</li>
</ul>
</blockquote>
<p><strong>与机械硬盘相比较</strong></p>
<blockquote>
<ul>
<li>SSD读写速度快，随机访问性能高，即通过电路控制访问位置；机械硬盘通过移动磁臂旋转磁盘控制访问位置，因此需要寻道时间和旋转延迟</li>
<li>SSD安静无噪声、耐摔抗震、能耗低，但造价高</li>
<li>SSD的一个块如果<strong>擦除次数过多</strong>，可能会坏掉；而机械硬盘的扇区不会因为写的次数太多而坏掉</li>
</ul>
</blockquote>
<p><strong>磨损均衡技术</strong></p>
<blockquote>
<p>因为SSD擦除时有损坏的风险，因此可以将擦除平均分布在各个块上，从而提升使用寿命</p>
<ul>
<li><strong>动态磨损均衡：</strong>写入数据时，优先选择累计擦除次数少的新闪存块</li>
<li><strong>静态磨损均衡：</strong>SSD监测并自动进行数据分配、迁移，让老旧的闪存块承担以读为主的存储任务，让较新的闪存块承担更多的写任务</li>
</ul>
</blockquote>
</blockquote>
<h2 id="四、其它补充"><a href="#四、其它补充" class="headerlink" title="四、其它补充"></a>四、其它补充</h2><blockquote>
<ul>
<li><p><strong>为什么磁盘的地址编码方式为（柱面号, 盘面号, 扇区号）：</strong></p>
<blockquote>
<p>假设某磁盘有8个柱面，4个盘面，8个扇区。现需要连续读取物理地址（00, 000, 000）~（00, 001, 111）的扇区</p>
<ul>
<li>若物理地址结构为（<strong>盘面号, 柱面号</strong>, 扇区号），读取（00, 000, 000）<del>（00, 000, 111）转两圈即可读完。但是读取（00, 001, 000）</del>（00, 001, 111）时，则<strong>需要启动磁头臂，将磁头转移到下一个磁道（柱面）上</strong></li>
<li>若物理地址结构为（<strong>柱面号, 盘面号</strong>, 扇区号），读取（00, 000, 000）<del>（00, 000, 111）转两圈即可读完。读取（00, 001, 000）</del>（00, 001, 111）时，只需要<strong>切换激活下一个盘面的磁头即可</strong></li>
</ul>
<p>因此两者相比较，明显读取连续地址时，直接切换盘面的磁头要比移动磁头要更省时间。</p>
</blockquote>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>基础学科</tag>
      </tags>
  </entry>
  <entry>
    <title>概率论与数理统计（一）</title>
    <url>/2021/01/23/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h3 id="1-1-一些概念"><a href="#1-1-一些概念" class="headerlink" title="1.1 一些概念"></a><b>1.1 一些概念</b></h3><blockquote>
<p><b>事件的概率:</b>一个事件发生的概率</p>
<ul>
<li><b>确定事件:</b>事件发生概率为确定值的事件<blockquote>
<ul>
<li><b>一定发生的事件：</b>事件发生的概率为1。</li>
<li><b>一定不发生的事件：</b>事件发生的概率为0。</li>
</ul>
</blockquote>
</li>
<li><b>随机事件：</b>事件发生的概率不确定，可能发生也可能不发生。</li>
</ul>
</blockquote>
<blockquote>
<p><b>试验：</b>对事件进行观察、测量和实验。<br><b>随机试验：</b></p>
<blockquote>
<ul>
<li>在相同条件下可重复。 </li>
<li>结果不止一个。</li>
<li>无法预测实验的结果。</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<p><b>事件：</b>随机试验的每一个结果。<br><b>随机事件：</b>可能发生也可能不发生的事件。<br><b>基本事件：</b>相对实验目的，不可再分（不必再分）的事件。（如，目的为观察结果丢硬币是正面还是方面，那么丢出一个硬币的正面就是一个基本事件。）<br><b>复合事件：</b>由基本事件复合。（如，丢骰子小于5的事件，复合了丢出1，2，3，4点的事件）<br><b>必然事件：</b>一定发生的事件，<b>用$\Omega$表示</b>。<br><b>不可能事件：</b>一定不发生的事件，<b>用$\phi$表示</b>。</p>
</blockquote>
<blockquote>
<p><b>样本空间：</b>所有基本事件的集合。<br><b>样本点：</b>样本空间的元素。</p>
</blockquote>
<h3 id="1-2-事件间的关系"><a href="#1-2-事件间的关系" class="headerlink" title="1.2 事件间的关系"></a><b>1.2 事件间的关系</b></h3><blockquote>
<ul>
<li><p><b>包含关系：</b>A发生，必定导致B也发生。</p>
<blockquote>
<p>表示方法：<br>A$\subset$B A包含于B<br>B$\supset$A B包含A</p>
</blockquote>
</li>
<li><p><b>并（和）关系：</b>A$\cup$B 或者 A+B，即表示A与B至少有一个发生。</p>
<blockquote>
<p><b>性质：</b>$A+B\supset A$， A+A&#x3D;A， A+$\varnothing$&#x3D;A， A+$\Omega$&#x3D;$\Omega$</p>
</blockquote>
</li>
<li><p><b>交（积）关系：</b>A$\cap$B 或者 AB，表示A与B同时发生。</p>
<blockquote>
<p><b>性质：</b>AB$\subset$A， AA&#x3D;A， A$\varnothing$&#x3D;$\varnothing$， A$\Omega$&#x3D;A</p>
</blockquote>
</li>
<li><p><b>差：</b>A-B，表示A发生而B不发生。</p>
<blockquote>
<p><b>性质：</b>A-B&#x3D;A-AB</p>
</blockquote>
</li>
<li><p><b>互不相容事件：</b>A，B不能同时发生。</p>
<blockquote>
<p><b>性质：</b>AB&#x3D;$\varnothing$</p>
</blockquote>
</li>
<li><p><b>对立事件：</b>A，B互不相容，并且A$\cup$B&#x3D;$\Omega$</p>
<blockquote>
<p><b>性质：</b>AB&#x3D;$\varnothing$ 且 A+B&#x3D;$\Omega$<br>A&#x3D;$ ^{\lnot}$B，B&#x3D;$ ^{\lnot}$A<br>A-B&#x3D;A-AB&#x3D;A$ ^{\lnot}$B<br><b>两者的区别：</b></p>
<ul>
<li>对立事件一定是互不相容事件，而互不相容事件不一定是对立事件</li>
<li>互不相容事件适用于多个事件，对立事件只适用于两个事件。</li>
<li>互不相容事件可以同时不发生，而对立事件一定会发生其中的一个。</li>
</ul>
</blockquote>
</li>
<li><p><b>完备事件组：</b></p>
<blockquote>
<p>$A_1$,$A_2$,$A_3$…$A_n$俩俩互不相容，且$A_1$+$A_2$+$A_3$+…$A_n$&#x3D;$\Omega$</p>
</blockquote>
</li>
</ul>
<p><b>事件间的运算律：</b></p>
<ul>
<li><b>交换律：</b>A$\cup$B&#x3D;B$\cap$A, A$\cap$B&#x3D;B$\cap$A</li>
<li><b>结合律：</b>(A$\cup$B)$\cup$C&#x3D;A$\cup$(B$\cup$C), (A$\cap$B)$\cap$C&#x3D;A$\cap$(B$\cap$C)</li>
<li><b>分配律：</b><blockquote>
<p>(A$\cup$B)$\cap$C&#x3D;(A$\cap$C)$\cup$(B$\cap$C)<br>(A$\cap$B)$\cup$C&#x3D;(A$\cup$C)$\cap$(B$\cup$C)</p>
</blockquote>
</li>
<li><b>对偶律：</b>$ ^{\lnot}$(A$\cup$B)&#x3D;$ ^{\lnot}$A$\cap$ $ ^{\lnot}$B , $ ^{\lnot}$(A$\cap$B)&#x3D;$ ^{\lnot}$A $\cup$ $ ^{\lnot}$B</li>
</ul>
</blockquote>
<h3 id="排序组合："><a href="#排序组合：" class="headerlink" title="排序组合："></a><b>排序组合：</b></h3><h4 id="两个原理："><a href="#两个原理：" class="headerlink" title="两个原理："></a><b>两个原理：</b></h4><blockquote>
<ul>
<li><b>加法原理：</b>几类的方案进行相加</li>
<li><b>乘法原理：</b>分几步进行相乘</li>
</ul>
</blockquote>
<h4 id="排列：从n个不同元素中取出m个进行排列"><a href="#排列：从n个不同元素中取出m个进行排列" class="headerlink" title="排列：从n个不同元素中取出m个进行排列"></a><b>排列：</b>从n个不同元素中取出m个进行排列</h4><blockquote>
<ul>
<li><b>不重复排列：</b>取出的m个元素中不可以出现重复（无放回）<blockquote>
<p>$P_{n}^m&#x3D;n(n-1)(n-2)…(n-m+1)&#x3D;\frac{n!}{(n-m)!}$<br><b>全排序：</b>从n个不同元素中取出n个元素进行排序。</p>
<blockquote>
<p>$P_{n}^n&#x3D;n!$</p>
</blockquote>
</blockquote>
</li>
<li><b>重复排序：</b>取出的m个元素可以出现重复（有放回）<blockquote>
<p>${nnn…n}&#x3D;{n^m}$<br>（0！&#x3D;1,这个可以用$P_{n}^m&#x3D;\frac{n!}{(n-m)!}$和$P_{n}^n$来证明）</p>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="组合："><a href="#组合：" class="headerlink" title="组合："></a><b>组合：</b></h4><blockquote>
<p>从n个不同元素中取出m个不同元素。<br>${C_{n}^m}&#x3D;{\frac{P_{n}^m}{m!}}&#x3D;\frac{n!}{m!(n-m)!}$<br>${C_{n}^m}&#x3D;{C_{n}^{n-m}}$<br>${C_{n}^0}&#x3D;{C_{n}^n}&#x3D;1$</p>
</blockquote>
<p><a href="/2021/01/29/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89/index.html">下一篇</a></p>
]]></content>
      <categories>
        <category>数学基础</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title>梯度下降法</title>
    <url>/2021/09/08/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/</url>
    <content><![CDATA[<h4 id="梯度下降的介绍"><a href="#梯度下降的介绍" class="headerlink" title="梯度下降的介绍"></a><b>梯度下降的介绍</b></h4><blockquote>
<p>梯度下降是一种在机器学习，甚至深度学习里都很常用的优化算法。<br>首先我们可以将<b>梯度下降</b>拆分为<b>梯度</b>和<b>下降</b>。</p>
<blockquote>
<ul>
<li><b>梯度</b>是函数的下降方向，可以理解为导数（多维就是对某一个参数的偏导）。</li>
<li><b>下降</b>即是减少。</li>
</ul>
</blockquote>
<p>梯度下降就是沿着函数的下降方向来找到函数最小值时的参数值。<br>梯度下降属于一种贪心策略，它只能找到局部的最优解。所以当要优化的函数是凸函数时，梯度下降是一个不错的选择。<br><b>效果如图所示：</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D.gif" alt="例子" title="例子"></p>
</blockquote>
<h4 id="梯度下降的数学推导"><a href="#梯度下降的数学推导" class="headerlink" title="梯度下降的数学推导"></a><b>梯度下降的数学推导</b></h4><blockquote>
<p><b>一般线性模型的梯度下降：</b></p>
<blockquote>
<p>先假设模型为$h_{\theta} &#x3D; \theta^T·X$（$\theta$和$X$都是向量）</p>
<ul>
<li>现在拥有数据集$[(x^1,y^1),(x^2,y^2),…,(x^n,y^n)]$</li>
<li>那么可以得到一个<del>(损失)</del>函数$J(\theta) &#x3D; \frac{1}{2} \sum^m_{i&#x3D;1}(h_{\theta}(x)-y^i)^2$</li>
<li>现在要利用梯度下降来求解$J(\theta)$最小时的$\theta$.</li>
<li>先计算梯度$\nabla J(\theta)$</li>
</ul>
<p>$\nabla J(\theta_j) &#x3D; \frac{\partial}{\partial \theta_j}J(\theta) &#x3D; (h_{\theta}(x) - y)x_j $</p>
<ul>
<li>然后对每一个$\theta_j$都减去它的梯度：$\theta_j:&#x3D;\theta_j - \alpha \nabla J(\theta_j)$<br><b>补充：</b>$\alpha$为学习率，根据个人来定义的，一般在$10^{-3}~10^{-5}$的量级</li>
</ul>
</blockquote>
<p><b>$J(\theta)$的由来：</b></p>
<blockquote>
<ul>
<li><p>假定误差$\epsilon$服从正态分布（根据直观感觉确实符合）</p>
</li>
<li><p>那么有$p(\epsilon) &#x3D; \frac{1}{\sqrt[]{2\pi} \sigma}exp(-\frac{\epsilon^2}{2\sigma^2})$其中$\epsilon &#x3D; |y^i-\theta^T x|$</p>
</li>
<li><p>所以可以获得似然函数$L_{\theta}(Y|x)&#x3D; \prod^n_{i&#x3D;1}  \frac{1}{\sqrt[]{2\pi} \sigma}exp(-\frac{(y^i-\theta^T x)^2}{2\sigma^2})$</p>
</li>
<li><p>现在我们要求$L_{\theta}(Y|x)$最大时的$\theta$就等价于求其对数的最大值时的$\theta$（极大似然估计）。<br>$log L_{\theta}(Y|x)&#x3D; log\prod^n_{i&#x3D;1}  \frac{1}{\sqrt[]{2\pi} \sigma}exp(-\frac{(y^i-\theta^T x)^2}{2\sigma^2})$</p>
</li>
<li><p>所以 $log L_{\theta}(Y|x)&#x3D;m \ log\frac{1}{\sqrt[]{2\pi} \sigma}-\frac{1}{\sigma^2} \frac{1}{2} \sum^m_{i&#x3D;1}(h_{\theta}(x)-y^i)^2$</p>
</li>
<li><p>由于$m \ log\frac{1}{\sqrt[]{2\pi} \sigma}$和$\frac{1}{\sigma^2}$是常数，所以要最大化$log L_{\theta}(Y|x)$就要最小化$\frac{1}{2} \sum^m_{i&#x3D;1}(h_{\theta}(x)-y^i)^2$</p>
</li>
</ul>
</blockquote>
</blockquote>
<h4 id="通过梯度下降来找函数最小值时的x"><a href="#通过梯度下降来找函数最小值时的x" class="headerlink" title="通过梯度下降来找函数最小值时的x"></a><b>通过梯度下降来找函数最小值时的x</b></h4><blockquote>
<p><b>代码：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">x</span>):</span><br><span class="line">   <span class="keyword">return</span> x**<span class="number">2</span> + x</span><br><span class="line"><span class="comment"># 函数的梯度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gradient</span>(<span class="params">x</span>):</span><br><span class="line">   <span class="keyword">return</span> <span class="number">2</span>*x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度下降法求最小值</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">cul_x：当前的x值</span></span><br><span class="line"><span class="string">learning_rate：学习率</span></span><br><span class="line"><span class="string">loop_times：循环的次数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GradientDescent</span>(<span class="params">cul_x, learning_rate, loop_times</span>):</span><br><span class="line">   xx = cul_x</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(loop_times):</span><br><span class="line">       xx = xx - learning_rate*gradient(xx)</span><br><span class="line">   <span class="keyword">return</span> xx</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   cul_x = <span class="number">3</span></span><br><span class="line">   rate = <span class="number">0.001</span></span><br><span class="line">   xx = GradientDescent(cul_x, rate, loop_times=<span class="number">10000</span>)</span><br><span class="line">   x = np.linspace(-<span class="number">10</span>, <span class="number">10</span>, <span class="number">1000</span>)</span><br><span class="line">   plt.plot(cul_x,fun(cul_x), <span class="string">&#x27;g*&#x27;</span>)    <span class="comment"># 画起始点</span></span><br><span class="line">   plt.plot(xx,fun(xx),<span class="string">&#x27;r*&#x27;</span>)           <span class="comment"># 画出最低点</span></span><br><span class="line">   plt.plot(x, fun(x))                 <span class="comment"># 绘制曲线</span></span><br><span class="line">   plt.grid()                          <span class="comment"># 给图加上网格</span></span><br><span class="line">   plt.show()</span><br></pre></td></tr></table></figure>
<p><b>结果：</b><br> <img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/%E4%BA%8C%E6%AC%A1%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%89%BE%E6%9C%80%E5%B0%8F%E5%80%BC.png" alt="例子" title="结果"><br><b>补充：</b>绿色的点是起始点，红色点是找到的最小值点。<br><b>补充：</b>将梯度下降反向操作就可以变成梯度上升算法了。</p>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>概率论与数理统计（三）</title>
    <url>/2021/01/30/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h3 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a><b>随机变量</b></h3><blockquote>
<p>主要分<b>离散型随机变量</b>和<b>非离散型随机变量</b>（主要为连续型随机变量）。</p>
</blockquote>
<h4 id="离散型随机变量："><a href="#离散型随机变量：" class="headerlink" title="离散型随机变量："></a><b>离散型随机变量：</b></h4><blockquote>
<p><b>定义：</b>X为离散型随机变量，X的所有取值$x_k$(k&#x3D;1,2,…)为可列个，所有$x_k$的概率都已知。<br><b>概率分布函数：</b>$P(X&#x3D;x_k)&#x3D;p_k$,其中$p_k&gt;&#x3D;0,\sum{p_k}&#x3D;1$<br>对于离散型随机变量，可以取到点上的概率。<br><b>离散型随机变量的概率分布图</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%A6%82%E7%8E%87%E8%AE%BA/%E7%A6%BB%E6%95%A3%E5%9E%8B%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E5%9B%BE.png" alt="离散型" title="离散型"></p>
</blockquote>
<h4 id="连续型随机变量："><a href="#连续型随机变量：" class="headerlink" title="连续型随机变量："></a><b>连续型随机变量：</b></h4><blockquote>
<p><b>定义：</b>存在非负可积$f(x),f(x)&gt;&#x3D;0$，若任意a&lt;&#x3D;b都有$p(a&lt;x&lt;&#x3D;b)&#x3D;\int_a^b{f(x)dx}$,那么x称为连续随机变量，$f(x)$称之为概率分布密度函数。<br><b>性质：</b></p>
<blockquote>
<ul>
<li>$f(x)&#x3D;0$</li>
<li>$\int_{-\infty}^{+\infty}{f(x)dx}$</li>
<li>连续型随机变量取个别值的概率为0.</li>
<li><b>补充：</b><blockquote>
<ul>
<li>概率为0的事件未必是不可能事件。</li>
<li>概率为1的事件未必是必然事件。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<p><b>连续型随机变量的概率密度分布图</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%A6%82%E7%8E%87%E8%AE%BA/%E8%BF%9E%E7%BB%AD%E5%9E%8B%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E5%9B%BE.png" alt="连续型" title="连续型"></p>
</blockquote>
<h4 id="分布函数（离散型和连续型都成立）"><a href="#分布函数（离散型和连续型都成立）" class="headerlink" title="分布函数（离散型和连续型都成立）"></a><b>分布函数</b>（离散型和连续型都成立）</h4><blockquote>
<ul>
<li><b>定义：</b><br>$F(x)&#x3D;P(X&lt;&#x3D;x)$,即随机变量X不超过x的概率。</li>
<li><b>性质：</b><blockquote>
<ul>
<li>0&lt;&#x3D;$F(x)$&lt;&#x3D;1,$x{\in}({-\infty},{+\infty})$</li>
<li>$F(x)$是关于x的不减函数，任意$x_1&lt;x_2$都有$F(x_1)&lt;&#x3D;F(x_2)$</li>
<li>$\lim_{x\to{+\infty}}F(x)&#x3D;1$   $\lim_{x\to{-\infty}}F(x)&#x3D;0$</li>
<li>F(x)是右连续函数(离散型的是右连续，连续型的是全连续)</li>
</ul>
</blockquote>
</li>
<li><b>公式：</b><blockquote>
<ul>
<li>$P(X&lt;&#x3D;a)&#x3D;F(a)$</li>
<li>$P(X&gt;a)&#x3D;1-P(X&lt;a)&#x3D;1-F(a)$</li>
<li>$P(a&lt;X&lt;&#x3D;b)&#x3D;P(X&lt;&#x3D;b)-P(X&lt;&#x3D;a)&#x3D;F(b)-F(a)$</li>
<li>$P(X&#x3D;a)&#x3D;F(a)-F(a-0)$</li>
<li>$P(a&lt;&#x3D;X&lt;&#x3D;b)&#x3D;F(b)-F(a-0)$</li>
<li>$P(X&lt;a)&#x3D;F(a-0)$</li>
<li>$P(X&gt;&#x3D;a)&#x3D;1-F(a-0)$</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<p><a href="/2021/01/29/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89/index.html">上一篇</a>,<a href="/2021/02/03/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%EF%BC%88%E5%9B%9B%EF%BC%89/index.html">下一篇</a></p>
]]></content>
      <categories>
        <category>数学基础</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title>概率论与数理统计（二）</title>
    <url>/2021/01/29/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h3 id="1-3-事件概率"><a href="#1-3-事件概率" class="headerlink" title="1.3 事件概率"></a><b>1.3 事件概率</b></h3><h4 id="1-3-1-概率的定义："><a href="#1-3-1-概率的定义：" class="headerlink" title="1.3.1 概率的定义："></a><b>1.3.1 概率的定义：</b></h4><blockquote>
<p>描述事件发生的可能大小，用P(A)来表示。<br><b>性质：</b></p>
<blockquote>
<ul>
<li>P($\Omega$)&#x3D;1, P($\phi$)&#x3D;0</li>
<li>0&lt;&#x3D;P(A)&lt;&#x3D;1</li>
</ul>
</blockquote>
</blockquote>
<h4 id="1-3-2-古典概率模型："><a href="#1-3-2-古典概率模型：" class="headerlink" title="1.3.2 古典概率模型："></a><b>1.3.2 古典概率模型：</b></h4><blockquote>
<p><b>定义的条件：</b></p>
<blockquote>
<ul>
<li>有限的样本点</li>
<li>等可能性（各样本点出现的可能性都相同）<br>$P(A)&#x3D;\frac{A中包含的基本事件数}{基本事件总数}$<br>如，丢骰子丢出1的概率为$\frac{1}{6}$就是一个古典概率模型。</li>
</ul>
</blockquote>
</blockquote>
<h4 id="1-3-3-几何概率模型"><a href="#1-3-3-几何概率模型" class="headerlink" title="1.3.3 几何概率模型"></a><b>1.3.3 几何概率模型</b></h4><blockquote>
<p>将概率问题转化成几何模型进而进行求解。（一般是找到决定事件结果的因素）<br><b>常见模型：</b>线段、平面、立体<br>几何概率具有<b>完全可加性</b></p>
</blockquote>
<h4 id="1-4-频率和概率"><a href="#1-4-频率和概率" class="headerlink" title="1.4 频率和概率"></a><b>1.4 频率和概率</b></h4><blockquote>
<ul>
<li><b>频率：</b>进行n次实验，A发生了m次，$\frac{m}{n}$就叫作频率，记作$W_{n}(A)$<blockquote>
<ul>
<li><b>性质：</b><blockquote>
<ul>
<li><b>非负性：</b>0&lt;&#x3D;$W_{n}(A)$&lt;&#x3D;1</li>
<li><b>规范性：</b>${W_{n}(\Omega)}&#x3D;1$, ${W_{n}(\phi)}&#x3D;0$</li>
<li><b>可加性：</b>$A_1,A_2,…,A_n$不相容，$W_n(A_1+A_2+…+A_m)&#x3D;W_n(A_1)+…+W_n(A_m)$</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><b>概率：</b>随着实验次数n增大时，频率$W_{n}(A)$会慢慢稳定地趋于某个数，这个数就叫作<b>统计概率</b>，简称<b>概率</b>。</li>
</ul>
</blockquote>
<h4 id="1-5-公理化"><a href="#1-5-公理化" class="headerlink" title="1.5 公理化"></a><b>1.5 公理化</b></h4><blockquote>
<ul>
<li><b>公理1：</b>（非负性）$0&lt;&#x3D;P(A)&lt;&#x3D;1$</li>
<li><b>公理2：</b>（规范性）$P(\Omega)&#x3D;1$</li>
<li><b>公理3：</b>（完全可加性）$A_1,A_2,A_3,…$互不相容，$P(A_1+A_2+A_3+…)&#x3D;P(A_1)+P(A_2)+P(A_3)+…$<br>有公理可以证明的性质：</li>
<li><b>性质1：</b>$P(\phi)&#x3D;0$</li>
<li><b>性质2：</b>有限可加，A_1,A_2,…,A_n互不相容，$P(A_1+A_2+…+A_n)&#x3D;P(A_1)+P(A_2)+…+P(A_n)$</li>
<li><b>性质3：</b>$P( ^{\lnot}A)&#x3D;1-P(A)$</li>
<li><b>性质4：</b><blockquote>
<ul>
<li>$P(A-B)&#x3D;P(A)-P(AB)$</li>
<li>$A{\supset}B,P(A-B)&#x3D;P(A)-P(B)$</li>
</ul>
</blockquote>
</li>
<li><b>性质5：</b>$P(A+B)&#x3D;P(A)+P(B)-P(AB)$<br><b>补充：</b>$P(A+B+C)&#x3D;P(A)+P(B)+P(C)-P(AB)-P(AC)-P(BC)+P(ABC)$</li>
</ul>
</blockquote>
<h4 id="1-6-条件概率"><a href="#1-6-条件概率" class="headerlink" title="1.6 条件概率"></a><b>1.6 条件概率</b></h4><blockquote>
<p><b>定义：</b>$\Omega$为样本空间，A，B为两个事件，P(B)&gt;0,在B已经发生的条件下A发生的概率叫作A对B的条件概率，记作$P(A|B)$<br>$P(A|B)&#x3D;\frac{n_{AB}}{n_B}&#x3D;\frac{P(AB)}{P(B)}$<br><b>注：</b>条件概率最大特点为，样本空间发生了改变，由${\Omega}$-&gt;${\Omega}_B$</p>
</blockquote>
<h4 id="1-7-乘法公式"><a href="#1-7-乘法公式" class="headerlink" title="1.7 乘法公式"></a><b>1.7 乘法公式</b></h4><blockquote>
<p>由$P(A|B)&#x3D;\frac{P(AB)}{P(B)}$转换可得，<br>1、$P(AB)&#x3D;P(B)P(A|B)$<br>2、$P(AB)&#x3D;P(A)P(B|A)$<br><b>一般形式：</b>$P(A_1,A_2,…,A_n)&#x3D;P(A_1)P(A_2|A_1)…P(A_n|{A_1}{A_2}…A_{n-1})$<br><b>如：</b>$P(ABC)&#x3D;P(A)P(B|A)P(C|AB)$</p>
</blockquote>
<h4 id="1-8-全概率公式：（因-果）"><a href="#1-8-全概率公式：（因-果）" class="headerlink" title="1.8 全概率公式：（因-&gt;果）"></a><b>1.8 全概率公式：（因-&gt;果）</b></h4><blockquote>
<p><b>定义：</b>$A_1,A_2,…,A_n$是完备事件组,$P(A_i)&gt;0,P(B)&#x3D;\sum_{i&#x3D;1}^n{P(A_i)P(B|A_i)}$  (其中,完备事件组意为将$\omega$分为n份，每份互不相交。B为任意事件)<br><b>补充：</b>对于一些情况，全概率公式可以放宽为：1、$A_i$互不相容  2、$A_i$的并集包括B<br>即，已知每一部分B在$A_i$中发生的概率，求整体B发生的概率为多少<br><b>图示：</b></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%A6%82%E7%8E%87%E8%AE%BA/%E5%85%A8%E6%A6%82%E7%8E%87%E5%85%AC%E5%BC%8F%E8%A1%A8%E7%A4%BA%E5%9B%BE.jpg" alt="全概率公式" title="全概率公式"></p>
</blockquote>
</blockquote>
<h4 id="1-9-贝叶斯公式：（果-因）"><a href="#1-9-贝叶斯公式：（果-因）" class="headerlink" title="1.9 贝叶斯公式：（果-&gt;因）"></a><b>1.9 贝叶斯公式：（果-&gt;因）</b></h4><blockquote>
<p>设$A_1,A_2,…,A_n$是完备事件组,B为任意事件,$P(A_i)&gt;0,P(B)&gt;0$<br>$P({A_k}|B)&#x3D;\frac{P(A_k)P(B|A_k)}{\sum_{i&#x3D;1}^n{P(A_i)P(B|A_i)}}&#x3D;\frac{P({A_k}B)}{P(B)}$<br>即，B已经发生，求B是在$A_k$中发生的概率为多少<br><b>图示：</b></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%A6%82%E7%8E%87%E8%AE%BA/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%85%AC%E5%BC%8F.jpg" alt="贝叶斯公式" title="贝叶斯公式"></p>
</blockquote>
<ul>
<li><b>先验概率：</b>指根据以往经验和分析得到的概率，如<b>全概率公式</b>，它往往作为”由因求果”问题中的”因”出现的概率</li>
<li><b>后验概率：</b>结果已经知道，求是某个原因导致结果的概率，如<b>贝叶斯公式</b>。</li>
</ul>
</blockquote>
<h4 id="事件的独立性："><a href="#事件的独立性：" class="headerlink" title="事件的独立性："></a><b>事件的独立性：</b></h4><blockquote>
<p><b>定义：</b>A发生的概率不受B发生B发生与否的影响。<br>$P(A|B)&#x3D;P(A)$<br>事件的独立性具有对称性。<br><b>定理：</b></p>
<ul>
<li>$P(A)&gt;0,P(B)&gt;0$A,B相互独立&lt;&#x3D;&gt;$P(AB)&#x3D;P(A)P(B)$<br><b>补充：</b><blockquote>
<ul>
<li>$P(A)&#x3D;0$或$P(B)&#x3D;0$,以上式子也成立。</li>
<li>$\Omega,\phi$与任意事件A也相互独立。</li>
</ul>
</blockquote>
</li>
<li>A,B相互独立，A与$ ^{\lnot}B$、$ ^{\lnot}A$与B、$ ^{\lnot}A$与$ ^{\lnot}B$也独立。</li>
<li>$P(A)&#x3D;0$或$P(A)&#x3D;1$,A与任何事件都独立。<br><b>多个事件的独立性：</b><br>如，A,B,C相互独立：</li>
<li>$P(AB)&#x3D;P(A)P(B)$</li>
<li>$P(BC)&#x3D;P(B)P(C)$</li>
<li>$P(AC)&#x3D;P(A)P(C)$</li>
<li>$P(ABC)&#x3D;P(A)P(B)P(C)$<br><b>独立事件和互不相容的区别：</b></li>
<li><b>独立事件：</b>A发生与B发生互不影响。</li>
<li><b>互不相容：</b>A与B的交集为空。<br><b>注：</b>$P(A)&gt;0,P(B)&gt;0$，独立事件与互不相容不可同时成立。</li>
</ul>
</blockquote>
<h4 id="伯努利模型："><a href="#伯努利模型：" class="headerlink" title="伯努利模型："></a><b>伯努利模型：</b></h4><blockquote>
<p><b>定义：</b></p>
<blockquote>
<ul>
<li><b>独立事件序列：</b>$E_1,E_2,…,E_n$个实验，且相互独立。</li>
<li><b>n重独立事件：</b>把一个实验E重复做n遍，且相互独立，记作$E^n$</li>
<li><b>n重伯努利实验：</b>做n次相互独立，结果只有两种的实验。<br>如,丢硬币，射击等概率事件</li>
</ul>
</blockquote>
<ul>
<li><b>定理：</b>A的概率p（0&lt;p&lt;1）,$ ^{\lnot}A&#x3D;1-p$,n重伯努利实验中A发生k次的概率：<br>$P_n(k)&#x3D;C_{n}^{k}p^k(1-p)^{n-k}&#x3D;C_{n}^kp^{k}q^{n-k}$<br>上式也叫二项概率公式。</li>
</ul>
</blockquote>
<p><a href="/2021/01/23/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89/index.html">上一篇</a>,<a href="/2021/01/30/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%EF%BC%88%E4%B8%89%EF%BC%89/index.html">下一篇</a></p>
]]></content>
      <categories>
        <category>数学基础</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title>模型选择与模型优化</title>
    <url>/2021/03/25/%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9%E4%B8%8E%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h4 id="训练误差与测试误差"><a href="#训练误差与测试误差" class="headerlink" title="训练误差与测试误差"></a><b>训练误差与测试误差</b></h4><blockquote>
<p>显然对于一个训练模型来说，它都有两种策略可供选择：</p>
<blockquote>
<ul>
<li><b>训练误差:</b>$R_{emp}(f)&#x3D;\frac{1}{N}\sum^N_{i&#x3D;1}L(y_i,f(x_i))$(其中N为训练样本集)</li>
<li><b>测试误差:</b>$e_{test}(f)&#x3D;\frac{1}{M}\sum^M_{i&#x3D;1}L(y_i,f(x_i))$(其中M为测试样本集)</li>
</ul>
</blockquote>
<p><b>两者的区别：</b></p>
<ul>
<li><b>训练误差</b>的大小,只能决定给定的问题是不是一个容易学习的问题,本质上并不重要。而<b>测试误差</b>则反映了该模型对未知训练集的预测能力。因此对于这两种策略，明显选择降低测试误差更要有意义。</li>
<li>我们通常将对未知数据的预测能力称为<b>泛化能力</b>。</li>
</ul>
</blockquote>
<h4 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a><b>过拟合</b></h4><blockquote>
<p><b>定义:</b><br>过拟合是指学习时选择的模型所包含的参数过多,模型的复杂度过高,导致这一模型对<b>已知数据</b>的预测效果很好,但对<b>未知数据</b>预测效果很差的现象。<br><b>例如：</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96/%E8%BF%87%E6%8B%9F%E5%90%88.png" alt="过拟合" title="过拟合"></p>
<ul>
<li>上图中第三幅就是一个过拟合的例子。<br>那么为了避免过拟合问题，选出最佳模型，通常有<b>正则化</b>与<b>交叉验证</b>两种方案。</li>
</ul>
</blockquote>
<h4 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a><b>正则化</b></h4><blockquote>
<ul>
<li>正则化是结构风险最小化策略的实现，它实际上是在<b>损失函数</b>上加一个<b>正则化项(有时也叫惩罚项)</b>。</li>
<li>正则化项一般是模型复杂度的单调递增函数，即模型复杂度越大，正则化项就越大。</li>
<li>正则化项可以是（一般也是）参数向量的<b>范数</b>。<br>正则化一般形式为：<br>$$min\ \frac{1}{N}\sum^N_{i&#x3D;1}L(y_i,f(x_i))+{\lambda}J(f)$$</li>
</ul>
<p><b>注：</b>其中$L(y_i,f(x_i))$为损失函数，${\lambda}J(f)$为正则化项，${\lambda}$为超参数，需要自己人工调节。<br>正则化可以取不同的形式，例如，在回归问题中，损失函数为<b>平方损失</b>，正则化分为：</p>
<blockquote>
<ul>
<li><p><b>Lasso回归</b>：<br>$$L(\omega)&#x3D;\frac{1}{N}\sum^N_{i&#x3D;1}(f(x_i,\omega)-y_i)^2+{\lambda}\lVert{\omega}\rVert$$</p>
</li>
<li><p><b>Ridge回归</b>：<br>$$L(\omega)&#x3D;\frac{1}{N}\sum^N_{i&#x3D;1}(f(x_i,\omega)-y_i)^2+\frac{\lambda}{2}\lVert{\omega}\rVert^2$$</p>
</li>
</ul>
</blockquote>
<p><b>两者区别：</b></p>
<blockquote>
<ul>
<li>Lasso回归加的是向量$\omega$的$L_1$范数，Ridge回归加的是向量$\omega$的$L_2$范数。</li>
<li>Lasso回归可以更好地进行特征值的选择，Ridge回归性能优于Lasso回归。</li>
</ul>
</blockquote>
<p><b>范数的定义：</b></p>
<blockquote>
<ul>
<li>它定义在赋范线性空间中，并满足一定的条件，即①非负性；②齐次性；③三角不等式。它常常被用来度量某个向量空间（或矩阵）中的每个向量的长度或大小。</li>
<li>$L_1$范数：$L_1&#x3D;(|\omega_1|+|\omega_2|+…+\omega_n)$</li>
<li>$L_2$范数：$L_2&#x3D;(|\omega_1|^2+|\omega_2|^2+…+|\omega_n|^2)^{\frac{1}{2}}$</li>
<li>$L_n$范数：$L_n&#x3D;(|\omega_1|^n+|\omega_2|^n+…+|\omega_n|^n)^{\frac{1}{n}}$</li>
</ul>
</blockquote>
<p><b>正则项的作用：</b></p>
<blockquote>
<ul>
<li>众所周知，过拟合出现的最大原因是出现了<b>无关参数</b>，<b>如</b>通过回归预测人的身高时，<b>有效的参数</b>应该是<b>人的年龄</b>，<b>人的骨骼生长情况</b>等，但是如果在模型中<b>多加一项财富</b>作为参数<b>（这很明显是无关参数）</b>，那么此时很可能会出现过拟合的现象。</li>
<li>正则项的大小与参数有关，在加入了无关参数之后，正则项会因此变大。但是我们的策略是求损失函数的最小值，那么正则项也应该随之减小。正则项减小，那么无关参数也会迫使趋近于零，从而减少无关参数的影响，减弱过拟合现象。</li>
</ul>
</blockquote>
</blockquote>
<h4 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a><b>交叉验证</b></h4><blockquote>
<ul>
<li><p>另一种常用的模型选择方法是交叉验证。</p>
</li>
<li><p>如果样本数据充足，进行<b>模型选择</b>的一种简单方法是<b>将数据分为三部分</b>，分别为<b>训练集</b>、<b>验证集</b>和<b>测试集</b>。训练集用于模型的训练、验证集用于模型的选择、测试集用于最终对学习方法的评估。</p>
</li>
<li><p>实际上数据是不充足的，此时可以采用交叉验证方法，即重复使用数据;把给定的数据进行切分，将切分的数据分为<b>训练集</b>和<b>测试集</b>。<br><b>交叉验证的分类：</b></p>
</li>
<li><p><b>简单交叉验证：</b></p>
<blockquote>
<p>随机地将数据分为两部分，一部分作为<b>训练集</b>，另一部分作为<b>测试集</b>，然后用测试集在各种条件下（如不同参数个数）训练模型，从而得到不同模型。在测试集上评价各个模型的<b>测试误差</b>，选出测试误差最小的模型。</p>
</blockquote>
</li>
<li><p><b>S折交叉验证</b></p>
<blockquote>
<p>首先随机地将已知的数据集切分为S个互不相交、大小相同的子集;然后利用S-1个子集的数据训练模型，利用剩下的子集测试模型;将这一过程对可能的S种选择重复进行，最后选出S次评测中平均测试误差最小的模型。</p>
</blockquote>
</li>
<li><p><b>留一交叉验证</b></p>
<blockquote>
<p>S折交叉验证的特殊情况是S&#x3D;N，称为留一交叉验证，往往在数据缺乏的情况下使用。</p>
</blockquote>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>牛顿法</title>
    <url>/2021/09/23/%E7%89%9B%E9%A1%BF%E6%B3%95/</url>
    <content><![CDATA[<h4 id="牛顿法介绍"><a href="#牛顿法介绍" class="headerlink" title="牛顿法介绍"></a><b>牛顿法介绍</b></h4><blockquote>
<p>牛顿法是求解<b>无约束最优化问题</b>的常用方法之一，有收敛速度快的优点。<br>牛顿法属于迭代算法，每一步都需要求解目标函数的二阶导数（hessian矩阵）<br>具体实现过程：</p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%89%9B%E9%A1%BF%E6%B3%95/%E7%89%9B%E9%A1%BF%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.gif" alt="牛顿法" title="牛顿法"></p>
</blockquote>
</blockquote>
<h5 id="非向量形式"><a href="#非向量形式" class="headerlink" title="非向量形式"></a><b>非向量形式</b></h5><blockquote>
<p>目标：找到一个有二阶导数函数$f(x)$的零点。</p>
<blockquote>
<ul>
<li>首先在零点附近取一点$x_0$进行泰勒展开，即<br>$$f(x)&#x3D;f(x_0)+f’(x_0)(x-x_0)+ \frac{1}{2}f’’(x_0)(x-x_0)^2$$</li>
<li>由于求的是零点，所以$f’(x)&#x3D;0$，即对上式求导<br>$$f’(x) &#x3D; f’(x_0)+f’’(x_0)(x-x_0)&#x3D;0$$</li>
<li>化简可得，<br>$$x &#x3D; x_0 - \frac{f’(x_0)}{f’’(x_0)}$$</li>
<li>每次更新一次x都可以迭代一次，所以最终可得<br>$$x_{n+1} &#x3D; x_n - \frac{f’(x_n)}{f’’(x_n)}$$</li>
</ul>
</blockquote>
<p>因此只要一直迭代下去就可以找到$f(x)$的零点，而且下降速度是建立在二阶导上的，所以下降速度会非常快。</p>
</blockquote>
<h5 id="向量形式"><a href="#向量形式" class="headerlink" title="向量形式"></a><b>向量形式</b></h5><blockquote>
<p>目标：找到一个有二阶导数函数$f(X)$的零点。<br>不一样的是，这里的$X&#x3D;[x_1,x_2,…,x_n]$的一个$n \times 1$的向量矩阵</p>
<blockquote>
<ul>
<li><p>首先也是在零点附近取一点$X_0$进行泰勒展开，即<br>$$f(X) &#x3D; f(X_0)+g(X_0)(X-X_0)+\frac{1}{2}(X-X_0)^T H (X-X_0)$$</p>
<blockquote>
<ul>
<li>其中，$g(X)&#x3D;[\frac{\partial f(X)}{\partial x_1},\frac{\partial f(X)}{\partial x_2},…,\frac{\partial f(X)}{\partial x_n}]$</li>
<li>H是一个hessian矩阵,具体值如下</li>
</ul>
<p>$$\begin{bmatrix}<br>{\frac{\partial^2 f(X)}{\partial x_1 \partial x_1}}&amp;{\frac{\partial^2 f(X)}{\partial x_1 \partial x_2}}&amp;{\cdots}&amp;{\frac{\partial^2 f(X)}{\partial x_1 \partial x_n}}\\<br>{\frac{\partial^2 f(X)}{\partial x_2 \partial x_1}}&amp;{\frac{\partial^2 f(X)}{\partial x_2 \partial x_2}}&amp;{\cdots}&amp;{\frac{\partial^2 f(X)}{\partial x_2 \partial x_n}}\\<br>{\vdots}&amp;{\vdots}&amp;{\ddots}&amp;{\vdots}\\<br>{\frac{\partial^2 f(X)}{\partial x_n \partial x_1}}&amp;{\frac{\partial^2 f(X)}{\partial x_n \partial x_2}}&amp;{\cdots}&amp;{\frac{\partial^2 f(X)}{\partial x_n \partial x_n}}\\<br>\end{bmatrix}$$</p>
</blockquote>
</li>
<li><p>同样$f’(X) &#x3D; 0$,得到$g(X_0)+H(X-X_0)&#x3D;0$</p>
</li>
<li><p>化简得，$X &#x3D; X_0-H^{-1}g(X_0)$<br><b>补充：</b>当H为正定矩阵时，$f(X)$可以找到极小值，当H为负定矩阵时，$f(X)$可以找到极大值，当H为不定矩阵时，$f(X)$找不到极值，当H为半正（负）定矩阵时，$f(X)$不确定是否有极值，需要通过其他方法来找极值。</p>
</li>
</ul>
</blockquote>
<p>在向量形式的牛顿法中，计算量最大在于<b>求出hessian矩阵的逆($H^{-1}$)</b>，对此拟牛顿法就是找一个同为n阶的方阵$G_k$来近似代替$H^{-1}$，从而减少计算量。</p>
</blockquote>
<h5 id="牛顿法的下降保证"><a href="#牛顿法的下降保证" class="headerlink" title="牛顿法的下降保证"></a><b>牛顿法的下降保证</b></h5><blockquote>
<p>如果$H_k$是正定的（$H_k^{-1}$也是），那么可以保证牛顿法搜索方向$p_k$是下降方向。<br><b>原因：</b></p>
<blockquote>
<p>由$X^{k+1} &#x3D; X^k - H_k^{-1}g_k$可得下降的方向$p_k&#x3D;-g_k$<br>所以$f(X)$在$X^{k}$处进行泰勒展开（展开一项）得，<br>$$f(X) &#x3D; f(X^k)+g_k(X-X^k)$$<br>化简成，<br>$$f(X) &#x3D; f(X^k)-g^T_k H^{-1}_k g_k)$$<br>因为$H^{-1}_k$是正定的，所以$g^T_k H^{-1}_k g_k$恒大于0，所以$f(X) &lt; f(X^k)$<br>所以牛顿法是下降的。</p>
</blockquote>
</blockquote>
<h4 id="用牛顿法找二元函数的极值"><a href="#用牛顿法找二元函数的极值" class="headerlink" title="用牛顿法找二元函数的极值"></a><b>用牛顿法找二元函数的极值</b></h4><blockquote>
<p><b>代码：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">x</span>):</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>*x**<span class="number">2</span> - <span class="number">5</span>*x +<span class="number">7</span></span><br><span class="line"><span class="comment"># 函数的梯度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gradient</span>(<span class="params">x</span>):</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span>*x - <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gradient_2</span>(<span class="params">x</span>):</span><br><span class="line">   <span class="keyword">return</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度下降法求最小值</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">cul_x：当前的x值</span></span><br><span class="line"><span class="string">learning_rate：学习率</span></span><br><span class="line"><span class="string">loop_times：循环的次数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GradientDescent</span>(<span class="params">cul_x, learning_rate, loop_times</span>):</span><br><span class="line">   xx = cul_x</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(loop_times):</span><br><span class="line">       xx = xx - learning_rate*gradient(xx)</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;xx_1:&#x27;</span>,xx)</span><br><span class="line">   <span class="keyword">return</span> xx</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Newtown</span>(<span class="params">cul_x, loop_times, rate</span>):</span><br><span class="line">   xx = cul_x</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(loop_times):</span><br><span class="line">       xx = xx - rate*(gradient(xx)/gradient_2(xx))</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;xx_2&#x27;</span>,xx)</span><br><span class="line">   <span class="keyword">return</span> xx</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">paitting</span>(<span class="params">cul_x,xx</span>):</span><br><span class="line">   x = np.linspace(-<span class="number">10</span>, <span class="number">10</span>, <span class="number">1000</span>)</span><br><span class="line">   plt.plot(cul_x, fun(cul_x), <span class="string">&#x27;g*&#x27;</span>)  <span class="comment"># 画起始点</span></span><br><span class="line">   plt.plot(xx, fun(xx), <span class="string">&#x27;r*&#x27;</span>)  <span class="comment"># 画出最低点</span></span><br><span class="line">   plt.plot(x, fun(x))  <span class="comment"># 绘制曲线</span></span><br><span class="line">   plt.grid()  <span class="comment"># 给图加上网格</span></span><br><span class="line">   plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  cul_x = <span class="number">10</span></span><br><span class="line">  rate = <span class="number">0.0001</span></span><br><span class="line">  xx_1 = GradientDescent(cul_x, rate, loop_times=<span class="number">10000</span>)</span><br><span class="line">  xx = Newtown(cul_x, loop_times=<span class="number">10</span>, rate=<span class="number">1</span>)</span><br><span class="line">  paitting(cul_x,xx_1)</span><br><span class="line">  paitting(cul_x,xx)</span><br></pre></td></tr></table></figure>
<p><b>输出：</b></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">xx_1: 0.8607149298702336</span><br><span class="line">xx_1: 0.8605506402910121</span><br><span class="line">xx_1: 0.860387336449266</span><br><span class="line">xx_1: 0.8602250124305704</span><br><span class="line">xx_1: 0.860063662355987</span><br><span class="line">xx_1: 0.859903280381851</span><br><span class="line">xx_1: 0.85974386069956</span><br><span class="line">xx_1: 0.8595853975353627</span><br><span class="line">xx_1: 0.8594278851501505</span><br><span class="line">xx_1: 0.8592713178392496</span><br><span class="line">xx_1: 0.8591156899322141</span><br><span class="line">xx_1: 0.8589609957926209</span><br><span class="line">xx_1: 0.8588072298178652</span><br><span class="line">xx_1: 0.858654386438958</span><br><span class="line">xx_1: 0.8585024601203243</span><br><span class="line">xx_1: 0.8583514453596023</span><br><span class="line">xx_1: 0.8582013366874447</span><br><span class="line">xx_1: 0.8580521286673201</span><br><span class="line">xx_1: 0.8579038158953162</span><br><span class="line">xx_1: 0.8577563929999442</span><br><span class="line">xx_1: 0.8576098546419445</span><br><span class="line">xx_1: 0.8574641955140928</span><br><span class="line">xx_1: 0.8573194103410082</span><br><span class="line">xx_1: 0.8571754938789622</span><br><span class="line">xx_1: 0.8570324409156884</span><br><span class="line">xx_1: 0.8568902462701943</span><br><span class="line">xx_1: 0.8567489047925732</span><br><span class="line">xx_1: 0.8566084113638177</span><br><span class="line">xx_1: 0.8564687608956348</span><br><span class="line">xx_1: 0.856329948330261</span><br><span class="line">xx_1: 0.8561919686402795</span><br><span class="line">xx_1: 0.8560548168284378</span><br><span class="line">xx_1: 0.8559184879274672</span><br><span class="line">xx_1: 0.8557829769999024</span><br><span class="line">xx_1: 0.855648279137903</span><br><span class="line">xx_2 0.8333333333333339</span><br><span class="line">xx_2 0.8333333333333334</span><br><span class="line">xx_2 0.8333333333333334</span><br><span class="line">xx_2 0.8333333333333334</span><br><span class="line">xx_2 0.8333333333333334</span><br><span class="line">xx_2 0.8333333333333334</span><br><span class="line">xx_2 0.8333333333333334</span><br><span class="line">xx_2 0.8333333333333334</span><br><span class="line">xx_2 0.8333333333333334</span><br><span class="line">xx_2 0.8333333333333334</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
</blockquote>
<p><b>补充：</b>上面的是梯度下降与牛顿法的比较，事实证明，牛顿法下降的速度是真的快。</p>
</blockquote>
<h4 id="拟牛顿法"><a href="#拟牛顿法" class="headerlink" title="拟牛顿法"></a><b>拟牛顿法</b></h4><blockquote>
<p>在牛顿法中，每一次迭代都需要重新计算一个$n \times n$的hessian矩阵的逆，因此在特征值较大时会造成很大的计算量，而且hessian阵还必须是正定矩阵。因此在牛顿法的技术上加以改进，利用一个同为$n \times n$的正定矩阵$G_k$或$B_k$来替代hessian矩阵。<br>首先，先来看拟牛顿法的hessian矩阵在迭代过程所满足的条件：</p>
<blockquote>
<p>$$\nabla f(X) &#x3D; g_k + H_k(X-X^{k})$$<br>令$X &#x3D; X^{k+1}$<br>$$g_{k+1} - g_k + H_k(X^{k+1}-X^k)$$<br>令$g_{k+1} - g_k&#x3D;y_k$,$X^{k+1}-X^{k} &#x3D; \delta$，则$H_k$满足以下条件<br>$$y_k&#x3D;H_k \delta_k$$<br>或<br>$$H_k^{-1}y_k &#x3D; \delta_k$$</p>
</blockquote>
<p>以上的称为拟牛顿条件。<br>拟牛顿法是将$G_k$近似代替$H_k^{-1}$或将$B_k$近似代替$H_k$<br>按照牛顿法条件，我们在每次迭代中选择更新$G_{k+1}$，<br>$$G_{k+1}&#x3D;G_k+\Delta G_k$$</p>
</blockquote>
<h5 id="DFP算法"><a href="#DFP算法" class="headerlink" title="DFP算法"></a><b>DFP算法</b></h5><blockquote>
<p>根据拟牛顿法要满足的条件，$G_{k+1}$应该满足：$G_{k+1}y_k &#x3D; \delta_k$<br>DFP算法中，$G_{k+1}$的迭代是由$G_k$加上两个附加矩阵$P_k$和$Q_k$，即<br>$$G_{k+1}&#x3D;G_k+P_k+Q_k$$<br>两边乘上$y_k$<br>$$G_{k+1}y_k&#x3D;G_k y_k+P_k y_k+Q_k y_k$$<br>为了让$G_{k+1}$满足拟牛顿的条件，所以可以使$P_k$和$Q_k$满足，<br>$P_k y_k &#x3D; \delta_k$和$Q_k y_k &#x3D; -G_k y_k$<br>所以$P_k$和$Q_k$可以写成，<br>$$P_k &#x3D; \frac{\delta_k \delta_k^T}{\delta^T_k y_k}$$<br>$$Q_k &#x3D; -\frac{G_k y_k y_k^T G_k}{y_k^T G_k y_k}$$<br>所以$G_{k+1}$的迭代公式为：</p>
<blockquote>
<p>$$G_{k+1} &#x3D; G_k + \frac{\delta_k \delta_k^T}{\delta^T_k y_k} - \frac{G_k y_k y_k^T G_k}{y_k^T G_k y_k}$$</p>
</blockquote>
<p><b>可以被证明的：</b>如果初始的$G_0$（自己设的矩阵）是正定矩阵，那么经过迭代后的$G_n$也是正定矩阵。<br><b>算法描述：</b></p>
<blockquote>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>深渊巨坑</tag>
        <tag>机器学习</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列</title>
    <url>/2023/05/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h4 id="前情知识："><a href="#前情知识：" class="headerlink" title="前情知识："></a>前情知识：</h4><blockquote>
<ul>
<li><strong>同步：</strong>可以理解为程序在执行完一个操作后，一直等待系统的返回，程序只有收到系统返回后才能继续下一步的操作（如打电话）</li>
<li><strong>异步：</strong>可以理解为程序在执行完一个操作后，委托系统作一个异步委托，当系统返回一个结果后，系统才自动触发委托，向程序发送结果。（如发信息）</li>
</ul>
</blockquote>
<h4 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h4><p>消息队列是在网络通信的消息传输中保存消息的容器（中间件）。</p>
<h4 id="为什么要使用消息队列"><a href="#为什么要使用消息队列" class="headerlink" title="为什么要使用消息队列"></a>为什么要使用消息队列</h4><p>因为在高并发的环境下，大量信息的涌入会使得mysql、redis等数据库造成高压威胁（相当于有一个水池，突然上游水闸开门了，水池自然很快会满，并导致水溢出）。加入消息队列，这样就可以异步处理请求，从而缓解系统压力（相当于在水库和水池之间接一根水管）</p>
<p><strong>不使用消息队列：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E4%B8%8D%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png" alt="不使用消息队列"></p>
<p><strong>使用消息队列：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png" alt="使用消息队列"></p>
<p>在不使用消息队列的情况下，用户请求直接连通数据库，大量<strong>同步请求</strong>使得数据库不堪重负，造成高响应延迟；在使用消息队列后，对于数据库来说，用户发送的是<strong>异步请求</strong>，因此数据库的负载压力得以减轻（由于是异步请求，因此还要作后续请求失败的处理）。</p>
<h4 id="消息队列的特点"><a href="#消息队列的特点" class="headerlink" title="消息队列的特点"></a>消息队列的特点</h4><ul>
<li><p><strong>异步：</strong></p>
<p>如上面所说的，通过接入消息队列这一中间件，大量请求可以得以异步处理，从而减去数据库的负载（实际上就是减少数据库的连接，让数据库不会一口气进行多个连接处理）</p>
</li>
<li><p><strong>削峰：</strong></p>
<p>由于异步特性，消息队列可以让原本的负载压力峰值下降（但是处理时间也会延长），如下图</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E5%89%8A%E5%B3%B0.png" alt="削峰"></p>
<p>如同水池接入一根水管，虽然处理时间延长了，但不会导致水的突然溢出，从而让部分水流失。</p>
</li>
<li><p><strong>解耦：</strong></p>
<p>有一个系统A要调用其他系统的方法，如果直接调用，那么其他系统改变，系统A也会改变，这样的耦合度过高，比较麻烦，</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E8%A7%A3%E8%80%A61.png" alt="解耦1"></p>
<p>但引入消息队列，将系统A和其他系统用消息队列连接起来，此时耦合度就会下降，因为其他系统如何改变，都不会影响到系统A的代码</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E8%A7%A3%E8%80%A62.png" alt="解耦2"></p>
</li>
</ul>
<h4 id="消息队列带来的问题"><a href="#消息队列带来的问题" class="headerlink" title="消息队列带来的问题"></a>消息队列带来的问题</h4><ul>
<li><p><strong>系统复杂性：</strong>因为引入消息队列，因此需要想办法去维护，比如处理<strong>消息重复消费</strong>、<strong>消息丢失</strong>、<strong>消息的顺序消费</strong>等问题，让系统复杂度上升了</p>
</li>
<li><p><strong>数据一致性：</strong>在解耦特性中，各系统之间的数据可能不一致，以及在各系统之间的联动中，其中一个系统出错或失败的后续处理</p>
</li>
<li><p><strong>可用性降低：</strong>在引入消息队列后，还需要考虑消息队列挂掉的问题。</p>
</li>
</ul>
<h4 id="絮絮叨叨"><a href="#絮絮叨叨" class="headerlink" title="絮絮叨叨"></a>絮絮叨叨</h4><p>其实计算机系统很多都采用了类消息队列的操作，如CPU缓存（好像不太合适）、进程队列等，为的就是不让处理的那一方压力过大崩掉。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>基础学科</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>概率论与数理统计（四）</title>
    <url>/2021/02/03/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h3 id="常见的概率分布"><a href="#常见的概率分布" class="headerlink" title="常见的概率分布"></a><b>常见的概率分布</b></h3><p><b>离散型分布：</b></p>
<h4 id="0-1分布："><a href="#0-1分布：" class="headerlink" title="0-1分布："></a><b>0-1分布：</b></h4><blockquote>
<p><b>定义：</b>$P(X&#x3D;k)&#x3D;p^k(1-p)^{1-k}$<br><b>特性：</b>实验只有两种结果，且实验只做一次。</p>
</blockquote>
<h4 id="几何分布："><a href="#几何分布：" class="headerlink" title="几何分布："></a><b>几何分布：</b></h4><blockquote>
<p><b>定义：</b>$P(X&#x3D;k)&#x3D;(1-p)^{k-1}p$，其中P(A)&#x3D;p，第k次是首次发生，前k-1次不发生。记作$G～B(p)$</p>
</blockquote>
<h4 id="二项分布："><a href="#二项分布：" class="headerlink" title="二项分布："></a><b>二项分布：</b></h4><blockquote>
<p><b>定义：</b>A为某事件发生的情况，一共做了n次实验，其中A发生的次数是k次。记作$X～B(n,p)$<br>$$P(X&#x3D;k)&#x3D;C_{n}^{k}p^k(1-p)^{n-k}$$其中，$k&#x3D;0,1,2,…,n$<br><b>特性：</b></p>
<blockquote>
<ul>
<li>$(n+1)p$不为整数时，$(n+1)p$取整时达到最大值。</li>
<li>$(n+1)p$为整数时，$(n+1)p$和$(n+1)p-1$是最大值。</li>
</ul>
</blockquote>
</blockquote>
<h4 id="泊松分布："><a href="#泊松分布：" class="headerlink" title="泊松分布："></a><b>泊松分布：</b></h4><blockquote>
<p><b>定义：</b>$$P(X&#x3D;k)&#x3D;\frac{\lambda^k}{k!}e^{-\lambda}$$其中$\lambda$为单位时间内随机事件的平均<b>发生率</b>，$k&#x3D;0,1,2,…$<br><b>注：</b>在一些情况下二项分布可以用泊松分布近似表示。<br><b>泊松分布的概率密度分布图：</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%A6%82%E7%8E%87%E8%AE%BA/%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83.png" alt="泊松分布" title="泊松分布"></p>
</blockquote>
<h4 id="超几何分布："><a href="#超几何分布：" class="headerlink" title="超几何分布："></a><b>超几何分布：</b></h4><blockquote>
<p><b>定义：</b>N个元素，$N_1$个元素属于第一类，$N_2$个元素属于第二类，在其中取n个元素，X：这n个元素中属于第一类的个数。<br>$$P(X&#x3D;k)&#x3D;\frac{C_{N_1}^kC_{N_2}^{n-k}}{C_N^n}$$<br>其中k&#x3D;0,1,2,…,min(n,$N_1$)<br><b>注：</b>当N很大，n相对于N小得很的时候，超几何分布可以近似看成二项分布。</p>
</blockquote>
<p><b>连续型分布</b></p>
<h4 id="均匀分布："><a href="#均匀分布：" class="headerlink" title="均匀分布："></a><b>均匀分布：</b></h4><blockquote>
<p><b>密度分布函数：</b><br>$$\begin{cases}<br>\frac{1}{b-a}\quad \quad (a&lt;&#x3D;x&lt;&#x3D;b)\\<br>\\<br>0\quad \quad(x属于其他)\\<br>\end{cases}$$</p>
<p><b>分布函数：</b><br>$$\begin{cases}<br>0 \quad \quad x&lt;0 \\<br>\frac{x-a}{b-a} \quad \quad (a&lt;&#x3D;x&lt;b)\\<br>1 \quad \quad \\<br>\end{cases}$$<br>记作$X～U[a,b]$<br><b>均匀分布的概率密度分布图：</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%A6%82%E7%8E%87%E8%AE%BA/%E5%9D%87%E5%8C%80%E5%88%86%E5%B8%83.png" alt="均匀分布" title="均匀分布"></p>
</blockquote>
<h4 id="指数分布："><a href="#指数分布：" class="headerlink" title="指数分布："></a><b>指数分布：</b></h4><blockquote>
<p><b>密度分布函数：</b><br>$$\begin{cases}<br>{\lambda}e^{-{\lambda}x}\quad \quad (x&gt;0)\\<br>\\<br>0 \quad \quad (x&lt;&#x3D;0)\\<br>\end{cases}$$<br>一般记作$X～E_{XP}(\lambda)$<br><b>分布函数：</b><br>$$\begin{cases}<br>1-e^{-{\lambda}x}\quad \quad (x&gt;0)\\<br>\\<br>0 \quad \quad (x&lt;&#x3D;0)\\<br>\end{cases}$$<br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%A6%82%E7%8E%87%E8%AE%BA/%E6%8C%87%E6%95%B0%E5%88%86%E5%B8%83.png" alt="指数分布" title="指数分布"><br><b>性质：无记忆性</b>，当$s,t&gt;&#x3D;0$时，有$P(x&gt;s+t|x&gt;s)&#x3D;p(x&gt;t)$<br>例如，x是一个灯泡的使用寿命，一个已经使用了s小时的灯泡，它能再使用t小时的概率与一个新灯泡使用t小时的概率是一样的。</p>
</blockquote>
<h4 id="正态分布："><a href="#正态分布：" class="headerlink" title="正态分布："></a><b>正态分布：</b></h4><blockquote>
<p><b>密度函数：</b><br>$$\phi(x)&#x3D;\frac{1}{\sqrt[]{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2{\sigma}^2}}$$<br><b>分布函数：</b><br>$$\Phi(x)&#x3D;\frac{1}{\sqrt[]{2\pi}\sigma}\int_{-\infty}^xe^{-\frac{(t-\mu)^2}{2{\sigma}^2}}$$<br>一般记作：$X～N(\mu,{\sigma}^2)$<br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%A6%82%E7%8E%87%E8%AE%BA/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83.png" alt="正态分布" title="正态分布"><br><b>性质：</b></p>
<ul>
<li>$y&#x3D;\phi(x)$以$x&#x3D;\mu$为对称轴，当$x&#x3D;\mu$时，$\phi(x)$最大值$\frac{1}{\sqrt[]{2\pi}\sigma}$</li>
<li>$y&#x3D;\phi(x)$以x轴为渐近线，$x&#x3D;\mu$土$\sigma$处有拐点</li>
<li>$\sigma$固定，$\mu$变化时，图像左&#x2F;右移动。</li>
<li>$\mu$固定，$\sigma$变小时，最高点上移，反之最高点下降</li>
</ul>
</blockquote>
<p><a href="/2021/01/30/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%EF%BC%88%E4%B8%89%EF%BC%89/index.html">上一篇</a></p>
]]></content>
      <categories>
        <category>数学基础</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数</title>
    <url>/2021/01/01/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
    <content><![CDATA[<h3 id="第一章-矩阵与行列式"><a href="#第一章-矩阵与行列式" class="headerlink" title="第一章 矩阵与行列式"></a><b>第一章 矩阵与行列式</b></h3><h4 id="第一节-矩阵及其运算"><a href="#第一节-矩阵及其运算" class="headerlink" title="第一节 矩阵及其运算"></a><b>第一节 矩阵及其运算</b></h4><h5 id="一、n维向量及其线性运算"><a href="#一、n维向量及其线性运算" class="headerlink" title="一、n维向量及其线性运算"></a><b>一、n维向量及其线性运算</b></h5><blockquote>
<p><b>定义：</b><br><b>n维向量：</b>$a&#x3D;\begin{pmatrix}a_1&amp;a_2&amp;a_3&amp;\cdots&amp;a_n\end{pmatrix}$<br><b>n维向量空间：</b>${R^n}&#x3D;\begin{pmatrix}a_1&amp;a_2&amp;a_3&amp;\cdots&amp;a_n\end{pmatrix}{|a_i{\in}R,i&#x3D;1,2,\cdots,n}$<br><b>零向量：</b>分量全为零，用0记之。<br><b>两个向量相等：</b>设向量$a&#x3D;\begin{pmatrix}a_1&amp;a_2&amp;a_3&amp;\cdots&amp;a_n\end{pmatrix}$,向量$b&#x3D;\begin{pmatrix}b_1&amp;b_2&amp;b_3&amp;\cdots&amp;b_n\end{pmatrix}$<br>如果，$a_i&#x3D;b_i(i&#x3D;1,2,{\cdots},n)$,那么我们说向量a与向量b相等，记作$a&#x3D;b$。<br><b>向量的线性运算：</b><br>(1) 加法运算：$a+b&#x3D;{\begin{pmatrix}a_1+b_1,a_2+b_2,{\cdots},a_n+b_n\end{pmatrix}}$<br>(2) 乘法运算：$ka&#x3D;{\begin{pmatrix}k{a_1},k{a_2},{\cdots},k{a_n}\end{pmatrix}}$</p>
</blockquote>
<h5 id="二、线性变换及系数矩阵"><a href="#二、线性变换及系数矩阵" class="headerlink" title="二、线性变换及系数矩阵"></a><b>二、线性变换及系数矩阵</b></h5><blockquote>
<p><b>定义：</b><br><b>线性变换：</b> 变元$x_1,x_2,{\cdots},x_n$与变元$y_1,y_2,{\cdots},y_m$之间的关系式，<br>$$\begin{cases}y_1&#x3D;a_{11}x_1+a_{12}x_2+{\cdots}+a_{1n}x_n,\\<br>y_2&#x3D;a_{21}x_1+a_{22}x_2+{\cdots}+a_{2n}x_n,\\<br>              \cdots \\<br>y_m&#x3D;a_{m1}x_1+a_{m2}x_2+{\cdots}+a_{mn}x_n\\<br>\end{cases}$$<br>称为变元$x_1,x_2,{\cdots},x_n$与变元$y_1,y_2,{\cdots},y_m$之间的<b>线性变换&lt;\b&gt;<br><b>系数矩阵：&lt;\b&gt;由线性变换的系数$a_{ij}(i&#x3D;1,2,{\cdots},m;j&#x3D;1,2,{\cdots},n)$排成<b>m行n列</b>的矩阵。<br><b>性质：</b><br>(1)、分配律：$(A+B)x&#x3D;Ax+Bx$<br>(2)、结合律：$(kA)x&#x3D;k(Ax)$<br>(3)、结合律：$(AB)x&#x3D;A(Bx)$</p>
</blockquote>
<h5 id="三、矩阵及其线性运算"><a href="#三、矩阵及其线性运算" class="headerlink" title="三、矩阵及其线性运算"></a><b>三、矩阵及其线性运算</b></h5><blockquote>
<p><b>定义：</b><br>由mXn个数$a_{ij}(i&#x3D;1,2,{\cdots},m;j&#x3D;1,2,{\cdots},n)$排成的m行n列的矩阵数表，<br>$$\begin{matrix}<br>{a_{11}}&amp;{a_{12}}&amp;{\cdots}&amp;{a_{1n}}\\<br>{a_{21}}&amp;{a_{22}}&amp;{\cdots}&amp;{a_{2n}}\\<br>{\vdots}&amp;{\vdots}&amp;{\ddots}&amp;{\vdots}\\<br>{a_{m1}}&amp;{a_{m2}}&amp;{\cdots}&amp;{a_{nm}}\\<br>\end{matrix}$$<br>称为一个mXn<b>矩阵</b>，其中每一个$a_{ij}$都是该矩阵的元素。<br><b>方阵：</b>行数与列数相等的矩阵称为方阵。<br><b>同型矩阵：</b>两个矩阵的<b>行数和列数相同</b>的两个矩阵。<br><b>矩阵相同：</b>两个矩阵的对应位元素相同的同型矩阵。<br><b>矩阵的加法：</b>设$A&#x3D;(a_{ij})$与$B&#x3D;(b_{ij})$都是mXn矩阵，记<br>$c_{ij}&#x3D;a_{ij}+b_{ij},(i&#x3D;1,2,{\cdots},m;j&#x3D;1,2,{\cdots},n)$<br>称mXn矩阵$C&#x3D;(c_{ij})$为矩阵A与矩阵B的和，记作$C&#x3D;A+B$<br><b>矩阵的乘数：</b></p>
</blockquote>
<p>​                                                                     </p>
]]></content>
      <categories>
        <category>数学基础</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>物理层</title>
    <url>/2022/01/16/%E7%89%A9%E7%90%86%E5%B1%82/</url>
    <content><![CDATA[<h2 id="物理层的基本概念："><a href="#物理层的基本概念：" class="headerlink" title="物理层的基本概念："></a>物理层的基本概念：</h2><blockquote>
<p>1、物理层考虑的是在不同的计算机上传输<b>数据比特流</b></p>
<p>2、物理层主要任务是描述与<strong>传输媒体接口</strong>有关的一些<strong>特性</strong></p>
<blockquote>
<ul>
<li><strong>机械特性：</strong>指接口的严格标准化的规定，如接口所用接线器的形状、尺寸、引脚数目等等。</li>
<li><strong>电气特性：</strong>指明在接口电缆各条线上出现电压的范围。</li>
<li><strong>功能特性：</strong>知名某条线上出现某一电平的意义。</li>
<li><strong>规程特性：</strong>指明对于不同功能的各种可能事件的出现顺序。</li>
</ul>
</blockquote>
<p>物理层的传输单元为<strong>比特流</strong>。</p>
</blockquote>
<h2 id="数据通信的基础知识："><a href="#数据通信的基础知识：" class="headerlink" title="数据通信的基础知识："></a><strong>数据通信的基础知识：</strong></h2><h3 id="数据系统的通信模型："><a href="#数据系统的通信模型：" class="headerlink" title="数据系统的通信模型："></a><strong>数据系统的通信模型：</strong></h3><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%80%9A%E8%AE%AF%E6%A8%A1%E5%9E%8B.png" alt="数据通讯模型"></p>
<p><strong>源系统</strong>一般包括以下部分：</p>
<ul>
<li><strong>信源</strong>：源点设备产生要发送的数据。又称<strong>原站</strong>或<strong>源点</strong>。</li>
<li><strong>发送器：</strong>源点生成的数字比特流需要通过发送器编码后才能在传输信道上传输。典型的发送器是<strong>调制器</strong>。</li>
</ul>
<p><strong>目的系统</strong>一般包括以下部分：</p>
<ul>
<li><strong>接收器：</strong>接收传输系统发送过来的信号，需要通过接收器编码才能让接收方处理。典型的接收器是<strong>解调器</strong>。</li>
<li><strong>终点：</strong>信号最终传输到的目的地，又称<strong>目的站</strong>或<strong>信宿</strong>。</li>
</ul>
<p><strong>补充：</strong>图上面的<strong>调制解调器</strong>是<strong>解调器</strong>与<strong>调制器</strong>的集合版，即<strong>调制解调器</strong>既可以将数字信号转成模拟信号，也可以将模拟信号转成数字信号。</p>
<p><strong>信号的分类：</strong></p>
<ul>
<li><strong>数字信号：</strong>代表信息的参数是离散的，也称<strong>离散信号</strong>。</li>
<li><strong>模拟信号：</strong>代表信息的参数是连续的，也称<strong>连续信号</strong>。</li>
</ul>
</blockquote>
<h3 id="有关信道的概念："><a href="#有关信道的概念：" class="headerlink" title="有关信道的概念："></a>有关信道的概念：</h3><blockquote>
<p><strong>信道：</strong>表示某一个方向发送信息的媒体。</p>
<p><strong>信息交互的基本方式：</strong></p>
<ul>
<li><strong>单向信道：</strong>又称<strong>单工信道</strong>，只能有一个方向的通信而无反方向的通信，只需一条信道。如：广播通信等</li>
<li><strong>双向交替信道：</strong>又称<strong>半双工信道</strong>，双方可以都发送和接收信息，但每一次只能有一方发送，另一方只能接收，需要两条信道。<strong>双向同时信道：</strong>又称<strong>全双工通信</strong>，双方可以<strong>同时发送与接收</strong>信息，也需要两条信道。</li>
</ul>
</blockquote>
<blockquote>
<p> <strong>信息传输方式：</strong></p>
<ul>
<li><strong>串行传输：</strong>每一次只能发送一个比特，只需一根线就能实现，所以日常能看见的基本都是串行传输。</li>
</ul>
<p><strong>特点：</strong>发送速度<strong>慢</strong>，费用<strong>低</strong>，适合<strong>远距离</strong>。</p>
<ul>
<li><strong>并行传输：</strong>每一次可以发送多个比特流，因此需要多跟线来实现，多用于计算机内部的传输。</li>
</ul>
<p><strong>特点：</strong>发送速度<strong>快</strong>，费用<strong>高</strong>，适合<strong>近距离</strong>。</p>
<p><strong>码元：</strong>指用一个<strong>固定时长</strong>的<strong>信号波形</strong>，代表不同离散数值的基本波形，是数字信道中数字信号的计量单位，这个时长内的信号称为k进制码元，该时长称为码元宽度。当码元的离散状态有M个时，此时该码元称为<strong>M进制码元</strong>。如在使用二进制编码时，只有0、1两种不同码元，也称为二进制码元。</p>
<p><strong>速率：</strong>速率也叫数据率，指数据的<strong>传输速率</strong>，表示单位时间内传输的数据量。可以用<strong>码元传输速率</strong>和<strong>信息传输速率</strong>表示。（<strong>注：</strong>这的传输速率指的是数据从主机发送到链路上的速率，链路上的称为<strong>传播速率</strong>。）</p>
<ul>
<li><p><strong>码元传输速率：</strong>别名码元速率、波形速率、调制速率、符号速率等，表示<strong>单位时间内数字系统所传输的码元个数</strong>（也称<strong>脉冲个数</strong>或<strong>信号的变化次数</strong>），单位为<strong>波特（Baud）</strong>。码元速率与进制数无关。</p>
</li>
<li><p><strong>信息传输速率：</strong>别名信息速率、比特率等，表示<strong>单位时间内数字通信系统的二进制码元个数</strong>（即<strong>比特数</strong>），单位是<strong>比特每秒（b&#x2F;s）</strong>。</p>
</li>
</ul>
<p><strong>关系：</strong>若一个码元携带<strong>n bit</strong>的信息量，则<strong>M Baud</strong>的码元传输速率对应的信息传输速率为<strong>M*n bit&#x2F;s</strong>。</p>
<p><strong>带宽：</strong>表示单位时间从网络中的某一点到另一点所能通过的“<strong>最高数据率</strong>”，一般用来表示网络的通信线路所能传输的能力，单位是<strong>b&#x2F;s</strong>。当然还有另一种带宽的定义：<strong>信道上最高能通过的频率与最低通过的频率之差。</strong></p>
</blockquote>
<h3 id="奈奎斯特定理与香农定理："><a href="#奈奎斯特定理与香农定理：" class="headerlink" title="奈奎斯特定理与香农定理："></a>奈奎斯特定理与香农定理：</h3><h4 id="奈奎斯特定理（又称奈氏准则）"><a href="#奈奎斯特定理（又称奈氏准则）" class="headerlink" title="奈奎斯特定理（又称奈氏准则）"></a>奈奎斯特定理（又称奈氏准则）</h4><blockquote>
<p><strong>定义：</strong>在<strong>理想低通（没有噪声、带宽有限）</strong>的信道中，为了避免<strong>码间串扰</strong>，极限码元传输速率为<strong>2W波特</strong>，其中W为该信道的带宽。</p>
<p>（<strong>补充：</strong>码间串扰指的是，信号传播频率过大导致接收端接收到的信号波形失去码元之间的清晰界限的现象。）</p>
<p><strong>根据码元传输速率与比特传输速率之间的转换</strong>，可以得到码元种类为V的信道极限数据传输速率为：<br>$$<br>理想信道的极限数据传输速率&#x3D;2Wlog_2V	\quad(单位为b&#x2F;s)<br>$$<br><strong>对于奈氏准则，可得到以下结论：</strong></p>
<ul>
<li>在任何信道中，码元的传输速率是有上限的，超过上限则会出现码间串扰。</li>
<li>信道的带宽越高，码元的有效传播速率越快。</li>
<li>奈氏准则给出了码元传输的限制，但未给定信息的传输速率，即未对一个码元对应多少位比特做出限制。</li>
</ul>
</blockquote>
<h4 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h4><blockquote>
<p> <strong>定义：</strong>香农定理给定了<strong>带宽有限、存在高斯白噪声</strong>干扰的信道的极限数据传输速率为：<br>$$<br>信道的极限数据传输速率&#x3D;Wlog_2(1+\frac{S}{N}) \quad (单位为b&#x2F;s)<br>$$<br>其中W为信道带宽，S&#x2F;N为信噪比（可以用来表示噪声对于信号的影响）定义为：<br>$$<br>信噪比&#x3D;10log_{10}(\frac{S}{N}) \quad (单位为dB)<br>$$<br><strong>对于香农定理，可得到以下结论：</strong></p>
<ul>
<li>信道的带宽或信道比越大，信息的极限传输速率就越高。</li>
<li>对于一定的带宽和一定的信噪比，信息传输速率的上限是确定的。</li>
<li>只要信息传输速率低于极限，那么就能找到某种方式提升信息传输速率。</li>
<li>香农定理求得的是极限信息传输速率，实际信道的传输速率要低于该值。</li>
</ul>
<p><strong>总结：</strong>香农定理<strong>考虑的是更实际的极限传输速率</strong>，<strong>奈氏准则考虑的是一个无噪声的理想条件下</strong>的极限传输速率。</p>
</blockquote>
<h3 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h3><blockquote>
<p><strong>编码：</strong>把数据转换成数字信号的过程。</p>
<p><strong>调制：</strong>把数据转换成模拟信号的过程。</p>
</blockquote>
<h4 id="数字数据编码为数字信号"><a href="#数字数据编码为数字信号" class="headerlink" title="数字数据编码为数字信号"></a>数字数据编码为数字信号</h4><p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%89%A9%E7%90%86%E5%B1%82/%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F.png" alt="常用编码方式"></p>
<h5 id="归零编码"><a href="#归零编码" class="headerlink" title="归零编码"></a>归零编码</h5><blockquote>
<p><strong>定义：</strong>在归零编码中用高电平代表1、低电平代表0（也可以相反），每个时钟周期均跳为低电平。</p>
</blockquote>
<h5 id="非归零编码"><a href="#非归零编码" class="headerlink" title="非归零编码"></a>非归零编码</h5><blockquote>
<p><strong>定义：</strong>高电平代表1，低电平代表0，且一整个时钟周期都不改变电平。缺点是双方满以同步。</p>
</blockquote>
<h5 id="反向非零编码"><a href="#反向非零编码" class="headerlink" title="反向非零编码"></a>反向非零编码</h5><blockquote>
<p><strong>定义：</strong>电平翻转的代表0，电平保持不变的代表1。</p>
</blockquote>
<h5 id="曼彻斯特编码"><a href="#曼彻斯特编码" class="headerlink" title="曼彻斯特编码"></a>曼彻斯特编码</h5><blockquote>
<p><strong>定义：</strong>将一个码元的时钟周期分为两个相等的间隔，前半部分为高电平，后半部分为低电平代表1；前半部分为低电平，后半部分为高电平代表0。（也可以相反）</p>
</blockquote>
<h5 id="差分曼彻斯特编码"><a href="#差分曼彻斯特编码" class="headerlink" title="差分曼彻斯特编码"></a>差分曼彻斯特编码</h5><blockquote>
<p><strong>定义：</strong>如果码元为1，则前半个码元的电平与上一个码元的后半部分的电平相等；若码元为0，则前半个码元的电平与上一个码元的后半部分的电平相反。</p>
</blockquote>
<h4 id="数字数据调制为模拟信号"><a href="#数字数据调制为模拟信号" class="headerlink" title="数字数据调制为模拟信号"></a>数字数据调制为模拟信号</h4><p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E5%AD%97%E8%B0%83%E5%88%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F.png" alt="数字调制的三种方式"></p>
<h5 id="幅移键控-ASK-（调幅）"><a href="#幅移键控-ASK-（调幅）" class="headerlink" title="幅移键控(ASK)（调幅）"></a>幅移键控(ASK)（调幅）</h5><blockquote>
<p>通过改变载波信号的振幅来表示数字0和1，而载波的频率与相位不变。<strong>特点是</strong>容易实现，但抗干扰能力差。</p>
</blockquote>
<h5 id="频移键控-FSK-（调频）"><a href="#频移键控-FSK-（调频）" class="headerlink" title="频移键控(FSK)（调频）"></a>频移键控(FSK)（调频）</h5><blockquote>
<p>通过改变载波信号的频率来表示数字0和1，而载波的振幅与相位不变。<strong>特点是</strong>容易实现，抗干扰能力强。</p>
</blockquote>
<h5 id="相移键控-PSK-（调相位）"><a href="#相移键控-PSK-（调相位）" class="headerlink" title="相移键控(PSK)（调相位）"></a>相移键控(PSK)（调相位）</h5><blockquote>
<p>通过改变载波信号的相位来表示数字0和1，而载波的振幅与频率不变。</p>
</blockquote>
<h5 id="正交振幅调制-QAM-（调幅加调相位）"><a href="#正交振幅调制-QAM-（调幅加调相位）" class="headerlink" title="正交振幅调制(QAM)（调幅加调相位）"></a>正交振幅调制(QAM)（调幅加调相位）</h5><blockquote>
<p>在频率相同的情况下，将<strong>幅移键控</strong>和<strong>相移键控</strong>相结合，形成叠加信号。</p>
<p>设波特率为B，采用m个相位，每个相位有n种振幅，则QAM技术的数据传输速率R为：<br>$$<br>R&#x3D;Blog_2(mn)\quad(单位为b&#x2F;s)<br>$$</p>
</blockquote>
<h4 id="模拟数据编码为数字信号"><a href="#模拟数据编码为数字信号" class="headerlink" title="模拟数据编码为数字信号"></a>模拟数据编码为数字信号</h4><blockquote>
<p>这种编码方式最典型的例子是常用于对音频信号进行编码的<strong>脉码调制(PCM)<strong>它主要包括三个步骤，即</strong>采样、量化</strong>和<strong>编码</strong>。</p>
<ul>
<li><p><strong>采样：</strong>指对模拟信号进行周期性扫描，把时间上连续的信号变成时间上离散的信号。</p>
<p><strong>注意：</strong>采样的频率必须大于模拟数据的频带带宽（最高变化频率）的两倍，这样才能保证采样的信号不失真。</p>
</li>
<li><p><strong>量化：</strong>把采样取得的电平幅值按照一定的分级标度转化为对应的数字值并取整数。</p>
</li>
<li><p><strong>编码：</strong>把量化的结果转换为对应的二进制编码。</p>
</li>
</ul>
</blockquote>
<h4 id="模拟数据调制为模拟信号"><a href="#模拟数据调制为模拟信号" class="headerlink" title="模拟数据调制为模拟信号"></a>模拟数据调制为模拟信号</h4><blockquote>
<p>为了实现传输的有效性，可能需要较高的频率。这种调制方式还可以使用频分复用。</p>
</blockquote>
<h2 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h2><blockquote>
<p><strong>传输媒体</strong>也称为传输介质或传输媒介，它是数据传输系统中在发送器和接收器之间的物理通路<strong>（它不属于物理层）</strong>。传输媒体可以分为两大类，<strong>导引型传输媒体</strong>和<strong>非导引型传输媒体</strong>。</p>
<p>在导引型传输媒体中，电磁波被导引沿固定媒体传播；在非导引型传输媒体中，电磁波在自由空间里传播（也就是无线传输）。</p>
</blockquote>
<h3 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h3><h4 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h4><blockquote>
<p>双绞线也称为双扭线，把两根相互绝缘的铜导线并排在一起，然后用规则的方式<strong>绞合</strong>起来就形成了双绞线。绞合的两根线可以有效地较少相互的电磁干扰。</p>
<p>根据是否加入屏蔽层,可以将双绞线分为:<strong>无屏蔽双绞线</strong>与<strong>屏蔽双绞线</strong>。由字面上可以知道后者的抗干扰能力要比前者强。</p>
<p>同时双绞线还可以根据不同的绞合度进行分类。</p>
<p><strong>双绞线结构图:</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%89%A9%E7%90%86%E5%B1%82/%E5%8F%8C%E7%BB%9E%E7%BA%BF.png" alt="双绞线"></p>
<p><strong>双绞线的特点：</strong></p>
<ul>
<li>模拟传输与数字传输都可以使用双绞线</li>
<li>双绞线的通信距离一般为几到十几公里，太远的传输距离会导致信号失真，这时则需要加上中继器对信号进行整形。</li>
<li>双绞线在传输数字信号时的速率为几兆比特，传输距离为几公里，因此较多用于局域网的传输。</li>
<li>双绞线便宜。</li>
</ul>
</blockquote>
<h4 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h4><blockquote>
<p><strong>组成：</strong>同轴电缆由内导体同质芯线（单股实心线或多股绞合线）、绝缘层、网状编织的外导体屏蔽层以及保护塑料外层所组成。</p>
<p><strong>同轴电缆结构图：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%89%A9%E7%90%86%E5%B1%82/%E5%90%8C%E8%BD%B4%E7%94%B5%E7%BC%86.png" alt="同轴电缆"></p>
<p>同轴电缆的嗲款取决于电缆的质量，高质量的同轴电缆的带宽接近1GHz。</p>
<p>同轴电缆主要用于有线电视的信号传输中，以及局域网的信号通信中也存在同轴电缆的身影。</p>
</blockquote>
<h4 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h4><blockquote>
<p>光纤通信就是利用光导纤维传递光脉冲来进行通信。<strong>有光脉冲相当于1，没有光脉冲相当于0</strong>。</p>
<p>光纤是光的通信媒体，因此需要进行光信号与电信号之间的转换。</p>
<ul>
<li><strong>发送端：</strong>采用<strong>发光二极管</strong>或<strong>半导体激光器</strong>这两元件，让电脉冲可以转化成光脉冲。</li>
<li><strong>接收端：</strong>采用<strong>光电二极管</strong>或<strong>成光检测器</strong>这两元件，让光脉冲可以转化成电脉冲。</li>
</ul>
<p><strong>组成：</strong>光纤主要由<strong>纤芯（实心）</strong>和<strong>包层</strong>构成双层通信圆柱体，其中纤芯非常细，直径在8~100微米之间。其中包层的折射率要小于纤芯的折射率（因此在大的入射角中发生全反射，降低信号的衰减）。</p>
<p><strong>光纤的构造及传播方式：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%89%A9%E7%90%86%E5%B1%82/%E5%85%89%E7%BA%A4%E7%9A%84%E6%9E%84%E9%80%A0.png" alt="光纤的构造"></p>
<p>当然在光纤中只要满足入射角大于某个值就可发生全反射，那么就可以在光纤中射入多条光脉冲信号。由此可以将光纤分为：<strong>单模光纤</strong>和<strong>多模光纤</strong>。</p>
<p><strong>单模光纤：</strong>光纤直径只有一个光的波长，使得光线一直向前传播，而不会产生多次反射。</p>
<p><strong>多模光纤：</strong>可以存在多条不同角度入射的光线在一条光纤中传输。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%89%A9%E7%90%86%E5%B1%82/%E5%85%89%E7%BA%A4%E7%A7%8D%E7%B1%BB.png" alt="光纤种类"></p>
<p><strong>光纤特点：</strong></p>
<ul>
<li>传输损耗小，中继距离长，对远距离传输十分友好。</li>
<li>抗雷电及电磁干扰性能好。</li>
<li>无串音干扰，保密性好，不容易被窃听或截取数据。</li>
<li>体积小，重量轻。</li>
</ul>
</blockquote>
<h3 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h3><h4 id="无线电波"><a href="#无线电波" class="headerlink" title="无线电波"></a>无线电波</h4><blockquote>
<p>属于无线传输信息的方式之一，传播的特点是呈辐射状地向所有方向进行传输。</p>
</blockquote>
<h4 id="微波"><a href="#微波" class="headerlink" title="微波"></a>微波</h4><blockquote>
<p>微波通信主要有两类方式：<strong>地面微波接力通信</strong>和<strong>卫星通信</strong></p>
<ul>
<li><strong>地面微波接力通信：</strong>由于微波在空间是直线传播的，而地球是一个曲面的球体。因此在使用微波通信时就需要采用天线塔对信号进行接力。</li>
<li><strong>卫星通信：</strong>顾名思义就是使用人造卫星，对地球上传播的微波信号进行接力。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>微波波段频率很高，其频段范围宽，所以其通信信道的容量大。</li>
<li>微波传输质量较高。</li>
<li>由于是无线传输，因此受地形限制要小。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>相邻中继站之间必须直视，不能有障碍物。</li>
<li>微波的传播更容易受自然环境的影响。</li>
<li>与电缆通信相比较，微波通信的隐蔽性与保密性较差。</li>
<li>中继站等设备的建造与维护花销大。</li>
</ul>
<p><strong>补充：</strong>卫星通信的传播时延较长。</p>
</blockquote>
<h2 id="中继器与集线器"><a href="#中继器与集线器" class="headerlink" title="中继器与集线器"></a>中继器与集线器</h2><h3 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h3><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%89%A9%E7%90%86%E5%B1%82/%E4%B8%AD%E7%BB%A7%E5%99%A8.png" alt="中继器"></p>
<p><strong>功能：</strong>对信号进行<strong>再生和还原</strong>，对衰减的信号进行放大，保持与原数据相同。</p>
<p><strong>中继器的两端：</strong></p>
<ul>
<li>仅对信号进行一个增强作用不会进行差错检测。</li>
<li>两端可连接相同媒体（两端都是双绞线），也可以连不同媒体。</li>
<li>中继器两端的网段一定是同一个协议。</li>
</ul>
<p><strong>5-4-3规则：</strong>网络标准对信号的延迟进行了规定，因此中继器的添加也要有所限制。否则会导致信息传输延迟过大。</p>
</blockquote>
<h3 id="集线器（多口中继器）"><a href="#集线器（多口中继器）" class="headerlink" title="集线器（多口中继器）"></a>集线器（多口中继器）</h3><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%89%A9%E7%90%86%E5%B1%82/%E9%9B%86%E7%BA%BF%E5%99%A8.png" alt="集线器"></p>
<p><strong>功能：</strong>对信号进行<strong>再生、放大、转发</strong>，对衰减的信号进行放大，接着将信号转发到其他所有（除输入端口外）处于工作状态的端口上。</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>基础学科</tag>
      </tags>
  </entry>
  <entry>
    <title>知识图谱</title>
    <url>/2023/04/23/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/</url>
    <content><![CDATA[<h3 id="知识图谱"><a href="#知识图谱" class="headerlink" title="知识图谱"></a>知识图谱</h3><ul>
<li><p><strong>什么是知识图谱：</strong></p>
<p>知识图谱本质是一个语义网络；它是一个基于图的数据结构，由边和节点构成，节点表示<strong>实体</strong>，边表示两个节点之间的<strong>关系</strong>。</p>
</li>
<li><p><strong>知识图谱的表现形式</strong></p>
<p>知识图谱实际上就是三元组，形式为**&lt;实体，关系，实体&gt;<strong>或</strong>&lt;实体，属性，属性值&gt;**</p>
</li>
<li><p><strong>知识图谱的构成：</strong></p>
<ul>
<li><p><strong>数据模式（schema）：</strong>一个领域内的数据模型，即包含了这个领域里面有意义的概念类型（type）以及这些类型的属性（property），schema主要是去定义需求。</p>
</li>
<li><p><strong>域（domain）：</strong>域的概念是凌驾于所有类型之上，对域的定义尽量抽象，而且域与域之间尽量相互独立。例如，地理位置域，而省份；城市；国家；等则不能作为域（以为它们有所交叉）</p>
</li>
<li><p><strong>域的类型（type）：</strong>构建这个schema的核心需求是什么，到底解决用户什么问题。为了满足这些需求，我们需要创造出哪些概念？</p>
</li>
<li><p><strong>本体：</strong>用于描述事物的本质，是对于特定领域真实存在的实体的类型、属性，以及它们之间的相互关系的一种定义</p>
</li>
<li><p><strong>实体：</strong>客观世界的事物，是构成知识图谱的基本单位。</p>
</li>
<li><p><strong>关系：</strong>指两个或多个实体之间的某种联系（如，广州-位于-中国，其中位于就是一种关系）。</p>
</li>
</ul>
</li>
<li><p><strong>构造知识图谱的方式：</strong></p>
<ul>
<li><p><strong>自顶向下（Top-Down）</strong>：即首先为知识图谱定义数据模式，数据模式从最顶层概念构建，逐步向下细化，形成结构良好的分类学层次，然后再添加实体</p>
</li>
<li><p><strong>自底向上（Bottom-Up）：</strong>即首先对实体进行归纳组织，形成底层概念，然后逐步向上抽象，形成上层概念。</p>
</li>
</ul>
<p>自底向上的方式适合构建通用领域的知识图谱，以及数据、业务非常复杂某些行业领域知识图谱；而自顶向下的方式适合构建行业垂直领域知识图谱</p>
</li>
<li><p><strong>例子：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/%E4%BE%8B%E5%AD%90.png" alt="例子"></p>
<p>这里将电影名作为实体，将电影类型、时长、语言、别名作为该类型实体的属性；</p>
<p>将地区定为一个实体，但暂时没有属性</p>
<p>将人作为一个实体，将性别、出生年月、国籍、职业作为它的属性</p>
<p>根据这三个实体，可以两两定义出它们之间的关系：执导、出演、上映于；从而得到三元组&lt;人，执导，电影&gt;、&lt;人，出演，电影&gt;、&lt;电影，上映于，地区&gt;</p>
</li>
<li><p><strong>知识抽取：</strong>从语句中抽取构造知识图谱所需要的实体、关系、属性和事件；为了进行知识抽取，于是就有了<strong>实体识别</strong>、<strong>关系抽取</strong>、<strong>属性抽取</strong>、事件抽取等技术</p>
<ul>
<li><p><strong>实体识别：</strong>实体识别的主要任务就是识别待处理文本中三大类（实体类、时间类、数字类）、七小类（人名、机构名、地名、时间、日期、货币、百分比）命名实体（当然我们也可以自己定义相关的实体类别，不一定仅局限于上述的几类）。<br>例如，在语句”2019年香港演员古天乐有18部电影上映，他可真是电影界劳模“中，”香港演员“、”古天乐“、”他“都表示一个任务的实体，其中”他“是指称实体，”古天乐“是命名实体。</p>
<p>一般所说的实体识别是指<strong>命名实体识别（NER）</strong>，它包括：判断实体边界位置、区分实体类别两个步骤</p>
<p><strong>NER的标注方式：</strong>为了训练NER模型，需要先对数据进行标注。常用的标注形式有：BIEOS、BMEOS、BIO（这里每个大写字母为一个含义，不是什么词组缩写）。以BIEOS为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">《  O</span><br><span class="line">影  MOV-S</span><br><span class="line">》  O</span><br><span class="line">是  O</span><br><span class="line">由  O</span><br><span class="line">张  PER-B</span><br><span class="line">艺  PER-I</span><br><span class="line">谋  PER-E</span><br><span class="line">导  O</span><br><span class="line">演  O</span><br><span class="line">，  O</span><br><span class="line">孙  PER-B</span><br><span class="line">俪  PER-E</span><br><span class="line">和  O</span><br><span class="line">邓  PER-B</span><br><span class="line">超  PER-E</span><br><span class="line">主  O</span><br><span class="line">演  O</span><br><span class="line">的  O</span><br><span class="line">一  O</span><br><span class="line">部  O</span><br><span class="line">电  O</span><br><span class="line">影  O</span><br><span class="line">。  O</span><br></pre></td></tr></table></figure>

<p>其中，</p>
<p>O表示非实体名称字符；</p>
<p>S表示单个字符的实体名称（MOV-S就表示这是一个电影的单字符实体）</p>
<p>B表示实体名称的开始位置（PER-B表示这是一个人名实体开始的位置）</p>
<p>I&#x2F;M表示实体名称的中间位置（PER-I表示这是一个人名实体中间的位置）</p>
<p>E表示实体名称的结尾位置（PER-E表示这是一个人名实体结尾的位置）</p>
<p>其中，MOV、PER用于表示电影名、人名这两类实体</p>
<p><strong>命名实体识别（NER）</strong>要做的工作就是在上述语句中判断张艺谋三个字中”张“是实体开始的位置，”艺“是实体中间的位置，”某“是实体结束的位置。本质上，这是一个序列标注问题，也可以是一个多分类问题。</p>
<p><strong>NER常用算法：</strong>基于规则模板的算法、基于机器学习的算法、基于神经网络的算法。</p>
<ul>
<li><p><strong>基于机器学习的算法：</strong> <strong>隐马尔科夫模型（HMM）</strong>、<strong>条件随机场（CRF）</strong>，其中无论是HMM还是CRF，它们的最终目的就是需要根据观察序列找到一条概率最大的输出序列路径，即将”张艺谋“的预测输出顺序为 ”PER-B、PER-I、PER-E“ ，而不是 ”PER-I、PER-B、PER-E“ 之类的错误路径，也就是B一定在I、E之前，E一定在B之后。</p>
</li>
<li><p><strong>基于神经网络的算法：</strong> <strong>BI-LSTM-CRF模型</strong>、<strong>BI-LSTM-softmax 模型</strong>、<strong>bert模型</strong></p>
</li>
</ul>
<p><strong>NER评价指标：</strong>由于NER可以看作多分类任务，所以可以使用多分类的评估指标来评估NER模型效果，如F1值就是常用的评价指标<br>$$<br>正确率&#x3D;\frac{识别出的正确实体数}{识别出的实体数}<br>$$</p>
<p>$$<br>召回率&#x3D;\frac{识别出的正确实体数}{样本的实体数}<br>$$</p>
<p>正确率与召回率的取值都在0和1之间。正确率和召回率有时会出现矛盾的情况，这是需要综合考虑它们的<strong>加权调和均值</strong>，即F值，其中最常用的是F1值，<strong>当F1值较高时说明实验方法比较有效</strong>，F1值定义如下：<br>$$<br>F1&#x3D;\frac{2<em>正确率</em>召回率}{正确率+召回率}<br>$$</p>
</li>
<li><p><strong>关系抽取</strong></p>
<p>关系抽取就是自动识别实体之间具有的某种语义关系，这里主要介绍二元关系抽取</p>
<p><strong>关系抽取分类：</strong></p>
<ul>
<li><strong>面向结构化文本的关系抽取：</strong>结构化文本包括表格数据、XML文档以及数据库数据这类具有良好布局，抽取关系比较简单的数据。</li>
<li><strong>面向非结构化文本的关系抽取：</strong>非结构化文本就是指纯文本，即一句”2019年香港演员古天乐有18部电影上映，他可真是电影界劳模“，文本中没有明确的关系。</li>
<li><strong>面向半结构化文本的关系抽取：</strong>它不符合关系型数据库或其他数据表的形式关联起来的数据模型结构，但又包含相关标记，数据结构与内容混在一起。如HTML文档，json等</li>
<li><strong>句子级关系抽取：</strong>也称为句子级关系分类，即从一个句子中抽取关系</li>
<li><strong>篇章级关系抽取：</strong>该任务旨在判断两个实体之间是否具有语义关系，而不关心两实体之间是否具有上下文关系</li>
</ul>
<p>根据抽取的领域，关系抽取又可以分为：</p>
<ul>
<li><strong>限定领域关系抽取：</strong>指在一个或多个限定领域内对实体间的语义关系进行抽取。一般来说，在限定领域下，关系都是预先定义好的有限个类别，因此可以采用基于监督学习的方法来处理，即针对每个关系类别标注足够多的样本，然后使用多分类模型来训练关系抽取模型</li>
<li><strong>开放领域关系抽取：</strong>该任务不限定关系的类别，依据模型对自然语言句子理解的结果从中开放式的抽取实体三元组</li>
</ul>
<p><strong>关系抽取的难点：</strong></p>
<ul>
<li>同一关系可以用多种不同的词汇进行表达：比如，“张艺谋执导了《影》” 和句子 “张艺谋导演了《影》” 都表达了张艺谋和《影》之间的导演关系。</li>
<li>同一个短语或者词可能表达了不同的关系。比如：“李梅是我的姑娘”，这个“姑娘”到底指女儿呢还是女朋友呢？</li>
<li>同一对实体之间可能存在不止一种关系。比如徐峥导演了《人在囧途》，徐峥也主演了《人在囧途》。</li>
</ul>
<p><strong>限定领域的非结构化文本的句子级关系抽取的常用算法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//任务</span><br><span class="line">输入：句子“Steve Jobs was the co-founder of Apple Inc”和两个实体 Steve Jobs 和 Apple Inc</span><br><span class="line">要求输出：实体之间的关系：/business/company/founder</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>基于模板的关系抽取方法</strong></p>
<p>基于模板的关系抽取就是通过人工编辑或总结学习得到模板，然后使用这些模板去文本中匹配，匹配到了就代表着抽取到了指定实体之间的关系。例如，假设X和Y都表示公司实体，那么可以用以下模板表示“收购”关系：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X is acquired by Y</span><br><span class="line">X is purchased by Y</span><br><span class="line">X is bought by Y</span><br></pre></td></tr></table></figure>

<p>当句子中所出现的实体的上下文出现上诉模板时，就可以认为这两个实体具备“收购”的语义关系</p>
<p>但很明显，缺点在于这是纯人工的模板，都无法穷举所有模板，因此这种关系抽取的方法的召回率都特别低。（当然在此基础上，可以将学习到的模板进行聚类，于是就有了自提升策略的学习方法）</p>
</li>
<li><p><strong>基于特征工程的机器学习方法</strong></p>
<p>基于特征的方法需要显示的将关系实例转化成分类器能够接受的特征向量，然后使用分类器模型进行训练。常见的关系抽取特征有以下几个：</p>
<ul>
<li>实体属性特征</li>
<li>重叠特征</li>
<li>依存句法特征</li>
<li>句法树特征</li>
</ul>
<p>因为需要使用特征抽取工具来提取上述所列举的特征，所以要用到一些自然语言处理工具，同时特征抽取的过程是一个串联的（Pipeline）过程，前一步的输出要作为后一步的输入，显然，由于自然语言处理工具的性能不能保证百分百的准确，这不可避免的造成错误的累积和传递，导致抽取的特征不精准，当然最终的关系抽取效果就大打折扣了。所以现在都流行端到端（end to end）的模型</p>
</li>
<li><p><strong>基于神经网络的方法</strong></p>
<p><strong>PCNN模型</strong></p>
<p><strong>CNN+ATT模型</strong></p>
<p><strong>bert模型</strong></p>
</li>
</ul>
</li>
<li><p><strong>属性抽取</strong></p>
<p>属性抽取可以转变成关系抽取，它们都是三元组，可以使用上述关系抽取模型来做</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>自然语言处理</category>
      </categories>
      <tags>
        <tag>深渊巨坑</tag>
        <tag>自然语言处理</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归代码实现</title>
    <url>/2021/09/21/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a><b>梯度下降</b></h4><blockquote>
<p><b>算法描述：</b></p>
<blockquote>
<ul>
<li>导入数据</li>
<li>计算$h(x)$，并且计算梯度</li>
<li>利用梯度下降函数GD()计算循环loop_times的$\theta$</li>
<li>画图</li>
</ul>
</blockquote>
<p><b>代码实现：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]        <span class="comment"># 画图时显示中文</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span>          <span class="comment"># 画图时显示负号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dataSet</span>():</span><br><span class="line">   x = np.random.uniform(-<span class="number">3</span>,<span class="number">3</span>,<span class="number">200</span>)</span><br><span class="line">   r = np.random.uniform(-<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line">   xx = np.linspace(-<span class="number">10</span>,<span class="number">10</span>,<span class="number">200</span>)</span><br><span class="line">   target = r * xx + x</span><br><span class="line">   data = xx</span><br><span class="line">   <span class="keyword">return</span> target,data</span><br><span class="line"></span><br><span class="line"><span class="comment"># h(x) = theta^T * X 的值（所有的）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">h_x</span>(<span class="params">XX, theta</span>):</span><br><span class="line">   y_h = theta*XX</span><br><span class="line">   h = np.ones((<span class="built_in">len</span>(y_h)), <span class="built_in">type</span>(y_h))</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(y_h)):</span><br><span class="line">       h[i] = <span class="built_in">sum</span>(y_h[i])</span><br><span class="line">   <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"><span class="comment">#只计算一个点</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">S_h_x</span>(<span class="params">XX, theta</span>):</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">sum</span>(XX*theta)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度（计算所有训练点的梯度）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Gradient</span>(<span class="params">target,XX,theta</span>):</span><br><span class="line">   temp = np.zeros(np.shape(XX))</span><br><span class="line">   h = h_x(XX,theta)</span><br><span class="line">   g = np.zeros(np.size(theta))</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(XX)):</span><br><span class="line">       <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(theta)):</span><br><span class="line">           temp[i][j] = (h[i]-target[i])*XX[i][j]</span><br><span class="line">           g[j] = g[j] + temp[i][j]</span><br><span class="line">   <span class="keyword">return</span> g</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">target:所有的标签值</span></span><br><span class="line"><span class="string">XX：所有的训练点</span></span><br><span class="line"><span class="string">theta：参数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GD</span>(<span class="params">target,XX,theta,alpha,loop_times</span>):</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(loop_times):</span><br><span class="line">       g = Gradient(target, XX, theta)</span><br><span class="line">       <span class="comment"># print(g)</span></span><br><span class="line">       <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(theta)):</span><br><span class="line">           theta[j] = theta[j] - alpha * g[j]</span><br><span class="line">           <span class="comment"># print(&#x27;theta:&#x27;,theta)</span></span><br><span class="line">   <span class="keyword">return</span> theta</span><br><span class="line"></span><br><span class="line"><span class="comment">#梯度下降法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Gradient_Descent</span>(<span class="params">target,x_1,theta,alpha,loop_times</span>):</span><br><span class="line">   one = np.ones_like(x_1)</span><br><span class="line">   XX = np.column_stack((x_1, one))</span><br><span class="line">   h = h_x(XX, theta)</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;theta(SG):&#x27;</span>,theta)</span><br><span class="line">   theta = GD(target,XX,theta,alpha,loop_times)</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;theta(SG):&#x27;</span>,theta)</span><br><span class="line">   painting(x_1,XX,theta)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画图的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">painting</span>(<span class="params">x_1,XX,theta</span>):</span><br><span class="line">   plt.plot(x_1,target,<span class="string">&#x27;g.&#x27;</span>)</span><br><span class="line">   plt.plot(x_1,h_x(XX,theta))</span><br><span class="line">   plt.legend([<span class="string">&#x27;点&#x27;</span>,<span class="string">&#x27;结果线&#x27;</span>])</span><br><span class="line">   plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   target,x_1 = dataSet()</span><br><span class="line">   alpha = <span class="number">0.0001</span></span><br><span class="line">   loop_times_1 = <span class="number">1000</span></span><br><span class="line">   theta = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">   Gradient_Descent(target,x_1,theta,alpha,loop_times_1)</span><br></pre></td></tr></table></figure>
<p><b>结果：</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%BB%93%E6%9E%9C.png" alt="结果" title="结果"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theta(SG): [0, 0]</span><br><span class="line">theta(SG): [2.172834592870355, 0.01991698264914968]</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h4 id="随机梯度下降法"><a href="#随机梯度下降法" class="headerlink" title="随机梯度下降法"></a><b>随机梯度下降法</b></h4><blockquote>
<p><b>算法描述：</b></p>
<blockquote>
<ul>
<li>导入数据</li>
<li>计算$h(x)$，并且计算梯度</li>
<li>利用梯度下降函数SGD()计算循环loop_times的$\theta$</li>
<li>画图</li>
</ul>
</blockquote>
<p><b>代码实现：</b></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]        <span class="comment"># 画图时显示中文</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span>          <span class="comment"># 画图时显示负号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dataSet</span>():</span><br><span class="line">   x = np.random.uniform(-<span class="number">3</span>,<span class="number">3</span>,<span class="number">200</span>)</span><br><span class="line">   r = np.random.uniform(-<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line">   xx = np.linspace(-<span class="number">10</span>,<span class="number">10</span>,<span class="number">200</span>)</span><br><span class="line">   target = r * xx + x</span><br><span class="line">   data = xx</span><br><span class="line">   <span class="keyword">return</span> target,data</span><br><span class="line"></span><br><span class="line"><span class="comment"># h(x) = theta^T * X 的值（所有的）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">h_x</span>(<span class="params">XX, theta</span>):</span><br><span class="line">   y_h = theta*XX</span><br><span class="line">   h = np.ones((<span class="built_in">len</span>(y_h)), <span class="built_in">type</span>(y_h))</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(y_h)):</span><br><span class="line">       h[i] = <span class="built_in">sum</span>(y_h[i])</span><br><span class="line">   <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"><span class="comment">#只计算一个点</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">S_h_x</span>(<span class="params">XX, theta</span>):</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">sum</span>(XX*theta)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">XX：一个二维训练点</span></span><br><span class="line"><span class="string">theta：二维参数</span></span><br><span class="line"><span class="string">target：一个标签值</span></span><br><span class="line"><span class="string">返回：一个训练点计算出来的梯度</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">S_Gradient</span>(<span class="params">XX,theta,target</span>):</span><br><span class="line">   gradient = np.ones(<span class="built_in">len</span>(XX))</span><br><span class="line">   h = S_h_x(XX,theta)</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(XX)):</span><br><span class="line">       gradient[i] = (h - target)*XX[i]</span><br><span class="line">   <span class="keyword">return</span> gradient</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机梯度下降</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">target:所有的标签值</span></span><br><span class="line"><span class="string">XX：所有的训练点</span></span><br><span class="line"><span class="string">theta：参数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SGD</span>(<span class="params">target,XX,theta, alpha, loop_times</span>):</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(loop_times):</span><br><span class="line">       idx = i % <span class="built_in">len</span>(XX)</span><br><span class="line">       gradient = S_Gradient(XX[idx],theta,target[idx])</span><br><span class="line">       <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(theta)):</span><br><span class="line">           theta[j] = theta[j] - alpha * gradient[j]</span><br><span class="line">   <span class="keyword">return</span> theta</span><br><span class="line"></span><br><span class="line"><span class="comment">#随机梯度下降法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Stochastic_Gradient_Descent</span>(<span class="params">target,x_1,theta,alpha,loop_times</span>):</span><br><span class="line">   one = np.ones_like(x_1)</span><br><span class="line">   XX = np.column_stack((x_1, one))</span><br><span class="line">   h = h_x(XX, theta)</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;theta(SGD)&#x27;</span>,theta)</span><br><span class="line">   theta = SGD(target,XX,theta,alpha,loop_times)</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;theta(SGD):&#x27;</span>,theta)</span><br><span class="line">   painting(x_1,XX,theta)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画图的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">painting</span>(<span class="params">x_1,XX,theta</span>):</span><br><span class="line">   plt.plot(x_1,target,<span class="string">&#x27;g.&#x27;</span>)</span><br><span class="line">   plt.plot(x_1,h_x(XX,theta))</span><br><span class="line">   plt.legend([<span class="string">&#x27;点&#x27;</span>,<span class="string">&#x27;结果线&#x27;</span>])</span><br><span class="line">   plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   target,x_1 = dataSet()</span><br><span class="line">   alpha = <span class="number">0.0001</span></span><br><span class="line">   loop_times_2 = <span class="number">10000</span></span><br><span class="line">   theta = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">   Stochastic_Gradient_Descent(target,x_1,theta,alpha,loop_times_2)</span><br></pre></td></tr></table></figure>
<p><b>结果：</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D.png" alt="结果" title="结果"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theta(SGD) [0, 0]</span><br><span class="line">theta(SGD): [-2.0468784503363575, -0.03359178568076404]</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>深渊巨坑</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归</title>
    <url>/2021/09/18/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<h4 id="线性回归的介绍"><a href="#线性回归的介绍" class="headerlink" title="线性回归的介绍"></a><b>线性回归的介绍</b></h4><blockquote>
<p>线性回归是机器学习中最经典的回归算法之一。<br>线性回归实际上就是在一堆线性的点中找到一条直线，使得所有点离这条线最近。<br>首先设点$x_0$的值为$y_0$，我们通过模型的到它的值为$y$，那么我们设它们的误差值为$y-y_0$<del>（别问，问就是容易计算）</del><br>那么由此可以所有点的误差值之和为：$J(\theta)&#x3D;\frac{1}{2} \sum^n_{i&#x3D;1}(\theta ^T X - y^i_0)^2$<br>（为什么是这个式子详见<a href="/2021/09/08/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/index.html">这里</a>）<br>那么我们现在的目的就是通过缩小$J$来找到最合适的$\theta$<br>对此有三种方法可以求出最合适的$\theta$</p>
<blockquote>
<ul>
<li>梯度下降法</li>
<li>牛顿法</li>
<li>解析式法</li>
</ul>
</blockquote>
</blockquote>
<h4 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a><b>梯度下降法</b></h4><blockquote>
<p>梯度下降介绍详见<a href="/2021/09/08/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/index.html">这里</a><br>梯度下降可以分为两类，一类是梯度下降，另一类是随机梯度下降<br><b>两者区别：</b></p>
<blockquote>
<ul>
<li><b>梯度下降：</b>用最小二乘法计算$J(\theta)$时，减的是$\sum^n_{i&#x3D;1}(\theta^T X-y^i)X^i_j$</li>
<li><b>随机梯度下降：</b>计算$J(\theta)$时，减的是$(\theta^T X-y^i)X^i_j$<br>梯度下降相较于随机梯度来说会下降得更快，但是计算量会大得多，因为每次都要计算所有点的误差然后再相加。<br>而随机梯度下降虽然下降得比较慢，而且下降方向会随机，但是它计算量少，每次只需要计算某个点的误差就行了。<br><b>相关代码：</b><a href="/2021/09/21/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/index.html">代码实现！</a></li>
</ul>
</blockquote>
</blockquote>
<h4 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a><b>牛顿法</b></h4>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>深渊巨坑</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>网络层</title>
    <url>/2022/02/12/%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<h2 id="网络层介绍"><a href="#网络层介绍" class="headerlink" title="网络层介绍"></a>网络层介绍</h2><blockquote>
<p><strong>任务：</strong>向上层提供简单灵活的、<strong>无连接的</strong>、<strong>尽最大努力交付的</strong>数据报服务。</p>
<p><strong>传输单元</strong>：网络层传输单元是<strong>IP数据报</strong>或<strong>分组</strong>。</p>
<p><strong>功能：</strong></p>
<blockquote>
<ul>
<li><p><strong>路由选择</strong>与<strong>分组转发</strong></p>
<blockquote>
<p><strong>路由选择：</strong>指按照复杂的分布式算法，根据各相邻路由器所得到的关于整个网络拓扑的变化情况，动态地改变所选择的路由。</p>
<p><strong>分组转发：</strong>指路由器根据转发表将用户的IP数据报从合适的端口转发出去。</p>
</blockquote>
</li>
<li><p><strong>异构网络互联</strong></p>
<blockquote>
<p><strong>定义：</strong>将两个以上的计算机网络，通过一定方法，用一种或多种中间设备相互连接起来，以构成更大的网络。</p>
<p><strong>中间设备的种类：</strong></p>
<blockquote>
<ul>
<li><strong>物理层：</strong>中继器、集线器</li>
<li><strong>数据链路层：</strong>网桥或交换机</li>
<li><strong>网络层：</strong>路由器</li>
<li><strong>网络层以上：</strong>网关</li>
</ul>
</blockquote>
<p><strong>注意：</strong>使用<strong>物理层或数据链路层的中继系统</strong>时，只是把<strong>一个网络</strong>扩大了，从<strong>网络层</strong>的角度看，它们<strong>仍是同一个网络</strong>不能称为网络互联。因此网络互联需要用到指定<strong>路由器</strong>。</p>
</blockquote>
</li>
<li><p><strong>拥塞控制</strong>，包括<strong>开环控制（静态）</strong>和<strong>闭环控制（动态）</strong></p>
</li>
</ul>
</blockquote>
</blockquote>
<h2 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><blockquote>
<p>电路交换的方式最常见的网络就是<strong>电话网络</strong>。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2.png" alt="电路交换"></p>
<p><strong>电路交换的阶段：</strong></p>
<blockquote>
<ul>
<li><strong>建立连接</strong></li>
<li><strong>通信</strong></li>
<li><strong>释放连接</strong></li>
</ul>
</blockquote>
<p><strong>注意：</strong>电路交换中每次建立好的链路后是不变的，属于独占资源的形式。</p>
<p><strong>优点：</strong></p>
<blockquote>
<ul>
<li><strong>通信时延小</strong></li>
<li><strong>有序传输</strong></li>
<li><strong>没有冲突</strong>（因为独占一条线路）</li>
<li><strong>实时性强</strong></li>
</ul>
</blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<ul>
<li><strong>建立连接时间长</strong></li>
<li><strong>线路独占，使用效率低</strong></li>
<li><strong>灵活性差</strong></li>
<li><strong>无差错控制</strong></li>
</ul>
</blockquote>
</blockquote>
<h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><blockquote>
<p><strong>报文：</strong>指源主机发送的信息<strong>整体</strong>。</p>
<p>报文转发实际上是一口气将数据报文发送出去，由交换设备进行转发，直到目的地址。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/%E6%8A%A5%E6%96%87%E4%BA%A4%E6%8D%A2.png" alt="报文交换"></p>
<p><strong>优点：</strong></p>
<blockquote>
<ul>
<li><strong>无需建立连接</strong></li>
<li><strong>存储转发，动态分配线路</strong></li>
<li><strong>线路利用率高</strong></li>
<li><strong>多目标服务（一个报文可以发送到多个目的地）</strong></li>
</ul>
</blockquote>
<p><strong>缺点</strong></p>
<blockquote>
<ul>
<li><strong>有存储转发时延</strong></li>
<li><strong>报文大小不定，需要交换设备有较大的缓存空间</strong></li>
</ul>
</blockquote>
</blockquote>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><blockquote>
<p><strong>分组：</strong>将大的数据块（报文）分割成小的数据块中的每一块（大小可以不一样）。</p>
<p>分组转发实际上就是每一次发送一个分组，让分组在网络中通过交换设备来到达目的地（每一个分组走的路可能不一样）。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2.png" alt="分组交换"></p>
<p><strong>优点：</strong></p>
<blockquote>
<ul>
<li><strong>无需建立连接</strong></li>
<li><strong>存储转发，动态分配线路</strong></li>
<li><strong>线路利用率高</strong></li>
<li><strong>相较于报文交换，存储管理更容易</strong></li>
<li><strong>相较于报文交换，发送到目的主机的时间（发送时延+传输时延）更短</strong></li>
</ul>
</blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<ul>
<li><strong>有存储转发时延</strong></li>
<li><strong>需要传输额外的信息量（对每一个分组中的信息）</strong></li>
<li><strong>如果乱序到达目的主机，要对各分组进行重组。</strong></li>
</ul>
</blockquote>
<p><strong>注意：</strong>计算分组交换的总时延时可以分成两部分：<strong>所有分组在第一个结点的发送时延</strong>+<strong>最后一个分组经过所有结点的总时延</strong></p>
<p><strong>三种数据交换方式比较：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/%E4%B8%89%E7%A7%8D%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2.png" alt="三种数据交换"></p>
</blockquote>
</blockquote>
<h4 id="数据报方式"><a href="#数据报方式" class="headerlink" title="数据报方式"></a>数据报方式</h4><blockquote>
<p>为网络层提供<strong>无连接服务</strong>。</p>
<p><strong>无连接服务：</strong>不事先为分组确定传输路径，每个分组独立确定传输路径，所以不同分组的传输路径可能不一样。</p>
<p><strong>注意：</strong>TCP&#x2F;IP体系的网络层提供的是<strong>数据报服务</strong>。</p>
<p><strong>数据报：</strong></p>
<blockquote>
<p><strong>特点：</strong></p>
<ul>
<li><strong>无连接</strong></li>
<li><strong>每个分组携带源地址与目的地址</strong></li>
<li><strong>路由器根据分组的目的地址转发分组</strong></li>
</ul>
</blockquote>
</blockquote>
<h4 id="虚电路方式"><a href="#虚电路方式" class="headerlink" title="虚电路方式"></a>虚电路方式</h4><blockquote>
<p>为网络层提供<strong>有连接服务</strong>。</p>
<p><strong>有连接服务：</strong>事先为分组确定传输路径（建立连接），然后沿着该路径传输系列分组，传输结束后拆除连接，所以所有分组的传输路径是一样的。</p>
<p><strong>虚电路：</strong></p>
<blockquote>
<p><strong>定义：</strong>一条主机到目的主机类似于电路的路径（逻辑连接），路径上所有结点都维持一张虚电路表。</p>
<p><strong>补充：</strong>实际上就是电路交换的复制版，但链路建立在逻辑上而不是物理上。</p>
</blockquote>
</blockquote>
<h4 id="数据报服务与虚电路服务的区别"><a href="#数据报服务与虚电路服务的区别" class="headerlink" title="数据报服务与虚电路服务的区别"></a>数据报服务与虚电路服务的区别</h4><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%B8%8E%E8%99%9A%E7%94%B5%E8%B7%AF%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="数据报与虚电路的区别"></p>
</blockquote>
<h2 id="路由选择"><a href="#路由选择" class="headerlink" title="路由选择"></a>路由选择</h2><blockquote>
<p><strong>最佳路由：</strong>最佳只能相对于某一特定要求下的出较为合理的选择。</p>
<p><strong>标准路由表:</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/%E8%BD%AC%E5%8F%91%E8%A1%A8.png" alt="转发表"></p>
<p><strong>分类:</strong> </p>
<blockquote>
<ul>
<li><p><strong>静态路由算法（非自适应路由算法）</strong>：管理员手工配置路由信息。（多应用于拓扑变化不大、较小的网络）</p>
</li>
<li><p><strong>动态路由算法（自适应路由算法）</strong>：路由器间彼此交换信息，按照路由算法优化出路由表项。（多用于更新快的网络）</p>
<blockquote>
<ul>
<li><p><strong>全局性：</strong>链路状态路由算法  <strong>OSPF协议</strong></p>
<p><strong>特点：</strong>所有路由器掌握完整的网络拓扑和链路费用（转跳次数）信息。</p>
</li>
<li><p><strong>分散性：</strong>距离向量路由算法  <strong>RIP协议</strong></p>
<p><strong>特点：</strong>路由器只掌握物理相连的邻居及链路费用。</p>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>分层次的路由选择协议：</strong></p>
<blockquote>
<p><strong>自治系统AS：</strong>在单一的技术管理下的一组路由器，而这些路由器使用一种AS内部的路由选择协议和共同的度量以确定分组在该AS内的路由，同时还使用一种AS之间的路由协议以确定在AS之间的路由（类似于子网划分，不过主机换成路由器）。</p>
<p><strong>路由选择协议：</strong></p>
<blockquote>
<ul>
<li><strong>内部网关协议IGP</strong>：一个AS内部使用的协议，如<strong>RIP、OSPF</strong></li>
<li><strong>外部网关协议EGP</strong>：AS之间使用的协议，如<strong>BGP</strong></li>
</ul>
</blockquote>
</blockquote>
<p><strong>路由选择算法：</strong></p>
<blockquote>
<p>路由选择算法是路由选择协议更新路由时所使用的算法。</p>
<p>主要包括：</p>
<ul>
<li><strong>RIP协议使用的距离向量算法</strong></li>
<li><strong>OSPF协议使用的链路状态算法</strong></li>
</ul>
</blockquote>
</blockquote>
<h3 id="RIP协议"><a href="#RIP协议" class="headerlink" title="RIP协议"></a>RIP协议</h3><blockquote>
<p>RIP是一种分布式的基于<strong>距离向量</strong>的路由选择协议，是因特网的协议标准，且多用于较小的AS（自治系统）中，最大优点是<strong>简单</strong>。</p>
<p>RIP协议要求网络中每一个路由器都维护<strong>从它自己到其他每一个目的网络的唯一最佳距离记录。</strong>（即一组距离）</p>
<p><strong>距离：</strong>通常称为“跳数”，即从源端口到目的端口所经过的路由器个数（从一路由器到直接连接的网络距离为1）。</p>
<p><strong>注意：</strong>RIP允许一条路由最多只包含15个路由器，因此<strong>距离16表示网络不可达</strong>。</p>
<p><strong>例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/RIP%E5%8D%8F%E8%AE%AE%E8%B7%AF%E7%94%B1%E8%A1%A8%E4%BE%8B%E5%AD%90.png" alt="RIP协议路由表例子"></p>
<p><strong>注意：</strong>路由表一开始只知道和自己直连的网络的距离（距离都为1），接着每一个路由器也只和数目有限的相邻路由器交换并更新路由信息。</p>
</blockquote>
<p><strong>RIP规定：</strong></p>
<blockquote>
<ul>
<li>网络中的每个路由器都要维护从<strong>它自身到其他每个目的网络的距离记录</strong>（体现在路由表上要包含所有网络的距离记录）</li>
<li>距离称为跳数，即经过路由器的个数。（直接连接的网络跳数为1，每多加一个路由器距离就加1）</li>
<li>RIP认为好的路由经过的路由器较少（不考虑该路由的时延等情况）</li>
<li>RIP规定一条路由最多只能进行<strong>15跳</strong>。因此如果距离等于16跳就表示为该网络不可达</li>
<li>RIP默认在任意两个使用RIP协议的路由器之间每<strong>30秒</strong>就广播一次RIP路由更新信息（以便动态查询路由器的网络情况）</li>
<li>在RIP中不支持子网掩码和RIP广播，但在新的RIP2中，支持变长子网掩码和CIDR</li>
</ul>
</blockquote>
<p><strong>RIP协议特点：</strong></p>
<blockquote>
<ul>
<li><p>仅和<strong>相邻路由器</strong>交换信息。</p>
</li>
<li><p>路由器交换的信息是<strong>自己的路由表</strong>。</p>
</li>
<li><p><strong>每30秒</strong>交换一次路由信息，然后更新路由根据信息更新路由表。若<strong>超过180秒</strong>没收到邻居路由器的通告，则判定邻居路由器出现故障，并更新自己的路由表。</p>
<p>最终会使所有路由器都知道本自治系统任何一个网络的最短距离和下一跳路由器的地址。</p>
</li>
</ul>
</blockquote>
<p><strong>距离向量算法：</strong></p>
<blockquote>
<ul>
<li><p>修改相邻路由器发来的RIP报文中<strong>所有表项</strong>。</p>
<p>对地址为x的相邻路由器发来的RIP报文，将”下一跳“字段中的地址修改为x，并将距离+1。</p>
</li>
<li><p>对修改后的RIP报文中的每一项做以下处理：</p>
<blockquote>
<ul>
<li><p>若路由表中没有，则将该项目填入路由表中</p>
</li>
<li><p>若路由表中有</p>
<blockquote>
<ul>
<li>若下一跳是x，则用收到的项目代替原路由表的项目。</li>
<li>若下一跳不是x，则比较原项目的距离，选择距离小的保留。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p>若180s还没收到相邻路由器x的更新路由表，则把x设为不可达的路由器，即把距离设置为16。</p>
</li>
</ul>
</blockquote>
<p><strong>RIP协议的报文格式：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/RIP%E5%8D%8F%E8%AE%AE%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" alt="RIP协议报文格式"></p>
<p><strong>注意：</strong>RIP是应用层协议，使用UDP传输数据。</p>
</blockquote>
<p><strong>RIP协议特点：</strong></p>
<blockquote>
<p>当网络出现故障时，要经过较长的时间才能将此信息传输到所有的路由器。</p>
<p>RIP用最大距离为15限制了网络的规模</p>
</blockquote>
<p><strong>补充：</strong></p>
<blockquote>
<ul>
<li><p><strong>RIP是应用层协议，它使用UDP传输数据。</strong></p>
</li>
<li><p>RIP选择的不一定是时间最短的路径，但一定是路由器最少的路径。</p>
</li>
</ul>
</blockquote>
</blockquote>
<h3 id="OSPF协议"><a href="#OSPF协议" class="headerlink" title="OSPF协议"></a>OSPF协议</h3><blockquote>
<p><strong>全称：</strong>开放最短路径优先。“<strong>开放</strong>”表明OFPS协议是公开发表的。“<strong>最短路径优先</strong>”是使用Dijkstra提供的<strong>最短路径算法SPF</strong>。</p>
<p>OSPF最主要的特征是使用分布式的<strong>链路状态协议</strong>。</p>
<p><strong>洪泛法：</strong>一个节点向它<strong>所有</strong>的相邻节点发送一个数据报，它的相邻节点又把这个数据报发给<strong>所有</strong>的相邻节点，直到TTL为0或其他停止条件满足为止。</p>
<p><strong>特点：</strong></p>
<blockquote>
<ul>
<li>使用洪泛法向自治系统内<strong>所有路由器</strong>发送信息。</li>
<li>发送的信息就是与本路由器<strong>相邻的所有路由器的链路状态</strong>（链路状态包括：本路由器和哪些路由器相邻，以及该链路的度量&#x2F;代价–费用、距离、时延、带宽等）</li>
<li>只有当<strong>链路状态发生变化时</strong>，<strong>路由器才向所有路由器洪泛式发送信息</strong>（即路由器通过所有端口向所有相邻的路由器发送信息）</li>
<li><strong>OSPF是网络层协议</strong>，直接使用IP数据报传输。</li>
<li>OSPF可以根据不同情况设置不同的代价（路由器数量、传输时延等）</li>
<li><strong>如果到同一网络有多条代价相同的链路，OSPF可以将通信量分配给这几条路径</strong>（称为<strong>多路径间的负载平衡</strong>）</li>
<li>所有OSPF路由器之间都有鉴别功能，保证仅在可信赖的路由器之间交换链路状态信息</li>
<li>支持可变长的子网划分和无分类编址CIDR</li>
<li>每隔10秒，每两各相邻路由器就交换一次问候分组，以确保哪些站可达。</li>
</ul>
</blockquote>
<p><strong>OSPF工作原理：</strong></p>
<blockquote>
<p>各路由器频繁地交换链路状态信息，因此所有路由器都能间建立一个链路状态数据库（全网的拓扑结构图）。</p>
<p>然后各路由器根据这个数据库使用Dijkstra最短路径算法计算从自己到各目的网路的最优路径，以此构建自己的路由表。</p>
<p>当链路状态发生变化时，每个路由器又重新计算到各目的网络的最优路径，构建新的路由表。</p>
<p><strong>注意：</strong>虽然Dijkstra可以计算完整的最优路径，但路由表只存储”下一跳“的路由器。</p>
</blockquote>
<p><strong>链路状态路由算法：</strong></p>
<blockquote>
<ul>
<li><p>每个路由器发现它的邻居结点【HELLO问候分组】，并了解邻居节点的网络地址。</p>
</li>
<li><p>设置到它的每个邻居的成本度量metric。</p>
</li>
<li><p>构造【DD数据库描述分组】，向邻站给出自己的链路状态数据库中所有链路状态项目的摘要信息。</p>
</li>
<li><p>如果DD分组中的摘要自己都有，则邻站不做处理；如果没有或者是更新的，则发送【LSR链路状态请求分组】。</p>
</li>
<li><p>收到邻站的LSR分组后，发送【LSU链路状态更新分组】进行更新。</p>
</li>
<li><p>更新完毕后，邻站返回一个【LSAck链路状态确认分组】进行分组。</p>
</li>
<li><p>使用Dijkstra根据自己的链路状态数据库构造到其他节点间的最短路径。</p>
</li>
</ul>
</blockquote>
<p><strong>OSPF的区域</strong></p>
<blockquote>
<p>OSPF会将一个自治系统再划分成为若干个更小的范围，叫做<strong>区域</strong>，每一个区域都有一个32位的区域标识符（用点分十进制表示）。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/OSPF%E7%9A%84%E5%8C%BA%E5%9F%9F.png" alt="OSPF的区域"></p>
</blockquote>
<p><strong>OSPF分组</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/OSPF%E5%88%86%E7%BB%84.png" alt="OSPF分组"><br>OSPF直接使用<strong>IP数据报</strong>进行传送，属于<strong>网络层的协议</strong>。</p>
<p><strong>分组类型：</strong></p>
<blockquote>
<ul>
<li><strong>问候分组</strong>：用来发现和维持邻站的可达性。</li>
<li><strong>数据库描述分组：</strong>向邻站给出自己的链路状态数据库中所有链路状态项目的摘要信息。</li>
<li><strong>链路状态请求分组：</strong>向对方请求发送某些链路状态项目的详细信息</li>
<li><strong>链路状态更新请求：</strong>用洪泛法对全网更新链路状态。</li>
<li><strong>链路状态确认分组：</strong>对链路更新分组的确认。</li>
</ul>
</blockquote>
</blockquote>
<p><strong>OSPF的其他特点：</strong></p>
<blockquote>
<ul>
<li>每隔30分钟就要刷新一次数据库中链路的状态。</li>
<li>由于每个路由器的链路状态只涉及到与之相邻路由器的连通状态，因而与整个互联网的规模无直接关系。（所以适合规模大的网络）</li>
<li>收敛速度快。</li>
</ul>
</blockquote>
<p><strong>SOPF与RIP协议的区别：</strong></p>
<blockquote>
<p>在RIP协议中，每个节点仅与其相邻节点交流，默认其相邻节点提供的是自己到网络中所有其他节点的最低费用。</p>
<p>在SOPF协议中，每个节点通过广播的方式与其他节点交谈，但它仅告诉其他节点与它直接相连的链路的费用。</p>
</blockquote>
</blockquote>
<h3 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a>BGP协议</h3><blockquote>
<p><strong>特点：</strong></p>
<blockquote>
<ul>
<li><p>每个AS都要有<strong>至少一个</strong>的发言人。</p>
</li>
<li><p>与其他AS的邻站BGP发言人交换信息。</p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/BGP%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84BGP%E5%8F%91%E8%A8%80%E4%BA%BA.png" alt="BGP协议中的BGP发言人"></p>
<p><strong>注意：</strong>BGP发言人一般是AS中的边界路由器，但也可以是非边界路由器。</p>
</blockquote>
</li>
<li><p>交换的网络可达性的信息，即要到达某个网络所要经过的一系列AS。</p>
</li>
<li><p><strong>刚开始</strong>的时候BGP<strong>交换整个路由表</strong>，但<strong>后面仅交换发生变化时更新有变化的部分</strong>。</p>
</li>
<li><p>BGP是<strong>应用层协议</strong>，它是<strong>基于TCP连接</strong>进行信息的传输。</p>
</li>
</ul>
</blockquote>
<p><strong>BGP协议交换信息的过程</strong>：</p>
<blockquote>
<p>BGP所交换的网络可达性的信息就是要<strong>到达某个网络所要经过的一系列AS</strong>。当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就要根据所采用的策略从收到的路由信息中找到到达各AS的<strong>较好路径</strong>。</p>
<p><strong>例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/BGP%E4%BE%8B%E5%AD%90.png" alt="BGP例子"></p>
<p><strong>注意：</strong>交换的信息是一组向量，即一个完整的路径。</p>
</blockquote>
</blockquote>
<p><strong>BGP协议报文格式：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/BGP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" alt="BGP报文格式"></p>
<p><strong>补充：</strong>BGP是<strong>应用层</strong>协议，使用<strong>TCP</strong>传送。因此BGP发言人在交换信息前需要<strong>先建立TCP连接</strong>。</p>
</blockquote>
<p><strong>其他特点：</strong></p>
<blockquote>
<ul>
<li>支持CIDR，所以BGP的路由表应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各自治系统序列。</li>
<li>在BGP刚运行时，BGP的邻站时交换整个BGP的路由表，但以后只需要交换<strong>发生改变的部分</strong>。</li>
</ul>
</blockquote>
<p><strong>BGP-4的四种报文</strong></p>
<blockquote>
<ul>
<li><strong>OPEN（打开）报文：</strong>用来与相邻的另一个BGP发言人建立关系，并认证发送方。</li>
<li><strong>UPDATE（更新）报文</strong>：通告新路径或撤销原路径。</li>
<li><strong>KEEPALIVE（保活）报文：</strong>在无UPDATE时，周期性地证实邻站的连通性；也用作OPEN的确认。</li>
<li><strong>NOTIFICATION（通知）报文：</strong>报告先前报文的差错；也用于关闭连接。</li>
</ul>
</blockquote>
</blockquote>
<h3 id="三种路由协议的比较"><a href="#三种路由协议的比较" class="headerlink" title="三种路由协议的比较"></a>三种路由协议的比较</h3><blockquote>
<ul>
<li><strong>RIP</strong>是一种分布式的基于距离向量的内部网关路由选择协议，通过<strong>广播UDP报文</strong>来减缓路由信息。</li>
<li><strong>OSPF</strong>是一个内部网关协议，因为要交换的信息量大，所以报文长度尽量要短，所以不使用传输层协议，而直接使用<strong>IP数据报</strong>。</li>
<li><strong>BGP</strong>是一个外部网关协议，在不同的自治系统之间交换路由信息，由于网络环境复杂，需要保证可靠传输，所以采用<strong>TCP</strong>。</li>
</ul>
<p><strong>图：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/%E4%B8%89%E7%A7%8D%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E6%AF%94%E8%BE%83.png" alt="三种路由协议比较"></p>
</blockquote>
</blockquote>
<h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><blockquote>
<p><strong>定义：</strong>给互联网上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内<strong>唯一</strong>的<strong>32位</strong>的标识符。</p>
<p><strong>IP地址：</strong>{&lt;网络号&gt;,&lt;主机号&gt;}</p>
<p><strong>IP编制的历史阶段：</strong>分类的IP地址、子网的划分、构成超网（无分类编址方法）。</p>
</blockquote>
<h3 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h3><blockquote>
<p><strong>TCP&#x2F;IP协议栈：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%8D%8F%E8%AE%AE%E6%A0%88.png" alt="协议栈"></p>
</blockquote>
<p><strong>IP数据报大体结构：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.png" alt="IP数据报格式"></p>
<p>固定部分一定会有且固定20字节，而可变部分一般都没有。</p>
<p><strong>IP数据报详细格式：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%AF%A6%E7%BB%86%E6%A0%BC%E5%BC%8F.png" alt="IP数据报详细格式"></p>
<p><strong>注意：</strong>这里31指的是比特数，所以一行数据就是4个字节。</p>
<ul>
<li><p><strong>版本字段：</strong>4位比特数，指代使用IPv4或IPv6这两个协议。</p>
</li>
<li><p><strong>首部长度：</strong>4位比特数，表示范围是0-15。<strong>单位是4B</strong>，最小为5（即5X4B&#x3D;20B刚好等于固定长度的20B）。</p>
</li>
<li><p><strong>区分服务：</strong>指示期望获得哪类服务（不重要）。</p>
</li>
<li><p><strong>总长度：</strong>指首部+数据的长度，可表示范围：$2^{16}-1&#x3D;65535$，<strong>单位为1B</strong>（所以IP数据报的最长度为65535字节，一般不会很大）。</p>
</li>
<li><p><strong>标识：</strong>对同一个数据报中的每一个分片设的一个标识字段。用于找到同一数据报中的所有分片（这里的分片是将一个IP数据报切分至MTU）。</p>
</li>
<li><p><strong>标志：</strong>目前只有<strong>最低位（MF）</strong>与<strong>中间位（DF）</strong>有意义。当<strong>MF&#x3D;1时表示后面还有分片，MF&#x3D;0表示本数据报已经是同一个数据报中的最后一个分片</strong>了。而<strong>DF&#x3D;0时表示可以分片</strong>， <strong>DF&#x3D;1表示不能分片</strong>。</p>
</li>
<li><p><strong>片偏移：</strong>指较长的分组在分片后，某片在原分组中的<strong>相对位置</strong>，以<strong>8B为单位</strong>。</p>
</li>
<li><p><strong>生存时间（TTL）：</strong>IP数据报的生存时间。每经过一个路由器就减一，变成0时就丢弃。</p>
</li>
<li><p><strong>协议：</strong>数据部分使用的协议。</p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%8D%8F%E8%AE%AE%E5%AD%97%E6%AE%B5.png" alt="协议字段"></p>
</blockquote>
</li>
<li><p><strong>首部检验和：</strong>只检验首部</p>
</li>
<li><p><strong>源地址：</strong>发送方的IP地址。</p>
</li>
<li><p><strong>目的地址：</strong>接收方的IP地址。</p>
</li>
<li><p><strong>可选字段：</strong>0-40字节，用来支持排错、测量以及安全措施。</p>
</li>
<li><p><strong>填充字段：</strong>全0，把首部补成4B的整数倍。</p>
</li>
</ul>
</blockquote>
<p><strong>网络层转发分组的流程：</strong></p>
<blockquote>
<ul>
<li>从数据报首部获得<strong>目的主机地址D</strong>，根据D获得<strong>目的网络地址N</strong></li>
<li>如果网络N与路由器直接相连接，则直接把数据报交付给目的主机D。</li>
<li>如果路由表中有目的地址为D的<strong>特定主机路由</strong>，那么将数据报交给特定的下一跳路由器，否则执行下一步。</li>
<li>如果路由表中有<strong>直达网络N的路由</strong>，那么将数据报交给下一跳路由器，否则执行下一步。</li>
<li>如果路由表中有一个<strong>默认路由</strong>，则把数据报交给默认路由器，否则报告转发分组出错。</li>
</ul>
<p><strong>注意：</strong>得到下一跳路由器的IP地址后并不是直接就转发分组，而是将该IP地址转换成MAC地址（通过ARP协议），将其放在MAC帧的首部中，然后根据这个MAC地址找到下一跳路由器。在不同网络中传送时，<strong>MAC帧</strong>（不是数据报）中的<strong>源地址</strong>和<strong>目的地址</strong>都要发生变化；但在<strong>网桥</strong>中转发MAC帧，<strong>不改变帧的源地址</strong>。</p>
</blockquote>
<p><strong>补充：</strong></p>
<blockquote>
<ul>
<li><strong>IP数据报分片：</strong>当IP数据报的总长度大于链路MTU时，就需要将IP数据报中的数据分装在多个较小的IP数据报中，这些较小的数据报称为<strong>片</strong>。</li>
<li><strong>IP分组：</strong>是上层对数据的一个分割，一个IP分组就是一个IP数据报（当然也可能需要分片）。</li>
</ul>
</blockquote>
</blockquote>
<h3 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h3><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%88%86%E7%B1%BB%E7%9A%84IP%E5%9C%B0%E5%9D%80.png" alt="分类的IP地址"></p>
<p><strong>特殊的IP地址：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/%E7%89%B9%E6%AE%8A%E7%9A%84IP%E5%9C%B0%E5%9D%80.png" alt="特殊的IP地址"></p>
<p><strong>私有IP地址：</strong>私有地址就是<strong>内部网络</strong>或<strong>本地网络</strong>的IP地址，如实验室中各主机的ip地址。（在广域网中路由器无法识别）</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/%E7%A7%81%E6%9C%89ip%E5%9C%B0%E5%9D%80.png" alt="私有ip地址"></p>
<p><strong>分类的IP地址中可表示的最大主机数：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%88%86%E7%B1%BB%E7%9A%84IP%E5%9C%B0%E5%9D%80%E6%9C%80%E5%A4%A7%E4%B8%BB%E6%9C%BA%E6%95%B0.png" alt="分类的IP地址最大主机数"></p>
</blockquote>
<h4 id="网络地址转换技术（NAT）"><a href="#网络地址转换技术（NAT）" class="headerlink" title="网络地址转换技术（NAT）"></a>网络地址转换技术（NAT）</h4><blockquote>
<p><strong>网络地址转换NAT：</strong>在<strong>专用网</strong>连接到<strong>因特网</strong>的路由器上安装NAT软件，安装了NAT软件的路由器称为<strong>NAT路由器</strong>，它需要至少拥有一个有效的<strong>外部全球IP地址</strong>。</p>
<p><strong>转换方式：</strong>NAT转换表中存放着{本地IP地址：端口}到{全球IP地址：端口}的映射，外部主机要与一个私有局域网内的主机通信，那目的地址就要填**{NAT路由器的IP：端口（路由器）}**，NAT路由器收到该数据报后根据映射表将数据报分发给局域网内对应的主机。</p>
<p><strong>图例：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/NAT%E5%AE%9E%E4%BE%8B.png" alt="NAT实例"></p>
</blockquote>
<p>其中NAT路由器有一个NAT转换表，用于让私有网络内部的主机能与外网主机进行通信，如</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/NAT%E8%BD%AC%E6%8D%A2%E8%A1%A8.png" alt="NAT转换表"></p>
<p>外部要与内部网络通信，填写目的地址时填的都是WAN端的信息，NAT路由器在接收到WAN端的地址后会自动将其转换成LAN端的地址。</p>
<p><strong>NAT路由器与普通路由器的区别：</strong></p>
<blockquote>
<ul>
<li>在网络层中，普通的路由器在转发IP数据报时，不改变源IP地址和目的IP地址；而NAT路由器转发IP数据报给私有局域网时，一定要改变IP数据报的目的IP地址。 </li>
<li>普通路由器仅工作在网络层；NAT路由器转发时需要查看和转换传输层的端口号。</li>
</ul>
</blockquote>
</blockquote>
<h3 id="子网划分与子网掩码"><a href="#子网划分与子网掩码" class="headerlink" title="子网划分与子网掩码"></a>子网划分与子网掩码</h3><blockquote>
<p><strong>分类IP地址的缺点：</strong></p>
<blockquote>
<ul>
<li>IP地址空间的利用率有时会很低。（如申请一个B类地址后，实际上的主机数很少）</li>
<li>两级IP地址不灵活。</li>
</ul>
</blockquote>
<p><strong>子网划分：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86.png" alt="子网划分"></p>
<p>某单位划分子网后，<strong>对外依旧表示为一个网络</strong>，即本单位外的网络看不到本单位子网的划分。</p>
</blockquote>
<p><strong>子网掩码：</strong></p>
<blockquote>
<p><strong>格式：</strong>对于二级IP地址，网络号对应部分，其子网掩码全为1；主机号对应部分，其子网掩码全为0。对于三级IP地址，网络号与子网号对应部分，其子网掩码全为1；主机号对应部分，其子网掩码全为0，如</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81.png" alt="子网掩码"></p>
<p><strong>注意：</strong>只需要将子网掩码与IP地址<strong>逐位相与</strong>即可得到<strong>子网地址</strong>。</p>
</blockquote>
<p><strong>使用子网划分的路由表：</strong></p>
<blockquote>
<ul>
<li><strong>目的网络地址</strong></li>
<li><strong>目的网络的子网掩码</strong></li>
<li><strong>下一跳地址（下一个路由器的IP地址）</strong></li>
</ul>
</blockquote>
<p><strong>划分子网转发分组的算法：</strong></p>
<blockquote>
<ul>
<li>提取分组的目的IP地址</li>
<li>判断是为直接交付（用各子网的掩码与目的IP地址进行相与，然后与各子网的IP号进行匹配。）</li>
<li>特定主机路由</li>
<li>检测路由表中有无路径（检测目的地址是否在路由表中）</li>
<li>如果上一步不行，那就将分组发给默认路由，默认路由又将分组发送给新的路由器。</li>
<li>循环上述步骤直到TTL归零。</li>
</ul>
</blockquote>
<p><strong>一个子网划分的例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%AD%90%E7%BD%91%E4%BE%8B%E5%AD%90.png" alt="子网例子"></p>
</blockquote>
</blockquote>
<h3 id="无分类编址（CIDR）"><a href="#无分类编址（CIDR）" class="headerlink" title="无分类编址（CIDR）"></a>无分类编址（CIDR）</h3><blockquote>
<p><strong>无分类域间路由选择CIDR：</strong></p>
<blockquote>
<ul>
<li><p>消除了传统A类、B类和C类地址及划分子网的概念。</p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/CIDR.png" alt="CIDR"></p>
<p><strong>CIDR记法：</strong>IP地址后加上“&#x2F;”，然后写上<strong>网络前缀（可任意长）的位数</strong>，如：<strong>128.14.32.0&#x2F;20</strong>（指前20位都是网络前缀，后12位是主机号）</p>
</blockquote>
</li>
<li><p>融合子网地址与子网掩码，方便子网划分（实际上就是变成了动态的子网划分）</p>
</li>
</ul>
</blockquote>
<p><strong>构成超网：</strong></p>
<blockquote>
<p>将多个子网聚合成一个较大的子网，叫做<strong>构成超网</strong>，或<strong>路由聚合</strong>。</p>
<p><strong>方法：</strong>将网络前缀缩短。</p>
<p><strong>例子：</strong></p>
<blockquote>
<p> <img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/%E6%9E%84%E6%88%90%E8%B6%85%E7%BD%91.png" alt="构成超网"><br> 将206.1.0.0**&#x2F;17<strong>和206.1.128.0</strong>&#x2F;17<strong>融合成一个超网就是：206.1.0.0</strong>&#x2F;16**</p>
</blockquote>
</blockquote>
<p><strong>最长前缀匹配：</strong></p>
<blockquote>
<p><strong>指使用CIDR时，查找路由表可能得到几个匹配结果，这是应该选择具有最长网络前缀的路由。</strong>（因为前缀越长，地址块越小，路由越具体）</p>
<p><strong>例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/%E6%9C%80%E9%95%BF%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D.png" alt="最长前缀匹配"></p>
<p>先将目的地址转化成路由表中目的网络的格式：132.0.0.0&#x2F;8、132.0.0.0&#x2F;11、132.19.236.0&#x2F;22</p>
<p>选择最长的前缀，所以选择B。</p>
</blockquote>
</blockquote>
<p><strong>补充：</strong>在CIDR中，<strong>子网号</strong>的划分<strong>可以全0或者全1</strong>，但<strong>主机号依旧不能全0或全1</strong>.</p>
</blockquote>
<h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><blockquote>
<p><strong>IP地址与硬件地址：</strong></p>
<blockquote>
<ul>
<li>在IP层抽象的互联网上只能看到IP数据报。</li>
<li>虽然IP数据报中有完整的源IP地址和目的IP地址，但路由器只根据<strong>目的IP地址的网络号</strong>进行路由选择。</li>
<li>在<strong>局域网</strong>的数据链路层只能看见MAC帧，但通过路由器转发分组的时候，该IP分组在每个网络中都会被路由器<strong>解封装</strong>与<strong>重新封装</strong>（除非到了目的网络的路由器），因此<strong>IP数据报在分组转发</strong>的时候所使用的<strong>MAC地址会不断改变</strong>。</li>
<li>路由器有多个IP地址，也有多个MAC地址。</li>
</ul>
</blockquote>
<p><strong>位置：</strong>处于网络层和数据链路层之间。</p>
<p><strong>设备基础</strong>： 在<strong>每一台设备</strong>中都有一个 <strong>ARP高速缓存</strong>（存放IP地址与MAC地址的映射），并且这个映射表会经常<strong>动态更新</strong>（新增或超时删除）。</p>
<p><strong>作用：</strong>为主机查找接收端的MAC地址。</p>
<p><strong>数据传输过程：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B.png" alt="数据传输过程"></p>
<ul>
<li>应用将要发送信息放入传输层。</li>
<li>传输层视情况将数据进行划分，并将数据放入网络层中。</li>
<li>网路层接收到传输层的信息，然后<strong>根据MTU来决定</strong>是否将数据分组；对分组加上<strong>目的IP地址</strong>与<strong>源IP地址</strong>，最后将数据放入数据链路层。</li>
<li>数据链路层收到数据分组后，给数据加上<strong>帧头、FCS（检错码）</strong>以及<strong>MAC地址</strong>等信息，以此封装成<strong>帧</strong>，然后发给物理层。</li>
<li>物理层通过一系列操作后将数据转换成<strong>电信号</strong>或<strong>光信号</strong>后传输到介质上进行数据的发送。</li>
</ul>
</blockquote>
<p><strong>例子（ARP协议的实施过程）：</strong></p>
<blockquote>
<p>当主机A要向<strong>本局域网</strong>（重点）上某台主机B发送IP数据报时，先在其ARP高速缓存中查看有无主机B的IP地址，</p>
<ul>
<li><p><strong>如果有</strong>，就在ARP高速缓存中查找出对应的硬件地址，然后将MAC地址写入MAC帧中，最后通过局域网把该MAC帧发送到主机B上。</p>
</li>
<li><p><strong>如果没有，</strong>则需要根据ARP协议找到主机B的MAC地址。</p>
<blockquote>
<ul>
<li><p>ARP进程在本局域网上广播发送一个APR请求分组</p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%B9%BF%E6%92%ADARP%E8%AF%B7%E6%B1%82.png" alt="广播ARP请求"></p>
<p>IP1是本主机的IP地址，IP6是目的主机的IP地址，MAC1是本机的IP地址，全1代表要求IP6的MAC地址。</p>
</blockquote>
</li>
<li><p>所有主机收到该ARP请求，只有符合目的地址的主机才会接收该请求，并发回一个响应分组<strong>（注意这个响应分组是单播传送的）</strong>。</p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/ARP%E5%93%8D%E5%BA%94.png" alt="ARP响应"></p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>补充：</strong>本例中的两个主机是在同一个网络中，如果是在不同网络中，则由本网络的路由器来解决。</p>
</blockquote>
<p><strong>ARP的四种情况：</strong></p>
<blockquote>
<ul>
<li><strong>主机A</strong>发给<strong>本网络</strong>上的主机B：用ARP找到<strong>主机B的硬件地址</strong>。</li>
<li><strong>主机A</strong>发给<strong>另一网络</strong>上的主机B：用ARP找到<strong>本网络上的一个路由器（网关）的MAC地址</strong>，剩下的就交给该路由器了。</li>
<li><strong>路由器</strong>发给<strong>本网络</strong>的主机A：用ARP找到<strong>主机A的硬件地址</strong>。</li>
<li><strong>路由器</strong>发给<strong>另一个网络</strong>的主机B：用ARP协议找到<strong>目的网络上的一个路由器的MAC地址</strong>，剩下的就交给该路由器了。</li>
</ul>
</blockquote>
<p><strong>注意：</strong>ARP协议是自动运行的，主机并不知道。ARP协议是解决下一跳要怎么走的问题（即找到下一跳的MAC地址）。</p>
</blockquote>
<h3 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h3><blockquote>
<p><strong>主机获得IP地址的方式：</strong>静态配置、动态配置</p>
<p><strong>动态主机配置协议DHCP</strong>是<strong>应用层</strong>协议，使用<strong>客户&#x2F;服务器</strong>方式，客户端和服务端通过<strong>广播</strong>方式进行交互，交互方式基于<strong>UDP</strong>。</p>
<p><strong>作用：</strong>DHCP提供<strong>即插即用</strong>联网的机制，主机可以从服务器<strong>动态</strong>获取IP地址、子网掩码、默认网关（路由器）、DNS服务器名称及IP地址。允许<strong>地址重用（地址每次都可以分配给不同的主机）</strong>、支持<strong>移动用户加入网络</strong>，支持<strong>在用地址续租</strong>。</p>
<p><strong>协议运行过程：</strong></p>
<blockquote>
<ul>
<li>主机广播<strong>DHCP发现报文</strong>：试图找到网络中的DHCP服务器。</li>
<li>DHCP服务器广播<strong>DHCP提供报文</strong>：服务器拟分配给主机一个IP地址以及相关配置。</li>
<li>主机广播<strong>DHCP请求报文</strong>：主机向服务器申请IP地址。</li>
<li>DHCP服务器广播<strong>DHCP确认报文</strong>：服务器正式将IP地址分配给主机。</li>
</ul>
</blockquote>
<p><strong>补充：</strong>由于刚入网的主机没有IP地址，因此DHCP会是主机最先执行的协议之一；并且由于没有IP地址，因此只能通过广播方式进行交流。</p>
</blockquote>
<h3 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><blockquote>
<p><strong>位置：</strong>处于网络层和传输层之间。</p>
<p>ICMP允许主机或路由器<strong>报告差错</strong>情况或提供<strong>有关异常情况</strong>的报告。</p>
<p><strong>ICMP报文</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/ICMP%E6%8A%A5%E6%96%87.png" alt="ICMP报文"></p>
<ul>
<li><strong>类型：</strong>该ICMP报文属于什么类型的报文。</li>
<li><strong>代码：</strong>区分相同类型的不同情况。</li>
</ul>
<p><strong>注意：</strong>ICMP数据报属于IP数据报的数据部分。</p>
</blockquote>
<p><strong>ICMP报文类型</strong></p>
<blockquote>
<ul>
<li><p><strong>ICMP差错报告报文：</strong></p>
<blockquote>
<ul>
<li><strong>终点不可达：</strong>当路由器或主机<strong>无法交付</strong>数据报时就会向源点发送终点不可达报文。</li>
<li><strong>源点抑制：</strong>当路由器或主机由于<strong>拥塞</strong>而丢弃数据报时，就向源点发送源点抑制报文，使源点把数据发送速率放慢（现在已经不使用）。</li>
<li><strong>时间超过</strong>：当路由器收到<strong>生存时间（TTL）为0</strong>的数据报时，除丢弃外还需要向源点发送时间超过报文。当接收端在预定时间内不能收到一个数据报的所有切片时，也会把已收到的切片丢弃，并向源点发送时间超过报文。</li>
<li><strong>参数问题：</strong>当路由器或目的主机收到的数据报的<strong>首部字段出错</strong>时，就丢弃该数据报，并向源点发送参数问题报文。</li>
<li><strong>改变路由（重定向）：</strong>路由器把改变路由报文发送给主机，让主机知道下次应该将数据报发送给另外的路由器。</li>
</ul>
<p><strong>ICMP差错报告报文数据字段</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/ICMP%E5%B7%AE%E9%94%99%E6%8A%A5%E5%91%8A%E6%8A%A5%E6%96%87%E6%95%B0%E6%8D%AE%E5%AD%97%E6%AE%B5.png" alt="ICMP差错报告报文数据字段"></p>
</blockquote>
<p><strong>不应使用ICMP差错报告报文的情况：</strong></p>
<blockquote>
<ul>
<li><strong>对ICMP的差错</strong>再发送ICMP差错报告报文</li>
<li>对第一个分片以后的<strong>后续分片</strong>都不发送ICMP差错报告报文</li>
<li>对具有<strong>组播地址（一点到多点）</strong>的数据报不发送ICMP差错报告报文</li>
<li>对具有<strong>特殊地址（127.0.0.0或0.0.0.0）</strong>的数据报不发送ICMP差错报告报文。</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>ICMP询问报文</strong></p>
<blockquote>
<ul>
<li><strong>回送请求和回答报文：</strong>主机或路由器向特定目的主机发出的询问，收到此报文的主机必须向源主机或路由器发送ICMP回送回答报文。（实际应用就是ping）</li>
<li><strong>时间戳请求和回答报文：</strong>请某个主机或路由器回答当前的日期和时间，用来进行时钟同步和测量时间。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>ICMP的应用：</strong></p>
<blockquote>
<ul>
<li><strong>PING：</strong>测试两个主机之间的连通性，使用了<strong>ICMP回送请求和回答报文</strong>。</li>
<li><strong>Traceroute：</strong>跟踪一个分组从源点到终点的路径，使用了<strong>ICMP时间超过差错报告报文</strong>。</li>
</ul>
<p><strong>注意：</strong>PING工作在应用层，它直接使用网络层的ICMP，而未使用传输层的TCP或UDP。Traceroute工作在网络层。</p>
</blockquote>
</blockquote>
<h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><blockquote>
<p><strong>目的：</strong>为了解决IPv4使用殆尽的问题。</p>
<p><strong>IPv6的基本部分：</strong></p>
<blockquote>
<p>IPv6仍支持无连接的传送，但将协议数据单元PDU称为<strong>分组</strong>。</p>
<p><strong>IPv6数据报格式：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/IPv6%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.png" alt="IPv6数据报格式"></p>
<p><strong>基本首部固定为40字节，有效载荷相当于IPv4中的可变部分以及数据部分。</strong></p>
</blockquote>
<p><strong>IPv6数据报格式：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/IPv6%E6%95%B0%E6%8D%AE%E6%8A%A5.png" alt="IPv6数据报"></p>
<ul>
<li><strong>版本：</strong>一直为6，指明协议版本。</li>
<li><strong>优先级：</strong>表明该数据报的优先级。</li>
<li><strong>流标签：</strong> <strong>特定源点</strong>到<strong>特定终点</strong>一系列数据报称为流，每一个流都有专属的标识符，称为流标签。</li>
<li><strong>有效载荷长度：</strong>指有效载荷部分的大小。</li>
<li><strong>下一个首部：</strong>表示下一个<strong>扩展首部</strong>或<strong>上层协议首部</strong>。</li>
<li><strong>跳数限制：</strong>报文的生存时间</li>
</ul>
</blockquote>
</blockquote>
<p><strong>IPv6与IPv4的区别：</strong></p>
<blockquote>
<ul>
<li>IPv6将地址从32位扩大到<strong>128位</strong></li>
<li>IPv6将<strong>检验和字段</strong>彻底移出，减少每一跳的耗时。</li>
<li>IPv6将IPv4的可选字段移除，改成了<strong>拓展首部</strong>。</li>
<li>IPv6支持<strong>即插即用（即自动配置IP地址）</strong>，无需DHCP协议。</li>
<li>IPv6首部长度必须是<strong>8字节的整数倍</strong>。</li>
<li>IPv6<strong>只能在主机处（源节点）分片</strong>，<strong>IPv4可以在路由器和主机处分片</strong>。</li>
<li>ICMPv6：附加报文类型“分组过大”。</li>
<li>IPv6支持资源的预分配。</li>
<li>IPv6取消了协议字段，改成下一个首部字段。</li>
<li>IPv6取消了总长度字段，改成了有效载荷长度字段。</li>
<li>IPv6取消了服务类型字段。</li>
</ul>
</blockquote>
<p><strong>IPv6地址表示形式：</strong></p>
<blockquote>
<ul>
<li><strong>冒号十六进制记法：</strong>如，4BF5:AA12:0216:FEBC:BA5F:039A:BE9A:2170</li>
<li><strong>压缩形式：</strong>如，4BF5:0000:0000:0000:BA5F:039A:000A:2176  &#x3D;&gt;  4BF5:0:0:0:BA5F:39A:A:2176</li>
<li><strong>零压缩：</strong>一连串连续的0可以用一对冒号表示，如：FF05:0:0:0:0:0:0:B3 &#x3D;&gt; FF05::B3<strong>（注意双冒号在一个地址中只能出现一次）</strong></li>
</ul>
</blockquote>
<p><strong>IPv6基本地址类型：</strong></p>
<blockquote>
<ul>
<li><strong>单播：</strong>一对一通信，可以作源地址+目的地址</li>
<li><strong>多播（可以是广播）：</strong>一对多通信，可作目的地址</li>
<li><strong>任播：</strong>一对多中的一个通信，可作目的地址</li>
</ul>
</blockquote>
<p><strong>IPv6向IPv4过渡的策略：</strong></p>
<blockquote>
<ul>
<li><strong>双栈协议：</strong>指一台设备上<strong>同时启用IPv4的协议栈和IPv6的协议栈</strong>。</li>
<li><strong>隧道技术：</strong>通过使用互联网的基础设施之间传递数据的方式，通过对数据报进行<strong>重新封装</strong>，然后就可以通过不同的隧道进行传送了。</li>
</ul>
</blockquote>
</blockquote>
<h2 id="IP多播（组播）"><a href="#IP多播（组播）" class="headerlink" title="IP多播（组播）"></a>IP多播（组播）</h2><blockquote>
<p><strong>IP数据报的三种传输方式：</strong></p>
<blockquote>
<ul>
<li><strong>单播：</strong>用于发送数据报到单个目的地，且每发送一份单播报文都使用一个单播IP地址作为目的地址，是一个<strong>点对点</strong>的传输方式。</li>
<li><strong>广播：</strong>广播是指发送数据报到同一广播域或子网内的所有设备的一种数据传输方式，是一种<strong>点对多点</strong>传输方式。</li>
<li><strong>多播（组播）：</strong>组播数据发送者<strong>仅发送一次数据</strong>，借助组播路由协议为组播数据报建立组播分发树，被传递的数据到达距离用户端尽可能近的节点后才开始复制和分支，是一种<strong>点对多点</strong>传输方式。</li>
</ul>
</blockquote>
<p><strong>IP多播地址：</strong></p>
<blockquote>
<p>IP组播地址让源设备能够将分组发送给一组设备。属于多播组的设备将分配一个<strong>组播组IP地址</strong>（一群共同需求主机的相同标识。）</p>
<p>组播地址范围为：224.0.0.0 - 239.255.255.255（D类地址），一个D类地址表示一个组播组。<strong>只能用作目的地址</strong>。</p>
<p>组播组数据是“尽最大努力交付”应用<strong>UDP</strong>。（类比于直播）</p>
<p>对组播数据报不产生ICMP差错报文。</p>
<p>并非所有D类地址都可以用作组播地址。</p>
</blockquote>
<p><strong>多播过程：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%A4%9A%E6%92%AD%E4%BE%8B%E5%AD%90.png" alt="多播例子"></p>
</blockquote>
<p><strong>硬件多播：</strong></p>
<blockquote>
<p>多播IP地址需要相应的多播MAC地址在本地网络中实际传送帧。</p>
<p>多播MAC地址以十六进制<strong>01-00-5E</strong>开头，剩下的六位十六进制是根据IP多播组地址的最后23位转换得到的。</p>
<p>TCP&#x2F;IP协议使用的以太网多播地址的范围是：01-00-5E-00-00-00到01-00-5E-7F-FF-FF</p>
<p><strong>IP地址与MAC地址的映射：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%A4%9A%E6%92%AD%E6%98%A0%E5%B0%84.png" alt="多播映射"></p>
<p><strong>注意：</strong>收到多播数据报的主机还要在IP层使用软件进行过滤，把不是本主机要接收的数据报过滤掉。</p>
</blockquote>
</blockquote>
<p><strong>IGMP协议：</strong></p>
<blockquote>
<p><strong>作用：</strong>让路由器知道本局域网上<strong>是否有主机（进程）参加或退出某个多播组</strong>。</p>
<p><strong>例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/IGMP%E4%BE%8B%E5%AD%90.png" alt="IGMP例子"></p>
<p>多播组发送数据报时，路由器会根据IGMP协议来判断是否接收转发该数据报。</p>
</blockquote>
<p><strong>IGMP工作的两个阶段：</strong></p>
<blockquote>
<ul>
<li>某主机要加入多播组时，该主机向多播组的多播地址发送一个IGMP报文，声称自己要成为该组的成员。本地多播路由器在接收到IGMP报文后，要利用多播路由选择协议把这组成员关系发送给因特网上的其他多播路由器。</li>
<li>本地多播路由器周期性探询本地局域网上的主机，了解这些主机是否还是还是多播组的成员。只要有一个主机相应，那么多播路由器就认为该局域网还有多播组的成员。否则，就不再将这组的成员关系发给其他的多播路由器。</li>
</ul>
<p><strong>注意：</strong>组播路由器只知道该局域网内是否有多播组成员，并不知道有多少个。</p>
</blockquote>
</blockquote>
<p><strong>多播路由选择协议：</strong></p>
<blockquote>
<p><strong>目的：</strong>找出以源主机<strong>为根节点的多播转发树</strong>。</p>
<p>对<strong>不同的多播组</strong>对应不同的多播转发树；同一个多播组，对<strong>不同的源点</strong>也会有不同的多播转发树。</p>
<p><strong>多播路由常使用的路由算法：</strong></p>
<blockquote>
<ul>
<li><strong>基于链路状态的路由选择</strong></li>
<li><strong>基于距离-向量的路由选择</strong></li>
<li><strong>协议无关的组播（稀疏&#x2F;密集）</strong></li>
</ul>
</blockquote>
</blockquote>
</blockquote>
<h2 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h2><h3 id="移动IP的概念"><a href="#移动IP的概念" class="headerlink" title="移动IP的概念"></a>移动IP的概念</h3><blockquote>
<p><strong>定义：</strong>支持移动性的因特网体系结构与协议的共称。</p>
<p><strong>移动IP技术：</strong>移动结点以固定的网络IP地址实现<strong>跨越不同网段</strong>的漫游功能，并保证基于网络IP的网络权限在漫游过程中不发生任何改变。</p>
<p><strong>移动IP的目的：</strong>把分组自动地投递给移动结点。</p>
<p><strong>移动IP的一些名词：</strong></p>
<blockquote>
<ul>
<li><strong>移动结点：</strong>具有永久IP地址的移动结点。</li>
<li><strong>本地代理（归属代理）：</strong>在一个网络中，一个移动结点的永久“居所”被称为<strong>归属网络</strong>，在归属网络中代表移动结点执行移动管理功能的实体称为<strong>归属代理</strong>。它会移动结点的<strong>转交地址</strong>，采用隧道技术转交移动结点的数据包。</li>
<li><strong>外部代理：</strong>在外部网络帮助移动结点完成移动管理功能的实体。</li>
<li><strong>永久地址（归属地址&#x2F;主地址）：</strong>移动结点在归属网络中的源地址。</li>
<li><strong>转交地址（辅地址）：</strong>移动结点在外部网络的临时地址。</li>
</ul>
</blockquote>
</blockquote>
<h3 id="移动IP通信过程"><a href="#移动IP通信过程" class="headerlink" title="移动IP通信过程"></a>移动IP通信过程</h3><blockquote>
<p><strong>例子：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/%E7%A7%BB%E5%8A%A8IP%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.png" alt="移动IP通信过程"></p>
</blockquote>
<p><strong>通信流程：</strong></p>
<blockquote>
<ul>
<li>移动结点在归属网络的时候，使用主地址进行传统的TCP&#x2F;IP方式进行通信。</li>
<li>当移动结点进入一个外部网络的时候，外部代理交给移动结点一个临时的转交地址。</li>
<li>外部代理向本地代理登记移动结点的转交地址（告诉本地地址移动结点的可达地址）。</li>
<li>本地代理登记完转交结点后会构建一条通向转交地址的隧道。</li>
<li>这样以后，当本地代理收到发送给主地址的数据包时，重新封装，并将该数据包交给外部代理（此时使用的时转交地址）。</li>
<li>外部代理得到该数据包后，进行解封装，交给相应的移动结点（此时使用的是主地址）。</li>
<li>当移动结点离开外部网络的时候，转交地址会被撤销，而移动结点的主地址不变。</li>
</ul>
</blockquote>
<p><strong>补充：</strong>当移动结点移动到外部网络的时候<strong>不能直接发送分组</strong>与<strong>直接接收分组</strong>。</p>
</blockquote>
<h2 id="网络层设备"><a href="#网络层设备" class="headerlink" title="网络层设备"></a>网络层设备</h2><h3 id="路由器的组成与功能"><a href="#路由器的组成与功能" class="headerlink" title="路由器的组成与功能"></a>路由器的组成与功能</h3><blockquote>
<p><strong>定义：</strong>路由器是一种具有<strong>多个输入&#x2F;输出端口的专用计算机</strong>，其任务是<strong>连接不同的网络</strong>并<strong>完成路由转发</strong>。</p>
<p><strong>结构图：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%B1%82/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png" alt="路由器内部结构"></p>
</blockquote>
<ul>
<li><p><strong>路由选择：</strong></p>
<blockquote>
<p>路由选择部分也称<strong>控制部分</strong>，其核心部分是<strong>路由选择处理机</strong>。路由选择处理机会根据所选定的路由协议构造出路由表，同时定期与相邻路由器交换路由信息从而不断更新和维护路由表。</p>
</blockquote>
</li>
<li><p><strong>分组转发：</strong></p>
<blockquote>
<p>分组转发由三个部分组成：<strong>交换结构（核心）</strong>、<strong>一组输入端口</strong>、<strong>一组输出端口</strong></p>
<p><strong>输入端口：</strong>从物理层中的比特流提取出数据帧，进而从数据帧中提取出网络层的数据报。</p>
<p><strong>输出端口：</strong>与输入端口操作相反。</p>
<p><strong>交换结构：</strong>根据转发表（转发表根据路由表得出）对分组进行处理，即将某个输入端口的数据转到合适的输出端口转发出去。</p>
</blockquote>
</li>
</ul>
<p><strong>路由器的主要功能：</strong></p>
<blockquote>
<ul>
<li><strong>路由选择：</strong>根据不同的路由选择协议，与相邻的路由器进行交互从而完善路由表。</li>
<li><strong>分组转发：</strong>通过转发表的查询、转发相关的队列管理和任务调度。</li>
</ul>
</blockquote>
<p><strong>路由器与网桥（交换机）的区别：</strong></p>
<blockquote>
<ul>
<li>网桥与高层协议无关，而路由器是面向协议的。</li>
<li>路由器进行路径选择、分段、帧格式转换、对数据报的生存时间和流量进行控制。</li>
</ul>
</blockquote>
<p><strong>转发与路由选择的区别：</strong> <strong>转发</strong>是路由器根据转发表把收到的IP数据报从合适的端口转发出去，它仅涉及一个路由器；<strong>路由选择</strong>则涉及多个路由器，路由表就是多个路由器共同工作的结果。</p>
<p><strong>注意：</strong>虽然在讨论路由选择原理的时候不去刻意区分转发表和路由表的区别，但数以路由表并不等于转发表，<strong>分组转发实际靠的是查找转发表</strong>，而不是查找路由表。</p>
</blockquote>
<h2 id="一些其他问题："><a href="#一些其他问题：" class="headerlink" title="一些其他问题："></a>一些其他问题：</h2><blockquote>
<p><strong>分组和切片的区别：</strong>分组是在分组交换时对数据进行的切分，切片是IP数据报的大小超过数据链路层中的MTU后对数据报进行的一个划分。</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>基础学科</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机操作系统概述</title>
    <url>/2022/08/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="一、操作系统的基本概念"><a href="#一、操作系统的基本概念" class="headerlink" title="一、操作系统的基本概念"></a>一、操作系统的基本概念</h2><h3 id="1、操作系统的概念"><a href="#1、操作系统的概念" class="headerlink" title="1、操作系统的概念"></a>1、操作系统的概念</h3><blockquote>
<p><strong>操作系统：</strong>指<strong>控制</strong>和<strong>管理</strong>整个计算机系统的<strong>硬件</strong>与<strong>软件资源</strong>，合理地组织、调度计算机的工作和资源的分配，进而为用户和其他软件提供方便接口与环境的<strong>程序集合</strong>。</p>
</blockquote>
<h3 id="2、操作系统的功能"><a href="#2、操作系统的功能" class="headerlink" title="2、操作系统的功能"></a>2、操作系统的功能</h3><blockquote>
<p>​        操作系统管理着计算机的硬件&#x2F;软件资源，为多道程序提供了良好的运行环境，也是<strong>硬件和软件的连接桥梁</strong>，因此计算机系统有以下功能：</p>
<ul>
<li><strong>处理机管理：</strong>即在多道程序的环境下，处理机要向每道程序分配合适的资源，以及对进程何时创建、何时销毁、如何管理等问题进行解决，还有对于程序发生冲突（如对资源的抢夺）后如何处理，这都是操作系统处理机管理所需要负责的部分。</li>
<li><strong>存储器管理：</strong>为多道程序运行提供良好环境，包括程序内存的分配和回收、地址映射、内存保护等功能。</li>
<li><strong>文件管理：</strong>包括文件存储空间的管理、目录管理、文件读写管理和文件权限管理等内容</li>
<li><strong>设备管理：</strong>完成外部设备的I&#x2F;O请求，方便用户使用各种外设。</li>
</ul>
<p>同时还需要<strong>向用户提供接口</strong></p>
<ul>
<li><p><strong>命令接口</strong></p>
<blockquote>
<p>用户使用命令接口进行作业控制，其主要有两种方式：<strong>联机控制方式</strong>和<strong>脱机控制方式</strong></p>
<ul>
<li><strong>联机控制方式：</strong>又称<strong>交互式命令接口</strong>，即用户通过控制台或终端输入操作命令，而系统根据输入的命令进行反馈。用户输入一条命令，系统就反馈一条命令的结果。（类似于shell、python的交互编程）</li>
<li><strong>脱机控制方式：</strong>又称<strong>批处理命令接口</strong>，即需要用户实现写好一段作业控制命令，交给操作系统，操作系统收到以后，按照控制命令执行，期间用户无法对其进行修改，只能等操作系统完成所有命令后才能拿到结果。</li>
</ul>
</blockquote>
</li>
<li><p><strong>程序接口</strong></p>
<blockquote>
<p>程序接口由一组<strong>系统调用（也称广义指令）</strong>组成。用户通过在程序种使用这些系统调用来请求操作系统为其程序提供服务，如使用各种外部设备、申请分配和回收内存等。</p>
</blockquote>
</li>
</ul>
<p>操作系统还用作<strong>扩充机器</strong></p>
<blockquote>
<p>没有任何软件支持的计算机称为裸机，它仅有计算机系统的物质基础。而操作系统提供的各类管理服务使得用户可以更方便地使用计算机；因此我们把覆盖了软件的机器称为<strong>扩充机器</strong>或<strong>虚拟机</strong></p>
</blockquote>
</blockquote>
<h3 id="3、操作系统的特性"><a href="#3、操作系统的特性" class="headerlink" title="3、操作系统的特性"></a>3、操作系统的特性</h3><blockquote>
<ul>
<li><p><strong>并发性</strong></p>
<blockquote>
<p>指两个或多个事件在同一时间间隔内发生。操作系统的并发性是通过<strong>分时</strong>来实现的</p>
<p><strong>注意：</strong>并发在宏观上是同时发生的，但是在微观上（很小的时间间隔里）是交替发生的。</p>
<p><strong>并行：</strong>两个或多个事件在同一时间内同时发生，需要相应数量的硬件支持。</p>
<p><strong>并发与并行的区别：</strong>并发本质是在极短的时间内交替运行，并行则是在同一时刻都可以同时进行。</p>
</blockquote>
</li>
<li><p><strong>共享性</strong></p>
<blockquote>
<p>​        指系统中的资源可供内存中多个并发执行的进程共同使用，可以分为<strong>互斥共享</strong>与<strong>同时访问共享</strong></p>
<ul>
<li><strong>互斥共享：</strong>指在一个时间段内只允许一个进程访问该资源。（如一台打印机在一个时间段内只能打印一个进程发送的文件，下一个文件必须要等上一个文件打印完才能打印）</li>
<li><strong>同时访问共享：</strong>允许一段时间内由多个进程“同时“访问（这的同时也是宏观上的），在微观上这些进程也是对这些资源进行”分时共享“。</li>
</ul>
<p><strong>并发和共享是操作系统两个最基本的特征，两者间互为存在条件</strong></p>
</blockquote>
</li>
<li><p><strong>虚拟性</strong></p>
<blockquote>
<p>​        指把一个物理上的实体变为若干逻辑上的对应物。（如虚拟内存，利用空分复用技术来扩充内存的大小）</p>
<p>​        实际上虚拟性就是使用了并发性和共享性，将资源的使用时间分为很小的一段时间，让不同进程可以交替使用，从而在宏观上让我们看到一份资源可以供多个进程使用，感觉资源好像变多了。</p>
<p><strong>常见的虚拟技术：</strong>时分复用技术（处理器的共享）、空分复用技术（存储器的共享）</p>
</blockquote>
</li>
<li><p><strong>异步性</strong></p>
<blockquote>
<p>指多道程序允许多个进程并发执行，但资源有限，进程的执行不是一贯到底的，有时候需要停下来等待需要的资源，因此会走走停停，以不可知的速度向前推进。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="二、操作系统的发展与分类"><a href="#二、操作系统的发展与分类" class="headerlink" title="二、操作系统的发展与分类"></a>二、操作系统的发展与分类</h2><blockquote>
<ul>
<li><p><strong>手工操作阶段</strong></p>
<blockquote>
<p>​        此时并没有操作系统，机器的一切操作（程序装入、运行、结果输出）都基本需要人工干预。如，将程序通过打孔机打在一条纸带上，然后将指代放入机器，又机器执行完后又输出一条带孔的纸带作为结果。</p>
<p>此时有两个突出的缺点：</p>
<ul>
<li>用户独占全机，没有共享性，且每次只能输入一个程序</li>
<li>机器等待人工操作的时间过长，各资源利用率过低</li>
</ul>
</blockquote>
</li>
<li><p><strong>批处理阶段</strong>（操作系统开始出现）</p>
<blockquote>
<ul>
<li><p><strong>单道批处理系统</strong></p>
<blockquote>
<p>​        机器引入了一个<strong>脱机输入&#x2F;输出技术</strong>，即用户依次将作业输入到磁带上，机器会根据<strong>监督程序</strong>自动从磁带上读取作业，一个个地执行，当执行完成后，将结果输出到磁带上。</p>
<p><strong>特征：</strong></p>
<ul>
<li><strong>自动性：</strong>在顺利的情况下，磁带上的作业可以自动地逐一运行，无需人工干扰</li>
<li><strong>顺序性：</strong>磁带上的作业按照顺序依次进入内存，完成后的结果也依次输出到磁带中，因此属于先进先出类型的机器</li>
<li><strong>单道性：</strong>机器内存中一次只能有一个作业在运行，只有上一个作业退出后，下一个作业才能进入内存</li>
</ul>
</blockquote>
</li>
<li><p><strong>多道批处理系统</strong></p>
<blockquote>
<p>​        多道批处理设计技术允许多个程序同时进入内存并允许它们<strong>交替地运行</strong>，这些程序<strong>共享</strong>系统中各种资源。（因此这才是操作系统出现的标志）</p>
<p>​        虽然多道批处理解决了程序运行效率问题以及提高了机器的利用率，但是机器还是<strong>没有提供人机交互能力</strong>，用户不能了解自己程序的运行情况，也不能控制机器；也不能让多人使用机器。</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>分时操作系统</strong></p>
<blockquote>
<p>​        为了提供人机交互功能，后面又提出了分时操作系统。分时操作系统就是<strong>把处理器的运行时间分为很短的时间片</strong>，把这些时间片分给各个用户使用。使得各个用户可以交替获得计算机的服务。同时用户也可以使用键盘、鼠标等设备对操作系统进行操作，从而提供了人机交互功能。</p>
<p>​        由于计算机速度快，作业轮转得也快，因此每个用户都感觉自己独占了一台计算机。</p>
<p>​        虽然分时系统解决了人机交互问题，但无法解决紧急任务与普通任务得区分。</p>
</blockquote>
</li>
<li><p><strong>实时操作系统</strong></p>
<blockquote>
<p>​        实时操作系统就是<strong>为了能在某个时间限制内完成某些紧急任务而无需排队</strong>而诞生的。根据可靠度的不同，实时操作系统可以分为两类：</p>
<ul>
<li><strong>硬实时操作系统：</strong>某个动作<strong>必须</strong>在规定时间内完成，否则会出现重大问题的实时操作系统</li>
<li><strong>软实时操作系统：</strong>能接受<strong>偶尔</strong>违反时间限制且不会引起重大损害的实时操作系统</li>
</ul>
</blockquote>
</li>
<li><p>网络操作系统</p>
<blockquote>
<p>​        利用计算机网络将不同地点的计算机有机结合起来，提供一个统一、有效地使用各台计算机的方法，实现各台计算机之间的数据互传。</p>
<p>​        网络操作系统的主要特点是：网络中各资源的共享以及各计算机之间的通信</p>
</blockquote>
</li>
<li><p>分布式操作系统</p>
<blockquote>
<p>​        系统中任意两台计算机通过通信方式交换信息；系统中每台激素那几都具有等同地位；每台计算机上的资源为所有用户共享；系统中任意台计算机都能构成一个子系统，并且还能重构；任何工作都可以分布在几台计算机上，由它们并行工作。</p>
<p>​        特点是：分布性、并行性</p>
<p>​        与网络操作系统的区别是：分布式操作系统中的若干计算机相互协调完成同一任务。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="三、操作系统的运行环境"><a href="#三、操作系统的运行环境" class="headerlink" title="三、操作系统的运行环境"></a>三、操作系统的运行环境</h2><h3 id="1、操作系统的运行机制"><a href="#1、操作系统的运行机制" class="headerlink" title="1、操作系统的运行机制"></a>1、操作系统的运行机制</h3><blockquote>
<p><strong>程序的运行原理：</strong>系统在运行高级语言编写的程序时，会先将程序编译成一条条的机器指令；而运行时就是CPU执行一条条指令的过程。</p>
<p>​        根据程序的性质，可以将其分为两类程序：<strong>内核程序</strong>和<strong>应用程序</strong>。对于操作系统来说，这两种程序的作用不同，内核程序时应用程序的管理者。</p>
<p>​        而根据程序的不同，又可以分出两类指令：<strong>特权指令</strong>和<strong>非特权指令</strong>。其中内核程序使用的是特权指令，如I&#x2F;O指令、置中断指令等。而应用程序是无法使用特权指令的，当应用程序想要使用特权指令时，系统会自动产生中断，此时操作系统强行夺回电脑控制权，并禁止用户使用特权指令。</p>
<p>​        而根据CPU的状态，可以分出：<strong>用户态（目态）</strong>和<strong>核心态（管态、内核态）</strong>。其中用户态是运行应用程序的状态，当运行内核程序时，系统会转至核心态。CPU内部会有一个<strong>程序状态字寄存器（PSW）</strong>，其中存放的就是用户态或核心态的标志位，如果运行内核程序，该寄存器的标记为会变为核心态的标志位。</p>
<p>​        大多数操作系统的内核包括以下4方面：</p>
<ul>
<li><p><strong>时钟管理</strong></p>
<blockquote>
<p>​        时钟管理指的是对时钟部件的管理，操作系统除了向用户提供系统时间外，在程序并发执行的过程中也需要时钟信号（这会在内中断里会提到）。</p>
</blockquote>
</li>
<li><p><strong>中断机制</strong></p>
<blockquote>
<p>​        中断机制的初衷就是提高CPU的利用率（通过中断来切换不同进程对CPU的占有，使得CPU可以尽可能地工作）。</p>
<p>​        在中断机制中，只有少部分功能属于内核，它们负责保护现场和恢复中断现场，将控制权转移到其它程序上。</p>
</blockquote>
</li>
<li><p><strong>原语</strong></p>
<blockquote>
<p>原语是一些可被调用的公用小程序，它们各自完成一个规定的操作，并且有以下特点：</p>
<ul>
<li><strong>处于操作系统的最底层，最接近硬件</strong></li>
<li><strong>这些程序具有原子性</strong>（即执行时不能中断，只能一气呵成）</li>
<li><strong>这些程序执行时间短，且频繁被调用</strong></li>
</ul>
</blockquote>
</li>
<li><p><strong>系统控制的数据结构及处理</strong></p>
<blockquote>
<p>​        系统中用于登记状态信息的数据结构（作业控制块、进程控制块、消息队列、内存分配表等），为了实现有效的管理，系统需要一些基本的操作，常见的有以下操作：</p>
<ul>
<li><strong>进程管理</strong>：进程状态管理、进程调度和分配、进程创建和撤销等</li>
<li><strong>存储器管理</strong>：存储器空间的分配和回收、内存信息保护、代码对换程序等</li>
<li><strong>设备管理</strong>：缓冲区管理、设备分配和回收等</li>
</ul>
</blockquote>
</li>
</ul>
<p>核心态指令实际上就是<strong>系统调用类指令</strong>和一些针对<strong>时钟</strong>、<strong>中断</strong>、<strong>原语</strong>的操作指令。</p>
</blockquote>
<h3 id="2、中断与异常"><a href="#2、中断与异常" class="headerlink" title="2、中断与异常"></a>2、中断与异常</h3><blockquote>
<p><strong>中断的作用：</strong></p>
<blockquote>
<ul>
<li>CPU由用户态转为核心态的唯一方法</li>
<li>帮助操作系统重新取得CPU的使用权的方法</li>
</ul>
</blockquote>
<p><strong>中断的分类：</strong></p>
<blockquote>
<ul>
<li><p><strong>外中断</strong></p>
<blockquote>
<p>​        指来自于CPU以外的中断请求，如I&#x2F;O设备的中断信号，时钟部件的中断信号等。</p>
<p>​        当CPU收到外中断信号后，会进入核心态，查看中断类型，然后处理中断请求。</p>
<p><strong>注意：</strong>外中断与当前的指令无关，因为中断信号都来源于CPU外部。</p>
</blockquote>
</li>
<li><p><strong>内中断</strong></p>
<blockquote>
<p>​        内中断则是指来自于CPU内部的中断信号，也称为<strong>异常</strong>。如用户程序非法使用特权指令、操作数的违法输入、算术溢出等。根据类型不同又可以细分为以下三种：</p>
<ul>
<li><strong>陷阱&#x2F;陷入（trap）：</strong>由陷入指令引发，是应用程序需要请求内核服务时故意引发的。</li>
<li><strong>故障（fault）：</strong>由错误条件引发，<strong>可能被内核程序修复</strong>，修复后内核会把CPU还给应用程序。如缺页故障。</li>
<li><strong>终止（abort）：</strong>由致命错误引起，<strong>内核程序无法修复</strong>，引发此中断后，操作系统不会把CPU还给应用程序。如被除数为0，非法使用特权指令等。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>基本实现原理：</strong></p>
<blockquote>
<ul>
<li><p><strong>检测中断信号：</strong></p>
<blockquote>
<p><strong>外中断</strong>：CPU在执行指令的时候，在每一条指令的末尾都会有一个中断周期，用于检查是否存在中断信号</p>
<p><strong>内中断：</strong>CPU在执行指令的过程中会检查是否有异常发生</p>
</blockquote>
</li>
<li><p><strong>找到相应的中断处理程序：</strong>通过“中断向量表”来查找，操作系统会在内存中查找“中断向量表”来辨别中断的类型。</p>
</li>
</ul>
<p>详细的执行过程见计算机组成原理的第七章</p>
</blockquote>
</blockquote>
<h3 id="3、系统调用"><a href="#3、系统调用" class="headerlink" title="3、系统调用"></a>3、系统调用</h3><blockquote>
<p><strong>概念：</strong></p>
<blockquote>
<p><strong>系统调用</strong>：指用户在程序中调用操作系统所提供的一些子功能</p>
<p>​         可以将系统调用理解为操作系统提供的特殊公共子程序。系统中各类资源都是由操作系统统一控制的，因此凡是与资源相关的操作（内存分配、文件管理等），都需要通过系统调用方式向操作系统提出服务请求。</p>
<p>​        根据功能的不同，系统调用大致可以分为：设备管理、文件管理、进程控制、进程通信、内存管理</p>
<p><strong>系统调用与库函数的区别：</strong>系统调用一般封装在库函数中；而库函数不止系统调用，还有许多其他普通函数</p>
</blockquote>
<p><strong>系统调用的过程：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.png" alt="系统调用"></p>
<ul>
<li>用户程序向CPU传递参数（如所需系统调用的类型）</li>
<li>执行陷入指令&#x2F;Trap指令&#x2F;访管指令</li>
<li>此时转为内核态，由操作系统内核程序处理系统调用</li>
<li>返回应用程序，并由内核态转回用户态</li>
</ul>
</blockquote>
</blockquote>
<h2 id="四、操作系统体系结构"><a href="#四、操作系统体系结构" class="headerlink" title="四、操作系统体系结构"></a>四、操作系统体系结构</h2><blockquote>
<p>​        根据操作系统提供的服务和如何提供服务的问题上，可以将操作系统的体系结构分为以下几种：</p>
<ul>
<li><p><strong>大内核（单内核&#x2F;宏内核）</strong></p>
<blockquote>
<p>大内核是将操作系统的主要功能模块都作为系统内核（大内核之间功能之间的调用也是直接调用，无需消息传递）</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E5%A4%A7%E5%86%85%E6%A0%B8.png" alt="大内核"></p>
<p><strong>优点</strong>：高性能</p>
<p><strong>缺点：</strong>内核代码庞大，结构复杂</p>
</blockquote>
</li>
<li><p><strong>微内核</strong></p>
<blockquote>
<p>微内核只把基本的功能保留在内核中（微内核中各功能之间的调用需要消息传递）</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E5%BE%AE%E5%86%85%E6%A0%B8.png" alt="微内核"></p>
<p><strong>优点：</strong>内核功能少，结构简单</p>
<p><strong>缺点：</strong>使用时需要频繁地在核心态和用户态之间切换，性能低</p>
</blockquote>
</li>
<li><p><strong>分层结构</strong></p>
<blockquote>
<p>分层结构的操作系统的内核有多层结构，每一层可以<strong>单向</strong>调用<strong>更低一层</strong>提供的接口（类似计网中的网络系统结构）</p>
<img src="/picture/学习/操作系统上的图/计算机系统概述/分层结构.png" alt="分层结构" style="zoom:67%;" />

<p><strong>优点：</strong></p>
<blockquote>
<ul>
<li><strong>便于调试和验证</strong>，自底向上逐层调试验证</li>
<li>易于拓展，各接口之间调用接口清晰固定</li>
</ul>
</blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<ul>
<li>仅能调用相邻低层，难以确定各层的边界</li>
<li><strong>效率低</strong>，不可跨层调用，系统调用时间长</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>模块化</strong></p>
<blockquote>
<p>将内核划分为多个模块，各模块间相互协作</p>
<p>内核&#x3D;主模块+可加载内核模块</p>
<p><strong>主模块</strong>：只负责核心功能，如进程调度、内存管理等；<strong>可加载内核模块</strong>：可以动态加载新模块到内核，而无需重新编译整个内核，如驱动程序等</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E6%A8%A1%E5%9D%97%E5%8C%96.png" alt="模块化"></p>
<p><strong>优点：</strong></p>
<blockquote>
<ul>
<li>逻辑清晰，易于维护，确定模块间接口后即可多模块同时开发</li>
<li><strong>支持动态加载新的内核模块</strong>（如安装设备驱动程序到内核等），增强系统适应性</li>
<li><strong>任何模块都可以直接调用其它模块，无需采用消息传递进行通信</strong>，效率高</li>
</ul>
</blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<ul>
<li>模块间的接口定义</li>
<li>模块间相互依赖，难以调试</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>外核</strong></p>
<blockquote>
<p>这类操作系统有内核与外核组成。其中，<strong>内核负责进程调度、进程通信等功能</strong>；<strong>外核负责为用户进程分配未经抽象的硬件资源，且保证资源的使用安全</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E5%A4%96%E6%A0%B8.png" alt="外核"></p>
<p><strong>优点：</strong></p>
<blockquote>
<ul>
<li><strong>外核可以直接给用户进程分配“不虚拟、不抽象”（如未经虚拟化的内存空间）的硬件资源，用户可以更灵活的使用硬件资源</strong></li>
<li><strong>减少了虚拟硬件资源的“映射层”，提高了效率</strong>（如不需要再查页表）</li>
</ul>
</blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<ul>
<li>降低系统的一致性</li>
<li>使系统变得更复杂</li>
</ul>
</blockquote>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="五、操作系统引导"><a href="#五、操作系统引导" class="headerlink" title="五、操作系统引导"></a>五、操作系统引导</h2><blockquote>
<p><strong>操作系统引导（开机）：</strong>指计算机利用CPU运行特定程序，通过程序识别硬盘，识别硬盘分区，识别硬盘分区上的操作系统，最后通过程序启动操作系统。</p>
<p><strong>过程如下：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC.png" alt="操作系统系统引导"></p>
<ul>
<li><strong>激活CPU</strong>。激活的CPU会读取ROM中的boot程序，将指令寄存器设置为BIOS（基本输入&#x2F;输出系统）的第一条指令，即开始执行BIOS指令</li>
<li><strong>硬件自检：</strong>启动BIOS程序后，先进行硬件自检，检查硬件是否发生故障。</li>
<li><strong>加载带有操作系统的硬盘</strong>。硬件自检完后，BIOS开始读取BOOT Sequence，把控制权交给启动顺序排在第一位的存储设备（系统盘），然后CPU将该存储设备引导扇区的内容加载到内存中</li>
<li><strong>加载主引导记录（MBR）</strong>。硬盘通过特定的标识符区分引导硬盘和非引导硬盘，发现一个存储设备不是引导盘后，就检查下一个存储设备，直到找到引导记录。<strong>主引导记录MBR会告诉CPU去哪个分区找操作系统</strong></li>
<li><strong>扫描硬盘分区表</strong>，识别并找到操作系统所在的分区（也叫作活动分区）</li>
<li><strong>加载分区引导记录PBR</strong>。读取活动分区的第一个扇区，这个扇区被称为分区引导记录（PBR），其作用时寻找并激活分区根目录下用于引导操作系统的程序</li>
<li><strong>加载启动管理器</strong>。PBR搜索活动分区中的启动管理器，并加载它</li>
<li><strong>加载操作系统</strong></li>
</ul>
</blockquote>
</blockquote>
<h2 id="六、虚拟机"><a href="#六、虚拟机" class="headerlink" title="六、虚拟机"></a>六、虚拟机</h2><blockquote>
<p><strong>传统的计算机：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E4%BC%A0%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%9C%BA.png" alt="传统计算机"></p>
<p>​        一个机器只有一个操作系统，且只有操作系统可以使用特权指令，用户之间的程序可能会相互影响。</p>
</blockquote>
<p><strong>虚拟机</strong></p>
<blockquote>
<p>​        为了能在一台计算机上运行多个操作系统供多个用户使用，人们又发明了虚拟机的概念。</p>
<p>​        虚拟机是一台逻辑计算机，利用特殊的虚拟化技术，将计算机的物理特征抽象化，为用户提供一个抽象的、统一的、模拟的计算环境。虚拟化技术可以分为两类：</p>
<ul>
<li><p><strong>第一类虚拟化技术：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E7%AC%AC%E4%B8%80%E7%B1%BB%E8%99%9A%E6%8B%9F%E6%9C%BA.png" alt="第一类虚拟机"></p>
<p>​        第一类的<strong>虚拟机管理程序（VMM）</strong>类似于一个操作系统。它是唯一一个运行在最高特权级的程序（直接与硬件接触，代替了原来操作系统的位置）。在VMM的基础之上向上层提供若干台虚拟机。这些虚拟机是裸机硬件的复制品（拥有相应功能，但实际上不存在），因此可以在此基础之上运行不同的操作系统。</p>
<p>​        在第一类的虚拟机管理程序的作用下，所有的操作系统都是用户态的一个程序，不允许使用特权指令的。然而虚拟机上的操作系统认为自己运行在内核态中（伪），<strong>当这些操作系统需要用到特权指令时，VMM会将这些指令截获下来，判断是否合法，如果合法，那么将真正调用这些指令，然后将结果返回给相应的操作系统</strong>。</p>
<p>​        注意，第一类虚拟管理系统是直接作用在硬件上的，因此<strong>它为虚拟机赋予的如内存空间，存储空间都是未经抽象的物理资源</strong>。</p>
</blockquote>
</li>
<li><p><strong>第二类虚拟化技术：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E7%AC%AC%E4%BA%8C%E7%B1%BB%E8%99%9A%E6%8B%9F%E6%9C%BA.png" alt="第二类虚拟机"></p>
<p>​        第二类<strong>虚拟机管理程序（VMM）</strong>则与第一类完全不同，它是在原来操作系统的基础上增加了一个VMM，然后再在VMM上添加需要的操作系统。</p>
<p>​        因此，VMM就运行在了用户态上，而且所需要的资源是要经过宿主操作系统来分配的，因此<strong>此类虚拟机的内存空间，存储空间都是经过抽象的资源（逻辑上连续，物理上不一定连续）</strong>。而且此VMM实际上就一个应用程序，是和宿主操作系统上的进程有着相同地位的。</p>
<p>​        注意：在第二类虚拟机管理程序中，VMM的驱动程序是运行在核心态上的。</p>
</blockquote>
</li>
</ul>
<p><strong>两者的区别：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E4%B8%A4%E7%B1%BB%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AE%A1%E7%90%86%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AF%B9%E6%AF%94.png" alt="两类虚拟机管理程序的对比"></p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="七、其他补充"><a href="#七、其他补充" class="headerlink" title="七、其他补充"></a>七、其他补充</h2><blockquote>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>基础学科</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络体系结构</title>
    <url>/2022/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h2><blockquote>
<p><strong>定义：</strong>一般认为，<strong>计算机网络</strong>是一个将<strong>分散的</strong>、具有<strong>独立</strong>功能的<strong>计算机系统</strong>，通过<strong>通信设备</strong>与<strong>线路</strong>连接起来，由功能完善的<strong>软件</strong>实现<strong>资源共享</strong>和<strong>信息传递</strong>。</p>
<p>也可以理解为：由<strong>自治</strong>的计算机<strong>互联</strong>起来的集合体。</p>
</blockquote>
<h3 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h3><blockquote>
<p>从不同角度，计算机网络可以进行不同的分类：</p>
<ul>
<li><p><strong>从组成上看</strong>：</p>
<blockquote>
<ul>
<li><strong>软件：</strong>如，网络操作系统、邮件收发程序、ftp程序等</li>
<li><strong>硬件：</strong>如，主机、通信链路（双绞线之类的）、交换设备等</li>
<li><strong>协议：</strong>计算机通信的规则</li>
</ul>
</blockquote>
</li>
<li><p><strong>从工作方式上看：</strong></p>
<blockquote>
<ul>
<li><strong>边缘部分：</strong>指<strong>连接到网络上的所有主机</strong>或<strong>其他终端设备</strong>所组成的部分。</li>
<li><strong>核心部分：</strong> <strong>所有的网络</strong>以及网络上的<strong>交换设备</strong>所组成的部分。</li>
</ul>
</blockquote>
</li>
<li><p><strong>从功能上组成看：</strong></p>
<blockquote>
<ul>
<li><strong>通信子网：</strong>该子网具有数据传输、交换、控制和存储的能力，实现<strong>互联网计算机之间的数据通信</strong>，由<strong>各种传输介质、通信设备</strong>和<strong>相应的网络协议</strong>组成（一般涵括OSI模型中的<strong>物理层、数据链路层、网络层</strong>）。</li>
<li><strong>资源子网：</strong>该子网向网络用户提供共享其他计算机上的<strong>硬件资源、软件资源和数据资源（统称计算机网络资源）</strong>的服务。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h3><blockquote>
<p>计算机网络主要有以下五个功能：</p>
<ul>
<li><p><strong>数据通信：（最基本）</strong></p>
<blockquote>
<p>实现计算机网络上不同主机之间的数据传输。将分散在不同地理位置的计算机连接起来。</p>
<p>且<strong>属于最基本的功能</strong>，<strong>其他功能都需要建立在数据通信之上</strong>。</p>
</blockquote>
</li>
<li><p><strong>资源共享：</strong></p>
<blockquote>
<p>资源共享可以是<strong>软件共享、硬件共享、数据共享</strong>。它使计算机网络中的资源互通、分工合作，极大提高硬件、软件、数据资源的利用率。</p>
</blockquote>
</li>
<li><p>分布式处理：</p>
<blockquote>
<p>将某个复杂任务分配给网络中的其他计算机系统，从而利用空闲计算机资源来提高整个系统的利用率。</p>
</blockquote>
</li>
<li><p>提高可靠性</p>
<blockquote>
<p>计算机网络中的每台计算机可以通过网络互为替代。</p>
</blockquote>
</li>
<li><p>负载均衡</p>
<blockquote>
<p>将工作任务均衡地分配给计算机网络中的各台主机。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h3><blockquote>
<p>计算机网络根据不同的分类标准可以分成不同的类型：</p>
<ul>
<li><p><strong>分布范围：</strong></p>
<blockquote>
<ul>
<li><strong>广域网（WAN）：</strong>广域网的任务是提供长距离通信，运输主机发送的数据，一般的覆盖范围是<strong>直径几十千米到几百万米</strong>的区域（一般可以跨省，跨国），连接广域网之间各节点交换机的链路一般都是具有较大通信容量的高速链路（如光纤）。</li>
<li>城域网（MAN）：覆盖范围是5~50km，一般横跨几个市。城域网多使用<strong>以太网</strong>的技术，因此城域网一般并入局域网来讨论。</li>
<li><strong>局域网（LAN）：</strong>覆盖范围小，一般<strong>几十米到几千米</strong>。传统上，广域网使用交换技术，局域网使用广播技术。</li>
<li>个人区域网（PAN）：覆盖范围<strong>10米</strong>，一般指在个人工作范围内用无线技术将各个设备连接起来（如手机热点）。</li>
</ul>
</blockquote>
</li>
<li><p><strong>传输技术：</strong></p>
<blockquote>
<ul>
<li><strong>广播式网络：</strong>所有计算机共享一个公共的通信通道。当一台主机利用共享信道发送报文时，所有主机都可以监听到这个报文，但会根据目的地址来决定是否接收该报文。</li>
<li><strong>点对点式网络：</strong>每一条物理线路连接<strong>一对</strong>主机。如果没有物理线路，那么需要使用存储转发等技术来建立一条逻辑线路。</li>
</ul>
</blockquote>
</li>
<li><p><strong>拓扑结构：</strong></p>
<blockquote>
<ul>
<li><strong>总线型网络：</strong>所有主机都连接在一条共享信道上的网络。</li>
<li><strong>星型网络：</strong>每个主机都连接到中央交换机上的网络。</li>
<li><strong>环型网络：</strong>每台主机<strong>至少</strong>与其他两台主机进行连接，最终构成一个环状结构的网络，典型例子是令牌局域网。</li>
<li><strong>网状网络：</strong>每台主机相互连接，形成一张网状结构的网络。</li>
</ul>
</blockquote>
</li>
<li><p><strong>使用者：</strong></p>
<blockquote>
<ul>
<li><strong>公用网络：</strong>指电信公司建立的大型网络，也称为公众网。</li>
<li><strong>专用网络：</strong>指某个部门为了满足本单位而设置的专用网络。</li>
</ul>
</blockquote>
</li>
<li><p><strong>交换技术：</strong></p>
<blockquote>
<ul>
<li><strong>电路交换：</strong>指源结点与目的结点建立一条专用的通道的网络。</li>
<li><strong>报文交换：</strong>用户数据报加上源地址、目的地址、校验码等信息后，通过路由器等设备进行转发存储来到达目的主机，报文交换网络也称为<strong>存储-转发网络</strong>。</li>
<li><strong>分组交换：</strong>也称<strong>包交换网络</strong>。与报文交换类似，区别在于分组交换将数据报分割成更小的一个个分组。</li>
</ul>
</blockquote>
</li>
<li><p><strong>传输介质：</strong></p>
<blockquote>
<ul>
<li><strong>有线网络：</strong>网络的物理连接介质是导线的网络。</li>
<li><strong>无线网络：</strong>网络的物理传输介质是无线电波等的网络。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2><blockquote>
<p>性能指标从不同方面计量计算机网络的性能。</p>
<ul>
<li><p><strong>流量类：</strong></p>
<blockquote>
<ul>
<li><strong>带宽：</strong>本来用于表示线路允许通过的信号频带范围，单位是赫兹。在计算机网络中，带宽用来表示<strong>网络的通信线路</strong>所能传输的<strong>最大数据量</strong>，即<strong>最高数据传输速率</strong>，单位是<strong>比特&#x2F;秒（b&#x2F;s）</strong>。</li>
<li><strong>吞吐量：</strong>指<strong>单位时间内通过某个网络（或通道、接口）的数据量</strong>，受网络带宽或网络额定速率的限制，单位是<strong>比特</strong>。</li>
<li><strong>速率：</strong>网络中的速率是指连接到计算机网络上的主机在数字信道上<strong>传送数据的速率</strong>。也称为<strong>数据传输速率、数据率</strong>或<strong>比特率</strong>，单位是<strong>比特&#x2F;秒（b&#x2F;s，有时也用bps）</strong>。速率较高的时候，可以写作<strong>kb&#x2F;s</strong>（$10^3$b&#x2F;s，<strong>注意和内存中的KB作区别</strong>）</li>
</ul>
</blockquote>
</li>
<li><p><strong>时间类：</strong></p>
<blockquote>
<ul>
<li><p><strong>时延：</strong>指数据从<strong>网络的一端传送到另一端</strong>所需要的<strong>总时间</strong>，它由4个部分组成：<strong>发送时延、传播时延、处理时延</strong>和<strong>排队时延</strong>。一般计算公式如下：<br>$$<br>总时延&#x3D;发送时延+传播时延+处理时延+排队时延<br>$$</p>
<blockquote>
<ul>
<li><p><strong>发送时延：</strong>从发送分组的第一个比特开始，到该分组的最后一个比特发送完毕所需的时间，也称<strong>传输时延</strong>，计算公式：<br>$$<br>发送时延&#x3D;分组长度&#x2F;发送速率(信道宽度)<br>$$</p>
</li>
<li><p><strong>传播时延：</strong>电磁波在信道中传播一定距离所需的时间，即一个比特从一端传输到另一端的时间：<br>$$<br>传播时延&#x3D;信道长度&#x2F;信号在信道中的传输速率(一般固定)<br>$$</p>
</li>
<li><p><strong>处理时延：</strong>数据在交换结点为存储转发而进行的一些必要处理所花费的时间。</p>
</li>
<li><p><strong>排队时延：</strong>分组在进入路由器后要先在输入队列中等待处理，路由器确定转发端口后，还需再输入队列中等待转发时所需的时间。</p>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>时延带宽积：</strong>指发送端发送的<strong>第一个比特即将到达终点时，发送端已经发送的比特数</strong>。即$时延带宽积&#x3D;传播时延 \times 数据传播速率$（<strong>单位是比特</strong>）</p>
</li>
<li><p><strong>往返时延（RTT）：</strong>指从发送端发送数据开始，到发送端接收到接收端发回（接收端在接收到数据后立即发送确认）的确认所经历的时间。</p>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>百分比类：</strong></p>
<blockquote>
<ul>
<li><strong>信道利用率：</strong>指某一信道有百分之几的时间是有数据通过的，即$信道利用率&#x3D;有数据通过时间&#x2F;(有&#x2F;无)数据通过时间$。</li>
<li><strong>网络利用率：</strong>信道利用率的加权平均。</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>注意：</strong>传输与传播是有区别的，传输是发生在发送端上的，而传播是发生在链路上的。</p>
</blockquote>
<h2 id="计算机体系结构与参考模型"><a href="#计算机体系结构与参考模型" class="headerlink" title="计算机体系结构与参考模型"></a>计算机体系结构与参考模型</h2><h3 id="计算机网络分层结构"><a href="#计算机网络分层结构" class="headerlink" title="计算机网络分层结构"></a>计算机网络分层结构</h3><blockquote>
<p><strong>体系结构：</strong>计算机网络的各层及其协议的集合。</p>
<p><strong>计算机网络的分层原则：</strong></p>
<blockquote>
<ul>
<li>每一层都实现一种相对独立的功能，降低系统的复杂度。</li>
<li>各层之间的界限清晰，同时要易于理解，相互交流要少。</li>
<li>各层功能的精确定义独立于具体的实现方法。</li>
<li>保持上层对下层的独立性，上层单向使用下层提供过的服务。</li>
<li>整个分层应促进标准化工作。</li>
</ul>
</blockquote>
<p><strong>层次结构的含义：</strong></p>
<blockquote>
<ul>
<li>第n层的实体不仅要使用第n-1层的服务来实现自身定义的功能，还要向n+1层提供相应服务，所以<strong>该提供的服务是第n层及其下面各层提供的服务总和</strong>。</li>
<li>最低层只提供服务，是整个层次结构的基础；中间各层既是下一层服务的使用者，又是上一层服务的提供者；最高层面向用户提供服务。</li>
<li>上一层只能通过相邻间的接口使用下一层的服务，<strong>不能跨层调用其他层的服务</strong>；下层对提供服务的细节对于上层来说都是<strong>透明的</strong>。</li>
<li>两台主机在通信的过程中，对等层有一条逻辑上的直接通路。</li>
</ul>
</blockquote>
</blockquote>
<h3 id="计算机网络协议、接口、服务和服务访问点的概念"><a href="#计算机网络协议、接口、服务和服务访问点的概念" class="headerlink" title="计算机网络协议、接口、服务和服务访问点的概念"></a>计算机网络协议、接口、服务和服务访问点的概念</h3><blockquote>
<p><strong>协议：</strong></p>
<blockquote>
<p>协议就是规则的集合；协议规定了主机间在计算机网络中通信时的操作。</p>
<p>协议由<strong>语法、语义</strong>和<strong>同步</strong>三部分组成。</p>
<blockquote>
<ul>
<li><strong>语法规定了传输数据的格式</strong>。</li>
<li><strong>语义规定了所要完成的功能</strong>，即需要发出何种控制信息、完成何种动作等等。</li>
<li><strong>同步规定了执行各类操作的条件、时序关系等</strong>。</li>
</ul>
</blockquote>
<p><strong>特点：</strong>必须把<strong>所有</strong>不利条件事先都估计到，<strong>不能假定一切都是正常和理想的</strong>。</p>
</blockquote>
<p><strong>接口：</strong></p>
<blockquote>
<p>指上层使用下层提供的服务时的接口。</p>
<p>每层只有在<strong>相邻的层次</strong>之间定义接口。</p>
</blockquote>
<p><strong>服务：</strong></p>
<blockquote>
<p>服务是指下层为紧邻的上层提供的功能调用，它是<strong>垂直的</strong></p>
<p>计算机网络中服务可以分为三类：</p>
<blockquote>
<ul>
<li><strong>面向连接服务</strong>和<strong>无连接服务</strong></li>
<li><strong>可靠服务</strong>和<strong>不可靠服务</strong></li>
<li><strong>有应答服务</strong>和<strong>无应答服务</strong></li>
</ul>
</blockquote>
</blockquote>
<p><strong>服务访问点（SAP）：</strong>同一系统中相邻两层的实体相互交互的地方。如物理层的服务访问点为网卡接口。</p>
</blockquote>
<h3 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h3><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BB%AA%E8%AE%BA/OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.png" alt="OSI参考模型通信过程"></p>
<p>OSI参考模型由上往下可以分为：应用层、表示层、会话层、传输层、网络层、数据链路层以及物理层。</p>
<blockquote>
<ul>
<li><strong>应用层：</strong>OSI参考模型的最高层，是用户接触网络的层级，主要为用户提供各种网络服务。</li>
<li><strong>表示层：</strong>表示层可以使得<strong>不同编码</strong>和<strong>表示方法不同</strong>的两台主机之间可以进行数据与信息的交换。同时表示层还拥有<strong>数据压缩、数据加密</strong>和<strong>解密</strong>等功能。</li>
<li><strong>会话层：</strong>会话层为两个不同主机之间的通信提供服务，主要负责<strong>建立、管理</strong>或<strong>终止进程间的会话</strong>。同时会话层还会使用校验点使中途断开的会话得以<strong>重连，恢复通信</strong>。</li>
<li><strong>传输层：</strong>传输单元为<strong>报文段</strong>或<strong>用户数据报</strong>（取决与服务是否可靠），传输层负责主机中两个<strong>进程之间的通信</strong>，为两端系统的连接提供<strong>流量控制、差错控制、数据的传输管理</strong>等服务。</li>
<li><strong>网络层：</strong>传输单元为<strong>数据报</strong>，主要目的是将数据报从源地址传送到目的地址。主要对数据进行<strong>路由选择、实现流量控制、拥塞控制、差错控制</strong>等。</li>
<li><strong>数据链路层：</strong>传输单位是<strong>数据帧</strong>，任务是将网络层传来的IP数据报封装成帧。作用可以概括为：<strong>成帧、差错控制、流量控制</strong>和<strong>传输管理</strong></li>
<li><strong>物理层：</strong>传输单位为<strong>比特流</strong>，任务是透明的传输比特流。</li>
</ul>
</blockquote>
</blockquote>
<h3 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP&#x2F;IP模型"></a>TCP&#x2F;IP模型</h3><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E5%9B%BE/%E7%BB%AA%E8%AE%BA/TCP_IP%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.png" alt="TCP_IP参考模型"><br><strong>注意：</strong>TCP&#x2F;IP协议栈后面会在网络层中细讲。</p>
<p>TCP&#x2F;IP模型一共只有4层：</p>
<blockquote>
<ul>
<li><strong>应用层：</strong>（用户-用户）提供各种高层协议。</li>
<li><strong>传输层：</strong>（进程-进程）功能与OSI中的<strong>传输层</strong>相似，使得发送端和接收端上对等实体进行会话。同时也主要包括<strong>TCP</strong>与<strong>UDP</strong>两个协议。</li>
<li><strong>网际层：</strong>（主机-主机）与OSI的<strong>网络层</strong>功能类似，网际层会为数据分组<strong>选择合适的路由</strong>。</li>
<li><strong>网络接口层：</strong>类似于OSI参考模型的<strong>物理层</strong>和<strong>数据链路层</strong>，他表示与物理网络的接口。</li>
</ul>
</blockquote>
</blockquote>
<h3 id="TCP-IP模型与OSI模型的区别"><a href="#TCP-IP模型与OSI模型的区别" class="headerlink" title="TCP&#x2F;IP模型与OSI模型的区别"></a>TCP&#x2F;IP模型与OSI模型的区别</h3><blockquote>
<ul>
<li><strong>OSI模型</strong>中精确定义了<strong>服务、协议</strong>和<strong>接口</strong>这三个概念，而<strong>TCP&#x2F;IP模型</strong>中并没准确定义。</li>
<li><strong>OSI模型</strong>产生与协议之前，所以相较于<strong>TCP&#x2F;IP模型</strong>通用性更好，但在设计协议方面不如TCP&#x2F;IP模型。</li>
<li><strong>TCP&#x2F;IP模型</strong>在设计时考虑了许多异构网络的互联问题，因此特意划分出了网际层。</li>
<li><strong>OSI模型</strong>在<strong>网络层支持无连接和面向连接的通信</strong>，在<strong>传输层</strong>仅<strong>有面向连接</strong>的通信。<strong>TCP&#x2F;IP模型</strong>在<strong>网际层</strong>仅提供<strong>无连接通信</strong>，在<strong>传输层</strong>提供<strong>无连接</strong>和<strong>面向连接</strong>两种通信方法。<strong>（重点，经常考查）</strong></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>基础学科</tag>
      </tags>
  </entry>
  <entry>
    <title>输入输出管理</title>
    <url>/2022/08/12/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="一、I-O管理概述"><a href="#一、I-O管理概述" class="headerlink" title="一、I&#x2F;O管理概述"></a>一、I&#x2F;O管理概述</h2><h3 id="1、I-O设备"><a href="#1、I-O设备" class="headerlink" title="1、I&#x2F;O设备"></a>1、I&#x2F;O设备</h3><blockquote>
<p>根据使用特性可以分为以下几类：</p>
<ul>
<li><strong>人机交互类外部设备</strong>：用于计算机与用户之间交互的设备。如打印机、显示器、鼠标等</li>
<li><strong>存储设备：</strong>用于存储程序和数据的设备</li>
<li><strong>网络通信设备：</strong>用于与远程设备通信的设备。</li>
</ul>
<p><strong>按传输速率分类：</strong></p>
<ul>
<li><strong>低速设备</strong>（传输速率仅为每秒几字节到百字节的设备，如键盘、鼠标等）</li>
<li><strong>中速设备</strong>（传输速率为每秒数千字节至数万字节的设备，如打印机等）</li>
<li><strong>高速设备</strong>（传输速率在百千字节到千兆字节的一类设备，如磁盘、磁带等）</li>
</ul>
<p><strong>按信息交换的单位分类：</strong></p>
<ul>
<li><strong>块设备</strong>：信息的存取是以<strong>数据块</strong>作为单位的设备</li>
<li><strong>字符设备</strong>：信息的存取是以<strong>字符</strong>作为单位的设备</li>
</ul>
</blockquote>
<h3 id="2、I-O控制方式"><a href="#2、I-O控制方式" class="headerlink" title="2、I&#x2F;O控制方式"></a>2、I&#x2F;O控制方式</h3><blockquote>
<ul>
<li><p><strong>IO控制器</strong></p>
<blockquote>
<p>替CPU管理IO设备的一个中介部件。</p>
<p><strong>主要功能：</strong></p>
<blockquote>
<ul>
<li>接受和识别CPU发出的命令（控制寄存器）</li>
<li>向CPU报告设备的状态（状态寄存器）</li>
<li>进行数据交换（数据寄存器）</li>
<li>地址识别（由I&#x2F;O逻辑实现）</li>
</ul>
</blockquote>
<p><strong>组成：</strong></p>
<blockquote>
<ul>
<li>CPU与控制器之间的接口（实现控制器与CPU之间的通信）</li>
<li>I&#x2F;O逻辑（负责识别CPU发出的命令，并向设备发出命令）</li>
<li>控制器与设备之间的接口（实现控制器与设备之间的通信）</li>
</ul>
</blockquote>
<p><strong>两种寄存器编址方式：</strong></p>
<blockquote>
<ul>
<li><p><strong>内存映射I&#x2F;O</strong></p>
<blockquote>
<ul>
<li>控制器中的寄存器与内存同一编址</li>
<li>可以采用对内存进行操作的指令来对控制器进行操作</li>
</ul>
</blockquote>
</li>
<li><p><strong>寄存器独立编址</strong></p>
<blockquote>
<ul>
<li>控制器中的寄存器独立编址</li>
<li>需要设置专门的指令来操作控制器</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>I&#x2F;O控制方式</strong></p>
<blockquote>
<ul>
<li><p><strong>程序直接控制方式</strong></p>
<blockquote>
<img src="/picture/学习/操作系统上的图/输入输出管理/程序直接控制方式.png" alt="程序直接控制方式" style="zoom:60%;" />

<p><strong>完成一次读&#x2F;写操作的流程</strong></p>
<blockquote>
<ul>
<li>CPU向控制器发出读指令，设备启动并将状态寄存器设为1（未就绪）</li>
<li>CPU<strong>轮询</strong>检查控制器的状态（检查状态寄存器是否为0）</li>
<li>输入设备准备号数据后将数据传给控制器</li>
<li>控制器将输入的数据放到数据寄存器中，并将状态寄存器改为0</li>
<li>CPU将数据读入CPU的寄存器中，再将CPU寄存器中的内容放入内存</li>
</ul>
</blockquote>
<p><strong>CPU干预的频率</strong></p>
<blockquote>
<p>很频繁，I&#x2F;O操作开始之前、完成之后都需要CPU的介入，而且<strong>在等待完成的过程中CPU需要不停地轮询检查</strong></p>
</blockquote>
<p><strong>数据传送的单位：</strong>以字为单位</p>
<p><strong>数据流向：</strong></p>
<blockquote>
<p>读操作：I&#x2F;O设备$\to$CPU$\to$内存</p>
<p>写操作：内存$\to$CPU$\to$I&#x2F;O设备</p>
</blockquote>
<p><strong>优缺点：</strong></p>
<blockquote>
<p><strong>优点：</strong>实现简单</p>
<p><strong>缺点：</strong>CPU与I&#x2F;O设备只能串行工作，CPU需要一致轮询检查，长期处于“忙等”状态，CPU利用率低</p>
</blockquote>
</blockquote>
</li>
<li><p><strong>中断控制方式</strong></p>
<blockquote>
<img src="/picture/学习/操作系统上的图/输入输出管理/中断方式.png" alt="中断方式" style="zoom:60%;" />

<p><strong>完成一次读&#x2F;写操作的流程</strong></p>
<blockquote>
<ul>
<li>CPU向控制器发出命令后，CPU就去处理其它任务</li>
<li>I&#x2F;O设备准备好以后，向CPU发送一个中断请求</li>
<li>CPU收到中断请求后，将I&#x2F;O设备中的数据放到寄存器内</li>
<li>再将CPU寄存器中的内容放入内存</li>
</ul>
</blockquote>
<p><strong>CPU干预的频率</strong></p>
<blockquote>
<p>每次I&#x2F;O操作开始之前、完成之后都需要CPU的接入。</p>
<p>等待I&#x2F;O完成的过程中，CPU可以切换到别的进程执行</p>
</blockquote>
<p><strong>数据传送的单位</strong>：以字为单位</p>
<p><strong>数据流向：</strong></p>
<blockquote>
<p>读操作：I&#x2F;O设备$\to$CPU$\to$内存</p>
<p>写操作：内存$\to$CPU$\to$I&#x2F;O设备</p>
</blockquote>
<p><strong>优缺点：</strong></p>
<blockquote>
<p><strong>优点：</strong>与程序直接控制方式相比，I&#x2F;O控制器会通过中断机制来向CPU报告，而无需CPU不停地轮询。</p>
<p><strong>缺点：</strong>每个字在I&#x2F;O设备与内存之间的传输都需要经过CPU，而频繁的中断处理会消耗较多的CPU时间</p>
</blockquote>
</blockquote>
</li>
<li><p><strong>DMA方式</strong></p>
<blockquote>
<p><strong>DMA控制器</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86/DMA%E6%8E%A7%E5%88%B6%E5%99%A8.png" alt="DMA控制器"></p>
<ul>
<li><strong>数据寄存器（DR）：</strong>暂存从设备到内存或从内存到设备的数据</li>
<li><strong>内存地址寄存器（MAR）：</strong>用于表示数据应放到的哪块内存的地址</li>
<li><strong>数据计数器（DC）：</strong>表示剩余要读&#x2F;写的字节数</li>
<li><strong>命令&#x2F;状态寄存器（CR）：</strong>用于存放CPU发来的I&#x2F;O命令，或存放设备的状态信息</li>
</ul>
<p>注意：上面的寄存器可以有多个</p>
</blockquote>
<p><strong>完成一次读&#x2F;写操作的流程</strong></p>
<blockquote>
<ul>
<li>CPU给I&#x2F;O模块发出读写命令，之后CPU就可以去处理其它进程的请求</li>
<li>DMA接收到CPU的命令之后，将数据<strong>一个字一个字地</strong>写入DR中，等到够了一块，再写入磁盘（或内存中）</li>
<li>当DMA处理完命令后，向CPU发送一个中断请求，告诉CPU数据传输已经完成</li>
</ul>
</blockquote>
<p><strong>CPU干预的频率</strong></p>
<blockquote>
<p>仅在传送一个或多个数据块的开始和结束时，才需要CPU干预</p>
</blockquote>
<p><strong>数据传送单位</strong></p>
<blockquote>
<p>以<strong>一个或多个块</strong>为单位（以多个块为单位时，只能<strong>以连续的多个块为单位</strong>，而且这些读入内存后再内存中页必须是连续的）</p>
</blockquote>
<p><strong>数据流向：</strong></p>
<blockquote>
<p>读操作：I&#x2F;O设备$\to$内存</p>
<p>写操作：内存$\to$I&#x2F;O设备</p>
</blockquote>
<p><strong>优缺点：</strong></p>
<blockquote>
<p><strong>优点：</strong>传输以块为单位；CPU的介入频率进一步降低；CPU与I&#x2F;O设备的并行性进一步提升</p>
<p><strong>缺点：</strong>CPU每次发出一条I&#x2F;O指令，只能读写一个或多个连续的数据块</p>
</blockquote>
</blockquote>
</li>
<li><p><strong>通道控制方式</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86/%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F.png" alt="通道控制方式"></p>
<p><strong>完成一次读&#x2F;写操作的流程</strong></p>
<blockquote>
<ul>
<li>CPU向通道发出I&#x2F;O指令，指明通道程序再内存中的位置，并指明要操作的是哪个I&#x2F;O设备，然后CPU就可以去完成其它进程的请求了</li>
<li>通道控制器执行内存中的通道程序，按照CPU的要求将数据读写到相应的位置</li>
<li>通道执行完规定任务后，向CPU发送中断信号</li>
</ul>
</blockquote>
<p><strong>CPU干预的频率</strong>：极低，只有完成一组数据块的读写后才需要CPU处理</p>
<p><strong>数据传送的单位：</strong>以<strong>一组数据块</strong>为单位</p>
<p><strong>数据流向：</strong></p>
<blockquote>
<p>读操作：I&#x2F;O设备$\to$内存</p>
<p>写操作：内存$\to$I&#x2F;O设备</p>
</blockquote>
<p><strong>优缺点：</strong></p>
<blockquote>
<p><strong>优点：</strong>CPU、通道、I&#x2F;O设备可以并行工作，资源利用率高</p>
<p><strong>缺点：</strong>实现复杂，需要专门的通道硬件支持</p>
</blockquote>
<p><strong>注意：</strong>通道与CPU共享内存</p>
</blockquote>
</li>
</ul>
<p><strong>四种控制方式的比较：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F.png" alt="输入输出设备的控制方式"></p>
</blockquote>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="3、I-O子系统的层次结构"><a href="#3、I-O子系统的层次结构" class="headerlink" title="3、I&#x2F;O子系统的层次结构"></a>3、I&#x2F;O子系统的层次结构</h3><blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86/IO%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="IO子系统的层次结构"></p>
<ul>
<li><p><strong>用户层软件</strong>：实现与用户交互的接口，即用户可以直接调用由用户层提供的库函数接口</p>
</li>
<li><p><strong>设备独立性软件：</strong></p>
<blockquote>
<p>设备独立性软件这一层主要负责想用户层提供系统调用，所以又称<strong>系统调用处理层</strong>。</p>
<p>设备独立性又称为<strong>设备无关性</strong>，其主要功能如下：</p>
<ul>
<li><p>向上层提供统一的调用接口</p>
</li>
<li><p>设备保护（类似于文件的保护，即控制对设备的访问控制）</p>
</li>
<li><p>差错处理</p>
</li>
<li><p>设备的分配与回收</p>
</li>
<li><p>数据缓冲区管理</p>
</li>
<li><p>建立逻辑设备名到物理设备名的映射关系（建立了一种逻辑设备表）；根据设备类型选择调用的驱动程序</p>
<blockquote>
<p><strong>逻辑设备表：</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86/%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E8%A1%A8.png" alt="逻辑设备表"></p>
<p>操作系统可以根据管理方式的不同，分为两类：</p>
<ul>
<li>整个系统只设置一张逻辑设备表（LUT），这样就不能出现相同的逻辑设备名了</li>
<li>为每个用户设置一张逻辑设备表，每个用户使用的逻辑设备名可以重复</li>
</ul>
<p>上述的两种方案类似于单级目录和两级目录</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>设备驱动程序：</strong>与硬件直接相关，由硬件厂商给出的程序，其主要作用是<strong>实现系统对设备发出的操作指令，驱动I&#x2F;O设备工作</strong>。</p>
</li>
<li><p><strong>中断处理程序：</strong>用于保护被中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完后恢复被中断程序的现场后，返回到被中断进程</p>
</li>
</ul>
</blockquote>
<h3 id="4、输入-输出管理"><a href="#4、输入-输出管理" class="headerlink" title="4、输入&#x2F;输出管理"></a>4、输入&#x2F;输出管理</h3><blockquote>
<ul>
<li><p><strong>输入&#x2F;输出应用程序接口</strong></p>
<blockquote>
<p>为了解决用户层统一调用不同的外设，在用户层软件和设备独立软件之间添加了一些设备接口来解决该问题：</p>
<img src="/picture/学习/操作系统上的图/输入输出管理/输入输出应用程序接口.png" alt="输入输出应用程序接口" style="zoom:60%;" />

<ul>
<li><p><strong>字符设备接口</strong>：get&#x2F;put系统调用：向字符设备（这种设备不可寻址，且每次只读1个字符）读&#x2F;写一个字符</p>
</li>
<li><p><strong>块设备接口：</strong>read&#x2F;write系统调用：向块设备读写指针的位置读&#x2F;写多个字符；seek系统调用：修改读写指针的位置</p>
</li>
<li><p><strong>网络设备接口：</strong>又称<strong>网络套接字（socket）接口</strong></p>
<blockquote>
<p><strong>socket系统调用</strong>：创建一个网络套接字（详情参考计算机网络中的套接字），需要指明使用的网络协议（TCP或UDP）；</p>
<p><strong>bind系统调用</strong>：将套接字绑定到某个本地端口；</p>
<p><strong>connect系统调用</strong>：将套接字连接到远程地址；</p>
<p><strong>read&#x2F;write系统调用</strong>：从套接字读&#x2F;写数据</p>
</blockquote>
</li>
</ul>
<p><strong>补充：</strong></p>
<blockquote>
<ul>
<li><strong>阻塞I&#x2F;O</strong>：应用程序发出I&#x2F;O系统调用，<strong>进程需要转为阻塞态等待</strong>。如字符设备接口——从键盘读一个字符</li>
<li><strong>非阻塞I&#x2F;O</strong>：应用程序发出I&#x2F;O系统调用，系统调用可迅速返回，<strong>进程无需阻塞等待</strong>。块设备接口——往磁盘写数据</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>设备驱动程序接口</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86/%E7%BB%9F%E4%B8%80%E6%A0%87%E5%87%86%E7%9A%84%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3.png" alt="统一标准的设备驱动程序接口"></p>
<p>由于不同的设备生产公司所生产的设备不一样，因此它们对应的驱动程序也不一样。</p>
<p>因此，操作系统会做一个统一标准，要求所有设备的驱动程序都以这个标准为框架地开发驱动程序。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="二、I-O核心子系统"><a href="#二、I-O核心子系统" class="headerlink" title="二、I&#x2F;O核心子系统"></a>二、I&#x2F;O核心子系统</h2><h3 id="1、I-O子系统概述"><a href="#1、I-O子系统概述" class="headerlink" title="1、I&#x2F;O子系统概述"></a>1、I&#x2F;O子系统概述</h3><blockquote>
<p><strong>I&#x2F;O子系统：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86/IO%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F.png" alt="IO核心系统"></p>
</blockquote>
<p><strong>需要实现的技术</strong></p>
<blockquote>
<ul>
<li><strong>I&#x2F;O调度</strong></li>
<li><strong>设备保护</strong></li>
<li><strong>假脱机技术（SPOOLing技术）</strong></li>
<li><strong>设备分配与回收</strong></li>
<li><strong>缓冲区管理</strong></li>
</ul>
</blockquote>
<p><strong>I&#x2F;O调度：</strong>用某种算法确定一个好的顺序来处理各个I&#x2F;O请求</p>
<blockquote>
<p>如：磁盘调度（先来先服务、最短寻道优先算法、SCAN算法等）</p>
<p>同理也有打印机等设备的先来先服务算法、优先级算法、短作业优先算法等</p>
</blockquote>
<p><strong>设备保护：</strong>不同用于对各个设备有不同的访问权限。</p>
</blockquote>
<h3 id="2、假脱机技术（SPOOLing技术）"><a href="#2、假脱机技术（SPOOLing技术）" class="headerlink" title="2、假脱机技术（SPOOLing技术）"></a>2、假脱机技术（SPOOLing技术）</h3><blockquote>
<p><strong>脱机技术：</strong>即脱离主机的控制进行的输入&#x2F;输出操作，如</p>
<blockquote>
<p>在批处理阶段引入的脱机输入输出技术，即通过外围控制机来进行系统的输入输出，从而较少CPU的等待时间，提高效率。</p>
</blockquote>
<p><strong>假脱机技术：</strong>又称<strong>SPOOLing技术</strong>是用软件方式模拟脱机技术</p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86/%E5%81%87%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AF.png" alt="假脱机技术"></p>
<ul>
<li><strong>输入&#x2F;输出进程：</strong>相当于模拟脱机输入&#x2F;输出时的外围控制机</li>
<li><strong>缓冲区：</strong>用于暂存输入&#x2F;输出的数据</li>
</ul>
</blockquote>
<p><strong>假脱机技术的例子：</strong>共享打印机</p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86/%E5%85%B1%E4%BA%AB%E6%89%93%E5%8D%B0%E6%9C%BA.png" alt="共享打印机"></p>
<p>​        当多个用户进程提出输出打印的请求时，系统会答应它们的请求，但不会真正的把打印机分配给它们，而是由假脱机管理进程为每个进程左两件事：</p>
<ul>
<li>在磁盘输出井中为进程申请一个空闲缓冲区，并将要打印的数据送入其中</li>
<li>为用户进程申请一张空白的打印申请表，并将用户的打印请求填入表中</li>
</ul>
<p>​        当打印机空闲时，输出进程会从文件队列中取出一张打印申请表，并根据要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机上进行打印。</p>
<p><strong>本质：</strong>通过将打印任务变成队列，让各个进程认为自己好像独占了一台打印机，实质上依旧是按顺序逐个打印。</p>
</blockquote>
</blockquote>
<h3 id="3、设备的分配和回收"><a href="#3、设备的分配和回收" class="headerlink" title="3、设备的分配和回收"></a>3、设备的分配和回收</h3><blockquote>
<ul>
<li><p><strong>设备分配时考虑的因素</strong></p>
<blockquote>
<ul>
<li><p><strong>设备的固有属性</strong></p>
<blockquote>
<ul>
<li><strong>独占设备：</strong>一个时段只能分配给一个进程</li>
<li><strong>共享设备：</strong>可同时分配给多个进程使用（各进程往往是宏观上同时共享，微观上交替使用）</li>
<li><strong>虚拟设备：</strong>采用SPOOLing技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用</li>
</ul>
</blockquote>
</li>
<li><p><strong>设备分配算法</strong>：如先来先服务算法、优先级算法、短任务优先算法等</p>
</li>
<li><p><strong>设备分配中的安全性</strong></p>
<blockquote>
<ul>
<li><p><strong>安全分配方式：</strong>即每当进程发出I&#x2F;O请求后便进入阻塞态，直到其I&#x2F;O操作完成时才被唤醒。</p>
<blockquote>
<p>即一个进程只占用一个设备，因此不会产生死锁问题；但对于该进程来说，CPU和设备是串行工作的，因此运行效率并不高。</p>
</blockquote>
</li>
<li><p><strong>不安全分配方式：</strong>进程再发出I&#x2F;O请求后继续运行，需要时又发出第二个等多个I&#x2F;O请求，直到所需的设备已被另一进程占用时，该进程才会进入阻塞状态。</p>
<blockquote>
<p>即进程可以一直申请未被占有的外设。这样可以提高进程的工作效率；但由于一个进程可以占用多个设备，因此很容易产生死锁问题。</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>静态分配与动态分配</strong></p>
<blockquote>
<ul>
<li><strong>静态分配：</strong>进程运行前为其分配全部所需要的资源，运行结束后归还</li>
<li><strong>动态分配：</strong>在进程运行过程中根据运行需要进行分配，一旦用完就归还</li>
</ul>
</blockquote>
</li>
<li><p><strong>设备分配管理中的数据结构</strong></p>
<blockquote>
<p><strong>”设备、控制器、通道“之间的关系：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86/%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8%E9%80%9A%E9%81%93%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="设备控制器通道之间的关系"></p>
<p>一个通道可控制多个设备控制器，每各设备控制器又可以控制多台设备</p>
</blockquote>
<ul>
<li><p><strong>设备控制表（DCT）</strong></p>
<blockquote>
<p>系统会为每个设备配置一张DCT，用于<strong>记录设备情况</strong></p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86/%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E8%A1%A8.png" alt="设备控制表"></p>
</blockquote>
</li>
<li><p><strong>控制器控制表（COCT）</strong></p>
<blockquote>
<p>每个设备控制器都会对应一张COCT，操作系统根据COCT的信息对控制器进行操作和管理</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86/%E6%8E%A7%E5%88%B6%E5%99%A8%E6%8E%A7%E5%88%B6%E8%A1%A8.png" alt="控制器控制表"></p>
</blockquote>
</li>
<li><p><strong>通道控制表（CHCT）</strong></p>
<blockquote>
<p>每个通道都会对应一张CHCT，操作系统根据CHCT的信息对通道进行操作和管理</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86/%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E8%A1%A8.png" alt="通道控制表"></p>
</blockquote>
</li>
<li><p><strong>系统设备表（SDT）</strong></p>
<blockquote>
<p>记录了<strong>系统中全部设备</strong>的情况，每个设备对应一个表目</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E5%A4%87%E8%A1%A8.png" alt="系统设备表"></p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>设备分配的步骤</strong></p>
<blockquote>
<ul>
<li>根据进程请求的<strong>物理设备名</strong>查找系统设备表（SDT）</li>
<li>根据SDT找到<strong>设备控制表</strong>（DCT），若设备忙碌则将进程PCB挂到<strong>设备等待队列</strong>中，不忙碌则将设备分配给进程</li>
<li>根据DCT找到<strong>控制器控制表</strong>（COCT），若控制器忙碌则将进程PCB挂到<strong>设备等待队列</strong>中，不忙碌则将控制器分配给进程</li>
<li>根据COCT找到<strong>通道控制表</strong>（CHCT），若通道忙碌则将进程PCB挂到<strong>设备等待队列</strong>中，不忙碌则将通道分配给进程</li>
</ul>
<p><strong>缺点</strong>：</p>
<blockquote>
<ul>
<li>用户编程时必须使用“物理设备名”，不方便编程</li>
<li>若换了一台物理设备，则程序无法运行</li>
<li>若进程请求的物理设备正在忙碌，则即使系统中还又同类型的设备，进程也会进入阻塞等待</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>设备分配步骤的改进方法</strong></p>
<blockquote>
<p>加入逻辑设备名和物理设备名之间的映射，使得用户编程时可直接使用逻辑设备名。</p>
<ul>
<li>根据进程请求的<strong>逻辑设备名</strong>查找系统设备表（SDT）</li>
<li>根据SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给该进程。操作系统在<strong>逻辑设备表</strong>（LUT）中新增一个表项</li>
<li>根据DCT找到<strong>控制器控制表</strong>（COCT），若控制器忙碌则将进程PCB挂到<strong>设备等待队列</strong>中，不忙碌则将控制器分配给进程</li>
<li>根据COCT找到<strong>通道控制表</strong>（CHCT），若通道忙碌则将进程PCB挂到<strong>设备等待队列</strong>中，不忙碌则将通道分配给进程</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="4、缓冲区管理"><a href="#4、缓冲区管理" class="headerlink" title="4、缓冲区管理"></a>4、缓冲区管理</h3><blockquote>
<ul>
<li><p><strong>缓冲区概念</strong></p>
<blockquote>
<p>​        缓冲区是一个存储区域，可以又专门的硬件寄存器组成，也可以利用内存作为缓冲区。而使用硬件作为缓冲区的成本较高，容量也小（参考Cache）。一般情况更多的是利用内存作为缓冲区。</p>
<p><strong>缓冲区的作用：</strong></p>
<blockquote>
<ul>
<li>缓和CPU与I&#x2F;O设备之间速度不匹配的矛盾</li>
<li>较少对CPU的中断频率，放宽CPU中断响应时间的限制</li>
<li>解决数据大小不匹配的问题（如外设输入时是以块为单位的，而CPU是以字符为单位的）</li>
<li>提高CPU与I&#x2F;O设备之间的并行性</li>
</ul>
</blockquote>
<p><strong>缓冲区的特点：</strong></p>
<blockquote>
<p>当缓冲区<strong>数据非空时</strong>，<strong>不能往缓冲区写入数据</strong>，只能从缓冲区把数据传出；当<strong>缓冲区为空</strong>时，<strong>可以往缓冲区写入数据</strong>，但必须把缓冲区<strong>写满</strong>以后，才能从缓冲区把数据传出。</p>
</blockquote>
</blockquote>
</li>
<li><p><strong>单缓冲区</strong></p>
<blockquote>
<p>单缓冲策略是指，操作系统会在内存中分配一个缓冲区。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86/%E5%8D%95%E7%BC%93%E5%86%B2%E5%8C%BA.png" alt="单缓冲区"></p>
<p>假设<strong>输入时间</strong>为T，<strong>传送时间</strong>为M，<strong>处理时间</strong>为C，</p>
<ul>
<li><p>当T&gt;C时，</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86/%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B41.png" alt="处理时间1"></p>
<p><strong>处理时间为：T+M</strong></p>
</li>
<li><p>当T&lt;C时，</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86/%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B42.png" alt="处理时间2"></p>
<p><strong>处理时间为：C+M</strong></p>
</li>
</ul>
<p>因此，总结：单缓冲区处理每块数据的用时为：<strong>max(C, T)+M</strong></p>
</blockquote>
</li>
<li><p><strong>双缓冲区</strong></p>
<blockquote>
<p>双缓冲区是指，在主存中分配两个缓冲区</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86/%E5%8F%8C%E7%BC%93%E5%86%B2%E5%8C%BA.png" alt="双缓冲区"></p>
<p>假设初始状态为：工作区空，其中一个缓冲区满，另一个缓冲区空</p>
<ul>
<li><p>当T&gt;C+M时，</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86/%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B43.png" alt="处理时间3"></p>
<p><strong>处理时间为：T</strong></p>
</li>
<li><p>当T&lt;C+M时，</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86/%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B44.png" alt="处理时间4"></p>
<p><strong>处理时间为：C+M</strong></p>
</li>
</ul>
<p>因此，总结：双缓冲区处理每块数据的用时为：<strong>max(C+M , T)</strong></p>
</blockquote>
</li>
<li><p><strong>循环缓冲</strong></p>
<blockquote>
<p>包含大小多个大小相同的缓冲区，每个缓冲区中有一个链接指针指向下一个缓冲区，最后一个缓冲指向第一个缓冲区，多个缓冲区构成一个环型。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86/%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2%E5%8C%BA.png" alt="循环缓冲区"></p>
<p>该缓冲区中还设置了两个指针：in和out。in指向可以输入数据的第一个缓冲区；out指向可以提取数据的第一个满输入数据的缓冲区。</p>
</blockquote>
</li>
<li><p><strong>缓冲池</strong></p>
<blockquote>
<p>​        缓冲池由系统中共用的缓冲区组成。这些缓冲区按使用状况可以分为：<strong>空缓冲队列</strong>、<strong>装满输入数据的缓冲队列</strong>、<strong>装满输出数据的缓冲队列</strong></p>
<p>​        而根据一个缓冲区在实际运算中的功能不同，由设置了四种工作缓冲区：<strong>用于收容输入数据的工作缓冲区（hin）</strong>、<strong>用于提取输入数据的工作缓冲区（sin）</strong>、<strong>用于收容输出数据的工作缓冲区（hout）</strong>、<strong>用于提取输出数据的工作缓冲区（sout）</strong></p>
<p> <img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86/%E7%BC%93%E5%86%B2%E6%B1%A0.png" alt="缓冲池"></p>
<ul>
<li><strong>输入进程请求输入数据：</strong>从<strong>空缓冲队列</strong>中取下一块缓冲区放入<strong>收容输入</strong>中，等到输入数据满了以后，放到<strong>输入队列</strong>的队尾中</li>
<li><strong>计算过程需要取得一块输入数据：</strong>从<strong>输入队列</strong>中取下一块缓冲区放入<strong>提取输入</strong>中，等到数据提取完后，放回<strong>空缓冲队列</strong>中</li>
<li><strong>计算进程想要将准备好的数据写入到缓冲区中：</strong>从<strong>空缓冲队列</strong>中取下一块缓冲区放入<strong>收容输出</strong>中，等到输入数据满了以后，放到<strong>输出队列</strong>的队尾中</li>
<li><strong>输出进程请求输出数据：</strong>从<strong>输入队列</strong>中取下一块缓冲区放入<strong>提取输出</strong>中，等到数据输出完后，放回<strong>空缓冲队列</strong>中</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="三、其它补充"><a href="#三、其它补充" class="headerlink" title="三、其它补充"></a>三、其它补充</h2>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>基础学科</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2021/01/24/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="链表的定义和表示："><a href="#链表的定义和表示：" class="headerlink" title="链表的定义和表示："></a><b>链表的定义和表示：</b></h3><p>（<b>声明：</b>这里的链表都是线性表的链式结构。）</p>
<h4 id="链表的定义："><a href="#链表的定义：" class="headerlink" title="链表的定义："></a><b>链表的定义：</b></h4><blockquote>
<p>链表是一种物理存储结构上非连续、非顺序的存储结构（物理结构与逻辑结构不一致）。</p>
</blockquote>
<h4 id="链表存储结构："><a href="#链表存储结构：" class="headerlink" title="链表存储结构："></a><b>链表存储结构：</b></h4><blockquote>
<p><b>数据域</b>和<b>指针域</b></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LinkList</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> data;		<span class="comment">//数据域</span></span><br><span class="line">	LinkList* next;		<span class="comment">//指针域</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="链表的分类："><a href="#链表的分类：" class="headerlink" title="链表的分类："></a><b>链表的分类：</b></h4><blockquote>
<ul>
<li><b>单链表：</b>指针域只有一个next指针的链表<blockquote>
<ul>
<li><b>直线型的单链表</b></li>
<li><b>单循环链表</b></li>
</ul>
</blockquote>
</li>
<li><b>双向链表：</b>指针域有指向前一个节点的prior指针和指向后一个节点的next指针。<blockquote>
<ul>
<li><b>直线型的双向链表</b></li>
<li><b>双循环链表</b></li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<p><b>以下是单链表的表示图：</b><br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84.jpg" alt="链表" title="单链表"></p>
</blockquote>
<h3 id="链表的操作"><a href="#链表的操作" class="headerlink" title="链表的操作"></a><b>链表的操作</b></h3><blockquote>
<p>链表主要包括<b>增</b>（结点的增加）、<b>删</b>（删除某个结点）。</p>
<ul>
<li><b>增：</b>链表结点的插入分为<b>头插法</b>和<b>尾插法</b><blockquote>
<p><b>两者区别：</b>同样是按顺序将1-2-3-4-5创建成链表，<br>头插法的结果为：5-4-3-2-1<br>尾插法的结果为：1-2-3-4-5</p>
<ul>
<li><b>头插法：</b>即每次都将新结点插到头结点之后。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateList_H</span><span class="params">(Linklist &amp;L,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   LNode *p;</span><br><span class="line">   L=<span class="keyword">new</span> LNode;</span><br><span class="line">   L-&gt;next=<span class="literal">NULL</span>;		<span class="comment">//创建一个带头结点的空表</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">   &#123;</span><br><span class="line">p = <span class="keyword">new</span> LNode;		<span class="comment">//生成新的结点</span></span><br><span class="line">cin&gt;&gt;p-&gt;data;</span><br><span class="line"></span><br><span class="line">p-&gt;next=L-&gt;next;	<span class="comment">//将新结点插到头结点之后</span></span><br><span class="line">L-&gt;next=p;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><b>尾插法：</b>每次将新结点插到尾结点之后。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateList_R</span><span class="params">(Linklist &amp;L,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   LNode *p;</span><br><span class="line">   LNode *r;</span><br><span class="line">   L=<span class="keyword">new</span> LNode;</span><br><span class="line">   L-&gt;next=<span class="literal">NULL</span>;	<span class="comment">//创建一个带头结点的空表</span></span><br><span class="line">   </span><br><span class="line">   r=L;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">   &#123;</span><br><span class="line">       p=<span class="keyword">new</span> LNode;</span><br><span class="line">cin&gt;&gt;p-&gt;data;</span><br><span class="line"></span><br><span class="line">p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">r-&gt;next=p;</span><br><span class="line">r=p;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><b>删：</b>将链表中某个结点删掉。<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(LinkList*&amp; L, <span class="type">int</span> i)</span>			<span class="comment">//删除元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">LinkList* p = L, * q;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span>)		<span class="comment">//输入要删除的位置有误</span></span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;位置输入错误&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (j &lt; i - <span class="number">1</span> &amp;&amp; p != <span class="literal">NULL</span>)		<span class="comment">//查找要删除的位置</span></span><br><span class="line">&#123;</span><br><span class="line">	j++;</span><br><span class="line">	p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)		<span class="comment">//要删除的链表为空</span></span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;链表为空，删除失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	q = p-&gt;next;</span><br><span class="line">	<span class="keyword">if</span> (q == <span class="literal">NULL</span>)	<span class="comment">//要删除的链表为空</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;链表为空，删除失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p-&gt;next = q-&gt;next;	<span class="comment">//删除部分</span></span><br><span class="line">	<span class="keyword">delete</span> q;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;删除成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>基础学科</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>贝叶斯分类器</title>
    <url>/2021/08/27/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/</url>
    <content><![CDATA[<h4 id="贝叶斯分类器简介"><a href="#贝叶斯分类器简介" class="headerlink" title="贝叶斯分类器简介"></a><b>贝叶斯分类器简介</b></h4><blockquote>
<p>贝叶斯分类器是基于概率框架下的一种分类器，它与决策树等模型不一样。<br>决策树是直接对后验概率$P(y|x)$进行建模的<b>判别式模型</b><br>贝叶斯分类器则是先对联合概率分布$P(x,y)$建模，之后再对条件概率公式得出后验概率的<b>生成模型</b><br>其中贝叶斯分类器的核心部件就是<b>贝叶斯定理</b>。<br><b>补充：</b>贝叶斯分类器不仅可以分类，还能计算出对应类的概率。</p>
</blockquote>
<h4 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a><b>贝叶斯定理</b></h4><blockquote>
<p><b>定义：</b></p>
<blockquote>
<p>$$P(y|x)&#x3D;\frac{P(x|y)P(y)}{P(x)}$$</p>
<p>其中， $P(y|x)$称为<b>后验概率</b>，$P(x|y)$称为<b>似然概率</b>，$P(x)，P(y)$称为<b>先验概率</b></p>
</blockquote>
<ul>
<li>贝叶斯分类器就是根据贝叶斯定理，最终分别计算$P(y&#x3D;正例|x)$与$P(y&#x3D;反例|x)$这两个之间谁大谁小，从而得到分类结果。</li>
<li>当然也可以进行推广，计算$P(y&#x3D;类别1|x)$、$P(y&#x3D;类别2|x)$……$P(y&#x3D;类别n|x)$从而得到一个多分类器。</li>
<li>也可以通过计算后验概率来对搜索单词进行补全。</li>
</ul>
</blockquote>
<h4 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a><b>朴素贝叶斯</b></h4><blockquote>
<p>朴素贝叶斯是贝叶斯分类器中最简单的模型。它将各特征之间设为独立关系，举个例子:<br> <img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB/%E8%A5%BF%E7%93%9C%E4%BE%8B%E5%AD%90.png" alt="例子" title="例子"><br>其中特征x包括：色泽、根蒂、敲声、纹理、脐部、触感、密度、含糖率<br>现在我们要对一个<b>色泽&#x3D;青绿，根蒂&#x3D;蜷缩，敲声&#x3D;浊响，纹理&#x3D;清晰，脐部&#x3D;凹陷，触感&#x3D;硬滑，密度&#x3D;0.697，含糖率&#x3D;0.460</b>的西瓜进行判断它的好坏。<br>根据贝叶斯定理：$P(y|x)&#x3D;\frac{P(x|y)P(y)}{P(x)}$<br>首先它们两的P(x)是一样的，可以忽略不计，所以就变成了比较P(x|y&#x3D;好瓜)P(y&#x3D;好瓜)和P(x|y&#x3D;坏瓜)P(y&#x3D;坏瓜)之间的大小。</p>
<blockquote>
<ul>
<li>先计算出P(y&#x3D;好瓜)与P(y&#x3D;坏瓜)两个概率，利用频率代替概率容易得出例子中P(y&#x3D;好瓜)&#x3D;$\frac{8}{17} \approx 0.471$，P(y&#x3D;坏瓜)&#x3D;$\frac{9}{17} \approx 0.529$</li>
<li>这里就体现了朴素这两个字了，我们要求出P(x|y)，直接求，这有八个特征，而且样本量也不大，计算似然就会非常麻烦。为了简便计算，<b>我们假设各属性之间相互独立</b>，得到$P(x|y) &#x3D; \prod_{i&#x3D;0}^m P(x_i|y)$，即<br> <img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB/%E8%AE%A1%E7%AE%97%E8%A5%BF%E7%93%9C%E7%9A%84%E4%BC%BC%E7%84%B6%E5%87%BD%E6%95%B0.png" alt="例子" title="例子"><br><b>补充：</b>这里假设了密度和含糖率都服从正态分布。</li>
<li>最后计算P(y&#x3D;好瓜|x)和P(y&#x3D;坏瓜|x)，即<br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB/%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C.png" alt="例子" title="例子"></li>
</ul>
</blockquote>
<p>得到P(y&#x3D;好瓜)P(y&#x3D;好瓜|x) $&gt;$ P(y&#x3D;坏瓜)P(y&#x3D;坏瓜|x)，所以这个瓜是个好瓜。<br><b>注意：</b>有时如果数据集较小，计算似然概率时容易出现结果为0。这个时候需要利用<b>拉普拉斯平滑</b>来对模型进行改进，防止过拟合。</p>
</blockquote>
<h4 id="拉普拉斯平滑"><a href="#拉普拉斯平滑" class="headerlink" title="拉普拉斯平滑"></a><b>拉普拉斯平滑</b></h4><blockquote>
<p>拉普拉斯平滑的思想很简单，即对每个类别下所有划分的计数加1。<br>公式如下：</p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%B9%B3%E6%BB%91%E5%85%AC%E5%BC%8F.png" alt="例子" title="公式"><br><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%B9%B3%E6%BB%91%E5%85%AC%E5%BC%8F_1.png" alt="例子" title="公式"><br>其中$ajl$，代表第j个特征的第l个选择，$S_j$代表第j个特征的个数，K代表种类的个数，$\lambda$为1.</p>
</blockquote>
<p>通过拉普拉斯平滑的改进，可以有效避免过多出现零概率的现象。</p>
</blockquote>
<h4 id="半朴素贝叶斯"><a href="#半朴素贝叶斯" class="headerlink" title="半朴素贝叶斯"></a><b>半朴素贝叶斯</b></h4><blockquote>
<p>实际上，属性全部完全独立是不现实的，但考虑所有属性之间都有联系的话，计算又不方便。<br>因此平衡一下，假设部分属性之间存在联系。根据不同的策略可以得到不同联系算法。</p>
<ul>
<li><p><b>NB</b></p>
<blockquote>
<p>就是朴素贝叶斯分类。<br> <img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB/%E5%8D%8A%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AFNB.png" alt="例子" title="例子"></p>
</blockquote>
</li>
<li><p><b>SPODE</b></p>
<blockquote>
<p>假设所有的属性都依赖于同一个属性，称为“超父”，然后通过交叉验证的方式来确定超父。<br> <img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB/%E5%8D%8A%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AFSPODE.png" alt="例子" title="例子"></p>
</blockquote>
</li>
<li><p><b>AODE</b></p>
<blockquote>
<p>AODE与SPODE相类似，不过区别在于，SPODE利用模型来选择超父属性，AODE则是将每个属性都作为超父属性，即<br>$$h(x)&#x3D;max(\sum_{j&#x3D;1}^d P(c,x_j) \prod_{i&#x3D;1}^d P(x_i|c,x_j))$$</p>
</blockquote>
</li>
<li><p><b>TAN</b></p>
<blockquote>
<p>TAN(Tree Augmented naive Bayes)在最大带权生成树算法的基础上，通过下面的步骤将属性间的依赖关系简化为树形结构：</p>
<ul>
<li><p>计算任意两个属性之间的条件互信息:</p>
<blockquote>
<p>$$L(x_i,x_j|y)&#x3D;\sum_{x_i,x_j} P(x_i,x_j|c) log \frac{P(x_i,x_j|c)}{P(x_i|c)P(x_j|c)} \quad \quad c \in Y$$</p>
</blockquote>
</li>
<li><p>以属性为节点构造完全图，两节点之间的权值为互信息</p>
</li>
<li><p>构建此完全图的最大带权生成树，挑选根变量，将边设置为有向的；</p>
</li>
<li><p>加入类别节点y，增加从y到每个属性xi的有向边；<br> <img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB/%E5%8D%8A%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AFTAN.png" alt="例子" title="例子"></p>
</li>
</ul>
</blockquote>
</li>
</ul>
<p><b>补充：</b>半朴素贝叶斯与朴素贝叶斯在计算上最大的区别在于计算似然值$P(x|y) &#x3D; \prod_{i&#x3D;0}^m P(x_i|y)$的区别。<br>朴素贝叶斯的是：$P(x|y) &#x3D; \prod_{i&#x3D;0}^m P(x_i|y)$<br>半朴素贝叶斯的是：$P(x|y) &#x3D; \prod_{i&#x3D;0}^m P(x_i|x_n,y)$</p>
</blockquote>
<blockquote>
</blockquote>
<h4 id="贝叶斯网络"><a href="#贝叶斯网络" class="headerlink" title="贝叶斯网络"></a><b>贝叶斯网络</b></h4><blockquote>
<p> <img src="/picture/%E5%AD%A6%E4%B9%A0/%E8%A1%A8%E6%83%85%E5%8C%85/%E6%88%91%E6%91%B8%E5%88%B0%E4%BA%86.jpg" alt="摸了" title="还没看懂"></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>深渊巨坑</tag>
        <tag>机器学习</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>进程管理</title>
    <url>/2022/08/09/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="一、进程与线程"><a href="#一、进程与线程" class="headerlink" title="一、进程与线程"></a>一、进程与线程</h2><h3 id="1、进程的概念和特征"><a href="#1、进程的概念和特征" class="headerlink" title="1、进程的概念和特征"></a>1、进程的概念和特征</h3><blockquote>
<p><strong>定义：</strong></p>
<blockquote>
<ul>
<li>进程是程序的一次执行<strong>过程</strong>（进程属于一个过程，程序则是一个指令集合）</li>
<li>进程是一个程序及其数据在处理机上书顺序执行时所发生的活动</li>
<li>进程时具有独立功能的程序在一个数据集合上运行的<strong>过程</strong>，它是系统进行<strong>资源分配</strong>和<strong>调度的一个独立单位</strong></li>
</ul>
</blockquote>
<p><strong>组成：</strong></p>
<blockquote>
<p>准确来说应该是<strong>进程实体</strong>或<strong>进程映像</strong>的组成：</p>
<ul>
<li><strong>进程控制块（PCB）：</strong>记录进程的基本情况、运行状态和资源占用情况，从而控制和管理进程</li>
<li><strong>程序段：</strong>编译好的指令集合</li>
<li><strong>数据段：</strong>程序内部已经定义好的数据</li>
</ul>
</blockquote>
<p><strong>进程的特征：</strong></p>
<blockquote>
<ul>
<li><strong>动态性：</strong>进程最基本的特征</li>
<li><strong>并发性</strong></li>
<li><strong>独立性：</strong>进程能独立运行，是<strong>独立获得资源、独立接受调度的基本单位</strong></li>
<li><strong>异步性：</strong>各进程以不可预知的速度向前推进，可能导致的运行结果也是不可知的</li>
<li><strong>结构性：</strong>PCB、程序段、数据段</li>
</ul>
</blockquote>
</blockquote>
<h3 id="2、进程的状态与转换"><a href="#2、进程的状态与转换" class="headerlink" title="2、进程的状态与转换"></a>2、进程的状态与转换</h3><blockquote>
<p>​        进程在其生命周期内，进程可以处于不同的状态，通常进程可以分为以下5种状态。</p>
<p><strong>进程的状态：</strong></p>
<blockquote>
<ul>
<li><p><strong>运行态</strong></p>
<blockquote>
<p>​        进程正在处理机上运行。在<strong>单核</strong>情况下，每个时刻最多只有一个进程处于运行态。</p>
</blockquote>
</li>
<li><p><strong>就绪态</strong></p>
<blockquote>
<p>​        进程<strong>除处理机外的一切资源</strong>，一旦得到处理机，就可以立即运行；系统中处于就绪态的程序可以有多个，通常将它们排列起来形成一个队列，称为就绪队列</p>
</blockquote>
</li>
<li><p><strong>阻塞态</strong></p>
<blockquote>
<p>​        又称<strong>等待态</strong>。进程在进行到某个时间点上需要等待某个事件而暂停下来，这个事件可以<strong>是输入&#x2F;输出事件、等待某个资源（反正不包括处理机）</strong>。<strong>即使处理机空闲了，阻塞态的进程在得到资源前，都不会运行</strong></p>
</blockquote>
</li>
<li><p><strong>创建态</strong></p>
<blockquote>
<p>​        进程正在被创建，尚未转化为就绪态。</p>
</blockquote>
</li>
<li><p><strong>结束态</strong></p>
<blockquote>
<p>​        进程正从系统中消失的状态。</p>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>进程状态的转换：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt="进程状态转换"></p>
<ul>
<li><strong>就绪态</strong>$\to$<strong>运行态：</strong>处于就绪状态的进程被<strong>调度</strong>后，获得了CPU资源，因此由就绪态变为运行态</li>
<li><strong>运行态</strong>$\to$<strong>就绪态：</strong>处于运行态的进程<strong>运行时间用完后</strong>，只能让出CPU，因此从运行态转为就绪态（就绪进程也分优先级）</li>
<li><strong>运行态</strong>$\to$<strong>阻塞态：</strong>进程请求某一资源的使用和分配或等待某一事物的发生时，进程会从运行态转为阻塞态</li>
<li><strong>阻塞态</strong>$\to$<strong>就绪态：</strong>当进程所等待的事物得以满足后，就可以从阻塞态变为就绪态</li>
</ul>
<p><strong>注意：</strong></p>
<blockquote>
<ul>
<li>进程不能由就绪态转为阻塞态，因为申请资源或缺少某物只会发生在运行态。</li>
<li><strong>一个进程从运行态变为阻塞态是主动行为</strong>（因为需求是进程提出的），而<strong>阻塞态变为就绪态是被动的</strong>（因为这是由进程外的因素决定的）</li>
</ul>
</blockquote>
</blockquote>
<p><strong>进程的组织：</strong></p>
<blockquote>
<p>进程在内存中的存在形式可以分为两种：</p>
<ul>
<li><p><strong>链接方式</strong></p>
<blockquote>
<p>​        指操作系统会管理一系列的队列（实际上就是链表），队列中的每一个元素就是进程对应的PCB。如</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E9%93%BE%E6%8E%A5%E6%96%B9%E5%BC%8F.png" alt="链接方式"></p>
<p>​        很多操作系统会根据阻塞原因的不同，多分为多个阻塞队列。</p>
</blockquote>
</li>
<li><p><strong>索引方式</strong></p>
<blockquote>
<p>​        操作系统会设置一些索引表用于存放各进程的PCB块，如</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F.png" alt="索引方式"></p>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>进程控制：</strong></p>
<blockquote>
<p>​        进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有<strong>创建新进程</strong>、<strong>撤销已有进程</strong>、<strong>实现进程状态转换</strong>等。</p>
<p>​        在操作系统中，管理进程的操作被称为<strong>原语</strong>：执行期间不会被中断的操作</p>
<ul>
<li><p><strong>进程的创建</strong></p>
<blockquote>
<p>在操作系统中，许多程序的请求都会引起进程的创建，操作系统创建进程的步骤如下（<strong>创建原语</strong>）：</p>
<ul>
<li>为新进程分配一个唯一标识的<strong>进程标识号</strong>，并申请一个空白的PCB。如果PCB申请失败则创建失败（PCB数量有限）。</li>
<li>为进程分配资源，如分配数据、内存空间等。<strong>如果资源不足，则进入阻塞态（而非创建失败）</strong></li>
<li>初始化PCB，主要包括初始化标志信息、初始化处理机状态信息等</li>
<li>如果进程就绪队列可以接纳新进程，那么将新进程插入就绪队列，等待被调度</li>
</ul>
<p><strong>补充：</strong></p>
<blockquote>
<p>​        操作系统允许一个进程创建另一个进程。此时创建者称为<strong>父进程</strong>，被创建者称为<strong>子进程</strong>。子进程可以继承父进程所拥有的所有资源。在子进程被撤销时则将所有资源归还给父进程；如果父进程被撤销了，子进程也会被强制撤销。</p>
</blockquote>
</blockquote>
</li>
<li><p><strong>进程的终止</strong></p>
<blockquote>
<p>引起进程终止的事件：</p>
<ul>
<li><strong>正常结束：</strong>即进程已经完成任务，并自发退出运行</li>
<li><strong>异常结束：</strong>进程在运行时遇到了某种异常事件，如存储区越界、非法指令、运行超时等，使得进程无法继续运行</li>
<li><strong>外界干扰：</strong>指进程应外界的要求而终止运行，如用户或操作系统干预、父进程请求或父进程终止</li>
</ul>
<p>操作系统终止进程的步骤（撤销原语）：</p>
<ul>
<li>根据被终止进程的<strong>标识符</strong>，检索PCB表，从中读出该进程的状态</li>
<li>若被终止进程处于运行态，则立即终止该进程，将CPU资源交给其它就绪进程</li>
<li>若该进程还有子进程，那么先将其子进程终止（递归终止）</li>
<li>将该进程的所有资源归还给父进程或操作系统</li>
<li>将该进程的PCB从所在队列中删除</li>
</ul>
</blockquote>
</li>
<li><p><strong>进程的阻塞和唤醒</strong></p>
<blockquote>
<p>​        在进程执行的过程，有时会期待某些事件，如果请求事件未发生，而进程因为该事件未发生而不能继续工作，那么<strong>系统就会自动执行阻塞原语（Block）</strong>，使得进程由运行态转为阻塞态。（<strong>进程的阻塞是进程自身的一种主动行为</strong>），其过程为：</p>
<ul>
<li>找到将要被阻塞的进程的标识号所对应的PCB</li>
<li>将该进程的运行现场保护起来（结合计组的中断保护现场），并将其状态改为阻塞态，最后停止运行</li>
<li>把该PCB插入相应事件的等待队列里，将CPU资源交给其它就绪进程</li>
</ul>
<p>​        而在阻塞态的进程所期待的事件完成后，系统会调用<strong>唤醒原语（Wakeup）</strong>，将等待该事件的进程唤醒。唤醒原语的执行过程如下：</p>
<ul>
<li>在该事件的等待队列中找到相应进程的PCB</li>
<li>将其从等待队列中移出，并置其状态为就绪状态</li>
<li>把该PCB插入就绪队列，等待调度</li>
</ul>
<p><strong>注意：</strong>Block原语和Wakeup原语是一对刚好作用相反的原语，必须成对使用（即使用了Block原语后必须要有Wakeup原语才有可能执行），而且<strong>Block原语是由被阻塞进程自我调用实现的，而Wakeup原语则是由相关进程调用实现的</strong></p>
</blockquote>
</li>
<li><p><strong>进程切换</strong></p>
<blockquote>
<p>​        进程切换一般发生在进程的时间片用完以后发生，或缺少某事件而进入阻塞态，其过程主要如下：</p>
<ul>
<li>保存CPU的现场环境，如程序计数器以及各类寄存器的数据</li>
<li>更新PCB信息（如运行态$\to$就绪态&#x2F;阻塞态）</li>
<li>把进程的PCB移入相应的队列</li>
<li>选择就绪队列上的一个进程执行，并更新它的PCB</li>
<li>更新内存管理的数据结构</li>
<li>恢复该进程的现场，如将该程序的程序计数器及各类寄存器的数据放入CPU中</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<h3 id="3、进程的通信"><a href="#3、进程的通信" class="headerlink" title="3、进程的通信"></a>3、进程的通信</h3><blockquote>
<p>​        进程的通信指的是进程之间的<strong>信息交换</strong>。进程与进程之间一般都是相互密闭的，即进程与进程之间的数据是不互通的。因此需要引入进程的通信。而PV操作（后面临界资源会提到）是低级通信方式，而高级通信方式是指<strong>以较高的效率传输大量数据</strong>的通信方式。高级通信方式主要有以下三种：</p>
<ul>
<li><p><strong>共享存储</strong></p>
<blockquote>
<img src="/picture/学习/操作系统上的图/进程管理/共享存储.png" alt="共享存储" style="zoom:67%;" />

<p>​        共享存储就是操作系统直接在内存中开辟一块空间作为共享存储空间，即<strong>所有程序都可以对这片空间进程任意存取</strong>，从而实现进程间的相互通信。而根据开辟空间的方式不同，又可以分为两类：<strong>低级方式</strong>和<strong>高级方式</strong></p>
<ul>
<li><strong>低级方式：</strong>共享空间是一个<strong>数据结构</strong>的共享，如系统开辟一个数组作为共享空间（空间在物理上不一定连续）。而这类的共享空间的读写效率较低。</li>
<li><strong>高级方式：</strong>共享空间是<strong>基于存储空间</strong>的共享，即直接在内存中开辟一块连续的空间。这类共享空间读写效率要高得多。</li>
</ul>
</blockquote>
</li>
<li><p><strong>消息传递</strong></p>
<blockquote>
<p>​        在消息传递系统中，进程间的数据交流是以格式化的消息（Message）为单位的。如果进程间不存在可以直接访问的共享空间，那么就需要操作系统提供的消息传递方法实现进程通信。进程间的通信可以通过<strong>发送消息</strong>和<strong>接收消息</strong>两个原语进行数据交流，而操作系统中会有一个地方存储双方信息的内存块，根据收发方式不同可以分为两类通信方式：</p>
<ul>
<li><p><strong>直接通信方式：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E7%9B%B4%E6%8E%A5%E9%80%9A%E4%BF%A1.png" alt="直接通信"></p>
<ul>
<li>内存中有一个消息队列，用于存放进程间通信的消息</li>
<li>发送原语发送时是直接以进程的PID作为目的地址的</li>
<li>接收原语则在消息队列中找到要发送给自己的消息</li>
</ul>
</blockquote>
</li>
<li><p><strong>间接通信方式：</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E9%97%B4%E6%8E%A5%E9%80%9A%E4%BF%A1.png" alt="间接通信"></p>
<ul>
<li>内存中设置若干个信箱（缓冲区）</li>
<li>发送方需要发送信息时直接以信箱地址作为目的地</li>
<li>接收方则是以信箱地址为接收地址来接收信箱里<strong>所有的消息</strong></li>
<li>任何程序都可以在信箱内读取信箱里的消息</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>管道通信</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1.png" alt="管道通信"></p>
<p>​        管道通信时消息传递的一种特殊方法，“管道”指的是<strong>用于连接一个读进程和一个写进程以实现它们之间的通信的一个共享文件，又称pipe文件</strong>。</p>
<p>​        管道通信属于<strong>半双工通信</strong>，即通信双方同时只能有一个读和一个写，如果想要实现双方互动通信，则需要两个管道。另外从管道中读数据是<strong>一次性</strong>的，即数据一旦被读取，那么它就会被管道所抛弃。</p>
<p>​        管道使用的是<strong>先进先出</strong>的输出原理（实际上就是一个循环队列）。</p>
<p><strong>注意：</strong> <strong>考试时，一个管道可以多个写进程，一个读进程</strong>。现实里，存在一个管道有多个写进程，多个读进程。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="4、线程的概念和多线程模型"><a href="#4、线程的概念和多线程模型" class="headerlink" title="4、线程的概念和多线程模型"></a>4、线程的概念和多线程模型</h3><blockquote>
<p>​        为了<strong>提高程序的并发性执行，与提高资源的利用率和系统吞吐率</strong>，操作系统就引入了<strong>线程</strong>。引入线程还可以减小程序在并发执行时所付出的时空开销（即在同一程序内切换线程时不需要改变CPU的寄存器内容了）。</p>
<p>​        线程最直接的理解是“轻量级进程”，<strong>它取代进程成为了CPU的执行单元，也是程序执行流的最小单元</strong>。实际上线程就是对一个进程进行了功能上或用户上的划分，如一个进程有多个功能或多个用户使用，那么可以根据功能不同或使用的用户不同进行划分。</p>
<p>​        引入线程后，除了进程间可以并发执行，线程内也可以并发执行，从而提高系统的并发性。</p>
<p><strong>线程与进程的关系：</strong></p>
<blockquote>
<p> <img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.png" alt="进程与线程"></p>
<ul>
<li><strong>线程自己不占有系统资源，而是和同一进程内的其它线程共享进程的资源</strong></li>
<li><strong>线程也拥有就绪、阻塞和运行这三种基本状态</strong></li>
<li><strong>引入线程后，进程就不是处理机的分配单元了，但依旧是系统资源的分配单元</strong>（即<strong>线程是CPU的执行单元</strong>，<strong>进程是资源的分配单元</strong>）</li>
</ul>
</blockquote>
<p><strong>线程与进程的比较：</strong></p>
<blockquote>
<ul>
<li><strong>调度：</strong>在传统机器中，进程是<strong>拥有资源</strong>和<strong>独立调度</strong>的基本单位；引入线程后，<strong>线程</strong>变成了<strong>独立调度</strong>的基本单位，而进程依旧是拥有资源的基本单位。而且<strong>在线程切换中，不会引起进程切换；而在进程切换时，一定会引起线程切换</strong></li>
<li><strong>拥有资源：</strong>无论是那种操作系统，进程都是拥有资源的基本单位；线程则只能使用进程中所拥有的资源。</li>
<li><strong>并发性：</strong>引入线程后，不仅进程间拥有并发性；而且在一个进程内各个线程间也有并发性</li>
<li><strong>地址空间与其它资源：</strong>进程间的地址空间相互独立，而同一进程间的线程则可以相互共享资源。而且某进程内的线程对其它进程都是不可见的</li>
<li><strong>切换开销：</strong>进程切换时，系统开销会很大；线程切换时，系统开销则很小</li>
</ul>
</blockquote>
<p><strong>线程的属性：</strong></p>
<blockquote>
<ul>
<li>线程时处理机的调度单位</li>
<li>每一个线程都有一个线程ID、线程控制块（TCB）</li>
<li>线程也有就绪、阻塞、运行三种基本状态</li>
<li>线程几乎不拥有资源</li>
<li>同一进程的不同线程间共享该进程的资源</li>
</ul>
</blockquote>
<p><strong>线程的实现方式：</strong></p>
<blockquote>
<p>线程的实现可以分为两类：<strong>用户级线程</strong>、<strong>内核级线程</strong></p>
<ul>
<li><p><strong>用户级线程</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B.png" alt="用户级线程"></p>
<ul>
<li><p>在用户级线程中，有关线程管理的所有工作都由应用程序完成，<strong>内核意识不到线程的存在</strong>。应用程序可以通过线程设计库设计多线程程序。</p>
</li>
<li><p>线程的管理是由程序使用现线程设计库来管理多线程的</p>
</li>
<li><p>线程之间切换不需要CPU切换状态</p>
</li>
</ul>
<p><strong>优点：</strong>用户级线程的切换直接在用户空间即可，不需要切换到核心态，因此效率会更高</p>
<p><strong>缺点：</strong>在同一个进程中，<strong>如果一个线程被阻塞，那么其它线程也会被阻塞</strong>。并发度较低，多个线程不能再多核处理机上并行运行。</p>
</blockquote>
</li>
<li><p><strong>内核级线程</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E5%86%85%E6%A0%B8%E7%BA%A7%E7%9A%84%E7%BA%BF%E7%A8%8B.png" alt="内核级的线程"></p>
<ul>
<li>线程的管理工作由操作系统完成</li>
<li>线程在切换时需要从用户态转为核心态</li>
<li>操作系统可以意识到线程的存在</li>
</ul>
<p><strong>优点：</strong>当一个线程内阻塞后，别的线程依旧可以继续执行；在多喝处理机上也可以并行执行</p>
<p><strong>缺点：</strong>线程切换时需要CPU状态的转换，增加开销</p>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>多线程模型：</strong></p>
<blockquote>
<p>​        在内核级线程中，根据用户级线程和内核级线程的映射关系，可以划分为多种线程模型：</p>
<ul>
<li><p><strong>一对一模型</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E4%B8%80%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B.png" alt="一对一模型"></p>
<p>​        一个用户级线程映射到一个内核级线程中，即每个用户进程有与用户即线程相同数量的内核级线程。</p>
<p><strong>优点：</strong>当一个线程被阻塞后，别的线程依旧可以继续执行</p>
<p><strong>缺点：</strong>系统管理开销大，且一个进程占用多个内核级线程，系统的开销也大</p>
</blockquote>
</li>
<li><p><strong>多对一模型</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B.png" alt="多对一模型"></p>
<p>​        多个用户级线程映射到一个内核级线程中。且一个进程之被分配一个内核级线程</p>
<p><strong>优点：</strong>用户线程的切换在用户空间即可完成，无需切换到核心态，因此线程管理系统开销小</p>
<p><strong>缺点：</strong>当一个用户级线程被阻塞后，整个进程都会被主色，并行度不高，多个线程在多核CPU上也只能占用一个内核</p>
<p><strong>注意：</strong>只有内核级进程才是CPU分配的单位</p>
</blockquote>
</li>
<li><p><strong>多对多模型</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%A8%A1%E5%9E%8B.png" alt="多对多模型"></p>
<p>​        n个用户级线程映射到m个内核级线程中（$n \ge m$）。每个用户进程对应m个内核级线程。</p>
<p><strong>特点：</strong>既克服了多对一模型并发度不高的缺点，又克服了一对一模型中一开销大的问题</p>
</blockquote>
</li>
</ul>
</blockquote>
<ul>
<li><p><strong>线程的状态与转换</strong></p>
<blockquote>
<ul>
<li><p><strong>线程的状态转换</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2.png" alt="线程的状态与转换"></p>
<p>​         线程的状态与进程的状态类似，且只有就绪态、阻塞态、运行态；而且这三个状态之间的转换与进程一致。</p>
<p>​        线程的控制就是让线程在这三种状态中转换。</p>
</blockquote>
</li>
<li><p><strong>进程的组织</strong></p>
<blockquote>
<p> <img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87.png" alt="线程的组织"></p>
<p>​        与进程类似，线程也是由一个控制单元所操控的，则个控制单元称为<strong>线程控制块（TCB）</strong>，其属性如图所示。</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="二、处理机的调度"><a href="#二、处理机的调度" class="headerlink" title="二、处理机的调度"></a>二、处理机的调度</h2><h3 id="1、调度的概念"><a href="#1、调度的概念" class="headerlink" title="1、调度的概念"></a>1、调度的概念</h3><blockquote>
<ul>
<li><p><strong>调度的基本概念</strong>：</p>
<blockquote>
<p>​        处理机调度是对处理机的使用权进行分配，<strong>即从就绪队列中按照一定算法（公平、高效）选择一个进程并处理机交给它运行</strong>，以实现进程并发地执行</p>
</blockquote>
</li>
<li><p><strong>调度的层次</strong></p>
<blockquote>
<ul>
<li><strong>作业调度（高级调度）：</strong>指按一定原则从外存上处于后备状态的作业中挑选一个（或多个）作业，给它们分配内存、输入&#x2F;输出设备等资源，并建立相应的进程。作业调度就是<strong>内存与辅存之间的调度</strong>。对于每一个作业只能调入一次、调出一次。且<strong>作业调度频率较低</strong></li>
<li><strong>内存调度（中级调度）：</strong>为了节省内存空间，有时会将那些暂时不能运行的进程调至外存等待，此时的进程状态被称为<strong>挂起态</strong>。而内存调度就是把外存上的那些已具备运行条件的就绪进程<strong>再调入内存，并改为就绪态</strong>。（注意与作业调度的区别）</li>
<li><strong>进程调度（低级调度）：</strong>指按照某种方法和策略<strong>从就绪队列中选取一个进程，将处理机分配给它</strong>。进程调度的频率很高。</li>
</ul>
</blockquote>
</li>
<li><p><strong>三级调度的联系</strong></p>
<blockquote>
<ul>
<li>作业调度为进程活动做准备；内存调度则是将暂时不运行的进程挂起（或将挂起的进程唤醒）；进程调度则是最基本的操作，是CPU并发执行的根本</li>
<li>作业调度次数少；内存调度次数略多；进程调度次数最多</li>
</ul>
</blockquote>
</li>
<li><p><strong>调度器</strong></p>
<blockquote>
<ul>
<li><p><strong>调度器的使用时间：</strong></p>
<blockquote>
<ul>
<li><strong>创建新进程</strong></li>
<li><strong>进程退出</strong></li>
<li><strong>运行进程阻塞</strong></li>
<li><strong>I&#x2F;O中断</strong></li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>注意：</strong>只有进程的<strong>就绪态</strong>和<strong>运行态</strong>之间的转换是由调度程序引起的。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="2、调度时机、方式与过程"><a href="#2、调度时机、方式与过程" class="headerlink" title="2、调度时机、方式与过程"></a>2、调度时机、方式与过程</h3><blockquote>
<ul>
<li><p><strong>调度时机</strong></p>
<blockquote>
<ul>
<li><p>当前运行的进程<strong>主动放弃</strong>处理机</p>
<blockquote>
<ul>
<li>进程正常终止</li>
<li>运行过程中发生异常而终止</li>
<li>进程主动请求阻塞</li>
</ul>
</blockquote>
</li>
<li><p>当前运行的进程<strong>被动放弃</strong>处理机</p>
<blockquote>
<ul>
<li>分给进程的时间片用完</li>
<li>有更紧急的事需要处理（如I&#x2F;O中断）</li>
<li>有更高优先级的进程进入就绪队列中</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>不能进行进程调度的情况：</strong></p>
<blockquote>
<ul>
<li><p>在<strong>处理中断的过程中</strong></p>
</li>
<li><p>进程在<strong>操作系统内核程序临界区</strong>中</p>
<blockquote>
<p>注意，在<strong>普通临界区</strong>的进程可以被调度</p>
<p><strong>内核程序临界区：</strong>一般用来访问<strong>某种内核数据结构</strong>的，如进程的就绪队列，因为如果在使用这类数据结构的进程被调度以后，可能会导致其它的管理工作无法运行，从而影响到整个操作系统</p>
</blockquote>
</li>
<li><p><strong>在原子操作过程中</strong></p>
</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>调度切换与过程</strong></p>
<blockquote>
<ul>
<li><p>“狭义的进程调度”与“进程切换”的区别：</p>
<blockquote>
<p>​        <strong>狭义的进程调度</strong>是指<strong>从就绪队列中选一个要执行的进程</strong>。（这个进程可以是刚刚被暂停的进程，也可以是<strong>另一个进程</strong>，后一种情况就需要<strong>进程切换</strong>）</p>
<p>​        <strong>广义的进程调度</strong>包含了<strong>选择一个进程</strong>和<strong>进程切换</strong>两个步骤</p>
</blockquote>
</li>
<li><p><strong>进程切换的过程：</strong></p>
<blockquote>
<ul>
<li>对原来运行的进程中各种数据进程保存</li>
<li>对新的进程中各种数据的恢复</li>
</ul>
<p>（参考计组中，保存中断和恢复中断两步）</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>调度方式</strong></p>
<blockquote>
<ul>
<li><strong>非剥夺调度方式</strong>，又称<strong>非抢占方式</strong>，只允许进程主动放弃处理机。</li>
<li><strong>剥夺式调度方式，</strong>又称<strong>抢占方式</strong>，允许一个更优先得进程抢占另一个正在运行的进程的处理机。</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>补充：</strong></p>
<blockquote>
<p><strong>闲逛进程：</strong></p>
<blockquote>
<p>​         <strong>在处理机没有进程使用时，处理机会自动调用闲逛进程</strong>；闲逛进程的特点是，优先级低，0地址指令，能耗低。</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="3、调度的评价指标"><a href="#3、调度的评价指标" class="headerlink" title="3、调度的评价指标"></a>3、调度的评价指标</h3><blockquote>
<p>​        不同的调度算法具有不同的特性，为了比较处理机调度算法的性能，以下是最常用的评价准则：</p>
<ul>
<li><strong>CPU利用率：</strong>指CPU忙碌时间占CPU总运行时间的比例，即$CPU利用率&#x3D;\frac{CPU忙碌时间}{CPU总运行时间}$</li>
<li><strong>系统吞吐量：</strong>表示单位时间内CPU完成作业的数量，即$系统吞吐量&#x3D;\frac{作业完成数量}{使用的时间}$</li>
<li>⭐<strong>周转时间：</strong>指从作业提交到作业完成所经历的时间，是<strong>作业等待、在就绪队列中排队、在处理机上运行</strong>及<strong>输入&#x2F;输出所花费的时间</strong>即$周转时间&#x3D;作业完成时间-作业提交时间$</li>
<li><strong>平均周转时间：</strong>即周转时间除以作业的总数，即$平均周转时间&#x3D;\frac{n个作业的周转时间之和}{n}$</li>
<li>⭐<strong>带权周转时间：</strong>$带权周转时间&#x3D;\frac{作业周转时间}{作业实际运行时间}$</li>
<li><strong>平均带权周转时间：</strong>$平均带权周转时间&#x3D;\frac{n个作业的带权周转时间之和}{n}$</li>
<li><strong>等待时间：</strong>指进程处于<strong>等处理机</strong>状态的时间之和，即$等待时间&#x3D;运行时间-就绪时间$，注意，进程在等待I&#x2F;O设备的时间不算入等待时间；而对于作业的等待时间，除了考虑建立进程后的等待时间，还需要加上作业在外设后备队列中的等待时间。</li>
<li><strong>响应时间：</strong>指用户提交申请到系统首次产生响应的时间</li>
</ul>
</blockquote>
<h3 id="4、经典的调度算法"><a href="#4、经典的调度算法" class="headerlink" title="4、经典的调度算法"></a>4、经典的调度算法</h3><blockquote>
<p><strong>补充：</strong></p>
<blockquote>
<p><strong>饥饿</strong>：指进程长时间得不到服务的情况</p>
<p><strong>饿死：</strong>指进程一直得不到服务</p>
</blockquote>
</blockquote>
<h4 id="先来先服务调度算法（FCFS）"><a href="#先来先服务调度算法（FCFS）" class="headerlink" title="先来先服务调度算法（FCFS）"></a><strong>先来先服务调度算法（FCFS）</strong></h4><blockquote>
<p> <img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E7%AE%97%E6%B3%95.png" alt="先来先服务算法"></p>
<ul>
<li><p><strong>算法思想：</strong>主要从”公平“的角度考虑</p>
</li>
<li><p><strong>算法规则：</strong>按照作业&#x2F;进程到达的先后顺序进行服务</p>
</li>
<li><p><strong>使用范围：</strong>即可用于作业调度，又可用于进程调度</p>
</li>
<li><p><strong>是否可抢占：</strong>非抢占式算法</p>
</li>
<li><p><strong>优缺点：</strong></p>
</li>
</ul>
<blockquote>
<p><strong>优点：</strong>公平、算法实现简单</p>
<p><strong>缺点：</strong>排在长作业后面的短作业需要等待很长时间，带权周转时间长，对<strong>短作业不友好</strong>。</p>
</blockquote>
<ul>
<li><strong>是否会导致饥饿：</strong>不会</li>
</ul>
</blockquote>
<h4 id="短作业优先算法（SJF）"><a href="#短作业优先算法（SJF）" class="headerlink" title="短作业优先算法（SJF）"></a><strong>短作业优先算法（SJF）</strong></h4><blockquote>
<blockquote>
<ul>
<li><p><strong>算法思想：</strong>追求最少的平均等待时间，最少的平均周转时间、最少的平均带权周转时间</p>
</li>
<li><p><strong>算法规则：</strong>要求服务时间最短的进程优先</p>
</li>
<li><p><strong>使用范围：</strong>既可用于作业调度，又可用于进程调度</p>
</li>
<li><p><strong>是否可抢占：</strong>既有抢占式的，又有非抢占式的</p>
</li>
<li><p><strong>优缺点：</strong></p>
<blockquote>
<p><strong>优点：</strong>“最短的”平均等待时间、平均周转时间</p>
<p><strong>缺点：</strong>不公平。对<strong>短作业有利，长作业不利</strong>。可能产生<strong>饥饿</strong>现象。另外，作业&#x2F;进程的运行时间是用户提供的，可能会造假。</p>
</blockquote>
</li>
<li><p><strong>是否会饥饿：</strong>会</p>
</li>
</ul>
<p>​        短作业优先算法根据是否可抢占可以分为：<strong>短作业优先调度算法（SJF）</strong>和<strong>最短剩余时间优先算法（SRTN）</strong></p>
<ul>
<li><p><strong>短作业优先调度算法（SJF）</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95.png" alt="短作业优先算法"></p>
<p><strong>规则：</strong>每次调度时选择<strong>当前已到达</strong>且<strong>运行时间最短</strong>的作业&#x2F;进程；且每次只会在上一个进程完成后再调入新进程，属于<strong>非抢占式算法</strong></p>
</blockquote>
</li>
<li><p><strong>最短剩余时间优先算法（SRTN）</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E6%9C%80%E7%9F%AD%E5%89%A9%E4%BD%99%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95.png" alt="最短剩余时间优先算法"></p>
<p><strong>规则：</strong>每当<strong>有进程进入就绪队列时</strong>就需要判断是否调度，如果新到达的进程剩余时间按比当前运行进程剩余时间<strong>更短</strong>，则由新进程<strong>抢占</strong>处理机，当前运行进程重新回到就绪队列。如果<strong>一个进程完成时也需要调度</strong></p>
</blockquote>
</li>
</ul>
<p><strong>注意：</strong></p>
<blockquote>
<ul>
<li>如果题目<strong>未特别说明</strong>，<strong>默认是非抢占式的</strong></li>
<li>需要加上<strong>所有进程同时可运行</strong>时，采用SJF调度算法的平均等待时间、平均周转时间最少</li>
</ul>
</blockquote>
</blockquote>
</blockquote>
<h4 id="高响应比优先（HRRN）"><a href="#高响应比优先（HRRN）" class="headerlink" title="高响应比优先（HRRN）"></a><strong>高响应比优先（HRRN）</strong></h4><blockquote>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95.png" alt="高响应比优先算法"></p>
<p><strong>响应比：</strong>$响应比&#x3D;\frac{等待时间+要求服务时间}{要求服务时间}$</p>
<ul>
<li><p><strong>算法思想</strong>：综合考虑作业&#x2F;进程的等待时间和要求服务的时间</p>
</li>
<li><p><strong>算法规则：</strong>根据响应比的大小进行选择，处理机优先选择<strong>响应比高</strong>的进程进入处理机运行。</p>
</li>
<li><p><strong>使用范围：</strong>既可用于作业调度，又可用于进程调度</p>
</li>
<li><p><strong>是否可抢占：</strong> <strong>非抢占式算法</strong>。只有当前进程主动放弃处理机时，才能调度，才开始计算响应比</p>
</li>
<li><p><strong>优缺点：</strong></p>
<blockquote>
<p><strong>优点：</strong>综合考虑了等待时间和运行时间两个因素，对于长作业来说，可以避免等待时间过长而导致的饥饿问题</p>
</blockquote>
</li>
<li><p><strong>是否会导致饥饿：</strong>不会</p>
</li>
</ul>
</blockquote>
</blockquote>
<h4 id="时间片轮转（RR）"><a href="#时间片轮转（RR）" class="headerlink" title="时间片轮转（RR）"></a><strong>时间片轮转（RR）</strong></h4><blockquote>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E6%B3%95.png" alt="时间片轮转法"></p>
<ul>
<li><p><strong>算法思想：</strong>公平地、轮流为各个进程服务，让每个进程再一定时间间隔内都可以得到响应</p>
</li>
<li><p><strong>算法规则：</strong>按照各进程到达就绪队列的顺序，<strong>轮流让各个进程执行一个时间片</strong>。如果进程再时间片内未完成，那么将进程重新放到就绪队列的队尾中重新排队</p>
</li>
<li><p><strong>使用范围：</strong>仅适用于进程调度</p>
</li>
<li><p><strong>是否可抢占：</strong>属于可抢占式算法</p>
</li>
<li><p><strong>优缺点：</strong></p>
<blockquote>
<p><strong>优点：</strong>公平、响应快，适合用于分时操作系统</p>
<p><strong>缺点：</strong>进程切换频率高，造成开销；不区分任务的紧急程度</p>
</blockquote>
</li>
<li><p><strong>是否会导致饥饿：</strong>不会</p>
</li>
</ul>
<p><strong>注意：</strong></p>
<blockquote>
<p>​        在时间片轮转法中，时间片设置的大小非常关键。过大，就会退成先来先服务算法；过小又会导致进程切换频繁，造成系统开销大</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a><strong>优先级调度算法</strong></h4><blockquote>
<blockquote>
<ul>
<li><p><strong>算法思想：</strong>计算机需要根据任务的紧急情况进行处理</p>
</li>
<li><p><strong>算法规则：</strong>调度是选择优先级更高的作业&#x2F;进程</p>
</li>
<li><p><strong>使用范围：</strong>既可以用于作业调度，也可以用于进程调度（还可以用于之后的I&#x2F;O调度中）</p>
</li>
<li><p><strong>是否可抢占：</strong>既有抢占式的，又有非抢占式的</p>
</li>
<li><p><strong>优缺点：</strong></p>
<blockquote>
<p><strong>优点：</strong>可以使用优先级区分紧急程度、重要程度不同的各类进程&#x2F;作业</p>
<p><strong>缺点：</strong>如果源源不断地有高优先级进程到来，则可能导致饥饿</p>
</blockquote>
</li>
<li><p><strong>是否会导致饥饿：</strong>会</p>
</li>
</ul>
<p>优先级调度算法也可以根据是否可抢占分为两种算法：</p>
<ul>
<li><p><strong>非抢占式</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.png" alt="优先级调度算法"></p>
<p><strong>规则：</strong>只有当前进程<strong>主动放弃处理机</strong>时，才会在就绪队列中选取优先级最高的进程进行运行。</p>
</blockquote>
</li>
<li><p><strong>可抢占式</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95_%E6%8A%A2%E5%8D%A0%E5%BC%8F.png" alt="优先级调度算法_抢占式"></p>
<p><strong>规则：</strong>当就绪队列中有新进程加入时，需要比较它与正在运行的进程的优先级，如果高，那就将它调度到处理机上，原进程则放入就绪队列中</p>
</blockquote>
</li>
</ul>
<p><strong>注意：</strong></p>
<blockquote>
<p>就绪队列可以有多个，按照不同特点来排序</p>
<p>根据优先级是否可以动态改变，可以将优先级分为<strong>静态优先级</strong>和<strong>动态优先级</strong>；</p>
<p><strong>静态优先级：</strong>创建进程时确定，之后一直不变</p>
<p><strong>动态优先级：</strong>进程创建时有一个初始值，之后可以动态进程改变</p>
<p><strong>通常：</strong></p>
<p>系统进程优先级<strong>高于</strong>用户进程</p>
<p>前台进程优先级<strong>高于</strong>后台进程</p>
<p>操作系统更偏好于<strong>I&#x2F;O型进程</strong>（即可以让I&#x2F;O设备可以更早开始工作，与之相对的是<strong>CPU繁忙型进程</strong>）</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a><strong>多级反馈队列调度算法</strong></h4><blockquote>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.png" alt="多级反馈队列调度算法"></p>
<ul>
<li><p><strong>算法思想：</strong>对先来先服务、短作业优先、时间片轮转、优先级调度算法的折中权衡</p>
</li>
<li><p><strong>算法规则：</strong></p>
<blockquote>
<ul>
<li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li>
<li>新进程到达时先进入第1级队列，按照先来先服务原则排队等待被分配时间片，如果时间片用完而进程仍未借宿，则进程进入下一级队列队尾。如果此时已经在最下级的队列，则重新放回该级的队列列尾</li>
<li>只有上一级队列为空时，才会为下一级队列的进程分配时间片</li>
</ul>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97.png" alt="多级队列"></p>
</blockquote>
</li>
<li><p><strong>使用范围：</strong>只适用于进程调度</p>
</li>
<li><p><strong>是否可抢占：</strong>抢占式的算法。如果有新进程进入那么就需要先只需新进程。</p>
</li>
<li><p><strong>优缺点：</strong></p>
<blockquote>
<p><strong>优点：</strong>对各类进程相对公平（FCFS的优点）；每个新到达的进程都可以很快就得到响应（RR优点）；短进程只需要较少时间就可完成（SPF的优点）；不用估计进程的运行时间</p>
</blockquote>
</li>
<li><p><strong>是否会导致饥饿：</strong>会</p>
</li>
</ul>
</blockquote>
</blockquote>
<h4 id="多级队列调度算法"><a href="#多级队列调度算法" class="headerlink" title="多级队列调度算法"></a><strong>多级队列调度算法</strong></h4><blockquote>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.png" alt="多级队列调度算法"></p>
<ul>
<li><p><strong>算法思想：</strong>在系统中设置多个优先级不同的队列进行调度</p>
</li>
<li><p><strong>算法规则：</strong>系统中按进程类型设置多个队列，进程创建后插入某个队列中</p>
</li>
<li><p><strong>特点：</strong></p>
<blockquote>
<p>队列间可采用固定优先级，或时间片划分：</p>
<ul>
<li><p><strong>固定优先级：</strong>高优先级的进程执行完以后，低优先级进程才能被调度</p>
</li>
<li><p><strong>时间片划分：</strong>如三个队列分配时间50%、40%、10%</p>
</li>
</ul>
<p>各个队列可以采用不同的调度策略，如</p>
<p>系统进程队列采用优先级调度、交互进程采用时间片轮转、批处理进程采用先来先服务</p>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<h2 id="三、进程同步"><a href="#三、进程同步" class="headerlink" title="三、进程同步"></a>三、进程同步</h2><h3 id="1、进程同步的基本概念"><a href="#1、进程同步的基本概念" class="headerlink" title="1、进程同步的基本概念"></a>1、进程同步的基本概念</h3><blockquote>
<p>​        不同进程间相互运行时可能会产生不同的关系。如有一个加法进程和一个乘法进程，当我们需要运算一个既有加法又有乘法的混合运算时，我们就必须先运行乘法进程，最后再让加法进程运行，这就形成了一种制约关系。</p>
<ul>
<li><p><strong>临界资源</strong></p>
<blockquote>
<p><strong>定义：</strong>在系统中属于<strong>共享资源</strong>，但是在一个时间内<strong>只能有一个进程</strong>访问使用的资源，被称为临界资源</p>
<p>为了保证临界区的正确访问，一般访问临界区都会有以下部分：</p>
<ul>
<li><strong>进入区：</strong>判断<strong>是否能进入临界区</strong>的代码（如果判断可以进入，那么需要设置一个标志禁止其它进程进入临界区）</li>
<li><strong>临界区：</strong>在进程中<strong>访问临界资源</strong>的那段代码，又叫做<strong>临界段</strong>（临界区是一段代码）</li>
<li><strong>退出区：</strong>将正在访问临界区的标记清除</li>
<li><strong>剩余区：</strong>代码中的剩余部分</li>
</ul>
</blockquote>
</li>
<li><p><strong>进程同步</strong></p>
<blockquote>
<p>​        同步也称为<strong>直接制约</strong>关系，是指为了完成某个任务而建立的多个进程，这些进程在某个位置上需要协调它们的工作次序所产生的关系。如，</p>
<p>​        键盘输入进程与显示器显示进程。当显示器显示进程在现实字符时，必须得等键盘输入的进程发送了相应的字符数据后，显示器进程才能显示出相应的字符。因此这两进程构成一种同步关系。</p>
</blockquote>
</li>
<li><p><strong>进程互斥</strong></p>
<blockquote>
<p>​        互斥也称为<strong>间接制约</strong>关系，指当一个进程进入临界区使用临界区资源时，另一个进程必须等待，只有当占用临界区资源的进程退出临界区后，另一进程才允许其它进程去访问此临界区资源。如</p>
<p>​        现只有一台打印机，而有两个进程A和进程B，如果进程A需要打印时，进程B正在使用打印机，那么进程A就必须阻塞等待。等到进程B使用完成后，进程A才能使用打印机来打印。</p>
<p>​        为了禁止多个进程同时进入临界区，同步机制需要遵循以下准则：</p>
<blockquote>
<ul>
<li><strong>空闲让进：</strong>即临界区资源空闲时，可以允许一个请求进入临界区的进程立即进入</li>
<li><strong>忙则等待：</strong>当已经有进程进入临界区时，其它尝试进入临界区的进程必须等待</li>
<li><strong>有限等待：</strong>对请求访问临界区的进程，应该保证能在有限的时间内进入临界区</li>
<li><strong>让权等待：</strong>当程序不能进入临界区时，应<strong>释放处理机</strong>，防止进程忙等待</li>
</ul>
</blockquote>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="2、实现临界区互斥的基本方法"><a href="#2、实现临界区互斥的基本方法" class="headerlink" title="2、实现临界区互斥的基本方法"></a>2、实现临界区互斥的基本方法</h3><h4 id="2-1、软件实现方法"><a href="#2-1、软件实现方法" class="headerlink" title="2.1、软件实现方法"></a>2.1、软件实现方法</h4><blockquote>
<p>​         在进入区设置一些标志来表示是否有进程在临界区中，若已有进程在临界区，则在进入区通过循环检查进行等待；进程离开临界区后则在退出区修改标志。</p>
<ul>
<li><p><strong>单标志法</strong></p>
<blockquote>
<p>​        该算法设置一个<strong>公用整型变量</strong>turn，用于表示被允许进入临界区的进程标号，例如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P0进程：					  P1进程：</span></span><br><span class="line"><span class="keyword">while</span>(turn !=<span class="number">0</span>);   			<span class="keyword">while</span>(turn!=<span class="number">1</span>);			<span class="comment">//进入区</span></span><br><span class="line">critical section;			critical section;		<span class="comment">//临界区</span></span><br><span class="line">turn = <span class="number">1</span>;					turn = <span class="number">0</span>;				<span class="comment">//退出区</span></span><br><span class="line">remainder section;			remainder section;		<span class="comment">//剩余区</span></span><br></pre></td></tr></table></figure>

<p>当P0进程进入临界区时，如果turn!&#x3D;0那么就会被卡在while(turn !&#x3D;0)中，从而就实现了互斥关系。</p>
<p><strong>缺点：</strong></p>
<blockquote>
<p>​        很明显，<strong>当其中一方不进入临界区时，另一方就永远无法进入临界区</strong>；如此时turn&#x3D;1，而P1进程并不进入临界区，那么就不会执行turn&#x3D;0这句，那么P0就永远只能卡在while(turn !&#x3D;0)中。</p>
</blockquote>
</blockquote>
</li>
<li><p><strong>双标志先检查法</strong></p>
<blockquote>
<p>​         该算法的基本思想是，在每个进程访问临界区之前，先检查临界区是否被访问，如果正被访问，则该程序需等待；否则，进程才进入临界区，例如（<strong>即先检查，后上锁</strong>）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P0进程：						P1进程：</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);	  <span class="number">1</span>			  <span class="keyword">while</span>(flag[<span class="number">0</span>]);  <span class="number">2</span>	<span class="comment">//进入区，查看</span></span><br><span class="line">flag[<span class="number">0</span>]=TRUE;	  <span class="number">3</span>			  flag[<span class="number">1</span>]=TRUE;	   <span class="number">4</span>	<span class="comment">//进入区，上锁</span></span><br><span class="line">critical section; 			  critical section;		<span class="comment">//临界区</span></span><br><span class="line">flag[<span class="number">0</span>]=FLASE;	  			  flag[<span class="number">1</span>]=FLASE;		<span class="comment">//退出区，解锁</span></span><br><span class="line">remainder section;			  remainder section;	<span class="comment">//剩余区</span></span><br></pre></td></tr></table></figure>

<p>​        当进程需要进入临界区时，只有检查到有别的进程在访问临界区，那么它就会一直进行while循环，从而实现互斥关系。</p>
<p><strong>优点：</strong>不用交替进入，可连续使用</p>
<p><strong>缺点：</strong></p>
<blockquote>
<p>​        <strong>违反了“忙则等待”的准则</strong>，当上述代码按1,2,3,4执行时（进程P0在执行一句后发生进程调度就能实现这个顺序），就会发生P0和P1同时进入临界区的问题</p>
</blockquote>
</blockquote>
</li>
<li><p><strong>双标志后检查法</strong></p>
<blockquote>
<p>​        算法思想是：先将自己的标志设为True，然后再检测对方的状态标志，若对方标志为True，则进程等待；否则进入临界区。例如（<strong>先上锁，再检查</strong>）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P0进程：						P1进程：</span></span><br><span class="line">flag[<span class="number">0</span>]=TRUE;	  <span class="number">1</span>			  flag[<span class="number">1</span>]=TRUE;	   <span class="number">2</span>	<span class="comment">//进入区，上锁</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);	  <span class="number">3</span>			  <span class="keyword">while</span>(flag[<span class="number">0</span>]);  <span class="number">4</span>	<span class="comment">//进入区，查看</span></span><br><span class="line">critical section; 			  critical section;		<span class="comment">//临界区</span></span><br><span class="line">flag[<span class="number">0</span>]=FLASE;	  			  flag[<span class="number">1</span>]=FLASE;		<span class="comment">//退出区，解锁</span></span><br><span class="line">remainder section;			  remainder section;	<span class="comment">//剩余区</span></span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong>不用交替进入，可连续使用</p>
<p><strong>缺点：</strong></p>
<blockquote>
<p>​        当上述代码按1,2,3,4执行时（进程P0在执行一句后发生进程调度就能实现这个顺序），就会出现两边谁也无法进入临界区的情况，从而<strong>违反了“空闲让进”</strong>和<strong>“有限等待”</strong>两个准则，导致双方长时间等待造成”<strong>饥饿</strong>“现象。</p>
</blockquote>
<p><strong>补充：</strong>上面两种算法实际上是因为上锁和检查分开了执行才导致出现各自的问题。</p>
</blockquote>
</li>
<li><p><strong>Peterson法</strong></p>
<blockquote>
<p>​        <strong>算法思路：</strong>结合双标志法和单标志法。即如果双方都争着想进入临界区，那可以让进程尝试做出一个”谦让“行为，从而避免问题发生。例如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P0进程：						P1进程：</span></span><br><span class="line">flag[<span class="number">0</span>]=TRUE;	  			  flag[<span class="number">1</span>]=TRUE;	   		<span class="comment">//进入区，上锁</span></span><br><span class="line">turn=<span class="number">1</span>;						  turn=<span class="number">0</span>;				<span class="comment">//进入区，表示谦让</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]&amp;&amp;turn==<span class="number">1</span>);	  <span class="keyword">while</span>(flag[<span class="number">0</span>]&amp;&amp;turn==<span class="number">0</span>);  <span class="comment">//进入区，查看</span></span><br><span class="line">flag[<span class="number">0</span>]=FLASE;	  			  flag[<span class="number">1</span>]=FLASE;		<span class="comment">//退出区，解锁</span></span><br><span class="line">remainder section;			  remainder section;	<span class="comment">//剩余区</span></span><br></pre></td></tr></table></figure>

<p>​        利用turn进行谦让，如当P0想要访问临界区时，它会先上锁，然后通过turn&#x3D;1来表示谦让，如果此时P1也想访问临界区，那么P1在上完锁以后，也会通过turn&#x3D;0，来标志谦让。此时CPU回到P0时，turn已经等于0了，那么就不会阻塞在while循环里了；而P1进程则会因为turn&#x3D;0且flag[0]&#x3D;&#x3D;TRUE从而阻塞在while中。</p>
<p><strong>缺点：</strong> <strong>未遵循“让权等待”</strong>，即当到P1进程使用CPU时，它会一直循环While从而浪费CPU资源。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="2-2、硬件实现方法"><a href="#2-2、硬件实现方法" class="headerlink" title="2.2、硬件实现方法"></a>2.2、硬件实现方法</h4><blockquote>
<p>​        通过硬件支持实现临界段问题的方法统称为<strong>低级方法</strong>，或称<strong>元方法</strong></p>
<ul>
<li><p><strong>中断屏蔽技术</strong></p>
<blockquote>
<p>​        指当一个进程正在使用处理机执行其的临界区代码时，可以设置一个<strong>关中断</strong>来禁止中断发生（即导致无法调度其它进程），例如</p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line">关中断;</span><br><span class="line">临界区;</span><br><span class="line">开中断;</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong>简单、高效</p>
<p><strong>缺点：</strong>不适用于多核处理机（因为关了一个核的中断，还有其他核可以访问）；只适用于操作系统内核进程使用。</p>
</blockquote>
</li>
<li><p><strong>硬件指令方法</strong></p>
<blockquote>
<ul>
<li><p><strong>TestAndSet指令（TestAndSetLock,TAL）：</strong></p>
<blockquote>
<p>这条指令是<strong>原子操作</strong>，其功能是读出指的标志后把该标志设置为真。</p>
<p>代码表示（本操作都是<strong>硬件来实现</strong>的，代码仅作为解释使用）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TestAndSet指令</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">TestAndSet</span> <span class="params">(<span class="type">bool</span> *lock)</span>&#123;</span><br><span class="line">    <span class="type">bool</span> old;		</span><br><span class="line">    old = *lock;	<span class="comment">//old用于存放lock原来的值</span></span><br><span class="line">    *lock = <span class="literal">true</span>;	<span class="comment">//无论原来的值是什么，都先加锁</span></span><br><span class="line">    <span class="keyword">return</span> old;		<span class="comment">//返回原来的状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TestAndSet指令的使用案例</span></span><br><span class="line"><span class="keyword">while</span> (TestAndSet (&amp;lock));		<span class="comment">//“上锁”并检查是否有人上锁</span></span><br><span class="line">临界区；</span><br><span class="line">lock = <span class="literal">false</span>;					<span class="comment">//解锁</span></span><br><span class="line">剩余区</span><br></pre></td></tr></table></figure>

<p>​        当进程需要访问临界区资源时，会通过while循环来上锁（告诉其它进程，已经有人要访问临界区了），并查询现在是否有人访问临界区</p>
<p><strong>优点：</strong>实现简单；适用于多处理机系统</p>
<p><strong>缺点：</strong>违背了“让权等待”准则，即进程在等待时会一直占用着CPU</p>
</blockquote>
</li>
<li><p><strong>Swap指令（Exchange指令）：</strong></p>
<blockquote>
<p>这条指令也是由<strong>硬件实现</strong>，不可中断的，下面也用代码来解释以下其逻辑</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Swap指令，用于交换连个变量的值</span></span><br><span class="line">Swap (<span class="type">bool</span> *a, <span class="type">bool</span> *b)&#123;</span><br><span class="line">    <span class="type">bool</span> temp;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Swap指令的应用</span></span><br><span class="line"><span class="type">bool</span> old = <span class="literal">true</span>;	<span class="comment">//设置变量，用于表示原来锁的标记</span></span><br><span class="line"><span class="keyword">while</span>(old==<span class="literal">true</span>)</span><br><span class="line">    Swap(&amp;lock, &amp;old);		<span class="comment">//记录上一次锁的标记，直到lock==false</span></span><br><span class="line">临界区;</span><br><span class="line">lock = <span class="literal">false</span>;		<span class="comment">//关闭锁</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当已经有进程访问临界区时，lock会等于true，那么后来者就会卡在while中无法出来，只有lock解锁了，后来的进程才能解除While。（实际上逻辑与TestAndSet指令一致）</p>
<p><strong>缺点：</strong>依旧违反了“让权等待”，而且不能形成一个先来后到的队列，可能会导致后来的进程先进入临界区</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>互斥锁</strong></p>
<blockquote>
<p>​        用于解决临界区的最简单工具。一个进程在进入临界区时会得到锁，而在退出临界区时又会释放锁。其中函数acquire()表示获得锁，release()表示释放锁。</p>
<p>​        其中每个互斥锁都会有一个<strong>布尔变量available</strong>，用于表示锁是否可用。如果锁可用，则可以成功调用acquire()进行上锁，当锁不可用时，就会被阻塞，直到锁被释放</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">acquire()&#123;</span><br><span class="line">    <span class="keyword">while</span>(!available);		<span class="comment">//忙等待</span></span><br><span class="line">    available = <span class="literal">false</span>;		<span class="comment">//获得锁</span></span><br><span class="line">&#125;</span><br><span class="line">release()&#123;</span><br><span class="line">    available = <span class="literal">true</span>;		<span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中acquire()和release()都是原子操作，因此<strong>互斥锁通常采用硬件机制实现</strong></p>
<p><strong>特性：</strong></p>
<blockquote>
<ul>
<li>需忙等</li>
<li>等待时间时不用切换进程，在多处理机系统中，若上锁的时间短，则等待代价低</li>
<li>常用于多处理机系统，一个核忙等，其它核依旧照常工作</li>
<li>不适用于单处理机</li>
</ul>
</blockquote>
<p><strong>自旋锁：</strong>需要连续循环忙等的互斥锁，如TSL指令，swap指令等</p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="3、信号量"><a href="#3、信号量" class="headerlink" title="3、信号量"></a>3、信号量</h3><blockquote>
<p>​        信号量机制是一种功能较强的机制，可用于解决互斥和同步问题，它只能被两个标准的<strong>原语wait(S)<strong>和</strong>signal(S)<strong>访问，也可以记为“</strong>P操作</strong>”和“<strong>V操作</strong>”。</p>
<p>​        信号量实际上指的是系统中某种资源的数量。根据定义方式的不同，可以分为：</p>
<ul>
<li><p><strong>整型信号量</strong></p>
<blockquote>
<p>整型信号量被定义为一个用于表示资源数目的<strong>整型量S</strong>，其中P操作和V操作可以表示为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P(S)&#123;</span><br><span class="line">    <span class="keyword">while</span>(S&lt;=<span class="number">0</span>);		<span class="comment">//S小于0则陷入循环</span></span><br><span class="line">    S=S<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V(S)&#123;</span><br><span class="line">    S=S+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>P操作中，只要$S \le 0$，就会不断检查测试。因此违反了“让权等待”准则，使得程序陷入”<strong>忙等</strong>“状态。</p>
</blockquote>
</li>
<li><p><strong>记录型信号量</strong></p>
<blockquote>
<p>记录行信号量不仅定义了表示资源数<strong>的整型量value</strong>，还定义了一个<strong>等待队列process</strong>，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">typedeof <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> value;				<span class="comment">//表示资源的数量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span>		<span class="comment">//表示想要使用资源但陷入等待的进程队列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相应的P，V操作如下</span></span><br><span class="line">P(semaphore S)&#123;</span><br><span class="line">    S.value--;</span><br><span class="line">    <span class="keyword">if</span>(S.value&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        add this process to S.L;		<span class="comment">//将本进程放入该临界资源的阻塞队列中</span></span><br><span class="line">        block(S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V(semaphore S)&#123;</span><br><span class="line">    S.value++;</span><br><span class="line">    <span class="keyword">if</span>(S.value&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        remove a process P from S.L;</span><br><span class="line">        weakup(P);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：V操作中**if(S.value&lt;&#x3D;0)**表示在释放完资源（此时空闲资源至少为1）后，仍有想要申请资源的进程，因此唤醒阻塞队列中的一个进程进行临界资源的使用。</p>
</blockquote>
</li>
</ul>
<p><strong>利用信号量实现同步：</strong></p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore S=<span class="number">0</span>;			<span class="comment">//初始化信号量</span></span><br><span class="line">P1()&#123;</span><br><span class="line">    x;					<span class="comment">//语句X</span></span><br><span class="line">    V(S);				<span class="comment">//告诉进程P2，语句X已经完成，即S=1</span></span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()&#123;</span><br><span class="line">    ……</span><br><span class="line">    P(S);				<span class="comment">//当S=1时才能继续往下执行，否则只能等待</span></span><br><span class="line">    y;					<span class="comment">//检查到x已经执行，运行y语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>过程：</strong>若P2先执行P(S)时，S为0，执行P操作会使得P2阻塞，并进入阻塞队列；当P1执行完V(S)后，S变为1，此时P2才能继续跳出阻塞继续往下执行，从而实现了一个进程的同步过程。</p>
</blockquote>
<p><strong>利用信号量实现互斥：</strong></p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore S=<span class="number">1</span>;			<span class="comment">//初始化信号量</span></span><br><span class="line">P1()&#123;</span><br><span class="line">    ……</span><br><span class="line">    P(S);				<span class="comment">//开始访问临界区资源，上锁</span></span><br><span class="line">    进程P1访问临界区;</span><br><span class="line">    V(S);				<span class="comment">//访问结束，解锁</span></span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()&#123;</span><br><span class="line">    ……</span><br><span class="line">    P(S);				<span class="comment">//开始访问临界区资源，上锁</span></span><br><span class="line">    进程P2访问临界区;</span><br><span class="line">    V(S);				<span class="comment">//访问结束，解锁</span></span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>过程：</strong>略</p>
</blockquote>
<p><strong>补充：</strong>此外信号量机制还可以实现<strong>前驱关系</strong>的实现</p>
</blockquote>
<h3 id="4、常见的同步互斥问题"><a href="#4、常见的同步互斥问题" class="headerlink" title="4、常见的同步互斥问题"></a>4、常见的同步互斥问题</h3><h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h4><blockquote>
<p><strong>问题描述：</strong>一组生产者和一组消费者共享一个大小为n的缓冲区，只有当缓冲区不为空时，消费者才能从中拿走数据；只有当缓冲区部委满的时候，生产者才会往里面放数据。</p>
<p><strong>分析：</strong></p>
<blockquote>
<p><strong>关系分析：</strong>生产者和消费者对缓冲区的访问是互斥关系；同时生产者与消费者之间又形成了一个同步关系。</p>
<p><strong>信号量设置：</strong>根据关系判断可以设置mutex为访问互斥的信号量；设置full来表示当前缓冲区为“满”的状态；设置empty来表示当前缓冲区为空的状态。</p>
</blockquote>
<p><strong>代码描述：</strong></p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore mutex=<span class="number">1</span>;  semaphore empty=n;	semaphore full=<span class="number">0</span>;		<span class="comment">//初始化信号量</span></span><br><span class="line"></span><br><span class="line">producer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        生产数据;</span><br><span class="line">        P(empty);				<span class="comment">//表示空的位置又少了1</span></span><br><span class="line">        P(mutex);				<span class="comment">//互斥访问，加锁</span></span><br><span class="line">        将数据放入缓冲区;</span><br><span class="line">        V(mutex);				<span class="comment">//解锁</span></span><br><span class="line">        V(full);				<span class="comment">//表示有数据的位置又多了1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consummer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(full);				<span class="comment">//表示消费了一个数据</span></span><br><span class="line">        P(mutex);				<span class="comment">//互斥访问，加锁</span></span><br><span class="line">        将数据读取;</span><br><span class="line">        V(mutex);				<span class="comment">//解锁</span></span><br><span class="line">        V(empty)				<span class="comment">//表示空的位置又加了1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>实现<strong>同步</strong>的P操作一定要在实现<strong>互斥</strong>的P操作之前，否则会造成<strong>死锁</strong>，如</p>
<blockquote>
<p>​        当full&#x3D;0时（即缓冲区没有数据），此时消费者尝试读取缓冲区的数据，如果此时 P(mutex) 在前，那么就对缓冲区的访问提前上了锁，当执行到 P(full) 时，因为full&#x3D;0，因此消费者会在此处进入阻塞状态；到了生产者尝试将数据放入缓冲区时，发现现在有人正在访问缓冲区就会阻塞在 P(mutex) 中，从而导致了死锁。</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="多生产者-多消费者问题"><a href="#多生产者-多消费者问题" class="headerlink" title="多生产者-多消费者问题"></a>多生产者-多消费者问题</h4><blockquote>
<p><strong>问题描述：</strong></p>
<blockquote>
<p>​         桌子上有一个盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专拿盘中的橘子，女儿专拿盘中的苹果。只有盘子为空时，爸爸或妈妈才可以向盘子中放入一个水果；仅当盘子中有自己需要的水果时，女儿或儿子才可以从盘子中取出。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85.png" alt="多生产者多消费者"></p>
</blockquote>
<p><strong>分析：</strong></p>
<blockquote>
<p><strong>关系分析：</strong>爸爸，妈妈，女儿，儿子四人对盘子的访问属于一个互斥关系；爸爸和女儿构成一个同步关系；妈妈和儿子构成一个同步关系。</p>
<p><strong>信号量设置：</strong>盘子plate；爸爸和女儿同步信号量apple；妈妈和儿子同步信号量orange；</p>
</blockquote>
<p><strong>代码描述：</strong></p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore plate=<span class="number">1</span>;apple=<span class="number">0</span>;orange=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">dad()&#123;</span><br><span class="line">    准备苹果;</span><br><span class="line">    P(plate);		<span class="comment">//使用唯一的盘子</span></span><br><span class="line">    放入苹果;</span><br><span class="line">    V(apple);		<span class="comment">//表明苹果数量加一</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mom()&#123;</span><br><span class="line">    准备橘子;</span><br><span class="line">    P(plate);		<span class="comment">//使用唯一的盘子</span></span><br><span class="line">    放入橘子;</span><br><span class="line">    V(orange);		<span class="comment">//表明橘子数量加一</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">daughter()&#123;</span><br><span class="line">    P(orange);		<span class="comment">//拿走一个橘子</span></span><br><span class="line">    拿走橘子;</span><br><span class="line">    V(plate);		<span class="comment">//归还唯一的盘子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">son()&#123;</span><br><span class="line">    P(apple);		<span class="comment">//拿走一个苹果</span></span><br><span class="line">    拿走苹果;</span><br><span class="line">    V(plate);		<span class="comment">//归还唯一的盘子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>这里没有使用互斥信号量是因为，这里盘子只有一个，只要被使用了其它人就无法对其起作用了，从而起到了一个互斥访问的作用。如果例子中的盘子不止一个，那么就需要额外设置一个互斥访问的信号量了。</p>
</blockquote>
</blockquote>
<h4 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h4><blockquote>
<p><strong>问题描述：</strong></p>
<blockquote>
<p>​        有读者和写者两组进程<strong>共享一个文件</strong>，当多个读进程共同对其进行数据访问时不会产生副作用，而当写进程在使用时，其它进程也共同访问时就会出现数据不一致的错误。因此要求：①、<strong>允许多个读进程同时对文件执行读操作</strong>；②、<strong>只允许一个写者往文件中写信息</strong>；③<strong>任一写者在写操作完成前不允许其它读进程或写进程工作</strong>；④、<strong>写进程执行写操作前，要让已有的读进程和写进程全部退出</strong></p>
</blockquote>
<p><strong>分析：</strong></p>
<blockquote>
<p><strong>关系分析：</strong>写者和读者为互斥关系；写者和写者也为互斥关系；</p>
<p><strong>信号量设置：</strong>设置信号量count为计数器，用于记录当前读文件的进程个数；设置信号量mutex来保护count变化时的互斥；设置互斥信号量rw。</p>
</blockquote>
<p><strong>代码描述：</strong></p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> count=<span class="number">0</span>;		<span class="comment">//记录读者数</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>;	semaphore rw=<span class="number">1</span>;</span><br><span class="line">writer()&#123;</span><br><span class="line"> P(rw);			<span class="comment">//互斥访问共享文件</span></span><br><span class="line"> 写入;</span><br><span class="line"> V(rw);			<span class="comment">//解放共享文件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader()&#123;</span><br><span class="line"> P(mutex);		<span class="comment">//互斥地让count++</span></span><br><span class="line"> <span class="keyword">if</span>(count==<span class="number">0</span>)	<span class="comment">//如果为第一个读进程</span></span><br><span class="line">     P(rw);		<span class="comment">//那么就阻止写操作</span></span><br><span class="line"> count++;		<span class="comment">//读进程数加1</span></span><br><span class="line"> V(mutex);		<span class="comment">//互斥地让count++</span></span><br><span class="line"> 读取数据;</span><br><span class="line"> P(mutex);		<span class="comment">//互斥地让count--</span></span><br><span class="line"> count--;</span><br><span class="line"> <span class="keyword">if</span>(count==<span class="number">0</span>)	<span class="comment">//如果为最后一个读进程</span></span><br><span class="line">     V(rw);		<span class="comment">//就释放写操作</span></span><br><span class="line"> V(mutex);		<span class="comment">//互斥地让count--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>很明显，上面只要进行了读操作，而且有源源不断的读操作进来，那么写操作就会被一直阻塞（<strong>属于读操作优先</strong>），容易导致“饥饿”现象。如果希望纠正这个问题，那么就应该在写进程申请访问后，禁止后续读进程的请求，如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> count=<span class="number">0</span>;		<span class="comment">//记录读者数</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>;	semaphore rw=<span class="number">1</span>;</span><br><span class="line">semaphore w=<span class="number">1</span>;		<span class="comment">//用于实现写进程申请后，禁止后续进程的请求</span></span><br><span class="line">writer()&#123;</span><br><span class="line"> P(w);			<span class="comment">//禁止其它进程申请		</span></span><br><span class="line"> P(rw);			<span class="comment">//互斥访问共享文件</span></span><br><span class="line"> 写入;</span><br><span class="line"> V(rw);			<span class="comment">//解放共享文件</span></span><br><span class="line"> V(w);			<span class="comment">//解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader()&#123;</span><br><span class="line"> P(w);			<span class="comment">//在无写进程时进入</span></span><br><span class="line"> P(mutex);		<span class="comment">//互斥地让count++</span></span><br><span class="line"> <span class="keyword">if</span>(count==<span class="number">0</span>)	<span class="comment">//如果为第一个读进程</span></span><br><span class="line">     P(rw);		<span class="comment">//那么就阻止写操作</span></span><br><span class="line"> count++;		<span class="comment">//读进程数加1</span></span><br><span class="line"> V(mutex);		<span class="comment">//互斥地让count++</span></span><br><span class="line"> V(w);			<span class="comment">//解锁</span></span><br><span class="line"> 读取数据;</span><br><span class="line"> P(mutex);		<span class="comment">//互斥地让count--</span></span><br><span class="line"> count--;</span><br><span class="line"> <span class="keyword">if</span>(count==<span class="number">0</span>)	<span class="comment">//如果为最后一个读进程</span></span><br><span class="line">     V(rw);		<span class="comment">//就释放写操作</span></span><br><span class="line"> V(mutex);		<span class="comment">//互斥地让count--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        这样的<strong>写进程优先</strong>是相对上一个算法而言的，这个算法又可以称为<strong>读写公平法</strong>。因为它属于一个“<strong>先来先服务</strong>”的策略。当写进程申请临界区资源时，系统会让其先等待之前已经在读取数据的读进程完成后，才能申请使用；但对于后来的读进程，它又可以将它们阻塞在队列上，只有等写进程完成后才能进行数据的读取。</p>
</blockquote>
</blockquote>
<h4 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h4><blockquote>
<p><strong>问题描述：</strong></p>
<blockquote>
<p>​        假设一个系统有三个吸烟者进程和一个供应者进程。每个吸烟者需要不停地卷烟并抽掉它。卷一支烟需要三种材料：烟草、纸和胶水，而每个吸烟者各自拥有一种材料，即A拥有烟草，B拥有纸，C拥有胶水，供应者则会在这三样材料中轮流挑选两样放在桌子上，拥有剩下那种材料的吸烟者会将其拿走，并给供应者返回一个已完成的信号，此时供应者又会在这三样材料中轮流挑选两样放在桌子上，如此重复（让三个吸烟者<strong>轮流</strong>抽烟）</p>
</blockquote>
<p><strong>分析</strong></p>
<blockquote>
<p><strong>关系分析：</strong>供应者和三个吸烟者都是同步关系；三个吸烟者相互为互斥关系</p>
<p><strong>设置信号量：</strong>设置offer1，offer2，offer3分别为供应者提供的三种材料的信号量；finish表示吸烟者与供应者的同步信号量。</p>
</blockquote>
<p><strong>代码描述：</strong></p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//信号量设置</span></span><br><span class="line">semaphore offer1 = <span class="number">0</span>;	<span class="comment">//第一个吸烟者需要的两种材料</span></span><br><span class="line">semaphore offer2 = <span class="number">0</span>;	<span class="comment">//第二个吸烟者需要的两种材料</span></span><br><span class="line">semaphore offer3 = <span class="number">0</span>;	<span class="comment">//第三个吸烟者需要的两种材料</span></span><br><span class="line">semaphore finish = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//轮转的一个变量</span></span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">provider()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        num++;</span><br><span class="line">        num=num%<span class="number">3</span>;		<span class="comment">//轮流生成某两种材料</span></span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>)</span><br><span class="line">            V(offer1);	<span class="comment">//第一种材料加1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">1</span>)	</span><br><span class="line">            V(offer2);	<span class="comment">//第二种材料加1</span></span><br><span class="line">        <span class="keyword">else</span>(num==<span class="number">3</span>)</span><br><span class="line">            V(offer3);	<span class="comment">//第三种材料加1</span></span><br><span class="line">        P(finish);		<span class="comment">//查看是否有人完成吸烟</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//吸烟者1号</span></span><br><span class="line">Smoker1()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(offer1);		<span class="comment">//检查是否有想要的材料</span></span><br><span class="line">        拿走材料，卷烟，抽掉;</span><br><span class="line">        V(finish);		<span class="comment">//通知供应者已经完成吸烟</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//吸烟者2号</span></span><br><span class="line">Smoker2()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(offer2);		<span class="comment">//检查是否有想要的材料</span></span><br><span class="line">        拿走材料，卷烟，抽掉;</span><br><span class="line">        V(finish);		<span class="comment">//通知供应者已经完成吸烟</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//吸烟者3号</span></span><br><span class="line">Smoker3()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(offer3);		<span class="comment">//检查是否有想要的材料</span></span><br><span class="line">        拿走材料，卷烟，抽掉;</span><br><span class="line">        V(finish);		<span class="comment">//通知供应者已经完成吸烟</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>这里实现的是，供应者轮询提供不同的两种材料，如果需要随机提供，只需将轮询生成num的值改成随机生成即可。</p>
</blockquote>
</blockquote>
<h4 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h4><blockquote>
<p><strong>问题描述：</strong></p>
<blockquote>
<p>​        一张圆桌上有5位哲学家，每两名哲学家之间有一根筷子。每名哲学家会做的事就是干饭或思考。如果哲学家要干饭，那么需要同时拿起左右两根筷子。如果筷子在别人手上，则需要等待别人放下筷子后才能拿到筷子。哲学家只能拿起与自己相邻的两根筷子。</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98.png" alt="哲学家进餐问题"></p>
</blockquote>
<p><strong>分析</strong></p>
<blockquote>
<p><strong>关系分析：</strong>者五名哲学家对筷子的访问明显相互互斥</p>
<p><strong>信号量设置：</strong>互斥访问信号量数组chopstick[5]&#x3D;{1,1,1,1,1}表示5根筷子的互斥访问。给哲学家进行编号0~4，哲学家$i$左边的筷子编号为$i$，哲学家右边的筷子编号为$(i+1)%5$。</p>
<p><strong>问题分析：</strong>如果不加以限制，哲学家就很容易陷入死锁状态（即每一位哲学家都拿到了一根筷子，但每一位哲学家都在等待另一根筷子，从而陷入一个死胡同），为了防止这种事情发生，通常可以加入以下限制：①、最多只能允许四个哲学家同时进餐；②、仅当一位哲学家左右两边的筷子都能使用时，才允许他拿起筷子；③、对哲学家顺序编号，要求编号为奇数的哲学家先拿起右边的筷子，再拿起左边的筷子。编号为偶数的哲学家则与之相反；</p>
</blockquote>
<p><strong>代码描述：（算法②）</strong></p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;			<span class="comment">//设置取筷子的户次信号量</span></span><br><span class="line"></span><br><span class="line">Pi()&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        P(mutex);				<span class="comment">//保证能拿到两根筷子</span></span><br><span class="line">        P(chopstick[i]);		<span class="comment">//拿起左边的筷子</span></span><br><span class="line">        P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);	<span class="comment">//拿起右边的筷子</span></span><br><span class="line">        V(mutex);				<span class="comment">//允许其他人拿筷子</span></span><br><span class="line">        干饭;</span><br><span class="line">        V(chopstick[i]);		<span class="comment">//释放左边的筷子</span></span><br><span class="line">        V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);	<span class="comment">//释放右边的筷子</span></span><br><span class="line">        思考;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>哲学家问题本质上用于解决死锁问题，从一开始的资源分配上防止死锁的发生。</p>
</blockquote>
</blockquote>
<h3 id="5、管程"><a href="#5、管程" class="headerlink" title="5、管程"></a>5、管程</h3><blockquote>
<p><strong>定义：</strong>代表共享资源的数据结构，以及由对该数据结构实施操作的一组过程所组成的资源管理程序。</p>
<p><strong>管程的组成：</strong></p>
<blockquote>
<ul>
<li>管程的名称</li>
<li>局部于管程内部的共享数据说明</li>
<li>对该数据结构进行操作的一组函数</li>
<li>对于局部于管程内部的共享数据设置初始值的语句</li>
</ul>
<p>​        即管程内部定义了<strong>共享数据</strong>，而且需要操作该共享数据时，只能<strong>调用管程内部的函数</strong>进行操作。（管程本质上就是对共享数据的一个封装，然后对外提供了一些接口）</p>
</blockquote>
<p><strong>例子：</strong></p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">monitor Demo&#123;		   <span class="comment">//定义了一个名为“demo”的管程</span></span><br><span class="line">    共享数据 S;			<span class="comment">//定义了一个共享数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义对共享数据的初始化</span></span><br><span class="line">    init()&#123;</span><br><span class="line">        S=<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义申请资源的函数</span></span><br><span class="line">    take_away()&#123;</span><br><span class="line">        S--;		 <span class="comment">//资源减1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义归还资源的函数</span></span><br><span class="line">    give_back()&#123;</span><br><span class="line">        S++;		<span class="comment">//资源加1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质上就是一个类，然后共享资源为私有变量，只能通过向外提供的函数对其进行操作。</p>
</blockquote>
<p><strong>管程的特点：</strong></p>
<blockquote>
<ul>
<li>局部于管程的数据只能被管程内部的函数所访问</li>
<li>进程只有通过调用管程内部的函数才能访问共享数据</li>
<li><strong>每次只允许一个进程在管程内执行某个内部函数</strong></li>
<li>管程的互斥访问特性是由编译器实现实现的，程序员无需担心</li>
</ul>
</blockquote>
</blockquote>
<h2 id="四、进程的死锁"><a href="#四、进程的死锁" class="headerlink" title="四、进程的死锁"></a>四、进程的死锁</h2><h3 id="1、死锁的概念"><a href="#1、死锁的概念" class="headerlink" title="1、死锁的概念"></a>1、死锁的概念</h3><blockquote>
<p><strong>死锁的定义：</strong>指多个进程因为竞争资源而造成的一种僵局（互相等待对方的资源），若无外力作用（操作系统处理），这些进程都将无法向前推进</p>
<p><strong>死锁产生的原因：</strong></p>
<blockquote>
<ul>
<li>系统资源的竞争</li>
<li>进程推进顺序非法，即进程在推进时，请求和释放资源的顺序不当也会导致死锁</li>
<li>信号量使用不当</li>
</ul>
</blockquote>
<p><strong>死锁产生产生的必要条件：</strong></p>
<blockquote>
<ul>
<li><strong>互斥条件</strong></li>
<li><strong>不剥夺条件</strong></li>
<li><strong>请求并保持条件</strong>，即进程可以保持已有资源的同时去申请其他资源</li>
<li><strong>循环等待条件</strong>，即存在一个进程资源循环等待链</li>
</ul>
<p><strong>注意：</strong>产生死锁一定会有资源循环等待链，但有资源循环等待链不一定会产生死锁，如</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85.png" alt="循环等待"></p>
</blockquote>
<p><strong>死锁的处理策略：</strong></p>
<blockquote>
<ul>
<li><strong>死锁预防</strong></li>
<li><strong>死锁避免</strong></li>
<li><strong>死锁检测及解除</strong></li>
</ul>
</blockquote>
</blockquote>
<h3 id="2、死锁预防"><a href="#2、死锁预防" class="headerlink" title="2、死锁预防"></a>2、死锁预防</h3><blockquote>
<p>预防死锁的发生，只需要破坏死锁产生的4各必要条件之一即可。</p>
<ul>
<li><p><strong>破坏互斥条件</strong></p>
<blockquote>
<p>​        允许系统资源都能共享使用，如<strong>SPOOLing技术</strong>。但有些资源很难做到同时访问，而且有些时候我们还需要保护这种互斥性，因此破坏互斥条件不太能做到。</p>
</blockquote>
</li>
<li><p><strong>破坏不剥夺条件</strong></p>
<blockquote>
<p>​        当已经保持了某些资源的进程在申请新的资源而得不到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。</p>
<p>​        该策略实现起来比较复杂，而且可能导致即将完成的进程放弃资源导致功亏一篑。</p>
</blockquote>
</li>
<li><p><strong>破坏请求并保存条件</strong></p>
<blockquote>
<p>​        采用预先<strong>静分配方法</strong>，即进程在运行前一次申请完它所需的所有资源，在资源未能满足前，不允许它运行。一旦开始运行，这些资源则一直归它所有，不再提出其它请求。</p>
<p><strong>缺点：</strong>系统资源被严重浪费，如有些资源可能只使用一小部分时间；而且还会导致“饥饿”现象。</p>
</blockquote>
</li>
<li><p><strong>破坏循环等待条件</strong></p>
<blockquote>
<p>​        采用<strong>顺序资源分配法</strong>，首先给系统中的资源进行编号，规定进程只能按编号递增的顺序请求资源，如获得2,3,4的资源不能再回头申请1号资源，只能申请5,6,…等资源。</p>
<p><strong>缺点：</strong>限制了新设备资源的增加；作业使用资源的顺序和系统规定的顺序不一致，从而导致资源的浪费。如进程先使用3号资源再使用2号资源，此时他就可能出现占有2号资源来等待3号资源；给用户编程带来麻烦。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="3、死锁避免"><a href="#3、死锁避免" class="headerlink" title="3、死锁避免"></a>3、死锁避免</h3><blockquote>
<p>​         死锁的避免属于实现预防策略，即在分配资源的过程中，防止系统进入不安全状态，从而避免死锁。</p>
<p><strong>安全序列：</strong>指如果系统按照这种序列分配资源，则每个进程都能顺利完成。</p>
<p><strong>安全状态：</strong>能找到一个安全序列的状态</p>
<p><strong>银行家算法：</strong></p>
<blockquote>
<p><strong>思想：</strong>在分配资源前先预判这次分配是否会进入不安全状态，如果不进入，那么就分配；如果会进入不安全状态，那就不分配。</p>
<p><strong>例子：</strong></p>
<blockquote>
<p>资源总数为：(10, 5, 7)，剩下的可用资源为：(3, 3, 2)</p>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95.png" alt="银行家算法"></p>
<p>可以看出，这时候系统处于一个安全状态，因为剩余资源可以满足P1或P3的需求。</p>
<p>此时如果是P0发出一个(2, 1, 2)的资源请求，假如分配了，系统还剩(1, 2, 0)，那系统就会变为不安全状态，因此系统会拒绝这次请求；如果是P2申请一个(1, 0, 0)的请求，假如分配了，系统还剩(2, 3, 2)，还处于安全状态，因此这次申请给予满足。</p>
</blockquote>
<p><strong>注意：</strong>银行家算法具有试探下一步的功能，即如果此次资源分配导致系统处于不安全状态，那么将作废分配；如果此次资源分配后，系统仍处于安全状态，那就确定本次分配。</p>
</blockquote>
</blockquote>
<h3 id="4、死锁检测和解除"><a href="#4、死锁检测和解除" class="headerlink" title="4、死锁检测和解除"></a>4、死锁检测和解除</h3><blockquote>
<p>如果系统为进程分配资源时不采取任何措施，那就应该提供死锁检测和解除的手段。</p>
<ul>
<li><p><strong>资源分配图</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE.png" alt="资源分配图"></p>
<ul>
<li><strong>资源：</strong>R1方框中一个圆圈表示一个资源</li>
<li><strong>进程：</strong>形如P1那样的圆圈</li>
<li><strong>请求边：</strong>由<strong>进程指向资源</strong>的箭头</li>
<li><strong>分配边：</strong>由<strong>资源指向进程</strong>的箭头</li>
</ul>
</blockquote>
</li>
<li><p><strong>死锁定理</strong></p>
<blockquote>
<p><strong>资源分配图的完全化简</strong></p>
<blockquote>
<p><img src="/picture/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%9B%BE/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE%E7%9A%84%E5%8C%96%E7%AE%80.png" alt="资源分配图的化简"></p>
<ul>
<li>找到既不阻塞，又不是孤点的进程P1</li>
<li>将资源分配给它，然后擦掉它所有的连线</li>
<li>再寻找下一个既不阻塞，又不是孤点的进程，重复上述步骤</li>
</ul>
</blockquote>
<p><strong>定理：</strong>当资源分布图不可完全简化，则称之为<strong>死锁定理</strong></p>
</blockquote>
</li>
<li><p><strong>解除死锁的方式</strong></p>
<blockquote>
<ul>
<li><strong>资源剥夺法：</strong>挂起某些死锁进程，并抢占它的资源，分配给其它的死锁进程</li>
<li><strong>撤销进程法：</strong>强制测序部分或全部死锁进程并剥夺这些进程的资源（需要进程间具有优先级）</li>
<li><strong>进程回退法：</strong>让一个或多个进程回退到足以回避死锁的地步，进程回退时<strong>自愿释放资源而非剥夺</strong>（设置还原点）</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="五、其它补充"><a href="#五、其它补充" class="headerlink" title="五、其它补充"></a>五、其它补充</h2><blockquote>
<ul>
<li><p><strong>死锁、饥饿、死循环的区别：</strong></p>
<blockquote>
<ul>
<li><strong>死锁：</strong>资源争抢资源而陷入了僵局，需要外力才能解除死锁。</li>
<li><strong>饥饿：</strong>因为资源的竞争，导致某进程长时间得不到需要的资源，从而陷入阻塞，可以通过外力也可以等到资源空闲下来就能解除饥饿。</li>
<li><strong>死循环：</strong>程序员编写程序时所犯下的语法错误，导致进程一直重复一个操作，只能由用户停止进程才能解决死循环。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>基础学科</tag>
      </tags>
  </entry>
</search>
